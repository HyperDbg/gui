package out
//back\HyperDbgDev\hyperdbg\dependencies\ia32-doc\out\ia32.h.back

const(
CR0_PROTECTION_ENABLE_BIT =                                    0 //col:73
CR0_PROTECTION_ENABLE_FLAG =                                   0x01 //col:74
CR0_PROTECTION_ENABLE_MASK =                                   0x01 //col:75
CR0_PROTECTION_ENABLE(_) =                                     (((_) >> 0) & 0x01) //col:76
CR0_MONITOR_COPROCESSOR_BIT =                                  1 //col:86
CR0_MONITOR_COPROCESSOR_FLAG =                                 0x02 //col:87
CR0_MONITOR_COPROCESSOR_MASK =                                 0x01 //col:88
CR0_MONITOR_COPROCESSOR(_) =                                   (((_) >> 1) & 0x01) //col:89
CR0_EMULATE_FPU_BIT =                                          2 //col:108
CR0_EMULATE_FPU_FLAG =                                         0x04 //col:109
CR0_EMULATE_FPU_MASK =                                         0x01 //col:110
CR0_EMULATE_FPU(_) =                                           (((_) >> 2) & 0x01) //col:111
CR0_TASK_SWITCHED_BIT =                                        3 //col:135
CR0_TASK_SWITCHED_FLAG =                                       0x08 //col:136
CR0_TASK_SWITCHED_MASK =                                       0x01 //col:137
CR0_TASK_SWITCHED(_) =                                         (((_) >> 3) & 0x01) //col:138
CR0_EXTENSION_TYPE_BIT =                                       4 //col:148
CR0_EXTENSION_TYPE_FLAG =                                      0x10 //col:149
CR0_EXTENSION_TYPE_MASK =                                      0x01 //col:150
CR0_EXTENSION_TYPE(_) =                                        (((_) >> 4) & 0x01) //col:151
CR0_NUMERIC_ERROR_BIT =                                        5 //col:171
CR0_NUMERIC_ERROR_FLAG =                                       0x20 //col:172
CR0_NUMERIC_ERROR_MASK =                                       0x01 //col:173
CR0_NUMERIC_ERROR(_) =                                         (((_) >> 5) & 0x01) //col:174
CR0_WRITE_PROTECT_BIT =                                        16 //col:188
CR0_WRITE_PROTECT_FLAG =                                       0x10000 //col:189
CR0_WRITE_PROTECT_MASK =                                       0x01 //col:190
CR0_WRITE_PROTECT(_) =                                         (((_) >> 16) & 0x01) //col:191
CR0_ALIGNMENT_MASK_BIT =                                       18 //col:202
CR0_ALIGNMENT_MASK_FLAG =                                      0x40000 //col:203
CR0_ALIGNMENT_MASK_MASK =                                      0x01 //col:204
CR0_ALIGNMENT_MASK(_) =                                        (((_) >> 18) & 0x01) //col:205
CR0_NOT_WRITE_THROUGH_BIT =                                    29 //col:215
CR0_NOT_WRITE_THROUGH_FLAG =                                   0x20000000 //col:216
CR0_NOT_WRITE_THROUGH_MASK =                                   0x01 //col:217
CR0_NOT_WRITE_THROUGH(_) =                                     (((_) >> 29) & 0x01) //col:218
CR0_CACHE_DISABLE_BIT =                                        30 //col:232
CR0_CACHE_DISABLE_FLAG =                                       0x40000000 //col:233
CR0_CACHE_DISABLE_MASK =                                       0x01 //col:234
CR0_CACHE_DISABLE(_) =                                         (((_) >> 30) & 0x01) //col:235
CR0_PAGING_ENABLE_BIT =                                        31 //col:248
CR0_PAGING_ENABLE_FLAG =                                       0x80000000 //col:249
CR0_PAGING_ENABLE_MASK =                                       0x01 //col:250
CR0_PAGING_ENABLE(_) =                                         (((_) >> 31) & 0x01) //col:251
CR3_PAGE_LEVEL_WRITE_THROUGH_BIT =                             3 //col:273
CR3_PAGE_LEVEL_WRITE_THROUGH_FLAG =                            0x08 //col:274
CR3_PAGE_LEVEL_WRITE_THROUGH_MASK =                            0x01 //col:275
CR3_PAGE_LEVEL_WRITE_THROUGH(_) =                              (((_) >> 3) & 0x01) //col:276
CR3_PAGE_LEVEL_CACHE_DISABLE_BIT =                             4 //col:287
CR3_PAGE_LEVEL_CACHE_DISABLE_FLAG =                            0x10 //col:288
CR3_PAGE_LEVEL_CACHE_DISABLE_MASK =                            0x01 //col:289
CR3_PAGE_LEVEL_CACHE_DISABLE(_) =                              (((_) >> 4) & 0x01) //col:290
CR3_ADDRESS_OF_PAGE_DIRECTORY_BIT =                            12 //col:303
CR3_ADDRESS_OF_PAGE_DIRECTORY_FLAG =                           0xFFFFFFFFF000 //col:304
CR3_ADDRESS_OF_PAGE_DIRECTORY_MASK =                           0xFFFFFFFFF //col:305
CR3_ADDRESS_OF_PAGE_DIRECTORY(_) =                             (((_) >> 12) & 0xFFFFFFFFF) //col:306
CR4_VIRTUAL_MODE_EXTENSIONS_BIT =                              0 //col:330
CR4_VIRTUAL_MODE_EXTENSIONS_FLAG =                             0x01 //col:331
CR4_VIRTUAL_MODE_EXTENSIONS_MASK =                             0x01 //col:332
CR4_VIRTUAL_MODE_EXTENSIONS(_) =                               (((_) >> 0) & 0x01) //col:333
CR4_PROTECTED_MODE_VIRTUAL_INTERRUPTS_BIT =                    1 //col:344
CR4_PROTECTED_MODE_VIRTUAL_INTERRUPTS_FLAG =                   0x02 //col:345
CR4_PROTECTED_MODE_VIRTUAL_INTERRUPTS_MASK =                   0x01 //col:346
CR4_PROTECTED_MODE_VIRTUAL_INTERRUPTS(_) =                     (((_) >> 1) & 0x01) //col:347
CR4_TIMESTAMP_DISABLE_BIT =                                    2 //col:357
CR4_TIMESTAMP_DISABLE_FLAG =                                   0x04 //col:358
CR4_TIMESTAMP_DISABLE_MASK =                                   0x01 //col:359
CR4_TIMESTAMP_DISABLE(_) =                                     (((_) >> 2) & 0x01) //col:360
CR4_DEBUGGING_EXTENSIONS_BIT =                                 3 //col:372
CR4_DEBUGGING_EXTENSIONS_FLAG =                                0x08 //col:373
CR4_DEBUGGING_EXTENSIONS_MASK =                                0x01 //col:374
CR4_DEBUGGING_EXTENSIONS(_) =                                  (((_) >> 3) & 0x01) //col:375
CR4_PAGE_SIZE_EXTENSIONS_BIT =                                 4 //col:385
CR4_PAGE_SIZE_EXTENSIONS_FLAG =                                0x10 //col:386
CR4_PAGE_SIZE_EXTENSIONS_MASK =                                0x01 //col:387
CR4_PAGE_SIZE_EXTENSIONS(_) =                                  (((_) >> 4) & 0x01) //col:388
CR4_PHYSICAL_ADDRESS_EXTENSION_BIT =                           5 //col:399
CR4_PHYSICAL_ADDRESS_EXTENSION_FLAG =                          0x20 //col:400
CR4_PHYSICAL_ADDRESS_EXTENSION_MASK =                          0x01 //col:401
CR4_PHYSICAL_ADDRESS_EXTENSION(_) =                            (((_) >> 5) & 0x01) //col:402
CR4_MACHINE_CHECK_ENABLE_BIT =                                 6 //col:412
CR4_MACHINE_CHECK_ENABLE_FLAG =                                0x40 //col:413
CR4_MACHINE_CHECK_ENABLE_MASK =                                0x01 //col:414
CR4_MACHINE_CHECK_ENABLE(_) =                                  (((_) >> 6) & 0x01) //col:415
CR4_PAGE_GLOBAL_ENABLE_BIT =                                   7 //col:430
CR4_PAGE_GLOBAL_ENABLE_FLAG =                                  0x80 //col:431
CR4_PAGE_GLOBAL_ENABLE_MASK =                                  0x01 //col:432
CR4_PAGE_GLOBAL_ENABLE(_) =                                    (((_) >> 7) & 0x01) //col:433
CR4_PERFORMANCE_MONITORING_COUNTER_ENABLE_BIT =                8 //col:442
CR4_PERFORMANCE_MONITORING_COUNTER_ENABLE_FLAG =               0x100 //col:443
CR4_PERFORMANCE_MONITORING_COUNTER_ENABLE_MASK =               0x01 //col:444
CR4_PERFORMANCE_MONITORING_COUNTER_ENABLE(_) =                 (((_) >> 8) & 0x01) //col:445
CR4_OS_FXSAVE_FXRSTOR_SUPPORT_BIT =                            9 //col:468
CR4_OS_FXSAVE_FXRSTOR_SUPPORT_FLAG =                           0x200 //col:469
CR4_OS_FXSAVE_FXRSTOR_SUPPORT_MASK =                           0x01 //col:470
CR4_OS_FXSAVE_FXRSTOR_SUPPORT(_) =                             (((_) >> 9) & 0x01) //col:471
CR4_OS_XMM_EXCEPTION_SUPPORT_BIT =                             10 //col:484
CR4_OS_XMM_EXCEPTION_SUPPORT_FLAG =                            0x400 //col:485
CR4_OS_XMM_EXCEPTION_SUPPORT_MASK =                            0x01 //col:486
CR4_OS_XMM_EXCEPTION_SUPPORT(_) =                              (((_) >> 10) & 0x01) //col:487
CR4_USERMODE_INSTRUCTION_PREVENTION_BIT =                      11 //col:496
CR4_USERMODE_INSTRUCTION_PREVENTION_FLAG =                     0x800 //col:497
CR4_USERMODE_INSTRUCTION_PREVENTION_MASK =                     0x01 //col:498
CR4_USERMODE_INSTRUCTION_PREVENTION(_) =                       (((_) >> 11) & 0x01) //col:499
CR4_LINEAR_ADDRESSES_57_BIT_BIT =                              12 //col:511
CR4_LINEAR_ADDRESSES_57_BIT_FLAG =                             0x1000 //col:512
CR4_LINEAR_ADDRESSES_57_BIT_MASK =                             0x01 //col:513
CR4_LINEAR_ADDRESSES_57_BIT(_) =                               (((_) >> 12) & 0x01) //col:514
CR4_VMX_ENABLE_BIT =                                           13 //col:524
CR4_VMX_ENABLE_FLAG =                                          0x2000 //col:525
CR4_VMX_ENABLE_MASK =                                          0x01 //col:526
CR4_VMX_ENABLE(_) =                                            (((_) >> 13) & 0x01) //col:527
CR4_SMX_ENABLE_BIT =                                           14 //col:537
CR4_SMX_ENABLE_FLAG =                                          0x4000 //col:538
CR4_SMX_ENABLE_MASK =                                          0x01 //col:539
CR4_SMX_ENABLE(_) =                                            (((_) >> 14) & 0x01) //col:540
CR4_FSGSBASE_ENABLE_BIT =                                      16 //col:549
CR4_FSGSBASE_ENABLE_FLAG =                                     0x10000 //col:550
CR4_FSGSBASE_ENABLE_MASK =                                     0x01 //col:551
CR4_FSGSBASE_ENABLE(_) =                                       (((_) >> 16) & 0x01) //col:552
CR4_PCID_ENABLE_BIT =                                          17 //col:562
CR4_PCID_ENABLE_FLAG =                                         0x20000 //col:563
CR4_PCID_ENABLE_MASK =                                         0x01 //col:564
CR4_PCID_ENABLE(_) =                                           (((_) >> 17) & 0x01) //col:565
CR4_OS_XSAVE_BIT =                                             18 //col:581
CR4_OS_XSAVE_FLAG =                                            0x40000 //col:582
CR4_OS_XSAVE_MASK =                                            0x01 //col:583
CR4_OS_XSAVE(_) =                                              (((_) >> 18) & 0x01) //col:584
CR4_KEY_LOCKER_ENABLE_BIT =                                    19 //col:595
CR4_KEY_LOCKER_ENABLE_FLAG =                                   0x80000 //col:596
CR4_KEY_LOCKER_ENABLE_MASK =                                   0x01 //col:597
CR4_KEY_LOCKER_ENABLE(_) =                                     (((_) >> 19) & 0x01) //col:598
CR4_SMEP_ENABLE_BIT =                                          20 //col:608
CR4_SMEP_ENABLE_FLAG =                                         0x100000 //col:609
CR4_SMEP_ENABLE_MASK =                                         0x01 //col:610
CR4_SMEP_ENABLE(_) =                                           (((_) >> 20) & 0x01) //col:611
CR4_SMAP_ENABLE_BIT =                                          21 //col:621
CR4_SMAP_ENABLE_FLAG =                                         0x200000 //col:622
CR4_SMAP_ENABLE_MASK =                                         0x01 //col:623
CR4_SMAP_ENABLE(_) =                                           (((_) >> 21) & 0x01) //col:624
CR4_PROTECTION_KEY_ENABLE_BIT =                                22 //col:634
CR4_PROTECTION_KEY_ENABLE_FLAG =                               0x400000 //col:635
CR4_PROTECTION_KEY_ENABLE_MASK =                               0x01 //col:636
CR4_PROTECTION_KEY_ENABLE(_) =                                 (((_) >> 22) & 0x01) //col:637
CR4_CONTROL_FLOW_ENFORCEMENT_ENABLE_BIT =                      23 //col:648
CR4_CONTROL_FLOW_ENFORCEMENT_ENABLE_FLAG =                     0x800000 //col:649
CR4_CONTROL_FLOW_ENFORCEMENT_ENABLE_MASK =                     0x01 //col:650
CR4_CONTROL_FLOW_ENFORCEMENT_ENABLE(_) =                       (((_) >> 23) & 0x01) //col:651
CR4_PROTECTION_KEY_FOR_SUPERVISOR_MODE_ENABLE_BIT =            24 //col:661
CR4_PROTECTION_KEY_FOR_SUPERVISOR_MODE_ENABLE_FLAG =           0x1000000 //col:662
CR4_PROTECTION_KEY_FOR_SUPERVISOR_MODE_ENABLE_MASK =           0x01 //col:663
CR4_PROTECTION_KEY_FOR_SUPERVISOR_MODE_ENABLE(_) =             (((_) >> 24) & 0x01) //col:664
CR8_TASK_PRIORITY_LEVEL_BIT =                                  0 //col:683
CR8_TASK_PRIORITY_LEVEL_FLAG =                                 0x0F //col:684
CR8_TASK_PRIORITY_LEVEL_MASK =                                 0x0F //col:685
CR8_TASK_PRIORITY_LEVEL(_) =                                   (((_) >> 0) & 0x0F) //col:686
CR8_RESERVED_BIT =                                             4 //col:694
CR8_RESERVED_FLAG =                                            0xFFFFFFFFFFFFFFF0 //col:695
CR8_RESERVED_MASK =                                            0xFFFFFFFFFFFFFFF //col:696
CR8_RESERVED(_) =                                              (((_) >> 4) & 0xFFFFFFFFFFFFFFF) //col:697
DR6_BREAKPOINT_CONDITION_BIT =                                 0 //col:742
DR6_BREAKPOINT_CONDITION_FLAG =                                0x0F //col:743
DR6_BREAKPOINT_CONDITION_MASK =                                0x0F //col:744
DR6_BREAKPOINT_CONDITION(_) =                                  (((_) >> 0) & 0x0F) //col:745
DR6_DEBUG_REGISTER_ACCESS_DETECTED_BIT =                       13 //col:757
DR6_DEBUG_REGISTER_ACCESS_DETECTED_FLAG =                      0x2000 //col:758
DR6_DEBUG_REGISTER_ACCESS_DETECTED_MASK =                      0x01 //col:759
DR6_DEBUG_REGISTER_ACCESS_DETECTED(_) =                        (((_) >> 13) & 0x01) //col:760
DR6_SINGLE_INSTRUCTION_BIT =                                   14 //col:770
DR6_SINGLE_INSTRUCTION_FLAG =                                  0x4000 //col:771
DR6_SINGLE_INSTRUCTION_MASK =                                  0x01 //col:772
DR6_SINGLE_INSTRUCTION(_) =                                    (((_) >> 14) & 0x01) //col:773
DR6_TASK_SWITCH_BIT =                                          15 //col:783
DR6_TASK_SWITCH_FLAG =                                         0x8000 //col:784
DR6_TASK_SWITCH_MASK =                                         0x01 //col:785
DR6_TASK_SWITCH(_) =                                           (((_) >> 15) & 0x01) //col:786
DR6_RESTRICTED_TRANSACTIONAL_MEMORY_BIT =                      16 //col:799
DR6_RESTRICTED_TRANSACTIONAL_MEMORY_FLAG =                     0x10000 //col:800
DR6_RESTRICTED_TRANSACTIONAL_MEMORY_MASK =                     0x01 //col:801
DR6_RESTRICTED_TRANSACTIONAL_MEMORY(_) =                       (((_) >> 16) & 0x01) //col:802
DR7_LOCAL_BREAKPOINT_0_BIT =                                   0 //col:821
DR7_LOCAL_BREAKPOINT_0_FLAG =                                  0x01 //col:822
DR7_LOCAL_BREAKPOINT_0_MASK =                                  0x01 //col:823
DR7_LOCAL_BREAKPOINT_0(_) =                                    (((_) >> 0) & 0x01) //col:824
DR7_GLOBAL_BREAKPOINT_0_BIT =                                  1 //col:834
DR7_GLOBAL_BREAKPOINT_0_FLAG =                                 0x02 //col:835
DR7_GLOBAL_BREAKPOINT_0_MASK =                                 0x01 //col:836
DR7_GLOBAL_BREAKPOINT_0(_) =                                   (((_) >> 1) & 0x01) //col:837
DR7_LOCAL_BREAKPOINT_1_BIT =                                   2 //col:839
DR7_LOCAL_BREAKPOINT_1_FLAG =                                  0x04 //col:840
DR7_LOCAL_BREAKPOINT_1_MASK =                                  0x01 //col:841
DR7_LOCAL_BREAKPOINT_1(_) =                                    (((_) >> 2) & 0x01) //col:842
DR7_GLOBAL_BREAKPOINT_1_BIT =                                  3 //col:844
DR7_GLOBAL_BREAKPOINT_1_FLAG =                                 0x08 //col:845
DR7_GLOBAL_BREAKPOINT_1_MASK =                                 0x01 //col:846
DR7_GLOBAL_BREAKPOINT_1(_) =                                   (((_) >> 3) & 0x01) //col:847
DR7_LOCAL_BREAKPOINT_2_BIT =                                   4 //col:849
DR7_LOCAL_BREAKPOINT_2_FLAG =                                  0x10 //col:850
DR7_LOCAL_BREAKPOINT_2_MASK =                                  0x01 //col:851
DR7_LOCAL_BREAKPOINT_2(_) =                                    (((_) >> 4) & 0x01) //col:852
DR7_GLOBAL_BREAKPOINT_2_BIT =                                  5 //col:854
DR7_GLOBAL_BREAKPOINT_2_FLAG =                                 0x20 //col:855
DR7_GLOBAL_BREAKPOINT_2_MASK =                                 0x01 //col:856
DR7_GLOBAL_BREAKPOINT_2(_) =                                   (((_) >> 5) & 0x01) //col:857
DR7_LOCAL_BREAKPOINT_3_BIT =                                   6 //col:859
DR7_LOCAL_BREAKPOINT_3_FLAG =                                  0x40 //col:860
DR7_LOCAL_BREAKPOINT_3_MASK =                                  0x01 //col:861
DR7_LOCAL_BREAKPOINT_3(_) =                                    (((_) >> 6) & 0x01) //col:862
DR7_GLOBAL_BREAKPOINT_3_BIT =                                  7 //col:864
DR7_GLOBAL_BREAKPOINT_3_FLAG =                                 0x80 //col:865
DR7_GLOBAL_BREAKPOINT_3_MASK =                                 0x01 //col:866
DR7_GLOBAL_BREAKPOINT_3(_) =                                   (((_) >> 7) & 0x01) //col:867
DR7_LOCAL_EXACT_BREAKPOINT_BIT =                               8 //col:878
DR7_LOCAL_EXACT_BREAKPOINT_FLAG =                              0x100 //col:879
DR7_LOCAL_EXACT_BREAKPOINT_MASK =                              0x01 //col:880
DR7_LOCAL_EXACT_BREAKPOINT(_) =                                (((_) >> 8) & 0x01) //col:881
DR7_GLOBAL_EXACT_BREAKPOINT_BIT =                              9 //col:883
DR7_GLOBAL_EXACT_BREAKPOINT_FLAG =                             0x200 //col:884
DR7_GLOBAL_EXACT_BREAKPOINT_MASK =                             0x01 //col:885
DR7_GLOBAL_EXACT_BREAKPOINT(_) =                               (((_) >> 9) & 0x01) //col:886
DR7_RESTRICTED_TRANSACTIONAL_MEMORY_BIT =                      11 //col:898
DR7_RESTRICTED_TRANSACTIONAL_MEMORY_FLAG =                     0x800 //col:899
DR7_RESTRICTED_TRANSACTIONAL_MEMORY_MASK =                     0x01 //col:900
DR7_RESTRICTED_TRANSACTIONAL_MEMORY(_) =                       (((_) >> 11) & 0x01) //col:901
DR7_GENERAL_DETECT_BIT =                                       13 //col:916
DR7_GENERAL_DETECT_FLAG =                                      0x2000 //col:917
DR7_GENERAL_DETECT_MASK =                                      0x01 //col:918
DR7_GENERAL_DETECT(_) =                                        (((_) >> 13) & 0x01) //col:919
DR7_READ_WRITE_0_BIT =                                         16 //col:940
DR7_READ_WRITE_0_FLAG =                                        0x30000 //col:941
DR7_READ_WRITE_0_MASK =                                        0x03 //col:942
DR7_READ_WRITE_0(_) =                                          (((_) >> 16) & 0x03) //col:943
DR7_LENGTH_0_BIT =                                             18 //col:960
DR7_LENGTH_0_FLAG =                                            0xC0000 //col:961
DR7_LENGTH_0_MASK =                                            0x03 //col:962
DR7_LENGTH_0(_) =                                              (((_) >> 18) & 0x03) //col:963
DR7_READ_WRITE_1_BIT =                                         20 //col:965
DR7_READ_WRITE_1_FLAG =                                        0x300000 //col:966
DR7_READ_WRITE_1_MASK =                                        0x03 //col:967
DR7_READ_WRITE_1(_) =                                          (((_) >> 20) & 0x03) //col:968
DR7_LENGTH_1_BIT =                                             22 //col:970
DR7_LENGTH_1_FLAG =                                            0xC00000 //col:971
DR7_LENGTH_1_MASK =                                            0x03 //col:972
DR7_LENGTH_1(_) =                                              (((_) >> 22) & 0x03) //col:973
DR7_READ_WRITE_2_BIT =                                         24 //col:975
DR7_READ_WRITE_2_FLAG =                                        0x3000000 //col:976
DR7_READ_WRITE_2_MASK =                                        0x03 //col:977
DR7_READ_WRITE_2(_) =                                          (((_) >> 24) & 0x03) //col:978
DR7_LENGTH_2_BIT =                                             26 //col:980
DR7_LENGTH_2_FLAG =                                            0xC000000 //col:981
DR7_LENGTH_2_MASK =                                            0x03 //col:982
DR7_LENGTH_2(_) =                                              (((_) >> 26) & 0x03) //col:983
DR7_READ_WRITE_3_BIT =                                         28 //col:985
DR7_READ_WRITE_3_FLAG =                                        0x30000000 //col:986
DR7_READ_WRITE_3_MASK =                                        0x03 //col:987
DR7_READ_WRITE_3(_) =                                          (((_) >> 28) & 0x03) //col:988
DR7_LENGTH_3_BIT =                                             30 //col:990
DR7_LENGTH_3_FLAG =                                            0xC0000000 //col:991
DR7_LENGTH_3_MASK =                                            0x03 //col:992
DR7_LENGTH_3(_) =                                              (((_) >> 30) & 0x03) //col:993
CPUID_SIGNATURE =                                              0x00000000 //col:1022
CPUID_VERSION_INFORMATION =                                    0x00000001 //col:1063
CPUID_VERSION_INFORMATION_STEPPING_ID_BIT =                    0 //col:1074
CPUID_VERSION_INFORMATION_STEPPING_ID_FLAG =                   0x0F //col:1075
CPUID_VERSION_INFORMATION_STEPPING_ID_MASK =                   0x0F //col:1076
CPUID_VERSION_INFORMATION_STEPPING_ID(_) =                     (((_) >> 0) & 0x0F) //col:1077
CPUID_VERSION_INFORMATION_MODEL_BIT =                          4 //col:1079
CPUID_VERSION_INFORMATION_MODEL_FLAG =                         0xF0 //col:1080
CPUID_VERSION_INFORMATION_MODEL_MASK =                         0x0F //col:1081
CPUID_VERSION_INFORMATION_MODEL(_) =                           (((_) >> 4) & 0x0F) //col:1082
CPUID_VERSION_INFORMATION_FAMILY_ID_BIT =                      8 //col:1084
CPUID_VERSION_INFORMATION_FAMILY_ID_FLAG =                     0xF00 //col:1085
CPUID_VERSION_INFORMATION_FAMILY_ID_MASK =                     0x0F //col:1086
CPUID_VERSION_INFORMATION_FAMILY_ID(_) =                       (((_) >> 8) & 0x0F) //col:1087
CPUID_VERSION_INFORMATION_PROCESSOR_TYPE_BIT =                 12 //col:1096
CPUID_VERSION_INFORMATION_PROCESSOR_TYPE_FLAG =                0x3000 //col:1097
CPUID_VERSION_INFORMATION_PROCESSOR_TYPE_MASK =                0x03 //col:1098
CPUID_VERSION_INFORMATION_PROCESSOR_TYPE(_) =                  (((_) >> 12) & 0x03) //col:1099
CPUID_VERSION_INFORMATION_EXTENDED_MODEL_ID_BIT =              16 //col:1106
CPUID_VERSION_INFORMATION_EXTENDED_MODEL_ID_FLAG =             0xF0000 //col:1107
CPUID_VERSION_INFORMATION_EXTENDED_MODEL_ID_MASK =             0x0F //col:1108
CPUID_VERSION_INFORMATION_EXTENDED_MODEL_ID(_) =               (((_) >> 16) & 0x0F) //col:1109
CPUID_VERSION_INFORMATION_EXTENDED_FAMILY_ID_BIT =             20 //col:1115
CPUID_VERSION_INFORMATION_EXTENDED_FAMILY_ID_FLAG =            0xFF00000 //col:1116
CPUID_VERSION_INFORMATION_EXTENDED_FAMILY_ID_MASK =            0xFF //col:1117
CPUID_VERSION_INFORMATION_EXTENDED_FAMILY_ID(_) =              (((_) >> 20) & 0xFF) //col:1118
CPUID_ADDITIONAL_INFORMATION_BRAND_INDEX_BIT =                 0 //col:1137
CPUID_ADDITIONAL_INFORMATION_BRAND_INDEX_FLAG =                0xFF //col:1138
CPUID_ADDITIONAL_INFORMATION_BRAND_INDEX_MASK =                0xFF //col:1139
CPUID_ADDITIONAL_INFORMATION_BRAND_INDEX(_) =                  (((_) >> 0) & 0xFF) //col:1140
CPUID_ADDITIONAL_INFORMATION_CLFLUSH_LINE_SIZE_BIT =           8 //col:1149
CPUID_ADDITIONAL_INFORMATION_CLFLUSH_LINE_SIZE_FLAG =          0xFF00 //col:1150
CPUID_ADDITIONAL_INFORMATION_CLFLUSH_LINE_SIZE_MASK =          0xFF //col:1151
CPUID_ADDITIONAL_INFORMATION_CLFLUSH_LINE_SIZE(_) =            (((_) >> 8) & 0xFF) //col:1152
CPUID_ADDITIONAL_INFORMATION_MAX_ADDRESSABLE_IDS_BIT =         16 //col:1162
CPUID_ADDITIONAL_INFORMATION_MAX_ADDRESSABLE_IDS_FLAG =        0xFF0000 //col:1163
CPUID_ADDITIONAL_INFORMATION_MAX_ADDRESSABLE_IDS_MASK =        0xFF //col:1164
CPUID_ADDITIONAL_INFORMATION_MAX_ADDRESSABLE_IDS(_) =          (((_) >> 16) & 0xFF) //col:1165
CPUID_ADDITIONAL_INFORMATION_INITIAL_APIC_ID_BIT =             24 //col:1172
CPUID_ADDITIONAL_INFORMATION_INITIAL_APIC_ID_FLAG =            0xFF000000 //col:1173
CPUID_ADDITIONAL_INFORMATION_INITIAL_APIC_ID_MASK =            0xFF //col:1174
CPUID_ADDITIONAL_INFORMATION_INITIAL_APIC_ID(_) =              (((_) >> 24) & 0xFF) //col:1175
CPUID_FEATURE_INFORMATION_ECX_STREAMING_SIMD_EXTENSIONS_3_BIT = 0 //col:1194
CPUID_FEATURE_INFORMATION_ECX_STREAMING_SIMD_EXTENSIONS_3_FLAG = 0x01 //col:1195
CPUID_FEATURE_INFORMATION_ECX_STREAMING_SIMD_EXTENSIONS_3_MASK = 0x01 //col:1196
CPUID_FEATURE_INFORMATION_ECX_STREAMING_SIMD_EXTENSIONS_3(_) = (((_) >> 0) & 0x01) //col:1197
CPUID_FEATURE_INFORMATION_ECX_PCLMULQDQ_INSTRUCTION_BIT =      1 //col:1205
CPUID_FEATURE_INFORMATION_ECX_PCLMULQDQ_INSTRUCTION_FLAG =     0x02 //col:1206
CPUID_FEATURE_INFORMATION_ECX_PCLMULQDQ_INSTRUCTION_MASK =     0x01 //col:1207
CPUID_FEATURE_INFORMATION_ECX_PCLMULQDQ_INSTRUCTION(_) =       (((_) >> 1) & 0x01) //col:1208
CPUID_FEATURE_INFORMATION_ECX_DS_AREA_64BIT_LAYOUT_BIT =       2 //col:1216
CPUID_FEATURE_INFORMATION_ECX_DS_AREA_64BIT_LAYOUT_FLAG =      0x04 //col:1217
CPUID_FEATURE_INFORMATION_ECX_DS_AREA_64BIT_LAYOUT_MASK =      0x01 //col:1218
CPUID_FEATURE_INFORMATION_ECX_DS_AREA_64BIT_LAYOUT(_) =        (((_) >> 2) & 0x01) //col:1219
CPUID_FEATURE_INFORMATION_ECX_MONITOR_MWAIT_INSTRUCTION_BIT =  3 //col:1227
CPUID_FEATURE_INFORMATION_ECX_MONITOR_MWAIT_INSTRUCTION_FLAG = 0x08 //col:1228
CPUID_FEATURE_INFORMATION_ECX_MONITOR_MWAIT_INSTRUCTION_MASK = 0x01 //col:1229
CPUID_FEATURE_INFORMATION_ECX_MONITOR_MWAIT_INSTRUCTION(_) =   (((_) >> 3) & 0x01) //col:1230
CPUID_FEATURE_INFORMATION_ECX_CPL_QUALIFIED_DEBUG_STORE_BIT =  4 //col:1239
CPUID_FEATURE_INFORMATION_ECX_CPL_QUALIFIED_DEBUG_STORE_FLAG = 0x10 //col:1240
CPUID_FEATURE_INFORMATION_ECX_CPL_QUALIFIED_DEBUG_STORE_MASK = 0x01 //col:1241
CPUID_FEATURE_INFORMATION_ECX_CPL_QUALIFIED_DEBUG_STORE(_) =   (((_) >> 4) & 0x01) //col:1242
CPUID_FEATURE_INFORMATION_ECX_VIRTUAL_MACHINE_EXTENSIONS_BIT = 5 //col:1250
CPUID_FEATURE_INFORMATION_ECX_VIRTUAL_MACHINE_EXTENSIONS_FLAG = 0x20 //col:1251
CPUID_FEATURE_INFORMATION_ECX_VIRTUAL_MACHINE_EXTENSIONS_MASK = 0x01 //col:1252
CPUID_FEATURE_INFORMATION_ECX_VIRTUAL_MACHINE_EXTENSIONS(_) =  (((_) >> 5) & 0x01) //col:1253
CPUID_FEATURE_INFORMATION_ECX_SAFER_MODE_EXTENSIONS_BIT =      6 //col:1263
CPUID_FEATURE_INFORMATION_ECX_SAFER_MODE_EXTENSIONS_FLAG =     0x40 //col:1264
CPUID_FEATURE_INFORMATION_ECX_SAFER_MODE_EXTENSIONS_MASK =     0x01 //col:1265
CPUID_FEATURE_INFORMATION_ECX_SAFER_MODE_EXTENSIONS(_) =       (((_) >> 6) & 0x01) //col:1266
CPUID_FEATURE_INFORMATION_ECX_ENHANCED_INTEL_SPEEDSTEP_TECHNOLOGY_BIT = 7 //col:1274
CPUID_FEATURE_INFORMATION_ECX_ENHANCED_INTEL_SPEEDSTEP_TECHNOLOGY_FLAG = 0x80 //col:1275
CPUID_FEATURE_INFORMATION_ECX_ENHANCED_INTEL_SPEEDSTEP_TECHNOLOGY_MASK = 0x01 //col:1276
CPUID_FEATURE_INFORMATION_ECX_ENHANCED_INTEL_SPEEDSTEP_TECHNOLOGY(_) = (((_) >> 7) & 0x01) //col:1277
CPUID_FEATURE_INFORMATION_ECX_THERMAL_MONITOR_2_BIT =          8 //col:1285
CPUID_FEATURE_INFORMATION_ECX_THERMAL_MONITOR_2_FLAG =         0x100 //col:1286
CPUID_FEATURE_INFORMATION_ECX_THERMAL_MONITOR_2_MASK =         0x01 //col:1287
CPUID_FEATURE_INFORMATION_ECX_THERMAL_MONITOR_2(_) =           (((_) >> 8) & 0x01) //col:1288
CPUID_FEATURE_INFORMATION_ECX_SUPPLEMENTAL_STREAMING_SIMD_EXTENSIONS_3_BIT = 9 //col:1297
CPUID_FEATURE_INFORMATION_ECX_SUPPLEMENTAL_STREAMING_SIMD_EXTENSIONS_3_FLAG = 0x200 //col:1298
CPUID_FEATURE_INFORMATION_ECX_SUPPLEMENTAL_STREAMING_SIMD_EXTENSIONS_3_MASK = 0x01 //col:1299
CPUID_FEATURE_INFORMATION_ECX_SUPPLEMENTAL_STREAMING_SIMD_EXTENSIONS_3(_) = (((_) >> 9) & 0x01) //col:1300
CPUID_FEATURE_INFORMATION_ECX_L1_CONTEXT_ID_BIT =              10 //col:1310
CPUID_FEATURE_INFORMATION_ECX_L1_CONTEXT_ID_FLAG =             0x400 //col:1311
CPUID_FEATURE_INFORMATION_ECX_L1_CONTEXT_ID_MASK =             0x01 //col:1312
CPUID_FEATURE_INFORMATION_ECX_L1_CONTEXT_ID(_) =               (((_) >> 10) & 0x01) //col:1313
CPUID_FEATURE_INFORMATION_ECX_SILICON_DEBUG_BIT =              11 //col:1321
CPUID_FEATURE_INFORMATION_ECX_SILICON_DEBUG_FLAG =             0x800 //col:1322
CPUID_FEATURE_INFORMATION_ECX_SILICON_DEBUG_MASK =             0x01 //col:1323
CPUID_FEATURE_INFORMATION_ECX_SILICON_DEBUG(_) =               (((_) >> 11) & 0x01) //col:1324
CPUID_FEATURE_INFORMATION_ECX_FMA_EXTENSIONS_BIT =             12 //col:1332
CPUID_FEATURE_INFORMATION_ECX_FMA_EXTENSIONS_FLAG =            0x1000 //col:1333
CPUID_FEATURE_INFORMATION_ECX_FMA_EXTENSIONS_MASK =            0x01 //col:1334
CPUID_FEATURE_INFORMATION_ECX_FMA_EXTENSIONS(_) =              (((_) >> 12) & 0x01) //col:1335
CPUID_FEATURE_INFORMATION_ECX_CMPXCHG16B_INSTRUCTION_BIT =     13 //col:1343
CPUID_FEATURE_INFORMATION_ECX_CMPXCHG16B_INSTRUCTION_FLAG =    0x2000 //col:1344
CPUID_FEATURE_INFORMATION_ECX_CMPXCHG16B_INSTRUCTION_MASK =    0x01 //col:1345
CPUID_FEATURE_INFORMATION_ECX_CMPXCHG16B_INSTRUCTION(_) =      (((_) >> 13) & 0x01) //col:1346
CPUID_FEATURE_INFORMATION_ECX_XTPR_UPDATE_CONTROL_BIT =        14 //col:1354
CPUID_FEATURE_INFORMATION_ECX_XTPR_UPDATE_CONTROL_FLAG =       0x4000 //col:1355
CPUID_FEATURE_INFORMATION_ECX_XTPR_UPDATE_CONTROL_MASK =       0x01 //col:1356
CPUID_FEATURE_INFORMATION_ECX_XTPR_UPDATE_CONTROL(_) =         (((_) >> 14) & 0x01) //col:1357
CPUID_FEATURE_INFORMATION_ECX_PERFMON_AND_DEBUG_CAPABILITY_BIT = 15 //col:1366
CPUID_FEATURE_INFORMATION_ECX_PERFMON_AND_DEBUG_CAPABILITY_FLAG = 0x8000 //col:1367
CPUID_FEATURE_INFORMATION_ECX_PERFMON_AND_DEBUG_CAPABILITY_MASK = 0x01 //col:1368
CPUID_FEATURE_INFORMATION_ECX_PERFMON_AND_DEBUG_CAPABILITY(_) = (((_) >> 15) & 0x01) //col:1369
CPUID_FEATURE_INFORMATION_ECX_PROCESS_CONTEXT_IDENTIFIERS_BIT = 17 //col:1378
CPUID_FEATURE_INFORMATION_ECX_PROCESS_CONTEXT_IDENTIFIERS_FLAG = 0x20000 //col:1379
CPUID_FEATURE_INFORMATION_ECX_PROCESS_CONTEXT_IDENTIFIERS_MASK = 0x01 //col:1380
CPUID_FEATURE_INFORMATION_ECX_PROCESS_CONTEXT_IDENTIFIERS(_) = (((_) >> 17) & 0x01) //col:1381
CPUID_FEATURE_INFORMATION_ECX_DIRECT_CACHE_ACCESS_BIT =        18 //col:1390
CPUID_FEATURE_INFORMATION_ECX_DIRECT_CACHE_ACCESS_FLAG =       0x40000 //col:1391
CPUID_FEATURE_INFORMATION_ECX_DIRECT_CACHE_ACCESS_MASK =       0x01 //col:1392
CPUID_FEATURE_INFORMATION_ECX_DIRECT_CACHE_ACCESS(_) =         (((_) >> 18) & 0x01) //col:1393
CPUID_FEATURE_INFORMATION_ECX_SSE41_SUPPORT_BIT =              19 //col:1401
CPUID_FEATURE_INFORMATION_ECX_SSE41_SUPPORT_FLAG =             0x80000 //col:1402
CPUID_FEATURE_INFORMATION_ECX_SSE41_SUPPORT_MASK =             0x01 //col:1403
CPUID_FEATURE_INFORMATION_ECX_SSE41_SUPPORT(_) =               (((_) >> 19) & 0x01) //col:1404
CPUID_FEATURE_INFORMATION_ECX_SSE42_SUPPORT_BIT =              20 //col:1412
CPUID_FEATURE_INFORMATION_ECX_SSE42_SUPPORT_FLAG =             0x100000 //col:1413
CPUID_FEATURE_INFORMATION_ECX_SSE42_SUPPORT_MASK =             0x01 //col:1414
CPUID_FEATURE_INFORMATION_ECX_SSE42_SUPPORT(_) =               (((_) >> 20) & 0x01) //col:1415
CPUID_FEATURE_INFORMATION_ECX_X2APIC_SUPPORT_BIT =             21 //col:1423
CPUID_FEATURE_INFORMATION_ECX_X2APIC_SUPPORT_FLAG =            0x200000 //col:1424
CPUID_FEATURE_INFORMATION_ECX_X2APIC_SUPPORT_MASK =            0x01 //col:1425
CPUID_FEATURE_INFORMATION_ECX_X2APIC_SUPPORT(_) =              (((_) >> 21) & 0x01) //col:1426
CPUID_FEATURE_INFORMATION_ECX_MOVBE_INSTRUCTION_BIT =          22 //col:1434
CPUID_FEATURE_INFORMATION_ECX_MOVBE_INSTRUCTION_FLAG =         0x400000 //col:1435
CPUID_FEATURE_INFORMATION_ECX_MOVBE_INSTRUCTION_MASK =         0x01 //col:1436
CPUID_FEATURE_INFORMATION_ECX_MOVBE_INSTRUCTION(_) =           (((_) >> 22) & 0x01) //col:1437
CPUID_FEATURE_INFORMATION_ECX_POPCNT_INSTRUCTION_BIT =         23 //col:1445
CPUID_FEATURE_INFORMATION_ECX_POPCNT_INSTRUCTION_FLAG =        0x800000 //col:1446
CPUID_FEATURE_INFORMATION_ECX_POPCNT_INSTRUCTION_MASK =        0x01 //col:1447
CPUID_FEATURE_INFORMATION_ECX_POPCNT_INSTRUCTION(_) =          (((_) >> 23) & 0x01) //col:1448
CPUID_FEATURE_INFORMATION_ECX_TSC_DEADLINE_BIT =               24 //col:1457
CPUID_FEATURE_INFORMATION_ECX_TSC_DEADLINE_FLAG =              0x1000000 //col:1458
CPUID_FEATURE_INFORMATION_ECX_TSC_DEADLINE_MASK =              0x01 //col:1459
CPUID_FEATURE_INFORMATION_ECX_TSC_DEADLINE(_) =                (((_) >> 24) & 0x01) //col:1460
CPUID_FEATURE_INFORMATION_ECX_AESNI_INSTRUCTION_EXTENSIONS_BIT = 25 //col:1468
CPUID_FEATURE_INFORMATION_ECX_AESNI_INSTRUCTION_EXTENSIONS_FLAG = 0x2000000 //col:1469
CPUID_FEATURE_INFORMATION_ECX_AESNI_INSTRUCTION_EXTENSIONS_MASK = 0x01 //col:1470
CPUID_FEATURE_INFORMATION_ECX_AESNI_INSTRUCTION_EXTENSIONS(_) = (((_) >> 25) & 0x01) //col:1471
CPUID_FEATURE_INFORMATION_ECX_XSAVE_XRSTOR_INSTRUCTION_BIT =   26 //col:1480
CPUID_FEATURE_INFORMATION_ECX_XSAVE_XRSTOR_INSTRUCTION_FLAG =  0x4000000 //col:1481
CPUID_FEATURE_INFORMATION_ECX_XSAVE_XRSTOR_INSTRUCTION_MASK =  0x01 //col:1482
CPUID_FEATURE_INFORMATION_ECX_XSAVE_XRSTOR_INSTRUCTION(_) =    (((_) >> 26) & 0x01) //col:1483
CPUID_FEATURE_INFORMATION_ECX_OSX_SAVE_BIT =                   27 //col:1492
CPUID_FEATURE_INFORMATION_ECX_OSX_SAVE_FLAG =                  0x8000000 //col:1493
CPUID_FEATURE_INFORMATION_ECX_OSX_SAVE_MASK =                  0x01 //col:1494
CPUID_FEATURE_INFORMATION_ECX_OSX_SAVE(_) =                    (((_) >> 27) & 0x01) //col:1495
CPUID_FEATURE_INFORMATION_ECX_AVX_SUPPORT_BIT =                28 //col:1503
CPUID_FEATURE_INFORMATION_ECX_AVX_SUPPORT_FLAG =               0x10000000 //col:1504
CPUID_FEATURE_INFORMATION_ECX_AVX_SUPPORT_MASK =               0x01 //col:1505
CPUID_FEATURE_INFORMATION_ECX_AVX_SUPPORT(_) =                 (((_) >> 28) & 0x01) //col:1506
CPUID_FEATURE_INFORMATION_ECX_HALF_PRECISION_CONVERSION_INSTRUCTIONS_BIT = 29 //col:1514
CPUID_FEATURE_INFORMATION_ECX_HALF_PRECISION_CONVERSION_INSTRUCTIONS_FLAG = 0x20000000 //col:1515
CPUID_FEATURE_INFORMATION_ECX_HALF_PRECISION_CONVERSION_INSTRUCTIONS_MASK = 0x01 //col:1516
CPUID_FEATURE_INFORMATION_ECX_HALF_PRECISION_CONVERSION_INSTRUCTIONS(_) = (((_) >> 29) & 0x01) //col:1517
CPUID_FEATURE_INFORMATION_ECX_RDRAND_INSTRUCTION_BIT =         30 //col:1525
CPUID_FEATURE_INFORMATION_ECX_RDRAND_INSTRUCTION_FLAG =        0x40000000 //col:1526
CPUID_FEATURE_INFORMATION_ECX_RDRAND_INSTRUCTION_MASK =        0x01 //col:1527
CPUID_FEATURE_INFORMATION_ECX_RDRAND_INSTRUCTION(_) =          (((_) >> 30) & 0x01) //col:1528
CPUID_FEATURE_INFORMATION_EDX_FLOATING_POINT_UNIT_ON_CHIP_BIT = 0 //col:1548
CPUID_FEATURE_INFORMATION_EDX_FLOATING_POINT_UNIT_ON_CHIP_FLAG = 0x01 //col:1549
CPUID_FEATURE_INFORMATION_EDX_FLOATING_POINT_UNIT_ON_CHIP_MASK = 0x01 //col:1550
CPUID_FEATURE_INFORMATION_EDX_FLOATING_POINT_UNIT_ON_CHIP(_) = (((_) >> 0) & 0x01) //col:1551
CPUID_FEATURE_INFORMATION_EDX_VIRTUAL_8086_MODE_ENHANCEMENTS_BIT = 1 //col:1561
CPUID_FEATURE_INFORMATION_EDX_VIRTUAL_8086_MODE_ENHANCEMENTS_FLAG = 0x02 //col:1562
CPUID_FEATURE_INFORMATION_EDX_VIRTUAL_8086_MODE_ENHANCEMENTS_MASK = 0x01 //col:1563
CPUID_FEATURE_INFORMATION_EDX_VIRTUAL_8086_MODE_ENHANCEMENTS(_) = (((_) >> 1) & 0x01) //col:1564
CPUID_FEATURE_INFORMATION_EDX_DEBUGGING_EXTENSIONS_BIT =       2 //col:1573
CPUID_FEATURE_INFORMATION_EDX_DEBUGGING_EXTENSIONS_FLAG =      0x04 //col:1574
CPUID_FEATURE_INFORMATION_EDX_DEBUGGING_EXTENSIONS_MASK =      0x01 //col:1575
CPUID_FEATURE_INFORMATION_EDX_DEBUGGING_EXTENSIONS(_) =        (((_) >> 2) & 0x01) //col:1576
CPUID_FEATURE_INFORMATION_EDX_PAGE_SIZE_EXTENSION_BIT =        3 //col:1585
CPUID_FEATURE_INFORMATION_EDX_PAGE_SIZE_EXTENSION_FLAG =       0x08 //col:1586
CPUID_FEATURE_INFORMATION_EDX_PAGE_SIZE_EXTENSION_MASK =       0x01 //col:1587
CPUID_FEATURE_INFORMATION_EDX_PAGE_SIZE_EXTENSION(_) =         (((_) >> 3) & 0x01) //col:1588
CPUID_FEATURE_INFORMATION_EDX_TIMESTAMP_COUNTER_BIT =          4 //col:1596
CPUID_FEATURE_INFORMATION_EDX_TIMESTAMP_COUNTER_FLAG =         0x10 //col:1597
CPUID_FEATURE_INFORMATION_EDX_TIMESTAMP_COUNTER_MASK =         0x01 //col:1598
CPUID_FEATURE_INFORMATION_EDX_TIMESTAMP_COUNTER(_) =           (((_) >> 4) & 0x01) //col:1599
CPUID_FEATURE_INFORMATION_EDX_RDMSR_WRMSR_INSTRUCTIONS_BIT =   5 //col:1607
CPUID_FEATURE_INFORMATION_EDX_RDMSR_WRMSR_INSTRUCTIONS_FLAG =  0x20 //col:1608
CPUID_FEATURE_INFORMATION_EDX_RDMSR_WRMSR_INSTRUCTIONS_MASK =  0x01 //col:1609
CPUID_FEATURE_INFORMATION_EDX_RDMSR_WRMSR_INSTRUCTIONS(_) =    (((_) >> 5) & 0x01) //col:1610
CPUID_FEATURE_INFORMATION_EDX_PHYSICAL_ADDRESS_EXTENSION_BIT = 6 //col:1619
CPUID_FEATURE_INFORMATION_EDX_PHYSICAL_ADDRESS_EXTENSION_FLAG = 0x40 //col:1620
CPUID_FEATURE_INFORMATION_EDX_PHYSICAL_ADDRESS_EXTENSION_MASK = 0x01 //col:1621
CPUID_FEATURE_INFORMATION_EDX_PHYSICAL_ADDRESS_EXTENSION(_) =  (((_) >> 6) & 0x01) //col:1622
CPUID_FEATURE_INFORMATION_EDX_MACHINE_CHECK_EXCEPTION_BIT =    7 //col:1633
CPUID_FEATURE_INFORMATION_EDX_MACHINE_CHECK_EXCEPTION_FLAG =   0x80 //col:1634
CPUID_FEATURE_INFORMATION_EDX_MACHINE_CHECK_EXCEPTION_MASK =   0x01 //col:1635
CPUID_FEATURE_INFORMATION_EDX_MACHINE_CHECK_EXCEPTION(_) =     (((_) >> 7) & 0x01) //col:1636
CPUID_FEATURE_INFORMATION_EDX_CMPXCHG8B_BIT =                  8 //col:1644
CPUID_FEATURE_INFORMATION_EDX_CMPXCHG8B_FLAG =                 0x100 //col:1645
CPUID_FEATURE_INFORMATION_EDX_CMPXCHG8B_MASK =                 0x01 //col:1646
CPUID_FEATURE_INFORMATION_EDX_CMPXCHG8B(_) =                   (((_) >> 8) & 0x01) //col:1647
CPUID_FEATURE_INFORMATION_EDX_APIC_ON_CHIP_BIT =               9 //col:1657
CPUID_FEATURE_INFORMATION_EDX_APIC_ON_CHIP_FLAG =              0x200 //col:1658
CPUID_FEATURE_INFORMATION_EDX_APIC_ON_CHIP_MASK =              0x01 //col:1659
CPUID_FEATURE_INFORMATION_EDX_APIC_ON_CHIP(_) =                (((_) >> 9) & 0x01) //col:1660
CPUID_FEATURE_INFORMATION_EDX_SYSENTER_SYSEXIT_INSTRUCTIONS_BIT = 11 //col:1669
CPUID_FEATURE_INFORMATION_EDX_SYSENTER_SYSEXIT_INSTRUCTIONS_FLAG = 0x800 //col:1670
CPUID_FEATURE_INFORMATION_EDX_SYSENTER_SYSEXIT_INSTRUCTIONS_MASK = 0x01 //col:1671
CPUID_FEATURE_INFORMATION_EDX_SYSENTER_SYSEXIT_INSTRUCTIONS(_) = (((_) >> 11) & 0x01) //col:1672
CPUID_FEATURE_INFORMATION_EDX_MEMORY_TYPE_RANGE_REGISTERS_BIT = 12 //col:1681
CPUID_FEATURE_INFORMATION_EDX_MEMORY_TYPE_RANGE_REGISTERS_FLAG = 0x1000 //col:1682
CPUID_FEATURE_INFORMATION_EDX_MEMORY_TYPE_RANGE_REGISTERS_MASK = 0x01 //col:1683
CPUID_FEATURE_INFORMATION_EDX_MEMORY_TYPE_RANGE_REGISTERS(_) = (((_) >> 12) & 0x01) //col:1684
CPUID_FEATURE_INFORMATION_EDX_PAGE_GLOBAL_BIT_BIT =            13 //col:1693
CPUID_FEATURE_INFORMATION_EDX_PAGE_GLOBAL_BIT_FLAG =           0x2000 //col:1694
CPUID_FEATURE_INFORMATION_EDX_PAGE_GLOBAL_BIT_MASK =           0x01 //col:1695
CPUID_FEATURE_INFORMATION_EDX_PAGE_GLOBAL_BIT(_) =             (((_) >> 13) & 0x01) //col:1696
CPUID_FEATURE_INFORMATION_EDX_MACHINE_CHECK_ARCHITECTURE_BIT = 14 //col:1705
CPUID_FEATURE_INFORMATION_EDX_MACHINE_CHECK_ARCHITECTURE_FLAG = 0x4000 //col:1706
CPUID_FEATURE_INFORMATION_EDX_MACHINE_CHECK_ARCHITECTURE_MASK = 0x01 //col:1707
CPUID_FEATURE_INFORMATION_EDX_MACHINE_CHECK_ARCHITECTURE(_) =  (((_) >> 14) & 0x01) //col:1708
CPUID_FEATURE_INFORMATION_EDX_CONDITIONAL_MOVE_INSTRUCTIONS_BIT = 15 //col:1717
CPUID_FEATURE_INFORMATION_EDX_CONDITIONAL_MOVE_INSTRUCTIONS_FLAG = 0x8000 //col:1718
CPUID_FEATURE_INFORMATION_EDX_CONDITIONAL_MOVE_INSTRUCTIONS_MASK = 0x01 //col:1719
CPUID_FEATURE_INFORMATION_EDX_CONDITIONAL_MOVE_INSTRUCTIONS(_) = (((_) >> 15) & 0x01) //col:1720
CPUID_FEATURE_INFORMATION_EDX_PAGE_ATTRIBUTE_TABLE_BIT =       16 //col:1729
CPUID_FEATURE_INFORMATION_EDX_PAGE_ATTRIBUTE_TABLE_FLAG =      0x10000 //col:1730
CPUID_FEATURE_INFORMATION_EDX_PAGE_ATTRIBUTE_TABLE_MASK =      0x01 //col:1731
CPUID_FEATURE_INFORMATION_EDX_PAGE_ATTRIBUTE_TABLE(_) =        (((_) >> 16) & 0x01) //col:1732
CPUID_FEATURE_INFORMATION_EDX_PAGE_SIZE_EXTENSION_36BIT_BIT =  17 //col:1742
CPUID_FEATURE_INFORMATION_EDX_PAGE_SIZE_EXTENSION_36BIT_FLAG = 0x20000 //col:1743
CPUID_FEATURE_INFORMATION_EDX_PAGE_SIZE_EXTENSION_36BIT_MASK = 0x01 //col:1744
CPUID_FEATURE_INFORMATION_EDX_PAGE_SIZE_EXTENSION_36BIT(_) =   (((_) >> 17) & 0x01) //col:1745
CPUID_FEATURE_INFORMATION_EDX_PROCESSOR_SERIAL_NUMBER_BIT =    18 //col:1753
CPUID_FEATURE_INFORMATION_EDX_PROCESSOR_SERIAL_NUMBER_FLAG =   0x40000 //col:1754
CPUID_FEATURE_INFORMATION_EDX_PROCESSOR_SERIAL_NUMBER_MASK =   0x01 //col:1755
CPUID_FEATURE_INFORMATION_EDX_PROCESSOR_SERIAL_NUMBER(_) =     (((_) >> 18) & 0x01) //col:1756
CPUID_FEATURE_INFORMATION_EDX_CLFLUSH_BIT =                    19 //col:1764
CPUID_FEATURE_INFORMATION_EDX_CLFLUSH_FLAG =                   0x80000 //col:1765
CPUID_FEATURE_INFORMATION_EDX_CLFLUSH_MASK =                   0x01 //col:1766
CPUID_FEATURE_INFORMATION_EDX_CLFLUSH(_) =                     (((_) >> 19) & 0x01) //col:1767
CPUID_FEATURE_INFORMATION_EDX_DEBUG_STORE_BIT =                21 //col:1779
CPUID_FEATURE_INFORMATION_EDX_DEBUG_STORE_FLAG =               0x200000 //col:1780
CPUID_FEATURE_INFORMATION_EDX_DEBUG_STORE_MASK =               0x01 //col:1781
CPUID_FEATURE_INFORMATION_EDX_DEBUG_STORE(_) =                 (((_) >> 21) & 0x01) //col:1782
CPUID_FEATURE_INFORMATION_EDX_THERMAL_CONTROL_MSRS_FOR_ACPI_BIT = 22 //col:1791
CPUID_FEATURE_INFORMATION_EDX_THERMAL_CONTROL_MSRS_FOR_ACPI_FLAG = 0x400000 //col:1792
CPUID_FEATURE_INFORMATION_EDX_THERMAL_CONTROL_MSRS_FOR_ACPI_MASK = 0x01 //col:1793
CPUID_FEATURE_INFORMATION_EDX_THERMAL_CONTROL_MSRS_FOR_ACPI(_) = (((_) >> 22) & 0x01) //col:1794
CPUID_FEATURE_INFORMATION_EDX_MMX_SUPPORT_BIT =                23 //col:1802
CPUID_FEATURE_INFORMATION_EDX_MMX_SUPPORT_FLAG =               0x800000 //col:1803
CPUID_FEATURE_INFORMATION_EDX_MMX_SUPPORT_MASK =               0x01 //col:1804
CPUID_FEATURE_INFORMATION_EDX_MMX_SUPPORT(_) =                 (((_) >> 23) & 0x01) //col:1805
CPUID_FEATURE_INFORMATION_EDX_FXSAVE_FXRSTOR_INSTRUCTIONS_BIT = 24 //col:1815
CPUID_FEATURE_INFORMATION_EDX_FXSAVE_FXRSTOR_INSTRUCTIONS_FLAG = 0x1000000 //col:1816
CPUID_FEATURE_INFORMATION_EDX_FXSAVE_FXRSTOR_INSTRUCTIONS_MASK = 0x01 //col:1817
CPUID_FEATURE_INFORMATION_EDX_FXSAVE_FXRSTOR_INSTRUCTIONS(_) = (((_) >> 24) & 0x01) //col:1818
CPUID_FEATURE_INFORMATION_EDX_SSE_SUPPORT_BIT =                25 //col:1826
CPUID_FEATURE_INFORMATION_EDX_SSE_SUPPORT_FLAG =               0x2000000 //col:1827
CPUID_FEATURE_INFORMATION_EDX_SSE_SUPPORT_MASK =               0x01 //col:1828
CPUID_FEATURE_INFORMATION_EDX_SSE_SUPPORT(_) =                 (((_) >> 25) & 0x01) //col:1829
CPUID_FEATURE_INFORMATION_EDX_SSE2_SUPPORT_BIT =               26 //col:1837
CPUID_FEATURE_INFORMATION_EDX_SSE2_SUPPORT_FLAG =              0x4000000 //col:1838
CPUID_FEATURE_INFORMATION_EDX_SSE2_SUPPORT_MASK =              0x01 //col:1839
CPUID_FEATURE_INFORMATION_EDX_SSE2_SUPPORT(_) =                (((_) >> 26) & 0x01) //col:1840
CPUID_FEATURE_INFORMATION_EDX_SELF_SNOOP_BIT =                 27 //col:1849
CPUID_FEATURE_INFORMATION_EDX_SELF_SNOOP_FLAG =                0x8000000 //col:1850
CPUID_FEATURE_INFORMATION_EDX_SELF_SNOOP_MASK =                0x01 //col:1851
CPUID_FEATURE_INFORMATION_EDX_SELF_SNOOP(_) =                  (((_) >> 27) & 0x01) //col:1852
CPUID_FEATURE_INFORMATION_EDX_HYPER_THREADING_TECHNOLOGY_BIT = 28 //col:1862
CPUID_FEATURE_INFORMATION_EDX_HYPER_THREADING_TECHNOLOGY_FLAG = 0x10000000 //col:1863
CPUID_FEATURE_INFORMATION_EDX_HYPER_THREADING_TECHNOLOGY_MASK = 0x01 //col:1864
CPUID_FEATURE_INFORMATION_EDX_HYPER_THREADING_TECHNOLOGY(_) =  (((_) >> 28) & 0x01) //col:1865
CPUID_FEATURE_INFORMATION_EDX_THERMAL_MONITOR_BIT =            29 //col:1873
CPUID_FEATURE_INFORMATION_EDX_THERMAL_MONITOR_FLAG =           0x20000000 //col:1874
CPUID_FEATURE_INFORMATION_EDX_THERMAL_MONITOR_MASK =           0x01 //col:1875
CPUID_FEATURE_INFORMATION_EDX_THERMAL_MONITOR(_) =             (((_) >> 29) & 0x01) //col:1876
CPUID_FEATURE_INFORMATION_EDX_PENDING_BREAK_ENABLE_BIT =       31 //col:1887
CPUID_FEATURE_INFORMATION_EDX_PENDING_BREAK_ENABLE_FLAG =      0x80000000 //col:1888
CPUID_FEATURE_INFORMATION_EDX_PENDING_BREAK_ENABLE_MASK =      0x01 //col:1889
CPUID_FEATURE_INFORMATION_EDX_PENDING_BREAK_ENABLE(_) =        (((_) >> 31) & 0x01) //col:1890
CPUID_CACHE_PARAMETERS =                                       0x00000004 //col:1917
CPUID_EAX_CACHE_TYPE_FIELD_BIT =                               0 //col:1932
CPUID_EAX_CACHE_TYPE_FIELD_FLAG =                              0x1F //col:1933
CPUID_EAX_CACHE_TYPE_FIELD_MASK =                              0x1F //col:1934
CPUID_EAX_CACHE_TYPE_FIELD(_) =                                (((_) >> 0) & 0x1F) //col:1935
CPUID_EAX_CACHE_LEVEL_BIT =                                    5 //col:1941
CPUID_EAX_CACHE_LEVEL_FLAG =                                   0xE0 //col:1942
CPUID_EAX_CACHE_LEVEL_MASK =                                   0x07 //col:1943
CPUID_EAX_CACHE_LEVEL(_) =                                     (((_) >> 5) & 0x07) //col:1944
CPUID_EAX_SELF_INITIALIZING_CACHE_LEVEL_BIT =                  8 //col:1950
CPUID_EAX_SELF_INITIALIZING_CACHE_LEVEL_FLAG =                 0x100 //col:1951
CPUID_EAX_SELF_INITIALIZING_CACHE_LEVEL_MASK =                 0x01 //col:1952
CPUID_EAX_SELF_INITIALIZING_CACHE_LEVEL(_) =                   (((_) >> 8) & 0x01) //col:1953
CPUID_EAX_FULLY_ASSOCIATIVE_CACHE_BIT =                        9 //col:1959
CPUID_EAX_FULLY_ASSOCIATIVE_CACHE_FLAG =                       0x200 //col:1960
CPUID_EAX_FULLY_ASSOCIATIVE_CACHE_MASK =                       0x01 //col:1961
CPUID_EAX_FULLY_ASSOCIATIVE_CACHE(_) =                         (((_) >> 9) & 0x01) //col:1962
CPUID_EAX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS_SHARING_THIS_CACHE_BIT = 14 //col:1973
CPUID_EAX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS_SHARING_THIS_CACHE_FLAG = 0x3FFC000 //col:1974
CPUID_EAX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS_SHARING_THIS_CACHE_MASK = 0xFFF //col:1975
CPUID_EAX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS_SHARING_THIS_CACHE(_) = (((_) >> 14) & 0xFFF) //col:1976
CPUID_EAX_MAX_ADDRESSABLE_IDS_FOR_PROCESSOR_CORES_IN_PHYSICAL_PACKAGE_BIT = 26 //col:1987
CPUID_EAX_MAX_ADDRESSABLE_IDS_FOR_PROCESSOR_CORES_IN_PHYSICAL_PACKAGE_FLAG = 0xFC000000 //col:1988
CPUID_EAX_MAX_ADDRESSABLE_IDS_FOR_PROCESSOR_CORES_IN_PHYSICAL_PACKAGE_MASK = 0x3F //col:1989
CPUID_EAX_MAX_ADDRESSABLE_IDS_FOR_PROCESSOR_CORES_IN_PHYSICAL_PACKAGE(_) = (((_) >> 26) & 0x3F) //col:1990
CPUID_EBX_SYSTEM_COHERENCY_LINE_SIZE_BIT =                     0 //col:2006
CPUID_EBX_SYSTEM_COHERENCY_LINE_SIZE_FLAG =                    0xFFF //col:2007
CPUID_EBX_SYSTEM_COHERENCY_LINE_SIZE_MASK =                    0xFFF //col:2008
CPUID_EBX_SYSTEM_COHERENCY_LINE_SIZE(_) =                      (((_) >> 0) & 0xFFF) //col:2009
CPUID_EBX_PHYSICAL_LINE_PARTITIONS_BIT =                       12 //col:2017
CPUID_EBX_PHYSICAL_LINE_PARTITIONS_FLAG =                      0x3FF000 //col:2018
CPUID_EBX_PHYSICAL_LINE_PARTITIONS_MASK =                      0x3FF //col:2019
CPUID_EBX_PHYSICAL_LINE_PARTITIONS(_) =                        (((_) >> 12) & 0x3FF) //col:2020
CPUID_EBX_WAYS_OF_ASSOCIATIVITY_BIT =                          22 //col:2028
CPUID_EBX_WAYS_OF_ASSOCIATIVITY_FLAG =                         0xFFC00000 //col:2029
CPUID_EBX_WAYS_OF_ASSOCIATIVITY_MASK =                         0x3FF //col:2030
CPUID_EBX_WAYS_OF_ASSOCIATIVITY(_) =                           (((_) >> 22) & 0x3FF) //col:2031
CPUID_ECX_NUMBER_OF_SETS_BIT =                                 0 //col:2047
CPUID_ECX_NUMBER_OF_SETS_FLAG =                                0xFFFFFFFF //col:2048
CPUID_ECX_NUMBER_OF_SETS_MASK =                                0xFFFFFFFF //col:2049
CPUID_ECX_NUMBER_OF_SETS(_) =                                  (((_) >> 0) & 0xFFFFFFFF) //col:2050
CPUID_EDX_WRITE_BACK_INVALIDATE_BIT =                          0 //col:2067
CPUID_EDX_WRITE_BACK_INVALIDATE_FLAG =                         0x01 //col:2068
CPUID_EDX_WRITE_BACK_INVALIDATE_MASK =                         0x01 //col:2069
CPUID_EDX_WRITE_BACK_INVALIDATE(_) =                           (((_) >> 0) & 0x01) //col:2070
CPUID_EDX_CACHE_INCLUSIVENESS_BIT =                            1 //col:2079
CPUID_EDX_CACHE_INCLUSIVENESS_FLAG =                           0x02 //col:2080
CPUID_EDX_CACHE_INCLUSIVENESS_MASK =                           0x01 //col:2081
CPUID_EDX_CACHE_INCLUSIVENESS(_) =                             (((_) >> 1) & 0x01) //col:2082
CPUID_EDX_COMPLEX_CACHE_INDEXING_BIT =                         2 //col:2091
CPUID_EDX_COMPLEX_CACHE_INDEXING_FLAG =                        0x04 //col:2092
CPUID_EDX_COMPLEX_CACHE_INDEXING_MASK =                        0x01 //col:2093
CPUID_EDX_COMPLEX_CACHE_INDEXING(_) =                          (((_) >> 2) & 0x01) //col:2094
CPUID_MONITOR_MWAIT =                                          0x00000005 //col:2111
CPUID_EAX_SMALLEST_MONITOR_LINE_SIZE_BIT =                     0 //col:2122
CPUID_EAX_SMALLEST_MONITOR_LINE_SIZE_FLAG =                    0xFFFF //col:2123
CPUID_EAX_SMALLEST_MONITOR_LINE_SIZE_MASK =                    0xFFFF //col:2124
CPUID_EAX_SMALLEST_MONITOR_LINE_SIZE(_) =                      (((_) >> 0) & 0xFFFF) //col:2125
CPUID_EBX_LARGEST_MONITOR_LINE_SIZE_BIT =                      0 //col:2140
CPUID_EBX_LARGEST_MONITOR_LINE_SIZE_FLAG =                     0xFFFF //col:2141
CPUID_EBX_LARGEST_MONITOR_LINE_SIZE_MASK =                     0xFFFF //col:2142
CPUID_EBX_LARGEST_MONITOR_LINE_SIZE(_) =                       (((_) >> 0) & 0xFFFF) //col:2143
CPUID_ECX_ENUMERATION_OF_MONITOR_MWAIT_EXTENSIONS_BIT =        0 //col:2158
CPUID_ECX_ENUMERATION_OF_MONITOR_MWAIT_EXTENSIONS_FLAG =       0x01 //col:2159
CPUID_ECX_ENUMERATION_OF_MONITOR_MWAIT_EXTENSIONS_MASK =       0x01 //col:2160
CPUID_ECX_ENUMERATION_OF_MONITOR_MWAIT_EXTENSIONS(_) =         (((_) >> 0) & 0x01) //col:2161
CPUID_ECX_SUPPORTS_TREATING_INTERRUPTS_AS_BREAK_EVENT_FOR_MWAIT_BIT = 1 //col:2167
CPUID_ECX_SUPPORTS_TREATING_INTERRUPTS_AS_BREAK_EVENT_FOR_MWAIT_FLAG = 0x02 //col:2168
CPUID_ECX_SUPPORTS_TREATING_INTERRUPTS_AS_BREAK_EVENT_FOR_MWAIT_MASK = 0x01 //col:2169
CPUID_ECX_SUPPORTS_TREATING_INTERRUPTS_AS_BREAK_EVENT_FOR_MWAIT(_) = (((_) >> 1) & 0x01) //col:2170
CPUID_EDX_NUMBER_OF_C0_SUB_C_STATES_BIT =                      0 //col:2185
CPUID_EDX_NUMBER_OF_C0_SUB_C_STATES_FLAG =                     0x0F //col:2186
CPUID_EDX_NUMBER_OF_C0_SUB_C_STATES_MASK =                     0x0F //col:2187
CPUID_EDX_NUMBER_OF_C0_SUB_C_STATES(_) =                       (((_) >> 0) & 0x0F) //col:2188
CPUID_EDX_NUMBER_OF_C1_SUB_C_STATES_BIT =                      4 //col:2194
CPUID_EDX_NUMBER_OF_C1_SUB_C_STATES_FLAG =                     0xF0 //col:2195
CPUID_EDX_NUMBER_OF_C1_SUB_C_STATES_MASK =                     0x0F //col:2196
CPUID_EDX_NUMBER_OF_C1_SUB_C_STATES(_) =                       (((_) >> 4) & 0x0F) //col:2197
CPUID_EDX_NUMBER_OF_C2_SUB_C_STATES_BIT =                      8 //col:2203
CPUID_EDX_NUMBER_OF_C2_SUB_C_STATES_FLAG =                     0xF00 //col:2204
CPUID_EDX_NUMBER_OF_C2_SUB_C_STATES_MASK =                     0x0F //col:2205
CPUID_EDX_NUMBER_OF_C2_SUB_C_STATES(_) =                       (((_) >> 8) & 0x0F) //col:2206
CPUID_EDX_NUMBER_OF_C3_SUB_C_STATES_BIT =                      12 //col:2212
CPUID_EDX_NUMBER_OF_C3_SUB_C_STATES_FLAG =                     0xF000 //col:2213
CPUID_EDX_NUMBER_OF_C3_SUB_C_STATES_MASK =                     0x0F //col:2214
CPUID_EDX_NUMBER_OF_C3_SUB_C_STATES(_) =                       (((_) >> 12) & 0x0F) //col:2215
CPUID_EDX_NUMBER_OF_C4_SUB_C_STATES_BIT =                      16 //col:2221
CPUID_EDX_NUMBER_OF_C4_SUB_C_STATES_FLAG =                     0xF0000 //col:2222
CPUID_EDX_NUMBER_OF_C4_SUB_C_STATES_MASK =                     0x0F //col:2223
CPUID_EDX_NUMBER_OF_C4_SUB_C_STATES(_) =                       (((_) >> 16) & 0x0F) //col:2224
CPUID_EDX_NUMBER_OF_C5_SUB_C_STATES_BIT =                      20 //col:2230
CPUID_EDX_NUMBER_OF_C5_SUB_C_STATES_FLAG =                     0xF00000 //col:2231
CPUID_EDX_NUMBER_OF_C5_SUB_C_STATES_MASK =                     0x0F //col:2232
CPUID_EDX_NUMBER_OF_C5_SUB_C_STATES(_) =                       (((_) >> 20) & 0x0F) //col:2233
CPUID_EDX_NUMBER_OF_C6_SUB_C_STATES_BIT =                      24 //col:2239
CPUID_EDX_NUMBER_OF_C6_SUB_C_STATES_FLAG =                     0xF000000 //col:2240
CPUID_EDX_NUMBER_OF_C6_SUB_C_STATES_MASK =                     0x0F //col:2241
CPUID_EDX_NUMBER_OF_C6_SUB_C_STATES(_) =                       (((_) >> 24) & 0x0F) //col:2242
CPUID_EDX_NUMBER_OF_C7_SUB_C_STATES_BIT =                      28 //col:2248
CPUID_EDX_NUMBER_OF_C7_SUB_C_STATES_FLAG =                     0xF0000000 //col:2249
CPUID_EDX_NUMBER_OF_C7_SUB_C_STATES_MASK =                     0x0F //col:2250
CPUID_EDX_NUMBER_OF_C7_SUB_C_STATES(_) =                       (((_) >> 28) & 0x0F) //col:2251
CPUID_THERMAL_AND_POWER_MANAGEMENT =                           0x00000006 //col:2265
CPUID_EAX_TEMPERATURE_SENSOR_SUPPORTED_BIT =                   0 //col:2276
CPUID_EAX_TEMPERATURE_SENSOR_SUPPORTED_FLAG =                  0x01 //col:2277
CPUID_EAX_TEMPERATURE_SENSOR_SUPPORTED_MASK =                  0x01 //col:2278
CPUID_EAX_TEMPERATURE_SENSOR_SUPPORTED(_) =                    (((_) >> 0) & 0x01) //col:2279
CPUID_EAX_INTEL_TURBO_BOOST_TECHNOLOGY_AVAILABLE_BIT =         1 //col:2285
CPUID_EAX_INTEL_TURBO_BOOST_TECHNOLOGY_AVAILABLE_FLAG =        0x02 //col:2286
CPUID_EAX_INTEL_TURBO_BOOST_TECHNOLOGY_AVAILABLE_MASK =        0x01 //col:2287
CPUID_EAX_INTEL_TURBO_BOOST_TECHNOLOGY_AVAILABLE(_) =          (((_) >> 1) & 0x01) //col:2288
CPUID_EAX_APIC_TIMER_ALWAYS_RUNNING_BIT =                      2 //col:2294
CPUID_EAX_APIC_TIMER_ALWAYS_RUNNING_FLAG =                     0x04 //col:2295
CPUID_EAX_APIC_TIMER_ALWAYS_RUNNING_MASK =                     0x01 //col:2296
CPUID_EAX_APIC_TIMER_ALWAYS_RUNNING(_) =                       (((_) >> 2) & 0x01) //col:2297
CPUID_EAX_POWER_LIMIT_NOTIFICATION_BIT =                       4 //col:2304
CPUID_EAX_POWER_LIMIT_NOTIFICATION_FLAG =                      0x10 //col:2305
CPUID_EAX_POWER_LIMIT_NOTIFICATION_MASK =                      0x01 //col:2306
CPUID_EAX_POWER_LIMIT_NOTIFICATION(_) =                        (((_) >> 4) & 0x01) //col:2307
CPUID_EAX_CLOCK_MODULATION_DUTY_BIT =                          5 //col:2313
CPUID_EAX_CLOCK_MODULATION_DUTY_FLAG =                         0x20 //col:2314
CPUID_EAX_CLOCK_MODULATION_DUTY_MASK =                         0x01 //col:2315
CPUID_EAX_CLOCK_MODULATION_DUTY(_) =                           (((_) >> 5) & 0x01) //col:2316
CPUID_EAX_PACKAGE_THERMAL_MANAGEMENT_BIT =                     6 //col:2322
CPUID_EAX_PACKAGE_THERMAL_MANAGEMENT_FLAG =                    0x40 //col:2323
CPUID_EAX_PACKAGE_THERMAL_MANAGEMENT_MASK =                    0x01 //col:2324
CPUID_EAX_PACKAGE_THERMAL_MANAGEMENT(_) =                      (((_) >> 6) & 0x01) //col:2325
CPUID_EAX_HWP_BASE_REGISTERS_BIT =                             7 //col:2332
CPUID_EAX_HWP_BASE_REGISTERS_FLAG =                            0x80 //col:2333
CPUID_EAX_HWP_BASE_REGISTERS_MASK =                            0x01 //col:2334
CPUID_EAX_HWP_BASE_REGISTERS(_) =                              (((_) >> 7) & 0x01) //col:2335
CPUID_EAX_HWP_NOTIFICATION_BIT =                               8 //col:2341
CPUID_EAX_HWP_NOTIFICATION_FLAG =                              0x100 //col:2342
CPUID_EAX_HWP_NOTIFICATION_MASK =                              0x01 //col:2343
CPUID_EAX_HWP_NOTIFICATION(_) =                                (((_) >> 8) & 0x01) //col:2344
CPUID_EAX_HWP_ACTIVITY_WINDOW_BIT =                            9 //col:2350
CPUID_EAX_HWP_ACTIVITY_WINDOW_FLAG =                           0x200 //col:2351
CPUID_EAX_HWP_ACTIVITY_WINDOW_MASK =                           0x01 //col:2352
CPUID_EAX_HWP_ACTIVITY_WINDOW(_) =                             (((_) >> 9) & 0x01) //col:2353
CPUID_EAX_HWP_ENERGY_PERFORMANCE_PREFERENCE_BIT =              10 //col:2359
CPUID_EAX_HWP_ENERGY_PERFORMANCE_PREFERENCE_FLAG =             0x400 //col:2360
CPUID_EAX_HWP_ENERGY_PERFORMANCE_PREFERENCE_MASK =             0x01 //col:2361
CPUID_EAX_HWP_ENERGY_PERFORMANCE_PREFERENCE(_) =               (((_) >> 10) & 0x01) //col:2362
CPUID_EAX_HWP_PACKAGE_LEVEL_REQUEST_BIT =                      11 //col:2368
CPUID_EAX_HWP_PACKAGE_LEVEL_REQUEST_FLAG =                     0x800 //col:2369
CPUID_EAX_HWP_PACKAGE_LEVEL_REQUEST_MASK =                     0x01 //col:2370
CPUID_EAX_HWP_PACKAGE_LEVEL_REQUEST(_) =                       (((_) >> 11) & 0x01) //col:2371
CPUID_EAX_HDC_BIT =                                            13 //col:2378
CPUID_EAX_HDC_FLAG =                                           0x2000 //col:2379
CPUID_EAX_HDC_MASK =                                           0x01 //col:2380
CPUID_EAX_HDC(_) =                                             (((_) >> 13) & 0x01) //col:2381
CPUID_EAX_INTEL_TURBO_BOOST_MAX_TECHNOLOGY_3_AVAILABLE_BIT =   14 //col:2387
CPUID_EAX_INTEL_TURBO_BOOST_MAX_TECHNOLOGY_3_AVAILABLE_FLAG =  0x4000 //col:2388
CPUID_EAX_INTEL_TURBO_BOOST_MAX_TECHNOLOGY_3_AVAILABLE_MASK =  0x01 //col:2389
CPUID_EAX_INTEL_TURBO_BOOST_MAX_TECHNOLOGY_3_AVAILABLE(_) =    (((_) >> 14) & 0x01) //col:2390
CPUID_EAX_HWP_CAPABILITIES_BIT =                               15 //col:2396
CPUID_EAX_HWP_CAPABILITIES_FLAG =                              0x8000 //col:2397
CPUID_EAX_HWP_CAPABILITIES_MASK =                              0x01 //col:2398
CPUID_EAX_HWP_CAPABILITIES(_) =                                (((_) >> 15) & 0x01) //col:2399
CPUID_EAX_HWP_PECI_OVERRIDE_BIT =                              16 //col:2405
CPUID_EAX_HWP_PECI_OVERRIDE_FLAG =                             0x10000 //col:2406
CPUID_EAX_HWP_PECI_OVERRIDE_MASK =                             0x01 //col:2407
CPUID_EAX_HWP_PECI_OVERRIDE(_) =                               (((_) >> 16) & 0x01) //col:2408
CPUID_EAX_FLEXIBLE_HWP_BIT =                                   17 //col:2414
CPUID_EAX_FLEXIBLE_HWP_FLAG =                                  0x20000 //col:2415
CPUID_EAX_FLEXIBLE_HWP_MASK =                                  0x01 //col:2416
CPUID_EAX_FLEXIBLE_HWP(_) =                                    (((_) >> 17) & 0x01) //col:2417
CPUID_EAX_FAST_ACCESS_MODE_FOR_HWP_REQUEST_MSR_BIT =           18 //col:2423
CPUID_EAX_FAST_ACCESS_MODE_FOR_HWP_REQUEST_MSR_FLAG =          0x40000 //col:2424
CPUID_EAX_FAST_ACCESS_MODE_FOR_HWP_REQUEST_MSR_MASK =          0x01 //col:2425
CPUID_EAX_FAST_ACCESS_MODE_FOR_HWP_REQUEST_MSR(_) =            (((_) >> 18) & 0x01) //col:2426
CPUID_EAX_IGNORING_IDLE_LOGICAL_PROCESSOR_HWP_REQUEST_BIT =    20 //col:2433
CPUID_EAX_IGNORING_IDLE_LOGICAL_PROCESSOR_HWP_REQUEST_FLAG =   0x100000 //col:2434
CPUID_EAX_IGNORING_IDLE_LOGICAL_PROCESSOR_HWP_REQUEST_MASK =   0x01 //col:2435
CPUID_EAX_IGNORING_IDLE_LOGICAL_PROCESSOR_HWP_REQUEST(_) =     (((_) >> 20) & 0x01) //col:2436
CPUID_EAX_INTEL_THREAD_DIRECTOR_BIT =                          23 //col:2444
CPUID_EAX_INTEL_THREAD_DIRECTOR_FLAG =                         0x800000 //col:2445
CPUID_EAX_INTEL_THREAD_DIRECTOR_MASK =                         0x01 //col:2446
CPUID_EAX_INTEL_THREAD_DIRECTOR(_) =                           (((_) >> 23) & 0x01) //col:2447
CPUID_EBX_NUMBER_OF_INTERRUPT_THRESHOLDS_IN_THERMAL_SENSOR_BIT = 0 //col:2462
CPUID_EBX_NUMBER_OF_INTERRUPT_THRESHOLDS_IN_THERMAL_SENSOR_FLAG = 0x0F //col:2463
CPUID_EBX_NUMBER_OF_INTERRUPT_THRESHOLDS_IN_THERMAL_SENSOR_MASK = 0x0F //col:2464
CPUID_EBX_NUMBER_OF_INTERRUPT_THRESHOLDS_IN_THERMAL_SENSOR(_) = (((_) >> 0) & 0x0F) //col:2465
CPUID_ECX_HARDWARE_COORDINATION_FEEDBACK_CAPABILITY_BIT =      0 //col:2482
CPUID_ECX_HARDWARE_COORDINATION_FEEDBACK_CAPABILITY_FLAG =     0x01 //col:2483
CPUID_ECX_HARDWARE_COORDINATION_FEEDBACK_CAPABILITY_MASK =     0x01 //col:2484
CPUID_ECX_HARDWARE_COORDINATION_FEEDBACK_CAPABILITY(_) =       (((_) >> 0) & 0x01) //col:2485
CPUID_ECX_NUMBER_OF_INTEL_THREAD_DIRECTOR_CLASSES_BIT =        3 //col:2493
CPUID_ECX_NUMBER_OF_INTEL_THREAD_DIRECTOR_CLASSES_FLAG =       0x08 //col:2494
CPUID_ECX_NUMBER_OF_INTEL_THREAD_DIRECTOR_CLASSES_MASK =       0x01 //col:2495
CPUID_ECX_NUMBER_OF_INTEL_THREAD_DIRECTOR_CLASSES(_) =         (((_) >> 3) & 0x01) //col:2496
CPUID_ECX_PERFORMANCE_ENERGY_BIAS_PREFERENCE_BIT =             8 //col:2504
CPUID_ECX_PERFORMANCE_ENERGY_BIAS_PREFERENCE_FLAG =            0xFF00 //col:2505
CPUID_ECX_PERFORMANCE_ENERGY_BIAS_PREFERENCE_MASK =            0xFF //col:2506
CPUID_ECX_PERFORMANCE_ENERGY_BIAS_PREFERENCE(_) =              (((_) >> 8) & 0xFF) //col:2507
CPUID_EDX_RESERVED_BIT =                                       0 //col:2522
CPUID_EDX_RESERVED_FLAG =                                      0xFFFFFFFF //col:2523
CPUID_EDX_RESERVED_MASK =                                      0xFFFFFFFF //col:2524
CPUID_EDX_RESERVED(_) =                                        (((_) >> 0) & 0xFFFFFFFF) //col:2525
CPUID_STRUCTURED_EXTENDED_FEATURE_FLAGS =                      0x00000007 //col:2543
CPUID_EAX_NUMBER_OF_SUB_LEAVES_BIT =                           0 //col:2554
CPUID_EAX_NUMBER_OF_SUB_LEAVES_FLAG =                          0xFFFFFFFF //col:2555
CPUID_EAX_NUMBER_OF_SUB_LEAVES_MASK =                          0xFFFFFFFF //col:2556
CPUID_EAX_NUMBER_OF_SUB_LEAVES(_) =                            (((_) >> 0) & 0xFFFFFFFF) //col:2557
CPUID_EBX_FSGSBASE_BIT =                                       0 //col:2571
CPUID_EBX_FSGSBASE_FLAG =                                      0x01 //col:2572
CPUID_EBX_FSGSBASE_MASK =                                      0x01 //col:2573
CPUID_EBX_FSGSBASE(_) =                                        (((_) >> 0) & 0x01) //col:2574
CPUID_EBX_IA32_TSC_ADJUST_MSR_BIT =                            1 //col:2580
CPUID_EBX_IA32_TSC_ADJUST_MSR_FLAG =                           0x02 //col:2581
CPUID_EBX_IA32_TSC_ADJUST_MSR_MASK =                           0x01 //col:2582
CPUID_EBX_IA32_TSC_ADJUST_MSR(_) =                             (((_) >> 1) & 0x01) //col:2583
CPUID_EBX_SGX_BIT =                                            2 //col:2589
CPUID_EBX_SGX_FLAG =                                           0x04 //col:2590
CPUID_EBX_SGX_MASK =                                           0x01 //col:2591
CPUID_EBX_SGX(_) =                                             (((_) >> 2) & 0x01) //col:2592
CPUID_EBX_BMI1_BIT =                                           3 //col:2598
CPUID_EBX_BMI1_FLAG =                                          0x08 //col:2599
CPUID_EBX_BMI1_MASK =                                          0x01 //col:2600
CPUID_EBX_BMI1(_) =                                            (((_) >> 3) & 0x01) //col:2601
CPUID_EBX_HLE_BIT =                                            4 //col:2607
CPUID_EBX_HLE_FLAG =                                           0x10 //col:2608
CPUID_EBX_HLE_MASK =                                           0x01 //col:2609
CPUID_EBX_HLE(_) =                                             (((_) >> 4) & 0x01) //col:2610
CPUID_EBX_AVX2_BIT =                                           5 //col:2616
CPUID_EBX_AVX2_FLAG =                                          0x20 //col:2617
CPUID_EBX_AVX2_MASK =                                          0x01 //col:2618
CPUID_EBX_AVX2(_) =                                            (((_) >> 5) & 0x01) //col:2619
CPUID_EBX_FDP_EXCPTN_ONLY_BIT =                                6 //col:2625
CPUID_EBX_FDP_EXCPTN_ONLY_FLAG =                               0x40 //col:2626
CPUID_EBX_FDP_EXCPTN_ONLY_MASK =                               0x01 //col:2627
CPUID_EBX_FDP_EXCPTN_ONLY(_) =                                 (((_) >> 6) & 0x01) //col:2628
CPUID_EBX_SMEP_BIT =                                           7 //col:2634
CPUID_EBX_SMEP_FLAG =                                          0x80 //col:2635
CPUID_EBX_SMEP_MASK =                                          0x01 //col:2636
CPUID_EBX_SMEP(_) =                                            (((_) >> 7) & 0x01) //col:2637
CPUID_EBX_BMI2_BIT =                                           8 //col:2643
CPUID_EBX_BMI2_FLAG =                                          0x100 //col:2644
CPUID_EBX_BMI2_MASK =                                          0x01 //col:2645
CPUID_EBX_BMI2(_) =                                            (((_) >> 8) & 0x01) //col:2646
CPUID_EBX_ENHANCED_REP_MOVSB_STOSB_BIT =                       9 //col:2652
CPUID_EBX_ENHANCED_REP_MOVSB_STOSB_FLAG =                      0x200 //col:2653
CPUID_EBX_ENHANCED_REP_MOVSB_STOSB_MASK =                      0x01 //col:2654
CPUID_EBX_ENHANCED_REP_MOVSB_STOSB(_) =                        (((_) >> 9) & 0x01) //col:2655
CPUID_EBX_INVPCID_BIT =                                        10 //col:2661
CPUID_EBX_INVPCID_FLAG =                                       0x400 //col:2662
CPUID_EBX_INVPCID_MASK =                                       0x01 //col:2663
CPUID_EBX_INVPCID(_) =                                         (((_) >> 10) & 0x01) //col:2664
CPUID_EBX_RTM_BIT =                                            11 //col:2670
CPUID_EBX_RTM_FLAG =                                           0x800 //col:2671
CPUID_EBX_RTM_MASK =                                           0x01 //col:2672
CPUID_EBX_RTM(_) =                                             (((_) >> 11) & 0x01) //col:2673
CPUID_EBX_RDT_M_BIT =                                          12 //col:2679
CPUID_EBX_RDT_M_FLAG =                                         0x1000 //col:2680
CPUID_EBX_RDT_M_MASK =                                         0x01 //col:2681
CPUID_EBX_RDT_M(_) =                                           (((_) >> 12) & 0x01) //col:2682
CPUID_EBX_DEPRECATES_BIT =                                     13 //col:2688
CPUID_EBX_DEPRECATES_FLAG =                                    0x2000 //col:2689
CPUID_EBX_DEPRECATES_MASK =                                    0x01 //col:2690
CPUID_EBX_DEPRECATES(_) =                                      (((_) >> 13) & 0x01) //col:2691
CPUID_EBX_MPX_BIT =                                            14 //col:2697
CPUID_EBX_MPX_FLAG =                                           0x4000 //col:2698
CPUID_EBX_MPX_MASK =                                           0x01 //col:2699
CPUID_EBX_MPX(_) =                                             (((_) >> 14) & 0x01) //col:2700
CPUID_EBX_RDT_BIT =                                            15 //col:2706
CPUID_EBX_RDT_FLAG =                                           0x8000 //col:2707
CPUID_EBX_RDT_MASK =                                           0x01 //col:2708
CPUID_EBX_RDT(_) =                                             (((_) >> 15) & 0x01) //col:2709
CPUID_EBX_AVX512F_BIT =                                        16 //col:2715
CPUID_EBX_AVX512F_FLAG =                                       0x10000 //col:2716
CPUID_EBX_AVX512F_MASK =                                       0x01 //col:2717
CPUID_EBX_AVX512F(_) =                                         (((_) >> 16) & 0x01) //col:2718
CPUID_EBX_AVX512DQ_BIT =                                       17 //col:2724
CPUID_EBX_AVX512DQ_FLAG =                                      0x20000 //col:2725
CPUID_EBX_AVX512DQ_MASK =                                      0x01 //col:2726
CPUID_EBX_AVX512DQ(_) =                                        (((_) >> 17) & 0x01) //col:2727
CPUID_EBX_RDSEED_BIT =                                         18 //col:2733
CPUID_EBX_RDSEED_FLAG =                                        0x40000 //col:2734
CPUID_EBX_RDSEED_MASK =                                        0x01 //col:2735
CPUID_EBX_RDSEED(_) =                                          (((_) >> 18) & 0x01) //col:2736
CPUID_EBX_ADX_BIT =                                            19 //col:2742
CPUID_EBX_ADX_FLAG =                                           0x80000 //col:2743
CPUID_EBX_ADX_MASK =                                           0x01 //col:2744
CPUID_EBX_ADX(_) =                                             (((_) >> 19) & 0x01) //col:2745
CPUID_EBX_SMAP_BIT =                                           20 //col:2751
CPUID_EBX_SMAP_FLAG =                                          0x100000 //col:2752
CPUID_EBX_SMAP_MASK =                                          0x01 //col:2753
CPUID_EBX_SMAP(_) =                                            (((_) >> 20) & 0x01) //col:2754
CPUID_EBX_AVX512_IFMA_BIT =                                    21 //col:2760
CPUID_EBX_AVX512_IFMA_FLAG =                                   0x200000 //col:2761
CPUID_EBX_AVX512_IFMA_MASK =                                   0x01 //col:2762
CPUID_EBX_AVX512_IFMA(_) =                                     (((_) >> 21) & 0x01) //col:2763
CPUID_EBX_CLFLUSHOPT_BIT =                                     23 //col:2770
CPUID_EBX_CLFLUSHOPT_FLAG =                                    0x800000 //col:2771
CPUID_EBX_CLFLUSHOPT_MASK =                                    0x01 //col:2772
CPUID_EBX_CLFLUSHOPT(_) =                                      (((_) >> 23) & 0x01) //col:2773
CPUID_EBX_CLWB_BIT =                                           24 //col:2779
CPUID_EBX_CLWB_FLAG =                                          0x1000000 //col:2780
CPUID_EBX_CLWB_MASK =                                          0x01 //col:2781
CPUID_EBX_CLWB(_) =                                            (((_) >> 24) & 0x01) //col:2782
CPUID_EBX_INTEL_BIT =                                          25 //col:2788
CPUID_EBX_INTEL_FLAG =                                         0x2000000 //col:2789
CPUID_EBX_INTEL_MASK =                                         0x01 //col:2790
CPUID_EBX_INTEL(_) =                                           (((_) >> 25) & 0x01) //col:2791
CPUID_EBX_AVX512PF_BIT =                                       26 //col:2797
CPUID_EBX_AVX512PF_FLAG =                                      0x4000000 //col:2798
CPUID_EBX_AVX512PF_MASK =                                      0x01 //col:2799
CPUID_EBX_AVX512PF(_) =                                        (((_) >> 26) & 0x01) //col:2800
CPUID_EBX_AVX512ER_BIT =                                       27 //col:2806
CPUID_EBX_AVX512ER_FLAG =                                      0x8000000 //col:2807
CPUID_EBX_AVX512ER_MASK =                                      0x01 //col:2808
CPUID_EBX_AVX512ER(_) =                                        (((_) >> 27) & 0x01) //col:2809
CPUID_EBX_AVX512CD_BIT =                                       28 //col:2815
CPUID_EBX_AVX512CD_FLAG =                                      0x10000000 //col:2816
CPUID_EBX_AVX512CD_MASK =                                      0x01 //col:2817
CPUID_EBX_AVX512CD(_) =                                        (((_) >> 28) & 0x01) //col:2818
CPUID_EBX_SHA_BIT =                                            29 //col:2824
CPUID_EBX_SHA_FLAG =                                           0x20000000 //col:2825
CPUID_EBX_SHA_MASK =                                           0x01 //col:2826
CPUID_EBX_SHA(_) =                                             (((_) >> 29) & 0x01) //col:2827
CPUID_EBX_AVX512BW_BIT =                                       30 //col:2833
CPUID_EBX_AVX512BW_FLAG =                                      0x40000000 //col:2834
CPUID_EBX_AVX512BW_MASK =                                      0x01 //col:2835
CPUID_EBX_AVX512BW(_) =                                        (((_) >> 30) & 0x01) //col:2836
CPUID_EBX_AVX512VL_BIT =                                       31 //col:2842
CPUID_EBX_AVX512VL_FLAG =                                      0x80000000 //col:2843
CPUID_EBX_AVX512VL_MASK =                                      0x01 //col:2844
CPUID_EBX_AVX512VL(_) =                                        (((_) >> 31) & 0x01) //col:2845
CPUID_ECX_PREFETCHWT1_BIT =                                    0 //col:2859
CPUID_ECX_PREFETCHWT1_FLAG =                                   0x01 //col:2860
CPUID_ECX_PREFETCHWT1_MASK =                                   0x01 //col:2861
CPUID_ECX_PREFETCHWT1(_) =                                     (((_) >> 0) & 0x01) //col:2862
CPUID_ECX_AVX512_VBMI_BIT =                                    1 //col:2868
CPUID_ECX_AVX512_VBMI_FLAG =                                   0x02 //col:2869
CPUID_ECX_AVX512_VBMI_MASK =                                   0x01 //col:2870
CPUID_ECX_AVX512_VBMI(_) =                                     (((_) >> 1) & 0x01) //col:2871
CPUID_ECX_UMIP_BIT =                                           2 //col:2877
CPUID_ECX_UMIP_FLAG =                                          0x04 //col:2878
CPUID_ECX_UMIP_MASK =                                          0x01 //col:2879
CPUID_ECX_UMIP(_) =                                            (((_) >> 2) & 0x01) //col:2880
CPUID_ECX_PKU_BIT =                                            3 //col:2886
CPUID_ECX_PKU_FLAG =                                           0x08 //col:2887
CPUID_ECX_PKU_MASK =                                           0x01 //col:2888
CPUID_ECX_PKU(_) =                                             (((_) >> 3) & 0x01) //col:2889
CPUID_ECX_OSPKE_BIT =                                          4 //col:2895
CPUID_ECX_OSPKE_FLAG =                                         0x10 //col:2896
CPUID_ECX_OSPKE_MASK =                                         0x01 //col:2897
CPUID_ECX_OSPKE(_) =                                           (((_) >> 4) & 0x01) //col:2898
CPUID_ECX_WAITPKG_BIT =                                        5 //col:2904
CPUID_ECX_WAITPKG_FLAG =                                       0x20 //col:2905
CPUID_ECX_WAITPKG_MASK =                                       0x01 //col:2906
CPUID_ECX_WAITPKG(_) =                                         (((_) >> 5) & 0x01) //col:2907
CPUID_ECX_AVX512_VBMI2_BIT =                                   6 //col:2913
CPUID_ECX_AVX512_VBMI2_FLAG =                                  0x40 //col:2914
CPUID_ECX_AVX512_VBMI2_MASK =                                  0x01 //col:2915
CPUID_ECX_AVX512_VBMI2(_) =                                    (((_) >> 6) & 0x01) //col:2916
CPUID_ECX_CET_SS_BIT =                                         7 //col:2924
CPUID_ECX_CET_SS_FLAG =                                        0x80 //col:2925
CPUID_ECX_CET_SS_MASK =                                        0x01 //col:2926
CPUID_ECX_CET_SS(_) =                                          (((_) >> 7) & 0x01) //col:2927
CPUID_ECX_GFNI_BIT =                                           8 //col:2933
CPUID_ECX_GFNI_FLAG =                                          0x100 //col:2934
CPUID_ECX_GFNI_MASK =                                          0x01 //col:2935
CPUID_ECX_GFNI(_) =                                            (((_) >> 8) & 0x01) //col:2936
CPUID_ECX_VAES_BIT =                                           9 //col:2942
CPUID_ECX_VAES_FLAG =                                          0x200 //col:2943
CPUID_ECX_VAES_MASK =                                          0x01 //col:2944
CPUID_ECX_VAES(_) =                                            (((_) >> 9) & 0x01) //col:2945
CPUID_ECX_VPCLMULQDQ_BIT =                                     10 //col:2951
CPUID_ECX_VPCLMULQDQ_FLAG =                                    0x400 //col:2952
CPUID_ECX_VPCLMULQDQ_MASK =                                    0x01 //col:2953
CPUID_ECX_VPCLMULQDQ(_) =                                      (((_) >> 10) & 0x01) //col:2954
CPUID_ECX_AVX512_VNNI_BIT =                                    11 //col:2960
CPUID_ECX_AVX512_VNNI_FLAG =                                   0x800 //col:2961
CPUID_ECX_AVX512_VNNI_MASK =                                   0x01 //col:2962
CPUID_ECX_AVX512_VNNI(_) =                                     (((_) >> 11) & 0x01) //col:2963
CPUID_ECX_AVX512_BITALG_BIT =                                  12 //col:2969
CPUID_ECX_AVX512_BITALG_FLAG =                                 0x1000 //col:2970
CPUID_ECX_AVX512_BITALG_MASK =                                 0x01 //col:2971
CPUID_ECX_AVX512_BITALG(_) =                                   (((_) >> 12) & 0x01) //col:2972
CPUID_ECX_TME_EN_BIT =                                         13 //col:2979
CPUID_ECX_TME_EN_FLAG =                                        0x2000 //col:2980
CPUID_ECX_TME_EN_MASK =                                        0x01 //col:2981
CPUID_ECX_TME_EN(_) =                                          (((_) >> 13) & 0x01) //col:2982
CPUID_ECX_AVX512_VPOPCNTDQ_BIT =                               14 //col:2988
CPUID_ECX_AVX512_VPOPCNTDQ_FLAG =                              0x4000 //col:2989
CPUID_ECX_AVX512_VPOPCNTDQ_MASK =                              0x01 //col:2990
CPUID_ECX_AVX512_VPOPCNTDQ(_) =                                (((_) >> 14) & 0x01) //col:2991
CPUID_ECX_LA57_BIT =                                           16 //col:2998
CPUID_ECX_LA57_FLAG =                                          0x10000 //col:2999
CPUID_ECX_LA57_MASK =                                          0x01 //col:3000
CPUID_ECX_LA57(_) =                                            (((_) >> 16) & 0x01) //col:3001
CPUID_ECX_MAWAU_BIT =                                          17 //col:3007
CPUID_ECX_MAWAU_FLAG =                                         0x3E0000 //col:3008
CPUID_ECX_MAWAU_MASK =                                         0x1F //col:3009
CPUID_ECX_MAWAU(_) =                                           (((_) >> 17) & 0x1F) //col:3010
CPUID_ECX_RDPID_BIT =                                          22 //col:3016
CPUID_ECX_RDPID_FLAG =                                         0x400000 //col:3017
CPUID_ECX_RDPID_MASK =                                         0x01 //col:3018
CPUID_ECX_RDPID(_) =                                           (((_) >> 22) & 0x01) //col:3019
CPUID_ECX_KL_BIT =                                             23 //col:3025
CPUID_ECX_KL_FLAG =                                            0x800000 //col:3026
CPUID_ECX_KL_MASK =                                            0x01 //col:3027
CPUID_ECX_KL(_) =                                              (((_) >> 23) & 0x01) //col:3028
CPUID_ECX_CLDEMOTE_BIT =                                       25 //col:3035
CPUID_ECX_CLDEMOTE_FLAG =                                      0x2000000 //col:3036
CPUID_ECX_CLDEMOTE_MASK =                                      0x01 //col:3037
CPUID_ECX_CLDEMOTE(_) =                                        (((_) >> 25) & 0x01) //col:3038
CPUID_ECX_MOVDIRI_BIT =                                        27 //col:3045
CPUID_ECX_MOVDIRI_FLAG =                                       0x8000000 //col:3046
CPUID_ECX_MOVDIRI_MASK =                                       0x01 //col:3047
CPUID_ECX_MOVDIRI(_) =                                         (((_) >> 27) & 0x01) //col:3048
CPUID_ECX_MOVDIR64B_BIT =                                      28 //col:3054
CPUID_ECX_MOVDIR64B_FLAG =                                     0x10000000 //col:3055
CPUID_ECX_MOVDIR64B_MASK =                                     0x01 //col:3056
CPUID_ECX_MOVDIR64B(_) =                                       (((_) >> 28) & 0x01) //col:3057
CPUID_ECX_SGX_LC_BIT =                                         30 //col:3064
CPUID_ECX_SGX_LC_FLAG =                                        0x40000000 //col:3065
CPUID_ECX_SGX_LC_MASK =                                        0x01 //col:3066
CPUID_ECX_SGX_LC(_) =                                          (((_) >> 30) & 0x01) //col:3067
CPUID_ECX_PKS_BIT =                                            31 //col:3073
CPUID_ECX_PKS_FLAG =                                           0x80000000 //col:3074
CPUID_ECX_PKS_MASK =                                           0x01 //col:3075
CPUID_ECX_PKS(_) =                                             (((_) >> 31) & 0x01) //col:3076
CPUID_EDX_AVX512_4VNNIW_BIT =                                  2 //col:3092
CPUID_EDX_AVX512_4VNNIW_FLAG =                                 0x04 //col:3093
CPUID_EDX_AVX512_4VNNIW_MASK =                                 0x01 //col:3094
CPUID_EDX_AVX512_4VNNIW(_) =                                   (((_) >> 2) & 0x01) //col:3095
CPUID_EDX_AVX512_4FMAPS_BIT =                                  3 //col:3101
CPUID_EDX_AVX512_4FMAPS_FLAG =                                 0x08 //col:3102
CPUID_EDX_AVX512_4FMAPS_MASK =                                 0x01 //col:3103
CPUID_EDX_AVX512_4FMAPS(_) =                                   (((_) >> 3) & 0x01) //col:3104
CPUID_EDX_FAST_SHORT_REP_MOV_BIT =                             4 //col:3110
CPUID_EDX_FAST_SHORT_REP_MOV_FLAG =                            0x10 //col:3111
CPUID_EDX_FAST_SHORT_REP_MOV_MASK =                            0x01 //col:3112
CPUID_EDX_FAST_SHORT_REP_MOV(_) =                              (((_) >> 4) & 0x01) //col:3113
CPUID_EDX_AVX512_VP2INTERSECT_BIT =                            8 //col:3120
CPUID_EDX_AVX512_VP2INTERSECT_FLAG =                           0x100 //col:3121
CPUID_EDX_AVX512_VP2INTERSECT_MASK =                           0x01 //col:3122
CPUID_EDX_AVX512_VP2INTERSECT(_) =                             (((_) >> 8) & 0x01) //col:3123
CPUID_EDX_MD_CLEAR_BIT =                                       10 //col:3130
CPUID_EDX_MD_CLEAR_FLAG =                                      0x400 //col:3131
CPUID_EDX_MD_CLEAR_MASK =                                      0x01 //col:3132
CPUID_EDX_MD_CLEAR(_) =                                        (((_) >> 10) & 0x01) //col:3133
CPUID_EDX_SERIALIZE_BIT =                                      14 //col:3140
CPUID_EDX_SERIALIZE_FLAG =                                     0x4000 //col:3141
CPUID_EDX_SERIALIZE_MASK =                                     0x01 //col:3142
CPUID_EDX_SERIALIZE(_) =                                       (((_) >> 14) & 0x01) //col:3143
CPUID_EDX_HYBRID_BIT =                                         15 //col:3149
CPUID_EDX_HYBRID_FLAG =                                        0x8000 //col:3150
CPUID_EDX_HYBRID_MASK =                                        0x01 //col:3151
CPUID_EDX_HYBRID(_) =                                          (((_) >> 15) & 0x01) //col:3152
CPUID_EDX_PCONFIG_BIT =                                        18 //col:3159
CPUID_EDX_PCONFIG_FLAG =                                       0x40000 //col:3160
CPUID_EDX_PCONFIG_MASK =                                       0x01 //col:3161
CPUID_EDX_PCONFIG(_) =                                         (((_) >> 18) & 0x01) //col:3162
CPUID_EDX_CET_IBT_BIT =                                        20 //col:3170
CPUID_EDX_CET_IBT_FLAG =                                       0x100000 //col:3171
CPUID_EDX_CET_IBT_MASK =                                       0x01 //col:3172
CPUID_EDX_CET_IBT(_) =                                         (((_) >> 20) & 0x01) //col:3173
CPUID_EDX_IBRS_IBPB_BIT =                                      26 //col:3182
CPUID_EDX_IBRS_IBPB_FLAG =                                     0x4000000 //col:3183
CPUID_EDX_IBRS_IBPB_MASK =                                     0x01 //col:3184
CPUID_EDX_IBRS_IBPB(_) =                                       (((_) >> 26) & 0x01) //col:3185
CPUID_EDX_STIBP_BIT =                                          27 //col:3192
CPUID_EDX_STIBP_FLAG =                                         0x8000000 //col:3193
CPUID_EDX_STIBP_MASK =                                         0x01 //col:3194
CPUID_EDX_STIBP(_) =                                           (((_) >> 27) & 0x01) //col:3195
CPUID_EDX_L1D_FLUSH_BIT =                                      28 //col:3202
CPUID_EDX_L1D_FLUSH_FLAG =                                     0x10000000 //col:3203
CPUID_EDX_L1D_FLUSH_MASK =                                     0x01 //col:3204
CPUID_EDX_L1D_FLUSH(_) =                                       (((_) >> 28) & 0x01) //col:3205
CPUID_EDX_IA32_ARCH_CAPABILITIES_BIT =                         29 //col:3211
CPUID_EDX_IA32_ARCH_CAPABILITIES_FLAG =                        0x20000000 //col:3212
CPUID_EDX_IA32_ARCH_CAPABILITIES_MASK =                        0x01 //col:3213
CPUID_EDX_IA32_ARCH_CAPABILITIES(_) =                          (((_) >> 29) & 0x01) //col:3214
CPUID_EDX_IA32_CORE_CAPABILITIES_BIT =                         30 //col:3220
CPUID_EDX_IA32_CORE_CAPABILITIES_FLAG =                        0x40000000 //col:3221
CPUID_EDX_IA32_CORE_CAPABILITIES_MASK =                        0x01 //col:3222
CPUID_EDX_IA32_CORE_CAPABILITIES(_) =                          (((_) >> 30) & 0x01) //col:3223
CPUID_EDX_SSBD_BIT =                                           31 //col:3230
CPUID_EDX_SSBD_FLAG =                                          0x80000000 //col:3231
CPUID_EDX_SSBD_MASK =                                          0x01 //col:3232
CPUID_EDX_SSBD(_) =                                            (((_) >> 31) & 0x01) //col:3233
CPUID_DIRECT_CACHE_ACCESS_INFORMATION =                        0x00000009 //col:3247
CPUID_EAX_IA32_PLATFORM_DCA_CAP_BIT =                          0 //col:3258
CPUID_EAX_IA32_PLATFORM_DCA_CAP_FLAG =                         0xFFFFFFFF //col:3259
CPUID_EAX_IA32_PLATFORM_DCA_CAP_MASK =                         0xFFFFFFFF //col:3260
CPUID_EAX_IA32_PLATFORM_DCA_CAP(_) =                           (((_) >> 0) & 0xFFFFFFFF) //col:3261
CPUID_EBX_RESERVED_BIT =                                       0 //col:3275
CPUID_EBX_RESERVED_FLAG =                                      0xFFFFFFFF //col:3276
CPUID_EBX_RESERVED_MASK =                                      0xFFFFFFFF //col:3277
CPUID_EBX_RESERVED(_) =                                        (((_) >> 0) & 0xFFFFFFFF) //col:3278
CPUID_ECX_RESERVED_BIT =                                       0 //col:3292
CPUID_ECX_RESERVED_FLAG =                                      0xFFFFFFFF //col:3293
CPUID_ECX_RESERVED_MASK =                                      0xFFFFFFFF //col:3294
CPUID_ECX_RESERVED(_) =                                        (((_) >> 0) & 0xFFFFFFFF) //col:3295
CPUID_EDX_RESERVED_BIT =                                       0 //col:3309
CPUID_EDX_RESERVED_FLAG =                                      0xFFFFFFFF //col:3310
CPUID_EDX_RESERVED_MASK =                                      0xFFFFFFFF //col:3311
CPUID_EDX_RESERVED(_) =                                        (((_) >> 0) & 0xFFFFFFFF) //col:3312
CPUID_ARCHITECTURAL_PERFORMANCE_MONITORING =                   0x0000000A //col:3331
CPUID_EAX_VERSION_ID_OF_ARCHITECTURAL_PERFORMANCE_MONITORING_BIT = 0 //col:3342
CPUID_EAX_VERSION_ID_OF_ARCHITECTURAL_PERFORMANCE_MONITORING_FLAG = 0xFF //col:3343
CPUID_EAX_VERSION_ID_OF_ARCHITECTURAL_PERFORMANCE_MONITORING_MASK = 0xFF //col:3344
CPUID_EAX_VERSION_ID_OF_ARCHITECTURAL_PERFORMANCE_MONITORING(_) = (((_) >> 0) & 0xFF) //col:3345
CPUID_EAX_NUMBER_OF_PERFORMANCE_MONITORING_COUNTER_PER_LOGICAL_PROCESSOR_BIT = 8 //col:3351
CPUID_EAX_NUMBER_OF_PERFORMANCE_MONITORING_COUNTER_PER_LOGICAL_PROCESSOR_FLAG = 0xFF00 //col:3352
CPUID_EAX_NUMBER_OF_PERFORMANCE_MONITORING_COUNTER_PER_LOGICAL_PROCESSOR_MASK = 0xFF //col:3353
CPUID_EAX_NUMBER_OF_PERFORMANCE_MONITORING_COUNTER_PER_LOGICAL_PROCESSOR(_) = (((_) >> 8) & 0xFF) //col:3354
CPUID_EAX_BIT_WIDTH_OF_PERFORMANCE_MONITORING_COUNTER_BIT =    16 //col:3360
CPUID_EAX_BIT_WIDTH_OF_PERFORMANCE_MONITORING_COUNTER_FLAG =   0xFF0000 //col:3361
CPUID_EAX_BIT_WIDTH_OF_PERFORMANCE_MONITORING_COUNTER_MASK =   0xFF //col:3362
CPUID_EAX_BIT_WIDTH_OF_PERFORMANCE_MONITORING_COUNTER(_) =     (((_) >> 16) & 0xFF) //col:3363
CPUID_EAX_EBX_BIT_VECTOR_LENGTH_BIT =                          24 //col:3369
CPUID_EAX_EBX_BIT_VECTOR_LENGTH_FLAG =                         0xFF000000 //col:3370
CPUID_EAX_EBX_BIT_VECTOR_LENGTH_MASK =                         0xFF //col:3371
CPUID_EAX_EBX_BIT_VECTOR_LENGTH(_) =                           (((_) >> 24) & 0xFF) //col:3372
CPUID_EBX_CORE_CYCLE_EVENT_NOT_AVAILABLE_BIT =                 0 //col:3386
CPUID_EBX_CORE_CYCLE_EVENT_NOT_AVAILABLE_FLAG =                0x01 //col:3387
CPUID_EBX_CORE_CYCLE_EVENT_NOT_AVAILABLE_MASK =                0x01 //col:3388
CPUID_EBX_CORE_CYCLE_EVENT_NOT_AVAILABLE(_) =                  (((_) >> 0) & 0x01) //col:3389
CPUID_EBX_INSTRUCTION_RETIRED_EVENT_NOT_AVAILABLE_BIT =        1 //col:3395
CPUID_EBX_INSTRUCTION_RETIRED_EVENT_NOT_AVAILABLE_FLAG =       0x02 //col:3396
CPUID_EBX_INSTRUCTION_RETIRED_EVENT_NOT_AVAILABLE_MASK =       0x01 //col:3397
CPUID_EBX_INSTRUCTION_RETIRED_EVENT_NOT_AVAILABLE(_) =         (((_) >> 1) & 0x01) //col:3398
CPUID_EBX_REFERENCE_CYCLES_EVENT_NOT_AVAILABLE_BIT =           2 //col:3404
CPUID_EBX_REFERENCE_CYCLES_EVENT_NOT_AVAILABLE_FLAG =          0x04 //col:3405
CPUID_EBX_REFERENCE_CYCLES_EVENT_NOT_AVAILABLE_MASK =          0x01 //col:3406
CPUID_EBX_REFERENCE_CYCLES_EVENT_NOT_AVAILABLE(_) =            (((_) >> 2) & 0x01) //col:3407
CPUID_EBX_LAST_LEVEL_CACHE_REFERENCE_EVENT_NOT_AVAILABLE_BIT = 3 //col:3413
CPUID_EBX_LAST_LEVEL_CACHE_REFERENCE_EVENT_NOT_AVAILABLE_FLAG = 0x08 //col:3414
CPUID_EBX_LAST_LEVEL_CACHE_REFERENCE_EVENT_NOT_AVAILABLE_MASK = 0x01 //col:3415
CPUID_EBX_LAST_LEVEL_CACHE_REFERENCE_EVENT_NOT_AVAILABLE(_) =  (((_) >> 3) & 0x01) //col:3416
CPUID_EBX_LAST_LEVEL_CACHE_MISSES_EVENT_NOT_AVAILABLE_BIT =    4 //col:3422
CPUID_EBX_LAST_LEVEL_CACHE_MISSES_EVENT_NOT_AVAILABLE_FLAG =   0x10 //col:3423
CPUID_EBX_LAST_LEVEL_CACHE_MISSES_EVENT_NOT_AVAILABLE_MASK =   0x01 //col:3424
CPUID_EBX_LAST_LEVEL_CACHE_MISSES_EVENT_NOT_AVAILABLE(_) =     (((_) >> 4) & 0x01) //col:3425
CPUID_EBX_BRANCH_INSTRUCTION_RETIRED_EVENT_NOT_AVAILABLE_BIT = 5 //col:3431
CPUID_EBX_BRANCH_INSTRUCTION_RETIRED_EVENT_NOT_AVAILABLE_FLAG = 0x20 //col:3432
CPUID_EBX_BRANCH_INSTRUCTION_RETIRED_EVENT_NOT_AVAILABLE_MASK = 0x01 //col:3433
CPUID_EBX_BRANCH_INSTRUCTION_RETIRED_EVENT_NOT_AVAILABLE(_) =  (((_) >> 5) & 0x01) //col:3434
CPUID_EBX_BRANCH_MISPREDICT_RETIRED_EVENT_NOT_AVAILABLE_BIT =  6 //col:3440
CPUID_EBX_BRANCH_MISPREDICT_RETIRED_EVENT_NOT_AVAILABLE_FLAG = 0x40 //col:3441
CPUID_EBX_BRANCH_MISPREDICT_RETIRED_EVENT_NOT_AVAILABLE_MASK = 0x01 //col:3442
CPUID_EBX_BRANCH_MISPREDICT_RETIRED_EVENT_NOT_AVAILABLE(_) =   (((_) >> 6) & 0x01) //col:3443
CPUID_ECX_RESERVED_BIT =                                       0 //col:3458
CPUID_ECX_RESERVED_FLAG =                                      0xFFFFFFFF //col:3459
CPUID_ECX_RESERVED_MASK =                                      0xFFFFFFFF //col:3460
CPUID_ECX_RESERVED(_) =                                        (((_) >> 0) & 0xFFFFFFFF) //col:3461
CPUID_EDX_NUMBER_OF_FIXED_FUNCTION_PERFORMANCE_COUNTERS_BIT =  0 //col:3475
CPUID_EDX_NUMBER_OF_FIXED_FUNCTION_PERFORMANCE_COUNTERS_FLAG = 0x1F //col:3476
CPUID_EDX_NUMBER_OF_FIXED_FUNCTION_PERFORMANCE_COUNTERS_MASK = 0x1F //col:3477
CPUID_EDX_NUMBER_OF_FIXED_FUNCTION_PERFORMANCE_COUNTERS(_) =   (((_) >> 0) & 0x1F) //col:3478
CPUID_EDX_BIT_WIDTH_OF_FIXED_FUNCTION_PERFORMANCE_COUNTERS_BIT = 5 //col:3484
CPUID_EDX_BIT_WIDTH_OF_FIXED_FUNCTION_PERFORMANCE_COUNTERS_FLAG = 0x1FE0 //col:3485
CPUID_EDX_BIT_WIDTH_OF_FIXED_FUNCTION_PERFORMANCE_COUNTERS_MASK = 0xFF //col:3486
CPUID_EDX_BIT_WIDTH_OF_FIXED_FUNCTION_PERFORMANCE_COUNTERS(_) = (((_) >> 5) & 0xFF) //col:3487
CPUID_EDX_ANY_THREAD_DEPRECATION_BIT =                         15 //col:3494
CPUID_EDX_ANY_THREAD_DEPRECATION_FLAG =                        0x8000 //col:3495
CPUID_EDX_ANY_THREAD_DEPRECATION_MASK =                        0x01 //col:3496
CPUID_EDX_ANY_THREAD_DEPRECATION(_) =                          (((_) >> 15) & 0x01) //col:3497
CPUID_EXTENDED_TOPOLOGY =                                      0x0000000B //col:3521
CPUID_EAX_X2APIC_ID_TO_UNIQUE_TOPOLOGY_ID_SHIFT_BIT =          0 //col:3535
CPUID_EAX_X2APIC_ID_TO_UNIQUE_TOPOLOGY_ID_SHIFT_FLAG =         0x1F //col:3536
CPUID_EAX_X2APIC_ID_TO_UNIQUE_TOPOLOGY_ID_SHIFT_MASK =         0x1F //col:3537
CPUID_EAX_X2APIC_ID_TO_UNIQUE_TOPOLOGY_ID_SHIFT(_) =           (((_) >> 0) & 0x1F) //col:3538
CPUID_EBX_NUMBER_OF_LOGICAL_PROCESSORS_AT_THIS_LEVEL_TYPE_BIT = 0 //col:3558
CPUID_EBX_NUMBER_OF_LOGICAL_PROCESSORS_AT_THIS_LEVEL_TYPE_FLAG = 0xFFFF //col:3559
CPUID_EBX_NUMBER_OF_LOGICAL_PROCESSORS_AT_THIS_LEVEL_TYPE_MASK = 0xFFFF //col:3560
CPUID_EBX_NUMBER_OF_LOGICAL_PROCESSORS_AT_THIS_LEVEL_TYPE(_) = (((_) >> 0) & 0xFFFF) //col:3561
CPUID_ECX_LEVEL_NUMBER_BIT =                                   0 //col:3576
CPUID_ECX_LEVEL_NUMBER_FLAG =                                  0xFF //col:3577
CPUID_ECX_LEVEL_NUMBER_MASK =                                  0xFF //col:3578
CPUID_ECX_LEVEL_NUMBER(_) =                                    (((_) >> 0) & 0xFF) //col:3579
CPUID_ECX_LEVEL_TYPE_BIT =                                     8 //col:3592
CPUID_ECX_LEVEL_TYPE_FLAG =                                    0xFF00 //col:3593
CPUID_ECX_LEVEL_TYPE_MASK =                                    0xFF //col:3594
CPUID_ECX_LEVEL_TYPE(_) =                                      (((_) >> 8) & 0xFF) //col:3595
CPUID_EDX_X2APIC_ID_BIT =                                      0 //col:3610
CPUID_EDX_X2APIC_ID_FLAG =                                     0xFFFFFFFF //col:3611
CPUID_EDX_X2APIC_ID_MASK =                                     0xFFFFFFFF //col:3612
CPUID_EDX_X2APIC_ID(_) =                                       (((_) >> 0) & 0xFFFFFFFF) //col:3613
CPUID_EXTENDED_STATE_INFORMATION =                             0x0000000D //col:3636
CPUID_EAX_X87_STATE_BIT =                                      0 //col:3653
CPUID_EAX_X87_STATE_FLAG =                                     0x01 //col:3654
CPUID_EAX_X87_STATE_MASK =                                     0x01 //col:3655
CPUID_EAX_X87_STATE(_) =                                       (((_) >> 0) & 0x01) //col:3656
CPUID_EAX_SSE_STATE_BIT =                                      1 //col:3662
CPUID_EAX_SSE_STATE_FLAG =                                     0x02 //col:3663
CPUID_EAX_SSE_STATE_MASK =                                     0x01 //col:3664
CPUID_EAX_SSE_STATE(_) =                                       (((_) >> 1) & 0x01) //col:3665
CPUID_EAX_AVX_STATE_BIT =                                      2 //col:3671
CPUID_EAX_AVX_STATE_FLAG =                                     0x04 //col:3672
CPUID_EAX_AVX_STATE_MASK =                                     0x01 //col:3673
CPUID_EAX_AVX_STATE(_) =                                       (((_) >> 2) & 0x01) //col:3674
CPUID_EAX_MPX_STATE_BIT =                                      3 //col:3680
CPUID_EAX_MPX_STATE_FLAG =                                     0x18 //col:3681
CPUID_EAX_MPX_STATE_MASK =                                     0x03 //col:3682
CPUID_EAX_MPX_STATE(_) =                                       (((_) >> 3) & 0x03) //col:3683
CPUID_EAX_AVX_512_STATE_BIT =                                  5 //col:3689
CPUID_EAX_AVX_512_STATE_FLAG =                                 0xE0 //col:3690
CPUID_EAX_AVX_512_STATE_MASK =                                 0x07 //col:3691
CPUID_EAX_AVX_512_STATE(_) =                                   (((_) >> 5) & 0x07) //col:3692
CPUID_EAX_USED_FOR_IA32_XSS_1_BIT =                            8 //col:3698
CPUID_EAX_USED_FOR_IA32_XSS_1_FLAG =                           0x100 //col:3699
CPUID_EAX_USED_FOR_IA32_XSS_1_MASK =                           0x01 //col:3700
CPUID_EAX_USED_FOR_IA32_XSS_1(_) =                             (((_) >> 8) & 0x01) //col:3701
CPUID_EAX_PKRU_STATE_BIT =                                     9 //col:3707
CPUID_EAX_PKRU_STATE_FLAG =                                    0x200 //col:3708
CPUID_EAX_PKRU_STATE_MASK =                                    0x01 //col:3709
CPUID_EAX_PKRU_STATE(_) =                                      (((_) >> 9) & 0x01) //col:3710
CPUID_EAX_USED_FOR_IA32_XSS_2_BIT =                            13 //col:3717
CPUID_EAX_USED_FOR_IA32_XSS_2_FLAG =                           0x2000 //col:3718
CPUID_EAX_USED_FOR_IA32_XSS_2_MASK =                           0x01 //col:3719
CPUID_EAX_USED_FOR_IA32_XSS_2(_) =                             (((_) >> 13) & 0x01) //col:3720
CPUID_EBX_MAX_SIZE_REQUIRED_BY_ENABLED_FEATURES_IN_XCR0_BIT =  0 //col:3736
CPUID_EBX_MAX_SIZE_REQUIRED_BY_ENABLED_FEATURES_IN_XCR0_FLAG = 0xFFFFFFFF //col:3737
CPUID_EBX_MAX_SIZE_REQUIRED_BY_ENABLED_FEATURES_IN_XCR0_MASK = 0xFFFFFFFF //col:3738
CPUID_EBX_MAX_SIZE_REQUIRED_BY_ENABLED_FEATURES_IN_XCR0(_) =   (((_) >> 0) & 0xFFFFFFFF) //col:3739
CPUID_ECX_MAX_SIZE_OF_XSAVE_XRSTOR_SAVE_AREA_BIT =             0 //col:3754
CPUID_ECX_MAX_SIZE_OF_XSAVE_XRSTOR_SAVE_AREA_FLAG =            0xFFFFFFFF //col:3755
CPUID_ECX_MAX_SIZE_OF_XSAVE_XRSTOR_SAVE_AREA_MASK =            0xFFFFFFFF //col:3756
CPUID_ECX_MAX_SIZE_OF_XSAVE_XRSTOR_SAVE_AREA(_) =              (((_) >> 0) & 0xFFFFFFFF) //col:3757
CPUID_EDX_XCR0_SUPPORTED_BITS_BIT =                            0 //col:3771
CPUID_EDX_XCR0_SUPPORTED_BITS_FLAG =                           0xFFFFFFFF //col:3772
CPUID_EDX_XCR0_SUPPORTED_BITS_MASK =                           0xFFFFFFFF //col:3773
CPUID_EDX_XCR0_SUPPORTED_BITS(_) =                             (((_) >> 0) & 0xFFFFFFFF) //col:3774
CPUID_EAX_SUPPORTS_XSAVEC_AND_COMPACTED_XRSTOR_BIT =           1 //col:3797
CPUID_EAX_SUPPORTS_XSAVEC_AND_COMPACTED_XRSTOR_FLAG =          0x02 //col:3798
CPUID_EAX_SUPPORTS_XSAVEC_AND_COMPACTED_XRSTOR_MASK =          0x01 //col:3799
CPUID_EAX_SUPPORTS_XSAVEC_AND_COMPACTED_XRSTOR(_) =            (((_) >> 1) & 0x01) //col:3800
CPUID_EAX_SUPPORTS_XGETBV_WITH_ECX_1_BIT =                     2 //col:3806
CPUID_EAX_SUPPORTS_XGETBV_WITH_ECX_1_FLAG =                    0x04 //col:3807
CPUID_EAX_SUPPORTS_XGETBV_WITH_ECX_1_MASK =                    0x01 //col:3808
CPUID_EAX_SUPPORTS_XGETBV_WITH_ECX_1(_) =                      (((_) >> 2) & 0x01) //col:3809
CPUID_EAX_SUPPORTS_XSAVE_XRSTOR_AND_IA32_XSS_BIT =             3 //col:3815
CPUID_EAX_SUPPORTS_XSAVE_XRSTOR_AND_IA32_XSS_FLAG =            0x08 //col:3816
CPUID_EAX_SUPPORTS_XSAVE_XRSTOR_AND_IA32_XSS_MASK =            0x01 //col:3817
CPUID_EAX_SUPPORTS_XSAVE_XRSTOR_AND_IA32_XSS(_) =              (((_) >> 3) & 0x01) //col:3818
CPUID_EBX_SIZE_OF_XSAVE_AREAD_BIT =                            0 //col:3833
CPUID_EBX_SIZE_OF_XSAVE_AREAD_FLAG =                           0xFFFFFFFF //col:3834
CPUID_EBX_SIZE_OF_XSAVE_AREAD_MASK =                           0xFFFFFFFF //col:3835
CPUID_EBX_SIZE_OF_XSAVE_AREAD(_) =                             (((_) >> 0) & 0xFFFFFFFF) //col:3836
CPUID_ECX_USED_FOR_XCR0_1_BIT =                                0 //col:3850
CPUID_ECX_USED_FOR_XCR0_1_FLAG =                               0xFF //col:3851
CPUID_ECX_USED_FOR_XCR0_1_MASK =                               0xFF //col:3852
CPUID_ECX_USED_FOR_XCR0_1(_) =                                 (((_) >> 0) & 0xFF) //col:3853
CPUID_ECX_PT_STATE_BIT =                                       8 //col:3859
CPUID_ECX_PT_STATE_FLAG =                                      0x100 //col:3860
CPUID_ECX_PT_STATE_MASK =                                      0x01 //col:3861
CPUID_ECX_PT_STATE(_) =                                        (((_) >> 8) & 0x01) //col:3862
CPUID_ECX_USED_FOR_XCR0_2_BIT =                                9 //col:3868
CPUID_ECX_USED_FOR_XCR0_2_FLAG =                               0x200 //col:3869
CPUID_ECX_USED_FOR_XCR0_2_MASK =                               0x01 //col:3870
CPUID_ECX_USED_FOR_XCR0_2(_) =                                 (((_) >> 9) & 0x01) //col:3871
CPUID_ECX_CET_USER_STATE_BIT =                                 11 //col:3878
CPUID_ECX_CET_USER_STATE_FLAG =                                0x800 //col:3879
CPUID_ECX_CET_USER_STATE_MASK =                                0x01 //col:3880
CPUID_ECX_CET_USER_STATE(_) =                                  (((_) >> 11) & 0x01) //col:3881
CPUID_ECX_CET_SUPERVISOR_STATE_BIT =                           12 //col:3887
CPUID_ECX_CET_SUPERVISOR_STATE_FLAG =                          0x1000 //col:3888
CPUID_ECX_CET_SUPERVISOR_STATE_MASK =                          0x01 //col:3889
CPUID_ECX_CET_SUPERVISOR_STATE(_) =                            (((_) >> 12) & 0x01) //col:3890
CPUID_ECX_HDC_STATE_BIT =                                      13 //col:3896
CPUID_ECX_HDC_STATE_FLAG =                                     0x2000 //col:3897
CPUID_ECX_HDC_STATE_MASK =                                     0x01 //col:3898
CPUID_ECX_HDC_STATE(_) =                                       (((_) >> 13) & 0x01) //col:3899
CPUID_ECX_LBR_STATE_BIT =                                      15 //col:3906
CPUID_ECX_LBR_STATE_FLAG =                                     0x8000 //col:3907
CPUID_ECX_LBR_STATE_MASK =                                     0x01 //col:3908
CPUID_ECX_LBR_STATE(_) =                                       (((_) >> 15) & 0x01) //col:3909
CPUID_ECX_HWP_STATE_BIT =                                      16 //col:3915
CPUID_ECX_HWP_STATE_FLAG =                                     0x10000 //col:3916
CPUID_ECX_HWP_STATE_MASK =                                     0x01 //col:3917
CPUID_ECX_HWP_STATE(_) =                                       (((_) >> 16) & 0x01) //col:3918
CPUID_EDX_SUPPORTED_UPPER_IA32_XSS_BITS_BIT =                  0 //col:3934
CPUID_EDX_SUPPORTED_UPPER_IA32_XSS_BITS_FLAG =                 0xFFFFFFFF //col:3935
CPUID_EDX_SUPPORTED_UPPER_IA32_XSS_BITS_MASK =                 0xFFFFFFFF //col:3936
CPUID_EDX_SUPPORTED_UPPER_IA32_XSS_BITS(_) =                   (((_) >> 0) & 0xFFFFFFFF) //col:3937
CPUID_EAX_IA32_PLATFORM_DCA_CAP_BIT =                          0 //col:3965
CPUID_EAX_IA32_PLATFORM_DCA_CAP_FLAG =                         0xFFFFFFFF //col:3966
CPUID_EAX_IA32_PLATFORM_DCA_CAP_MASK =                         0xFFFFFFFF //col:3967
CPUID_EAX_IA32_PLATFORM_DCA_CAP(_) =                           (((_) >> 0) & 0xFFFFFFFF) //col:3968
CPUID_EBX_RESERVED_BIT =                                       0 //col:3984
CPUID_EBX_RESERVED_FLAG =                                      0xFFFFFFFF //col:3985
CPUID_EBX_RESERVED_MASK =                                      0xFFFFFFFF //col:3986
CPUID_EBX_RESERVED(_) =                                        (((_) >> 0) & 0xFFFFFFFF) //col:3987
CPUID_ECX_ECX_2_BIT =                                          0 //col:4002
CPUID_ECX_ECX_2_FLAG =                                         0x01 //col:4003
CPUID_ECX_ECX_2_MASK =                                         0x01 //col:4004
CPUID_ECX_ECX_2(_) =                                           (((_) >> 0) & 0x01) //col:4005
CPUID_ECX_ECX_1_BIT =                                          1 //col:4013
CPUID_ECX_ECX_1_FLAG =                                         0x02 //col:4014
CPUID_ECX_ECX_1_MASK =                                         0x01 //col:4015
CPUID_ECX_ECX_1(_) =                                           (((_) >> 1) & 0x01) //col:4016
CPUID_EDX_RESERVED_BIT =                                       0 //col:4031
CPUID_EDX_RESERVED_FLAG =                                      0xFFFFFFFF //col:4032
CPUID_EDX_RESERVED_MASK =                                      0xFFFFFFFF //col:4033
CPUID_EDX_RESERVED(_) =                                        (((_) >> 0) & 0xFFFFFFFF) //col:4034
CPUID_INTEL_RESOURCE_DIRECTOR_TECHNOLOGY_MONITORING_INFORMATION = 0x0000000F //col:4059
CPUID_EAX_RESERVED_BIT =                                       0 //col:4076
CPUID_EAX_RESERVED_FLAG =                                      0xFFFFFFFF //col:4077
CPUID_EAX_RESERVED_MASK =                                      0xFFFFFFFF //col:4078
CPUID_EAX_RESERVED(_) =                                        (((_) >> 0) & 0xFFFFFFFF) //col:4079
CPUID_EBX_RMID_MAX_RANGE_BIT =                                 0 //col:4093
CPUID_EBX_RMID_MAX_RANGE_FLAG =                                0xFFFFFFFF //col:4094
CPUID_EBX_RMID_MAX_RANGE_MASK =                                0xFFFFFFFF //col:4095
CPUID_EBX_RMID_MAX_RANGE(_) =                                  (((_) >> 0) & 0xFFFFFFFF) //col:4096
CPUID_ECX_RESERVED_BIT =                                       0 //col:4110
CPUID_ECX_RESERVED_FLAG =                                      0xFFFFFFFF //col:4111
CPUID_ECX_RESERVED_MASK =                                      0xFFFFFFFF //col:4112
CPUID_ECX_RESERVED(_) =                                        (((_) >> 0) & 0xFFFFFFFF) //col:4113
CPUID_EDX_SUPPORTS_L3_CACHE_INTEL_RDT_MONITORING_BIT =         1 //col:4129
CPUID_EDX_SUPPORTS_L3_CACHE_INTEL_RDT_MONITORING_FLAG =        0x02 //col:4130
CPUID_EDX_SUPPORTS_L3_CACHE_INTEL_RDT_MONITORING_MASK =        0x01 //col:4131
CPUID_EDX_SUPPORTS_L3_CACHE_INTEL_RDT_MONITORING(_) =          (((_) >> 1) & 0x01) //col:4132
CPUID_EAX_RESERVED_BIT =                                       0 //col:4156
CPUID_EAX_RESERVED_FLAG =                                      0xFFFFFFFF //col:4157
CPUID_EAX_RESERVED_MASK =                                      0xFFFFFFFF //col:4158
CPUID_EAX_RESERVED(_) =                                        (((_) >> 0) & 0xFFFFFFFF) //col:4159
CPUID_EBX_CONVERSION_FACTOR_BIT =                              0 //col:4173
CPUID_EBX_CONVERSION_FACTOR_FLAG =                             0xFFFFFFFF //col:4174
CPUID_EBX_CONVERSION_FACTOR_MASK =                             0xFFFFFFFF //col:4175
CPUID_EBX_CONVERSION_FACTOR(_) =                               (((_) >> 0) & 0xFFFFFFFF) //col:4176
CPUID_ECX_RMID_MAX_RANGE_BIT =                                 0 //col:4190
CPUID_ECX_RMID_MAX_RANGE_FLAG =                                0xFFFFFFFF //col:4191
CPUID_ECX_RMID_MAX_RANGE_MASK =                                0xFFFFFFFF //col:4192
CPUID_ECX_RMID_MAX_RANGE(_) =                                  (((_) >> 0) & 0xFFFFFFFF) //col:4193
CPUID_EDX_SUPPORTS_L3_OCCUPANCY_MONITORING_BIT =               0 //col:4207
CPUID_EDX_SUPPORTS_L3_OCCUPANCY_MONITORING_FLAG =              0x01 //col:4208
CPUID_EDX_SUPPORTS_L3_OCCUPANCY_MONITORING_MASK =              0x01 //col:4209
CPUID_EDX_SUPPORTS_L3_OCCUPANCY_MONITORING(_) =                (((_) >> 0) & 0x01) //col:4210
CPUID_EDX_SUPPORTS_L3_TOTAL_BANDWIDTH_MONITORING_BIT =         1 //col:4216
CPUID_EDX_SUPPORTS_L3_TOTAL_BANDWIDTH_MONITORING_FLAG =        0x02 //col:4217
CPUID_EDX_SUPPORTS_L3_TOTAL_BANDWIDTH_MONITORING_MASK =        0x01 //col:4218
CPUID_EDX_SUPPORTS_L3_TOTAL_BANDWIDTH_MONITORING(_) =          (((_) >> 1) & 0x01) //col:4219
CPUID_EDX_SUPPORTS_L3_LOCAL_BANDWIDTH_MONITORING_BIT =         2 //col:4225
CPUID_EDX_SUPPORTS_L3_LOCAL_BANDWIDTH_MONITORING_FLAG =        0x04 //col:4226
CPUID_EDX_SUPPORTS_L3_LOCAL_BANDWIDTH_MONITORING_MASK =        0x01 //col:4227
CPUID_EDX_SUPPORTS_L3_LOCAL_BANDWIDTH_MONITORING(_) =          (((_) >> 2) & 0x01) //col:4228
CPUID_INTEL_RESOURCE_DIRECTOR_TECHNOLOGY_ALLOCATION_INFORMATION = 0x00000010 //col:4254
CPUID_EAX_IA32_PLATFORM_DCA_CAP_BIT =                          0 //col:4271
CPUID_EAX_IA32_PLATFORM_DCA_CAP_FLAG =                         0xFFFFFFFF //col:4272
CPUID_EAX_IA32_PLATFORM_DCA_CAP_MASK =                         0xFFFFFFFF //col:4273
CPUID_EAX_IA32_PLATFORM_DCA_CAP(_) =                           (((_) >> 0) & 0xFFFFFFFF) //col:4274
CPUID_EBX_SUPPORTS_L3_CACHE_ALLOCATION_TECHNOLOGY_BIT =        1 //col:4290
CPUID_EBX_SUPPORTS_L3_CACHE_ALLOCATION_TECHNOLOGY_FLAG =       0x02 //col:4291
CPUID_EBX_SUPPORTS_L3_CACHE_ALLOCATION_TECHNOLOGY_MASK =       0x01 //col:4292
CPUID_EBX_SUPPORTS_L3_CACHE_ALLOCATION_TECHNOLOGY(_) =         (((_) >> 1) & 0x01) //col:4293
CPUID_EBX_SUPPORTS_L2_CACHE_ALLOCATION_TECHNOLOGY_BIT =        2 //col:4299
CPUID_EBX_SUPPORTS_L2_CACHE_ALLOCATION_TECHNOLOGY_FLAG =       0x04 //col:4300
CPUID_EBX_SUPPORTS_L2_CACHE_ALLOCATION_TECHNOLOGY_MASK =       0x01 //col:4301
CPUID_EBX_SUPPORTS_L2_CACHE_ALLOCATION_TECHNOLOGY(_) =         (((_) >> 2) & 0x01) //col:4302
CPUID_EBX_SUPPORTS_MEMORY_BANDWIDTH_ALLOCATION_BIT =           3 //col:4308
CPUID_EBX_SUPPORTS_MEMORY_BANDWIDTH_ALLOCATION_FLAG =          0x08 //col:4309
CPUID_EBX_SUPPORTS_MEMORY_BANDWIDTH_ALLOCATION_MASK =          0x01 //col:4310
CPUID_EBX_SUPPORTS_MEMORY_BANDWIDTH_ALLOCATION(_) =            (((_) >> 3) & 0x01) //col:4311
CPUID_ECX_RESERVED_BIT =                                       0 //col:4326
CPUID_ECX_RESERVED_FLAG =                                      0xFFFFFFFF //col:4327
CPUID_ECX_RESERVED_MASK =                                      0xFFFFFFFF //col:4328
CPUID_ECX_RESERVED(_) =                                        (((_) >> 0) & 0xFFFFFFFF) //col:4329
CPUID_EDX_RESERVED_BIT =                                       0 //col:4343
CPUID_EDX_RESERVED_FLAG =                                      0xFFFFFFFF //col:4344
CPUID_EDX_RESERVED_MASK =                                      0xFFFFFFFF //col:4345
CPUID_EDX_RESERVED(_) =                                        (((_) >> 0) & 0xFFFFFFFF) //col:4346
CPUID_EAX_LENGTH_OF_CAPACITY_BIT_MASK_BIT =                    0 //col:4369
CPUID_EAX_LENGTH_OF_CAPACITY_BIT_MASK_FLAG =                   0x1F //col:4370
CPUID_EAX_LENGTH_OF_CAPACITY_BIT_MASK_MASK =                   0x1F //col:4371
CPUID_EAX_LENGTH_OF_CAPACITY_BIT_MASK(_) =                     (((_) >> 0) & 0x1F) //col:4372
CPUID_EBX_EBX_0_BIT =                                          0 //col:4387
CPUID_EBX_EBX_0_FLAG =                                         0xFFFFFFFF //col:4388
CPUID_EBX_EBX_0_MASK =                                         0xFFFFFFFF //col:4389
CPUID_EBX_EBX_0(_) =                                           (((_) >> 0) & 0xFFFFFFFF) //col:4390
CPUID_ECX_CODE_AND_DATA_PRIORIZATION_TECHNOLOGY_SUPPORTED_BIT = 2 //col:4406
CPUID_ECX_CODE_AND_DATA_PRIORIZATION_TECHNOLOGY_SUPPORTED_FLAG = 0x04 //col:4407
CPUID_ECX_CODE_AND_DATA_PRIORIZATION_TECHNOLOGY_SUPPORTED_MASK = 0x01 //col:4408
CPUID_ECX_CODE_AND_DATA_PRIORIZATION_TECHNOLOGY_SUPPORTED(_) = (((_) >> 2) & 0x01) //col:4409
CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED_BIT =                   0 //col:4424
CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED_FLAG =                  0xFFFF //col:4425
CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED_MASK =                  0xFFFF //col:4426
CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED(_) =                    (((_) >> 0) & 0xFFFF) //col:4427
CPUID_EAX_LENGTH_OF_CAPACITY_BIT_MASK_BIT =                    0 //col:4451
CPUID_EAX_LENGTH_OF_CAPACITY_BIT_MASK_FLAG =                   0x1F //col:4452
CPUID_EAX_LENGTH_OF_CAPACITY_BIT_MASK_MASK =                   0x1F //col:4453
CPUID_EAX_LENGTH_OF_CAPACITY_BIT_MASK(_) =                     (((_) >> 0) & 0x1F) //col:4454
CPUID_EBX_EBX_0_BIT =                                          0 //col:4469
CPUID_EBX_EBX_0_FLAG =                                         0xFFFFFFFF //col:4470
CPUID_EBX_EBX_0_MASK =                                         0xFFFFFFFF //col:4471
CPUID_EBX_EBX_0(_) =                                           (((_) >> 0) & 0xFFFFFFFF) //col:4472
CPUID_ECX_RESERVED_BIT =                                       0 //col:4486
CPUID_ECX_RESERVED_FLAG =                                      0xFFFFFFFF //col:4487
CPUID_ECX_RESERVED_MASK =                                      0xFFFFFFFF //col:4488
CPUID_ECX_RESERVED(_) =                                        (((_) >> 0) & 0xFFFFFFFF) //col:4489
CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED_BIT =                   0 //col:4503
CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED_FLAG =                  0xFFFF //col:4504
CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED_MASK =                  0xFFFF //col:4505
CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED(_) =                    (((_) >> 0) & 0xFFFF) //col:4506
CPUID_EAX_MAX_MBA_THROTTLING_VALUE_BIT =                       0 //col:4530
CPUID_EAX_MAX_MBA_THROTTLING_VALUE_FLAG =                      0xFFF //col:4531
CPUID_EAX_MAX_MBA_THROTTLING_VALUE_MASK =                      0xFFF //col:4532
CPUID_EAX_MAX_MBA_THROTTLING_VALUE(_) =                        (((_) >> 0) & 0xFFF) //col:4533
CPUID_EBX_RESERVED_BIT =                                       0 //col:4548
CPUID_EBX_RESERVED_FLAG =                                      0xFFFFFFFF //col:4549
CPUID_EBX_RESERVED_MASK =                                      0xFFFFFFFF //col:4550
CPUID_EBX_RESERVED(_) =                                        (((_) >> 0) & 0xFFFFFFFF) //col:4551
CPUID_ECX_RESPONSE_OF_DELAY_IS_LINEAR_BIT =                    2 //col:4567
CPUID_ECX_RESPONSE_OF_DELAY_IS_LINEAR_FLAG =                   0x04 //col:4568
CPUID_ECX_RESPONSE_OF_DELAY_IS_LINEAR_MASK =                   0x01 //col:4569
CPUID_ECX_RESPONSE_OF_DELAY_IS_LINEAR(_) =                     (((_) >> 2) & 0x01) //col:4570
CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED_BIT =                   0 //col:4585
CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED_FLAG =                  0xFFFF //col:4586
CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED_MASK =                  0xFFFF //col:4587
CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED(_) =                    (((_) >> 0) & 0xFFFF) //col:4588
CPUID_INTEL_SGX =                                              0x00000012 //col:4611
CPUID_EAX_SGX1_BIT =                                           0 //col:4627
CPUID_EAX_SGX1_FLAG =                                          0x01 //col:4628
CPUID_EAX_SGX1_MASK =                                          0x01 //col:4629
CPUID_EAX_SGX1(_) =                                            (((_) >> 0) & 0x01) //col:4630
CPUID_EAX_SGX2_BIT =                                           1 //col:4636
CPUID_EAX_SGX2_FLAG =                                          0x02 //col:4637
CPUID_EAX_SGX2_MASK =                                          0x01 //col:4638
CPUID_EAX_SGX2(_) =                                            (((_) >> 1) & 0x01) //col:4639
CPUID_EAX_SGX_ENCLV_ADVANCED_BIT =                             5 //col:4646
CPUID_EAX_SGX_ENCLV_ADVANCED_FLAG =                            0x20 //col:4647
CPUID_EAX_SGX_ENCLV_ADVANCED_MASK =                            0x01 //col:4648
CPUID_EAX_SGX_ENCLV_ADVANCED(_) =                              (((_) >> 5) & 0x01) //col:4649
CPUID_EAX_SGX_ENCLS_ADVANCED_BIT =                             6 //col:4655
CPUID_EAX_SGX_ENCLS_ADVANCED_FLAG =                            0x40 //col:4656
CPUID_EAX_SGX_ENCLS_ADVANCED_MASK =                            0x01 //col:4657
CPUID_EAX_SGX_ENCLS_ADVANCED(_) =                              (((_) >> 6) & 0x01) //col:4658
CPUID_EBX_MISCSELECT_BIT =                                     0 //col:4673
CPUID_EBX_MISCSELECT_FLAG =                                    0xFFFFFFFF //col:4674
CPUID_EBX_MISCSELECT_MASK =                                    0xFFFFFFFF //col:4675
CPUID_EBX_MISCSELECT(_) =                                      (((_) >> 0) & 0xFFFFFFFF) //col:4676
CPUID_ECX_RESERVED_BIT =                                       0 //col:4690
CPUID_ECX_RESERVED_FLAG =                                      0xFFFFFFFF //col:4691
CPUID_ECX_RESERVED_MASK =                                      0xFFFFFFFF //col:4692
CPUID_ECX_RESERVED(_) =                                        (((_) >> 0) & 0xFFFFFFFF) //col:4693
CPUID_EDX_MAX_ENCLAVE_SIZE_NOT64_BIT =                         0 //col:4707
CPUID_EDX_MAX_ENCLAVE_SIZE_NOT64_FLAG =                        0xFF //col:4708
CPUID_EDX_MAX_ENCLAVE_SIZE_NOT64_MASK =                        0xFF //col:4709
CPUID_EDX_MAX_ENCLAVE_SIZE_NOT64(_) =                          (((_) >> 0) & 0xFF) //col:4710
CPUID_EDX_MAX_ENCLAVE_SIZE_64_BIT =                            8 //col:4716
CPUID_EDX_MAX_ENCLAVE_SIZE_64_FLAG =                           0xFF00 //col:4717
CPUID_EDX_MAX_ENCLAVE_SIZE_64_MASK =                           0xFF //col:4718
CPUID_EDX_MAX_ENCLAVE_SIZE_64(_) =                             (((_) >> 8) & 0xFF) //col:4719
CPUID_EAX_VALID_SECS_ATTRIBUTES_0_BIT =                        0 //col:4743
CPUID_EAX_VALID_SECS_ATTRIBUTES_0_FLAG =                       0xFFFFFFFF //col:4744
CPUID_EAX_VALID_SECS_ATTRIBUTES_0_MASK =                       0xFFFFFFFF //col:4745
CPUID_EAX_VALID_SECS_ATTRIBUTES_0(_) =                         (((_) >> 0) & 0xFFFFFFFF) //col:4746
CPUID_EBX_VALID_SECS_ATTRIBUTES_1_BIT =                        0 //col:4760
CPUID_EBX_VALID_SECS_ATTRIBUTES_1_FLAG =                       0xFFFFFFFF //col:4761
CPUID_EBX_VALID_SECS_ATTRIBUTES_1_MASK =                       0xFFFFFFFF //col:4762
CPUID_EBX_VALID_SECS_ATTRIBUTES_1(_) =                         (((_) >> 0) & 0xFFFFFFFF) //col:4763
CPUID_ECX_VALID_SECS_ATTRIBUTES_2_BIT =                        0 //col:4777
CPUID_ECX_VALID_SECS_ATTRIBUTES_2_FLAG =                       0xFFFFFFFF //col:4778
CPUID_ECX_VALID_SECS_ATTRIBUTES_2_MASK =                       0xFFFFFFFF //col:4779
CPUID_ECX_VALID_SECS_ATTRIBUTES_2(_) =                         (((_) >> 0) & 0xFFFFFFFF) //col:4780
CPUID_EDX_VALID_SECS_ATTRIBUTES_3_BIT =                        0 //col:4794
CPUID_EDX_VALID_SECS_ATTRIBUTES_3_FLAG =                       0xFFFFFFFF //col:4795
CPUID_EDX_VALID_SECS_ATTRIBUTES_3_MASK =                       0xFFFFFFFF //col:4796
CPUID_EDX_VALID_SECS_ATTRIBUTES_3(_) =                         (((_) >> 0) & 0xFFFFFFFF) //col:4797
CPUID_EAX_SUB_LEAF_TYPE_BIT =                                  0 //col:4821
CPUID_EAX_SUB_LEAF_TYPE_FLAG =                                 0x0F //col:4822
CPUID_EAX_SUB_LEAF_TYPE_MASK =                                 0x0F //col:4823
CPUID_EAX_SUB_LEAF_TYPE(_) =                                   (((_) >> 0) & 0x0F) //col:4824
CPUID_EBX_ZERO_BIT =                                           0 //col:4839
CPUID_EBX_ZERO_FLAG =                                          0xFFFFFFFF //col:4840
CPUID_EBX_ZERO_MASK =                                          0xFFFFFFFF //col:4841
CPUID_EBX_ZERO(_) =                                            (((_) >> 0) & 0xFFFFFFFF) //col:4842
CPUID_ECX_ZERO_BIT =                                           0 //col:4856
CPUID_ECX_ZERO_FLAG =                                          0xFFFFFFFF //col:4857
CPUID_ECX_ZERO_MASK =                                          0xFFFFFFFF //col:4858
CPUID_ECX_ZERO(_) =                                            (((_) >> 0) & 0xFFFFFFFF) //col:4859
CPUID_EDX_ZERO_BIT =                                           0 //col:4873
CPUID_EDX_ZERO_FLAG =                                          0xFFFFFFFF //col:4874
CPUID_EDX_ZERO_MASK =                                          0xFFFFFFFF //col:4875
CPUID_EDX_ZERO(_) =                                            (((_) >> 0) & 0xFFFFFFFF) //col:4876
CPUID_EAX_SUB_LEAF_TYPE_BIT =                                  0 //col:4901
CPUID_EAX_SUB_LEAF_TYPE_FLAG =                                 0x0F //col:4902
CPUID_EAX_SUB_LEAF_TYPE_MASK =                                 0x0F //col:4903
CPUID_EAX_SUB_LEAF_TYPE(_) =                                   (((_) >> 0) & 0x0F) //col:4904
CPUID_EAX_EPC_BASE_PHYSICAL_ADDRESS_1_BIT =                    12 //col:4911
CPUID_EAX_EPC_BASE_PHYSICAL_ADDRESS_1_FLAG =                   0xFFFFF000 //col:4912
CPUID_EAX_EPC_BASE_PHYSICAL_ADDRESS_1_MASK =                   0xFFFFF //col:4913
CPUID_EAX_EPC_BASE_PHYSICAL_ADDRESS_1(_) =                     (((_) >> 12) & 0xFFFFF) //col:4914
CPUID_EBX_EPC_BASE_PHYSICAL_ADDRESS_2_BIT =                    0 //col:4928
CPUID_EBX_EPC_BASE_PHYSICAL_ADDRESS_2_FLAG =                   0xFFFFF //col:4929
CPUID_EBX_EPC_BASE_PHYSICAL_ADDRESS_2_MASK =                   0xFFFFF //col:4930
CPUID_EBX_EPC_BASE_PHYSICAL_ADDRESS_2(_) =                     (((_) >> 0) & 0xFFFFF) //col:4931
CPUID_ECX_EPC_SECTION_PROPERTY_BIT =                           0 //col:4949
CPUID_ECX_EPC_SECTION_PROPERTY_FLAG =                          0x0F //col:4950
CPUID_ECX_EPC_SECTION_PROPERTY_MASK =                          0x0F //col:4951
CPUID_ECX_EPC_SECTION_PROPERTY(_) =                            (((_) >> 0) & 0x0F) //col:4952
CPUID_ECX_EPC_SIZE_1_BIT =                                     12 //col:4959
CPUID_ECX_EPC_SIZE_1_FLAG =                                    0xFFFFF000 //col:4960
CPUID_ECX_EPC_SIZE_1_MASK =                                    0xFFFFF //col:4961
CPUID_ECX_EPC_SIZE_1(_) =                                      (((_) >> 12) & 0xFFFFF) //col:4962
CPUID_EDX_EPC_SIZE_2_BIT =                                     0 //col:4976
CPUID_EDX_EPC_SIZE_2_FLAG =                                    0xFFFFF //col:4977
CPUID_EDX_EPC_SIZE_2_MASK =                                    0xFFFFF //col:4978
CPUID_EDX_EPC_SIZE_2(_) =                                      (((_) >> 0) & 0xFFFFF) //col:4979
CPUID_INTEL_PROCESSOR_TRACE_INFORMATION =                      0x00000014 //col:5002
CPUID_EAX_MAX_SUB_LEAF_BIT =                                   0 //col:5018
CPUID_EAX_MAX_SUB_LEAF_FLAG =                                  0xFFFFFFFF //col:5019
CPUID_EAX_MAX_SUB_LEAF_MASK =                                  0xFFFFFFFF //col:5020
CPUID_EAX_MAX_SUB_LEAF(_) =                                    (((_) >> 0) & 0xFFFFFFFF) //col:5021
CPUID_EBX_FLAG0_BIT =                                          0 //col:5035
CPUID_EBX_FLAG0_FLAG =                                         0x01 //col:5036
CPUID_EBX_FLAG0_MASK =                                         0x01 //col:5037
CPUID_EBX_FLAG0(_) =                                           (((_) >> 0) & 0x01) //col:5038
CPUID_EBX_FLAG1_BIT =                                          1 //col:5044
CPUID_EBX_FLAG1_FLAG =                                         0x02 //col:5045
CPUID_EBX_FLAG1_MASK =                                         0x01 //col:5046
CPUID_EBX_FLAG1(_) =                                           (((_) >> 1) & 0x01) //col:5047
CPUID_EBX_FLAG2_BIT =                                          2 //col:5054
CPUID_EBX_FLAG2_FLAG =                                         0x04 //col:5055
CPUID_EBX_FLAG2_MASK =                                         0x01 //col:5056
CPUID_EBX_FLAG2(_) =                                           (((_) >> 2) & 0x01) //col:5057
CPUID_EBX_FLAG3_BIT =                                          3 //col:5063
CPUID_EBX_FLAG3_FLAG =                                         0x08 //col:5064
CPUID_EBX_FLAG3_MASK =                                         0x01 //col:5065
CPUID_EBX_FLAG3(_) =                                           (((_) >> 3) & 0x01) //col:5066
CPUID_EBX_FLAG4_BIT =                                          4 //col:5073
CPUID_EBX_FLAG4_FLAG =                                         0x10 //col:5074
CPUID_EBX_FLAG4_MASK =                                         0x01 //col:5075
CPUID_EBX_FLAG4(_) =                                           (((_) >> 4) & 0x01) //col:5076
CPUID_EBX_FLAG5_BIT =                                          5 //col:5083
CPUID_EBX_FLAG5_FLAG =                                         0x20 //col:5084
CPUID_EBX_FLAG5_MASK =                                         0x01 //col:5085
CPUID_EBX_FLAG5(_) =                                           (((_) >> 5) & 0x01) //col:5086
CPUID_EBX_FLAG6_BIT =                                          6 //col:5094
CPUID_EBX_FLAG6_FLAG =                                         0x40 //col:5095
CPUID_EBX_FLAG6_MASK =                                         0x01 //col:5096
CPUID_EBX_FLAG6(_) =                                           (((_) >> 6) & 0x01) //col:5097
CPUID_EBX_FLAG7_BIT =                                          7 //col:5103
CPUID_EBX_FLAG7_FLAG =                                         0x80 //col:5104
CPUID_EBX_FLAG7_MASK =                                         0x01 //col:5105
CPUID_EBX_FLAG7(_) =                                           (((_) >> 7) & 0x01) //col:5106
CPUID_EBX_FLAG8_BIT =                                          8 //col:5112
CPUID_EBX_FLAG8_FLAG =                                         0x100 //col:5113
CPUID_EBX_FLAG8_MASK =                                         0x01 //col:5114
CPUID_EBX_FLAG8(_) =                                           (((_) >> 8) & 0x01) //col:5115
CPUID_ECX_FLAG0_BIT =                                          0 //col:5131
CPUID_ECX_FLAG0_FLAG =                                         0x01 //col:5132
CPUID_ECX_FLAG0_MASK =                                         0x01 //col:5133
CPUID_ECX_FLAG0(_) =                                           (((_) >> 0) & 0x01) //col:5134
CPUID_ECX_FLAG1_BIT =                                          1 //col:5141
CPUID_ECX_FLAG1_FLAG =                                         0x02 //col:5142
CPUID_ECX_FLAG1_MASK =                                         0x01 //col:5143
CPUID_ECX_FLAG1(_) =                                           (((_) >> 1) & 0x01) //col:5144
CPUID_ECX_FLAG2_BIT =                                          2 //col:5150
CPUID_ECX_FLAG2_FLAG =                                         0x04 //col:5151
CPUID_ECX_FLAG2_MASK =                                         0x01 //col:5152
CPUID_ECX_FLAG2(_) =                                           (((_) >> 2) & 0x01) //col:5153
CPUID_ECX_FLAG3_BIT =                                          3 //col:5159
CPUID_ECX_FLAG3_FLAG =                                         0x08 //col:5160
CPUID_ECX_FLAG3_MASK =                                         0x01 //col:5161
CPUID_ECX_FLAG3(_) =                                           (((_) >> 3) & 0x01) //col:5162
CPUID_ECX_FLAG31_BIT =                                         31 //col:5169
CPUID_ECX_FLAG31_FLAG =                                        0x80000000 //col:5170
CPUID_ECX_FLAG31_MASK =                                        0x01 //col:5171
CPUID_ECX_FLAG31(_) =                                          (((_) >> 31) & 0x01) //col:5172
CPUID_EDX_RESERVED_BIT =                                       0 //col:5186
CPUID_EDX_RESERVED_FLAG =                                      0xFFFFFFFF //col:5187
CPUID_EDX_RESERVED_MASK =                                      0xFFFFFFFF //col:5188
CPUID_EDX_RESERVED(_) =                                        (((_) >> 0) & 0xFFFFFFFF) //col:5189
CPUID_EAX_NUMBER_OF_CONFIGURABLE_ADDRESS_RANGES_FOR_FILTERING_BIT = 0 //col:5210
CPUID_EAX_NUMBER_OF_CONFIGURABLE_ADDRESS_RANGES_FOR_FILTERING_FLAG = 0x07 //col:5211
CPUID_EAX_NUMBER_OF_CONFIGURABLE_ADDRESS_RANGES_FOR_FILTERING_MASK = 0x07 //col:5212
CPUID_EAX_NUMBER_OF_CONFIGURABLE_ADDRESS_RANGES_FOR_FILTERING(_) = (((_) >> 0) & 0x07) //col:5213
CPUID_EAX_BITMAP_OF_SUPPORTED_MTC_PERIOD_ENCODINGS_BIT =       16 //col:5220
CPUID_EAX_BITMAP_OF_SUPPORTED_MTC_PERIOD_ENCODINGS_FLAG =      0xFFFF0000 //col:5221
CPUID_EAX_BITMAP_OF_SUPPORTED_MTC_PERIOD_ENCODINGS_MASK =      0xFFFF //col:5222
CPUID_EAX_BITMAP_OF_SUPPORTED_MTC_PERIOD_ENCODINGS(_) =        (((_) >> 16) & 0xFFFF) //col:5223
CPUID_EBX_BITMAP_OF_SUPPORTED_CYCLE_THRESHOLD_VALUE_ENCODINGS_BIT = 0 //col:5237
CPUID_EBX_BITMAP_OF_SUPPORTED_CYCLE_THRESHOLD_VALUE_ENCODINGS_FLAG = 0xFFFF //col:5238
CPUID_EBX_BITMAP_OF_SUPPORTED_CYCLE_THRESHOLD_VALUE_ENCODINGS_MASK = 0xFFFF //col:5239
CPUID_EBX_BITMAP_OF_SUPPORTED_CYCLE_THRESHOLD_VALUE_ENCODINGS(_) = (((_) >> 0) & 0xFFFF) //col:5240
CPUID_EBX_BITMAP_OF_SUPPORTED_CONFIGURABLE_PSB_FREQUENCY_ENCODINGS_BIT = 16 //col:5246
CPUID_EBX_BITMAP_OF_SUPPORTED_CONFIGURABLE_PSB_FREQUENCY_ENCODINGS_FLAG = 0xFFFF0000 //col:5247
CPUID_EBX_BITMAP_OF_SUPPORTED_CONFIGURABLE_PSB_FREQUENCY_ENCODINGS_MASK = 0xFFFF //col:5248
CPUID_EBX_BITMAP_OF_SUPPORTED_CONFIGURABLE_PSB_FREQUENCY_ENCODINGS(_) = (((_) >> 16) & 0xFFFF) //col:5249
CPUID_ECX_RESERVED_BIT =                                       0 //col:5263
CPUID_ECX_RESERVED_FLAG =                                      0xFFFFFFFF //col:5264
CPUID_ECX_RESERVED_MASK =                                      0xFFFFFFFF //col:5265
CPUID_ECX_RESERVED(_) =                                        (((_) >> 0) & 0xFFFFFFFF) //col:5266
CPUID_EDX_RESERVED_BIT =                                       0 //col:5280
CPUID_EDX_RESERVED_FLAG =                                      0xFFFFFFFF //col:5281
CPUID_EDX_RESERVED_MASK =                                      0xFFFFFFFF //col:5282
CPUID_EDX_RESERVED(_) =                                        (((_) >> 0) & 0xFFFFFFFF) //col:5283
CPUID_TIME_STAMP_COUNTER_INFORMATION =                         0x00000015 //col:5307
CPUID_EAX_DENOMINATOR_BIT =                                    0 //col:5318
CPUID_EAX_DENOMINATOR_FLAG =                                   0xFFFFFFFF //col:5319
CPUID_EAX_DENOMINATOR_MASK =                                   0xFFFFFFFF //col:5320
CPUID_EAX_DENOMINATOR(_) =                                     (((_) >> 0) & 0xFFFFFFFF) //col:5321
CPUID_EBX_NUMERATOR_BIT =                                      0 //col:5335
CPUID_EBX_NUMERATOR_FLAG =                                     0xFFFFFFFF //col:5336
CPUID_EBX_NUMERATOR_MASK =                                     0xFFFFFFFF //col:5337
CPUID_EBX_NUMERATOR(_) =                                       (((_) >> 0) & 0xFFFFFFFF) //col:5338
CPUID_ECX_NOMINAL_FREQUENCY_BIT =                              0 //col:5352
CPUID_ECX_NOMINAL_FREQUENCY_FLAG =                             0xFFFFFFFF //col:5353
CPUID_ECX_NOMINAL_FREQUENCY_MASK =                             0xFFFFFFFF //col:5354
CPUID_ECX_NOMINAL_FREQUENCY(_) =                               (((_) >> 0) & 0xFFFFFFFF) //col:5355
CPUID_EDX_RESERVED_BIT =                                       0 //col:5369
CPUID_EDX_RESERVED_FLAG =                                      0xFFFFFFFF //col:5370
CPUID_EDX_RESERVED_MASK =                                      0xFFFFFFFF //col:5371
CPUID_EDX_RESERVED(_) =                                        (((_) >> 0) & 0xFFFFFFFF) //col:5372
CPUID_PROCESSOR_FREQUENCY_INFORMATION =                        0x00000016 //col:5394
CPUID_EAX_PROCESOR_BASE_FREQUENCY_MHZ_BIT =                    0 //col:5405
CPUID_EAX_PROCESOR_BASE_FREQUENCY_MHZ_FLAG =                   0xFFFF //col:5406
CPUID_EAX_PROCESOR_BASE_FREQUENCY_MHZ_MASK =                   0xFFFF //col:5407
CPUID_EAX_PROCESOR_BASE_FREQUENCY_MHZ(_) =                     (((_) >> 0) & 0xFFFF) //col:5408
CPUID_EBX_PROCESSOR_MAXIMUM_FREQUENCY_MHZ_BIT =                0 //col:5423
CPUID_EBX_PROCESSOR_MAXIMUM_FREQUENCY_MHZ_FLAG =               0xFFFF //col:5424
CPUID_EBX_PROCESSOR_MAXIMUM_FREQUENCY_MHZ_MASK =               0xFFFF //col:5425
CPUID_EBX_PROCESSOR_MAXIMUM_FREQUENCY_MHZ(_) =                 (((_) >> 0) & 0xFFFF) //col:5426
CPUID_ECX_BUS_FREQUENCY_MHZ_BIT =                              0 //col:5441
CPUID_ECX_BUS_FREQUENCY_MHZ_FLAG =                             0xFFFF //col:5442
CPUID_ECX_BUS_FREQUENCY_MHZ_MASK =                             0xFFFF //col:5443
CPUID_ECX_BUS_FREQUENCY_MHZ(_) =                               (((_) >> 0) & 0xFFFF) //col:5444
CPUID_EDX_RESERVED_BIT =                                       0 //col:5459
CPUID_EDX_RESERVED_FLAG =                                      0xFFFFFFFF //col:5460
CPUID_EDX_RESERVED_MASK =                                      0xFFFFFFFF //col:5461
CPUID_EDX_RESERVED(_) =                                        (((_) >> 0) & 0xFFFFFFFF) //col:5462
CPUID_SOC_VENDOR_INFORMATION =                                 0x00000017 //col:5478
CPUID_EAX_MAX_SOC_ID_INDEX_BIT =                               0 //col:5495
CPUID_EAX_MAX_SOC_ID_INDEX_FLAG =                              0xFFFFFFFF //col:5496
CPUID_EAX_MAX_SOC_ID_INDEX_MASK =                              0xFFFFFFFF //col:5497
CPUID_EAX_MAX_SOC_ID_INDEX(_) =                                (((_) >> 0) & 0xFFFFFFFF) //col:5498
CPUID_EBX_SOC_VENDOR_ID_BIT =                                  0 //col:5512
CPUID_EBX_SOC_VENDOR_ID_FLAG =                                 0xFFFF //col:5513
CPUID_EBX_SOC_VENDOR_ID_MASK =                                 0xFFFF //col:5514
CPUID_EBX_SOC_VENDOR_ID(_) =                                   (((_) >> 0) & 0xFFFF) //col:5515
CPUID_EBX_IS_VENDOR_SCHEME_BIT =                               16 //col:5522
CPUID_EBX_IS_VENDOR_SCHEME_FLAG =                              0x10000 //col:5523
CPUID_EBX_IS_VENDOR_SCHEME_MASK =                              0x01 //col:5524
CPUID_EBX_IS_VENDOR_SCHEME(_) =                                (((_) >> 16) & 0x01) //col:5525
CPUID_ECX_PROJECT_ID_BIT =                                     0 //col:5540
CPUID_ECX_PROJECT_ID_FLAG =                                    0xFFFFFFFF //col:5541
CPUID_ECX_PROJECT_ID_MASK =                                    0xFFFFFFFF //col:5542
CPUID_ECX_PROJECT_ID(_) =                                      (((_) >> 0) & 0xFFFFFFFF) //col:5543
CPUID_EDX_STEPPING_ID_BIT =                                    0 //col:5557
CPUID_EDX_STEPPING_ID_FLAG =                                   0xFFFFFFFF //col:5558
CPUID_EDX_STEPPING_ID_MASK =                                   0xFFFFFFFF //col:5559
CPUID_EDX_STEPPING_ID(_) =                                     (((_) >> 0) & 0xFFFFFFFF) //col:5560
CPUID_EAX_SOC_VENDOR_BRAND_STRING_BIT =                        0 //col:5585
CPUID_EAX_SOC_VENDOR_BRAND_STRING_FLAG =                       0xFFFFFFFF //col:5586
CPUID_EAX_SOC_VENDOR_BRAND_STRING_MASK =                       0xFFFFFFFF //col:5587
CPUID_EAX_SOC_VENDOR_BRAND_STRING(_) =                         (((_) >> 0) & 0xFFFFFFFF) //col:5588
CPUID_EBX_SOC_VENDOR_BRAND_STRING_BIT =                        0 //col:5602
CPUID_EBX_SOC_VENDOR_BRAND_STRING_FLAG =                       0xFFFFFFFF //col:5603
CPUID_EBX_SOC_VENDOR_BRAND_STRING_MASK =                       0xFFFFFFFF //col:5604
CPUID_EBX_SOC_VENDOR_BRAND_STRING(_) =                         (((_) >> 0) & 0xFFFFFFFF) //col:5605
CPUID_ECX_SOC_VENDOR_BRAND_STRING_BIT =                        0 //col:5619
CPUID_ECX_SOC_VENDOR_BRAND_STRING_FLAG =                       0xFFFFFFFF //col:5620
CPUID_ECX_SOC_VENDOR_BRAND_STRING_MASK =                       0xFFFFFFFF //col:5621
CPUID_ECX_SOC_VENDOR_BRAND_STRING(_) =                         (((_) >> 0) & 0xFFFFFFFF) //col:5622
CPUID_EDX_SOC_VENDOR_BRAND_STRING_BIT =                        0 //col:5636
CPUID_EDX_SOC_VENDOR_BRAND_STRING_FLAG =                       0xFFFFFFFF //col:5637
CPUID_EDX_SOC_VENDOR_BRAND_STRING_MASK =                       0xFFFFFFFF //col:5638
CPUID_EDX_SOC_VENDOR_BRAND_STRING(_) =                         (((_) >> 0) & 0xFFFFFFFF) //col:5639
CPUID_EAX_RESERVED_BIT =                                       0 //col:5662
CPUID_EAX_RESERVED_FLAG =                                      0xFFFFFFFF //col:5663
CPUID_EAX_RESERVED_MASK =                                      0xFFFFFFFF //col:5664
CPUID_EAX_RESERVED(_) =                                        (((_) >> 0) & 0xFFFFFFFF) //col:5665
CPUID_EBX_RESERVED_BIT =                                       0 //col:5679
CPUID_EBX_RESERVED_FLAG =                                      0xFFFFFFFF //col:5680
CPUID_EBX_RESERVED_MASK =                                      0xFFFFFFFF //col:5681
CPUID_EBX_RESERVED(_) =                                        (((_) >> 0) & 0xFFFFFFFF) //col:5682
CPUID_ECX_RESERVED_BIT =                                       0 //col:5696
CPUID_ECX_RESERVED_FLAG =                                      0xFFFFFFFF //col:5697
CPUID_ECX_RESERVED_MASK =                                      0xFFFFFFFF //col:5698
CPUID_ECX_RESERVED(_) =                                        (((_) >> 0) & 0xFFFFFFFF) //col:5699
CPUID_EDX_RESERVED_BIT =                                       0 //col:5713
CPUID_EDX_RESERVED_FLAG =                                      0xFFFFFFFF //col:5714
CPUID_EDX_RESERVED_MASK =                                      0xFFFFFFFF //col:5715
CPUID_EDX_RESERVED(_) =                                        (((_) >> 0) & 0xFFFFFFFF) //col:5716
CPUID_DETERMINISTIC_ADDRESS_TRANSLATION_PARAMETERS =           0x00000018 //col:5736
CPUID_EAX_MAX_SUB_LEAF_BIT =                                   0 //col:5756
CPUID_EAX_MAX_SUB_LEAF_FLAG =                                  0xFFFFFFFF //col:5757
CPUID_EAX_MAX_SUB_LEAF_MASK =                                  0xFFFFFFFF //col:5758
CPUID_EAX_MAX_SUB_LEAF(_) =                                    (((_) >> 0) & 0xFFFFFFFF) //col:5759
CPUID_EBX_PAGE_ENTRIES_4KB_SUPPORTED_BIT =                     0 //col:5773
CPUID_EBX_PAGE_ENTRIES_4KB_SUPPORTED_FLAG =                    0x01 //col:5774
CPUID_EBX_PAGE_ENTRIES_4KB_SUPPORTED_MASK =                    0x01 //col:5775
CPUID_EBX_PAGE_ENTRIES_4KB_SUPPORTED(_) =                      (((_) >> 0) & 0x01) //col:5776
CPUID_EBX_PAGE_ENTRIES_2MB_SUPPORTED_BIT =                     1 //col:5782
CPUID_EBX_PAGE_ENTRIES_2MB_SUPPORTED_FLAG =                    0x02 //col:5783
CPUID_EBX_PAGE_ENTRIES_2MB_SUPPORTED_MASK =                    0x01 //col:5784
CPUID_EBX_PAGE_ENTRIES_2MB_SUPPORTED(_) =                      (((_) >> 1) & 0x01) //col:5785
CPUID_EBX_PAGE_ENTRIES_4MB_SUPPORTED_BIT =                     2 //col:5791
CPUID_EBX_PAGE_ENTRIES_4MB_SUPPORTED_FLAG =                    0x04 //col:5792
CPUID_EBX_PAGE_ENTRIES_4MB_SUPPORTED_MASK =                    0x01 //col:5793
CPUID_EBX_PAGE_ENTRIES_4MB_SUPPORTED(_) =                      (((_) >> 2) & 0x01) //col:5794
CPUID_EBX_PAGE_ENTRIES_1GB_SUPPORTED_BIT =                     3 //col:5800
CPUID_EBX_PAGE_ENTRIES_1GB_SUPPORTED_FLAG =                    0x08 //col:5801
CPUID_EBX_PAGE_ENTRIES_1GB_SUPPORTED_MASK =                    0x01 //col:5802
CPUID_EBX_PAGE_ENTRIES_1GB_SUPPORTED(_) =                      (((_) >> 3) & 0x01) //col:5803
CPUID_EBX_PARTITIONING_BIT =                                   8 //col:5810
CPUID_EBX_PARTITIONING_FLAG =                                  0x700 //col:5811
CPUID_EBX_PARTITIONING_MASK =                                  0x07 //col:5812
CPUID_EBX_PARTITIONING(_) =                                    (((_) >> 8) & 0x07) //col:5813
CPUID_EBX_WAYS_OF_ASSOCIATIVITY_00_BIT =                       16 //col:5820
CPUID_EBX_WAYS_OF_ASSOCIATIVITY_00_FLAG =                      0xFFFF0000 //col:5821
CPUID_EBX_WAYS_OF_ASSOCIATIVITY_00_MASK =                      0xFFFF //col:5822
CPUID_EBX_WAYS_OF_ASSOCIATIVITY_00(_) =                        (((_) >> 16) & 0xFFFF) //col:5823
CPUID_ECX_NUMBER_OF_SETS_BIT =                                 0 //col:5837
CPUID_ECX_NUMBER_OF_SETS_FLAG =                                0xFFFFFFFF //col:5838
CPUID_ECX_NUMBER_OF_SETS_MASK =                                0xFFFFFFFF //col:5839
CPUID_ECX_NUMBER_OF_SETS(_) =                                  (((_) >> 0) & 0xFFFFFFFF) //col:5840
CPUID_EDX_TRANSLATION_CACHE_TYPE_FIELD_BIT =                   0 //col:5863
CPUID_EDX_TRANSLATION_CACHE_TYPE_FIELD_FLAG =                  0x1F //col:5864
CPUID_EDX_TRANSLATION_CACHE_TYPE_FIELD_MASK =                  0x1F //col:5865
CPUID_EDX_TRANSLATION_CACHE_TYPE_FIELD(_) =                    (((_) >> 0) & 0x1F) //col:5866
CPUID_EDX_TRANSLATION_CACHE_LEVEL_BIT =                        5 //col:5872
CPUID_EDX_TRANSLATION_CACHE_LEVEL_FLAG =                       0xE0 //col:5873
CPUID_EDX_TRANSLATION_CACHE_LEVEL_MASK =                       0x07 //col:5874
CPUID_EDX_TRANSLATION_CACHE_LEVEL(_) =                         (((_) >> 5) & 0x07) //col:5875
CPUID_EDX_FULLY_ASSOCIATIVE_STRUCTURE_BIT =                    8 //col:5881
CPUID_EDX_FULLY_ASSOCIATIVE_STRUCTURE_FLAG =                   0x100 //col:5882
CPUID_EDX_FULLY_ASSOCIATIVE_STRUCTURE_MASK =                   0x01 //col:5883
CPUID_EDX_FULLY_ASSOCIATIVE_STRUCTURE(_) =                     (((_) >> 8) & 0x01) //col:5884
CPUID_EDX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS_BIT =     14 //col:5893
CPUID_EDX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS_FLAG =    0x3FFC000 //col:5894
CPUID_EDX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS_MASK =    0xFFF //col:5895
CPUID_EDX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS(_) =      (((_) >> 14) & 0xFFF) //col:5896
CPUID_EAX_RESERVED_BIT =                                       0 //col:5924
CPUID_EAX_RESERVED_FLAG =                                      0xFFFFFFFF //col:5925
CPUID_EAX_RESERVED_MASK =                                      0xFFFFFFFF //col:5926
CPUID_EAX_RESERVED(_) =                                        (((_) >> 0) & 0xFFFFFFFF) //col:5927
CPUID_EBX_PAGE_ENTRIES_4KB_SUPPORTED_BIT =                     0 //col:5941
CPUID_EBX_PAGE_ENTRIES_4KB_SUPPORTED_FLAG =                    0x01 //col:5942
CPUID_EBX_PAGE_ENTRIES_4KB_SUPPORTED_MASK =                    0x01 //col:5943
CPUID_EBX_PAGE_ENTRIES_4KB_SUPPORTED(_) =                      (((_) >> 0) & 0x01) //col:5944
CPUID_EBX_PAGE_ENTRIES_2MB_SUPPORTED_BIT =                     1 //col:5950
CPUID_EBX_PAGE_ENTRIES_2MB_SUPPORTED_FLAG =                    0x02 //col:5951
CPUID_EBX_PAGE_ENTRIES_2MB_SUPPORTED_MASK =                    0x01 //col:5952
CPUID_EBX_PAGE_ENTRIES_2MB_SUPPORTED(_) =                      (((_) >> 1) & 0x01) //col:5953
CPUID_EBX_PAGE_ENTRIES_4MB_SUPPORTED_BIT =                     2 //col:5959
CPUID_EBX_PAGE_ENTRIES_4MB_SUPPORTED_FLAG =                    0x04 //col:5960
CPUID_EBX_PAGE_ENTRIES_4MB_SUPPORTED_MASK =                    0x01 //col:5961
CPUID_EBX_PAGE_ENTRIES_4MB_SUPPORTED(_) =                      (((_) >> 2) & 0x01) //col:5962
CPUID_EBX_PAGE_ENTRIES_1GB_SUPPORTED_BIT =                     3 //col:5968
CPUID_EBX_PAGE_ENTRIES_1GB_SUPPORTED_FLAG =                    0x08 //col:5969
CPUID_EBX_PAGE_ENTRIES_1GB_SUPPORTED_MASK =                    0x01 //col:5970
CPUID_EBX_PAGE_ENTRIES_1GB_SUPPORTED(_) =                      (((_) >> 3) & 0x01) //col:5971
CPUID_EBX_PARTITIONING_BIT =                                   8 //col:5978
CPUID_EBX_PARTITIONING_FLAG =                                  0x700 //col:5979
CPUID_EBX_PARTITIONING_MASK =                                  0x07 //col:5980
CPUID_EBX_PARTITIONING(_) =                                    (((_) >> 8) & 0x07) //col:5981
CPUID_EBX_WAYS_OF_ASSOCIATIVITY_01_BIT =                       16 //col:5988
CPUID_EBX_WAYS_OF_ASSOCIATIVITY_01_FLAG =                      0xFFFF0000 //col:5989
CPUID_EBX_WAYS_OF_ASSOCIATIVITY_01_MASK =                      0xFFFF //col:5990
CPUID_EBX_WAYS_OF_ASSOCIATIVITY_01(_) =                        (((_) >> 16) & 0xFFFF) //col:5991
CPUID_ECX_NUMBER_OF_SETS_BIT =                                 0 //col:6005
CPUID_ECX_NUMBER_OF_SETS_FLAG =                                0xFFFFFFFF //col:6006
CPUID_ECX_NUMBER_OF_SETS_MASK =                                0xFFFFFFFF //col:6007
CPUID_ECX_NUMBER_OF_SETS(_) =                                  (((_) >> 0) & 0xFFFFFFFF) //col:6008
CPUID_EDX_TRANSLATION_CACHE_TYPE_FIELD_BIT =                   0 //col:6031
CPUID_EDX_TRANSLATION_CACHE_TYPE_FIELD_FLAG =                  0x1F //col:6032
CPUID_EDX_TRANSLATION_CACHE_TYPE_FIELD_MASK =                  0x1F //col:6033
CPUID_EDX_TRANSLATION_CACHE_TYPE_FIELD(_) =                    (((_) >> 0) & 0x1F) //col:6034
CPUID_EDX_TRANSLATION_CACHE_LEVEL_BIT =                        5 //col:6040
CPUID_EDX_TRANSLATION_CACHE_LEVEL_FLAG =                       0xE0 //col:6041
CPUID_EDX_TRANSLATION_CACHE_LEVEL_MASK =                       0x07 //col:6042
CPUID_EDX_TRANSLATION_CACHE_LEVEL(_) =                         (((_) >> 5) & 0x07) //col:6043
CPUID_EDX_FULLY_ASSOCIATIVE_STRUCTURE_BIT =                    8 //col:6049
CPUID_EDX_FULLY_ASSOCIATIVE_STRUCTURE_FLAG =                   0x100 //col:6050
CPUID_EDX_FULLY_ASSOCIATIVE_STRUCTURE_MASK =                   0x01 //col:6051
CPUID_EDX_FULLY_ASSOCIATIVE_STRUCTURE(_) =                     (((_) >> 8) & 0x01) //col:6052
CPUID_EDX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS_BIT =     14 //col:6061
CPUID_EDX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS_FLAG =    0x3FFC000 //col:6062
CPUID_EDX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS_MASK =    0xFFF //col:6063
CPUID_EDX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS(_) =      (((_) >> 14) & 0xFFF) //col:6064
CPUID_EXTENDED_FUNCTION_INFORMATION =                          0x80000000 //col:6084
CPUID_EAX_MAX_EXTENDED_FUNCTIONS_BIT =                         0 //col:6095
CPUID_EAX_MAX_EXTENDED_FUNCTIONS_FLAG =                        0xFFFFFFFF //col:6096
CPUID_EAX_MAX_EXTENDED_FUNCTIONS_MASK =                        0xFFFFFFFF //col:6097
CPUID_EAX_MAX_EXTENDED_FUNCTIONS(_) =                          (((_) >> 0) & 0xFFFFFFFF) //col:6098
CPUID_EBX_RESERVED_BIT =                                       0 //col:6112
CPUID_EBX_RESERVED_FLAG =                                      0xFFFFFFFF //col:6113
CPUID_EBX_RESERVED_MASK =                                      0xFFFFFFFF //col:6114
CPUID_EBX_RESERVED(_) =                                        (((_) >> 0) & 0xFFFFFFFF) //col:6115
CPUID_ECX_RESERVED_BIT =                                       0 //col:6129
CPUID_ECX_RESERVED_FLAG =                                      0xFFFFFFFF //col:6130
CPUID_ECX_RESERVED_MASK =                                      0xFFFFFFFF //col:6131
CPUID_ECX_RESERVED(_) =                                        (((_) >> 0) & 0xFFFFFFFF) //col:6132
CPUID_EDX_RESERVED_BIT =                                       0 //col:6146
CPUID_EDX_RESERVED_FLAG =                                      0xFFFFFFFF //col:6147
CPUID_EDX_RESERVED_MASK =                                      0xFFFFFFFF //col:6148
CPUID_EDX_RESERVED(_) =                                        (((_) >> 0) & 0xFFFFFFFF) //col:6149
CPUID_EXTENDED_CPU_SIGNATURE =                                 0x80000001 //col:6161
CPUID_EAX_RESERVED_BIT =                                       0 //col:6172
CPUID_EAX_RESERVED_FLAG =                                      0xFFFFFFFF //col:6173
CPUID_EAX_RESERVED_MASK =                                      0xFFFFFFFF //col:6174
CPUID_EAX_RESERVED(_) =                                        (((_) >> 0) & 0xFFFFFFFF) //col:6175
CPUID_EBX_RESERVED_BIT =                                       0 //col:6189
CPUID_EBX_RESERVED_FLAG =                                      0xFFFFFFFF //col:6190
CPUID_EBX_RESERVED_MASK =                                      0xFFFFFFFF //col:6191
CPUID_EBX_RESERVED(_) =                                        (((_) >> 0) & 0xFFFFFFFF) //col:6192
CPUID_ECX_LAHF_SAHF_AVAILABLE_IN_64_BIT_MODE_BIT =             0 //col:6206
CPUID_ECX_LAHF_SAHF_AVAILABLE_IN_64_BIT_MODE_FLAG =            0x01 //col:6207
CPUID_ECX_LAHF_SAHF_AVAILABLE_IN_64_BIT_MODE_MASK =            0x01 //col:6208
CPUID_ECX_LAHF_SAHF_AVAILABLE_IN_64_BIT_MODE(_) =              (((_) >> 0) & 0x01) //col:6209
CPUID_ECX_LZCNT_BIT =                                          5 //col:6216
CPUID_ECX_LZCNT_FLAG =                                         0x20 //col:6217
CPUID_ECX_LZCNT_MASK =                                         0x01 //col:6218
CPUID_ECX_LZCNT(_) =                                           (((_) >> 5) & 0x01) //col:6219
CPUID_ECX_PREFETCHW_BIT =                                      8 //col:6226
CPUID_ECX_PREFETCHW_FLAG =                                     0x100 //col:6227
CPUID_ECX_PREFETCHW_MASK =                                     0x01 //col:6228
CPUID_ECX_PREFETCHW(_) =                                       (((_) >> 8) & 0x01) //col:6229
CPUID_EDX_SYSCALL_SYSRET_AVAILABLE_IN_64_BIT_MODE_BIT =        11 //col:6246
CPUID_EDX_SYSCALL_SYSRET_AVAILABLE_IN_64_BIT_MODE_FLAG =       0x800 //col:6247
CPUID_EDX_SYSCALL_SYSRET_AVAILABLE_IN_64_BIT_MODE_MASK =       0x01 //col:6248
CPUID_EDX_SYSCALL_SYSRET_AVAILABLE_IN_64_BIT_MODE(_) =         (((_) >> 11) & 0x01) //col:6249
CPUID_EDX_EXECUTE_DISABLE_BIT_AVAILABLE_BIT =                  20 //col:6256
CPUID_EDX_EXECUTE_DISABLE_BIT_AVAILABLE_FLAG =                 0x100000 //col:6257
CPUID_EDX_EXECUTE_DISABLE_BIT_AVAILABLE_MASK =                 0x01 //col:6258
CPUID_EDX_EXECUTE_DISABLE_BIT_AVAILABLE(_) =                   (((_) >> 20) & 0x01) //col:6259
CPUID_EDX_PAGES_1GB_AVAILABLE_BIT =                            26 //col:6266
CPUID_EDX_PAGES_1GB_AVAILABLE_FLAG =                           0x4000000 //col:6267
CPUID_EDX_PAGES_1GB_AVAILABLE_MASK =                           0x01 //col:6268
CPUID_EDX_PAGES_1GB_AVAILABLE(_) =                             (((_) >> 26) & 0x01) //col:6269
CPUID_EDX_RDTSCP_AVAILABLE_BIT =                               27 //col:6275
CPUID_EDX_RDTSCP_AVAILABLE_FLAG =                              0x8000000 //col:6276
CPUID_EDX_RDTSCP_AVAILABLE_MASK =                              0x01 //col:6277
CPUID_EDX_RDTSCP_AVAILABLE(_) =                                (((_) >> 27) & 0x01) //col:6278
CPUID_EDX_IA64_AVAILABLE_BIT =                                 29 //col:6285
CPUID_EDX_IA64_AVAILABLE_FLAG =                                0x20000000 //col:6286
CPUID_EDX_IA64_AVAILABLE_MASK =                                0x01 //col:6287
CPUID_EDX_IA64_AVAILABLE(_) =                                  (((_) >> 29) & 0x01) //col:6288
CPUID_BRAND_STRING1 =                                          0x80000002 //col:6301
CPUID_BRAND_STRING2 =                                          0x80000003 //col:6306
CPUID_BRAND_STRING3 =                                          0x80000004 //col:6311
CPUID_EAX_PROCESSOR_BRAND_STRING_1_BIT =                       0 //col:6322
CPUID_EAX_PROCESSOR_BRAND_STRING_1_FLAG =                      0xFFFFFFFF //col:6323
CPUID_EAX_PROCESSOR_BRAND_STRING_1_MASK =                      0xFFFFFFFF //col:6324
CPUID_EAX_PROCESSOR_BRAND_STRING_1(_) =                        (((_) >> 0) & 0xFFFFFFFF) //col:6325
CPUID_EBX_PROCESSOR_BRAND_STRING_2_BIT =                       0 //col:6339
CPUID_EBX_PROCESSOR_BRAND_STRING_2_FLAG =                      0xFFFFFFFF //col:6340
CPUID_EBX_PROCESSOR_BRAND_STRING_2_MASK =                      0xFFFFFFFF //col:6341
CPUID_EBX_PROCESSOR_BRAND_STRING_2(_) =                        (((_) >> 0) & 0xFFFFFFFF) //col:6342
CPUID_ECX_PROCESSOR_BRAND_STRING_3_BIT =                       0 //col:6356
CPUID_ECX_PROCESSOR_BRAND_STRING_3_FLAG =                      0xFFFFFFFF //col:6357
CPUID_ECX_PROCESSOR_BRAND_STRING_3_MASK =                      0xFFFFFFFF //col:6358
CPUID_ECX_PROCESSOR_BRAND_STRING_3(_) =                        (((_) >> 0) & 0xFFFFFFFF) //col:6359
CPUID_EDX_PROCESSOR_BRAND_STRING_4_BIT =                       0 //col:6373
CPUID_EDX_PROCESSOR_BRAND_STRING_4_FLAG =                      0xFFFFFFFF //col:6374
CPUID_EDX_PROCESSOR_BRAND_STRING_4_MASK =                      0xFFFFFFFF //col:6375
CPUID_EDX_PROCESSOR_BRAND_STRING_4(_) =                        (((_) >> 0) & 0xFFFFFFFF) //col:6376
CPUID_EAX_PROCESSOR_BRAND_STRING_5_BIT =                       0 //col:6397
CPUID_EAX_PROCESSOR_BRAND_STRING_5_FLAG =                      0xFFFFFFFF //col:6398
CPUID_EAX_PROCESSOR_BRAND_STRING_5_MASK =                      0xFFFFFFFF //col:6399
CPUID_EAX_PROCESSOR_BRAND_STRING_5(_) =                        (((_) >> 0) & 0xFFFFFFFF) //col:6400
CPUID_EBX_PROCESSOR_BRAND_STRING_6_BIT =                       0 //col:6414
CPUID_EBX_PROCESSOR_BRAND_STRING_6_FLAG =                      0xFFFFFFFF //col:6415
CPUID_EBX_PROCESSOR_BRAND_STRING_6_MASK =                      0xFFFFFFFF //col:6416
CPUID_EBX_PROCESSOR_BRAND_STRING_6(_) =                        (((_) >> 0) & 0xFFFFFFFF) //col:6417
CPUID_ECX_PROCESSOR_BRAND_STRING_7_BIT =                       0 //col:6431
CPUID_ECX_PROCESSOR_BRAND_STRING_7_FLAG =                      0xFFFFFFFF //col:6432
CPUID_ECX_PROCESSOR_BRAND_STRING_7_MASK =                      0xFFFFFFFF //col:6433
CPUID_ECX_PROCESSOR_BRAND_STRING_7(_) =                        (((_) >> 0) & 0xFFFFFFFF) //col:6434
CPUID_EDX_PROCESSOR_BRAND_STRING_8_BIT =                       0 //col:6448
CPUID_EDX_PROCESSOR_BRAND_STRING_8_FLAG =                      0xFFFFFFFF //col:6449
CPUID_EDX_PROCESSOR_BRAND_STRING_8_MASK =                      0xFFFFFFFF //col:6450
CPUID_EDX_PROCESSOR_BRAND_STRING_8(_) =                        (((_) >> 0) & 0xFFFFFFFF) //col:6451
CPUID_EAX_PROCESSOR_BRAND_STRING_9_BIT =                       0 //col:6472
CPUID_EAX_PROCESSOR_BRAND_STRING_9_FLAG =                      0xFFFFFFFF //col:6473
CPUID_EAX_PROCESSOR_BRAND_STRING_9_MASK =                      0xFFFFFFFF //col:6474
CPUID_EAX_PROCESSOR_BRAND_STRING_9(_) =                        (((_) >> 0) & 0xFFFFFFFF) //col:6475
CPUID_EBX_PROCESSOR_BRAND_STRING_10_BIT =                      0 //col:6489
CPUID_EBX_PROCESSOR_BRAND_STRING_10_FLAG =                     0xFFFFFFFF //col:6490
CPUID_EBX_PROCESSOR_BRAND_STRING_10_MASK =                     0xFFFFFFFF //col:6491
CPUID_EBX_PROCESSOR_BRAND_STRING_10(_) =                       (((_) >> 0) & 0xFFFFFFFF) //col:6492
CPUID_ECX_PROCESSOR_BRAND_STRING_11_BIT =                      0 //col:6506
CPUID_ECX_PROCESSOR_BRAND_STRING_11_FLAG =                     0xFFFFFFFF //col:6507
CPUID_ECX_PROCESSOR_BRAND_STRING_11_MASK =                     0xFFFFFFFF //col:6508
CPUID_ECX_PROCESSOR_BRAND_STRING_11(_) =                       (((_) >> 0) & 0xFFFFFFFF) //col:6509
CPUID_EDX_PROCESSOR_BRAND_STRING_12_BIT =                      0 //col:6523
CPUID_EDX_PROCESSOR_BRAND_STRING_12_FLAG =                     0xFFFFFFFF //col:6524
CPUID_EDX_PROCESSOR_BRAND_STRING_12_MASK =                     0xFFFFFFFF //col:6525
CPUID_EDX_PROCESSOR_BRAND_STRING_12(_) =                       (((_) >> 0) & 0xFFFFFFFF) //col:6526
CPUID_EAX_RESERVED_BIT =                                       0 //col:6547
CPUID_EAX_RESERVED_FLAG =                                      0xFFFFFFFF //col:6548
CPUID_EAX_RESERVED_MASK =                                      0xFFFFFFFF //col:6549
CPUID_EAX_RESERVED(_) =                                        (((_) >> 0) & 0xFFFFFFFF) //col:6550
CPUID_EBX_RESERVED_BIT =                                       0 //col:6564
CPUID_EBX_RESERVED_FLAG =                                      0xFFFFFFFF //col:6565
CPUID_EBX_RESERVED_MASK =                                      0xFFFFFFFF //col:6566
CPUID_EBX_RESERVED(_) =                                        (((_) >> 0) & 0xFFFFFFFF) //col:6567
CPUID_ECX_RESERVED_BIT =                                       0 //col:6581
CPUID_ECX_RESERVED_FLAG =                                      0xFFFFFFFF //col:6582
CPUID_ECX_RESERVED_MASK =                                      0xFFFFFFFF //col:6583
CPUID_ECX_RESERVED(_) =                                        (((_) >> 0) & 0xFFFFFFFF) //col:6584
CPUID_EDX_RESERVED_BIT =                                       0 //col:6598
CPUID_EDX_RESERVED_FLAG =                                      0xFFFFFFFF //col:6599
CPUID_EDX_RESERVED_MASK =                                      0xFFFFFFFF //col:6600
CPUID_EDX_RESERVED(_) =                                        (((_) >> 0) & 0xFFFFFFFF) //col:6601
CPUID_EXTENDED_CACHE_INFO =                                    0x80000006 //col:6613
CPUID_EAX_RESERVED_BIT =                                       0 //col:6624
CPUID_EAX_RESERVED_FLAG =                                      0xFFFFFFFF //col:6625
CPUID_EAX_RESERVED_MASK =                                      0xFFFFFFFF //col:6626
CPUID_EAX_RESERVED(_) =                                        (((_) >> 0) & 0xFFFFFFFF) //col:6627
CPUID_EBX_RESERVED_BIT =                                       0 //col:6641
CPUID_EBX_RESERVED_FLAG =                                      0xFFFFFFFF //col:6642
CPUID_EBX_RESERVED_MASK =                                      0xFFFFFFFF //col:6643
CPUID_EBX_RESERVED(_) =                                        (((_) >> 0) & 0xFFFFFFFF) //col:6644
CPUID_ECX_CACHE_LINE_SIZE_IN_BYTES_BIT =                       0 //col:6658
CPUID_ECX_CACHE_LINE_SIZE_IN_BYTES_FLAG =                      0xFF //col:6659
CPUID_ECX_CACHE_LINE_SIZE_IN_BYTES_MASK =                      0xFF //col:6660
CPUID_ECX_CACHE_LINE_SIZE_IN_BYTES(_) =                        (((_) >> 0) & 0xFF) //col:6661
CPUID_ECX_L2_ASSOCIATIVITY_FIELD_BIT =                         12 //col:6676
CPUID_ECX_L2_ASSOCIATIVITY_FIELD_FLAG =                        0xF000 //col:6677
CPUID_ECX_L2_ASSOCIATIVITY_FIELD_MASK =                        0x0F //col:6678
CPUID_ECX_L2_ASSOCIATIVITY_FIELD(_) =                          (((_) >> 12) & 0x0F) //col:6679
CPUID_ECX_CACHE_SIZE_IN_1K_UNITS_BIT =                         16 //col:6685
CPUID_ECX_CACHE_SIZE_IN_1K_UNITS_FLAG =                        0xFFFF0000 //col:6686
CPUID_ECX_CACHE_SIZE_IN_1K_UNITS_MASK =                        0xFFFF //col:6687
CPUID_ECX_CACHE_SIZE_IN_1K_UNITS(_) =                          (((_) >> 16) & 0xFFFF) //col:6688
CPUID_EDX_RESERVED_BIT =                                       0 //col:6702
CPUID_EDX_RESERVED_FLAG =                                      0xFFFFFFFF //col:6703
CPUID_EDX_RESERVED_MASK =                                      0xFFFFFFFF //col:6704
CPUID_EDX_RESERVED(_) =                                        (((_) >> 0) & 0xFFFFFFFF) //col:6705
CPUID_EXTENDED_TIME_STAMP_COUNTER =                            0x80000007 //col:6717
CPUID_EAX_RESERVED_BIT =                                       0 //col:6728
CPUID_EAX_RESERVED_FLAG =                                      0xFFFFFFFF //col:6729
CPUID_EAX_RESERVED_MASK =                                      0xFFFFFFFF //col:6730
CPUID_EAX_RESERVED(_) =                                        (((_) >> 0) & 0xFFFFFFFF) //col:6731
CPUID_EBX_RESERVED_BIT =                                       0 //col:6745
CPUID_EBX_RESERVED_FLAG =                                      0xFFFFFFFF //col:6746
CPUID_EBX_RESERVED_MASK =                                      0xFFFFFFFF //col:6747
CPUID_EBX_RESERVED(_) =                                        (((_) >> 0) & 0xFFFFFFFF) //col:6748
CPUID_ECX_RESERVED_BIT =                                       0 //col:6762
CPUID_ECX_RESERVED_FLAG =                                      0xFFFFFFFF //col:6763
CPUID_ECX_RESERVED_MASK =                                      0xFFFFFFFF //col:6764
CPUID_ECX_RESERVED(_) =                                        (((_) >> 0) & 0xFFFFFFFF) //col:6765
CPUID_EDX_INVARIANT_TSC_AVAILABLE_BIT =                        8 //col:6781
CPUID_EDX_INVARIANT_TSC_AVAILABLE_FLAG =                       0x100 //col:6782
CPUID_EDX_INVARIANT_TSC_AVAILABLE_MASK =                       0x01 //col:6783
CPUID_EDX_INVARIANT_TSC_AVAILABLE(_) =                         (((_) >> 8) & 0x01) //col:6784
CPUID_EXTENDED_VIRTUAL_PHYSICAL_ADDRESS_SIZE =                 0x80000008 //col:6797
CPUID_EAX_NUMBER_OF_PHYSICAL_ADDRESS_BITS_BIT =                0 //col:6811
CPUID_EAX_NUMBER_OF_PHYSICAL_ADDRESS_BITS_FLAG =               0xFF //col:6812
CPUID_EAX_NUMBER_OF_PHYSICAL_ADDRESS_BITS_MASK =               0xFF //col:6813
CPUID_EAX_NUMBER_OF_PHYSICAL_ADDRESS_BITS(_) =                 (((_) >> 0) & 0xFF) //col:6814
CPUID_EAX_NUMBER_OF_LINEAR_ADDRESS_BITS_BIT =                  8 //col:6820
CPUID_EAX_NUMBER_OF_LINEAR_ADDRESS_BITS_FLAG =                 0xFF00 //col:6821
CPUID_EAX_NUMBER_OF_LINEAR_ADDRESS_BITS_MASK =                 0xFF //col:6822
CPUID_EAX_NUMBER_OF_LINEAR_ADDRESS_BITS(_) =                   (((_) >> 8) & 0xFF) //col:6823
CPUID_EBX_RESERVED_BIT =                                       0 //col:6838
CPUID_EBX_RESERVED_FLAG =                                      0xFFFFFFFF //col:6839
CPUID_EBX_RESERVED_MASK =                                      0xFFFFFFFF //col:6840
CPUID_EBX_RESERVED(_) =                                        (((_) >> 0) & 0xFFFFFFFF) //col:6841
CPUID_ECX_RESERVED_BIT =                                       0 //col:6855
CPUID_ECX_RESERVED_FLAG =                                      0xFFFFFFFF //col:6856
CPUID_ECX_RESERVED_MASK =                                      0xFFFFFFFF //col:6857
CPUID_ECX_RESERVED(_) =                                        (((_) >> 0) & 0xFFFFFFFF) //col:6858
CPUID_EDX_RESERVED_BIT =                                       0 //col:6872
CPUID_EDX_RESERVED_FLAG =                                      0xFFFFFFFF //col:6873
CPUID_EDX_RESERVED_MASK =                                      0xFFFFFFFF //col:6874
CPUID_EDX_RESERVED(_) =                                        (((_) >> 0) & 0xFFFFFFFF) //col:6875
IA32_P5_MC_ADDR =                                              0x00000000 //col:6912
IA32_P5_MC_TYPE =                                              0x00000001 //col:6920
IA32_MONITOR_FILTER_LINE_SIZE =                                0x00000006 //col:6932
IA32_TIME_STAMP_COUNTER =                                      0x00000010 //col:6940
IA32_PLATFORM_ID =                                             0x00000017 //col:6948
IA32_PLATFORM_ID_PLATFORM_ID_BIT =                             50 //col:6973
IA32_PLATFORM_ID_PLATFORM_ID_FLAG =                            0x1C000000000000 //col:6974
IA32_PLATFORM_ID_PLATFORM_ID_MASK =                            0x07 //col:6975
IA32_PLATFORM_ID_PLATFORM_ID(_) =                              (((_) >> 50) & 0x07) //col:6976
IA32_APIC_BASE =                                               0x0000001B //col:6991
IA32_APIC_BASE_BSP_FLAG_BIT =                                  8 //col:7002
IA32_APIC_BASE_BSP_FLAG_FLAG =                                 0x100 //col:7003
IA32_APIC_BASE_BSP_FLAG_MASK =                                 0x01 //col:7004
IA32_APIC_BASE_BSP_FLAG(_) =                                   (((_) >> 8) & 0x01) //col:7005
IA32_APIC_BASE_ENABLE_X2APIC_MODE_BIT =                        10 //col:7012
IA32_APIC_BASE_ENABLE_X2APIC_MODE_FLAG =                       0x400 //col:7013
IA32_APIC_BASE_ENABLE_X2APIC_MODE_MASK =                       0x01 //col:7014
IA32_APIC_BASE_ENABLE_X2APIC_MODE(_) =                         (((_) >> 10) & 0x01) //col:7015
IA32_APIC_BASE_APIC_GLOBAL_ENABLE_BIT =                        11 //col:7021
IA32_APIC_BASE_APIC_GLOBAL_ENABLE_FLAG =                       0x800 //col:7022
IA32_APIC_BASE_APIC_GLOBAL_ENABLE_MASK =                       0x01 //col:7023
IA32_APIC_BASE_APIC_GLOBAL_ENABLE(_) =                         (((_) >> 11) & 0x01) //col:7024
IA32_APIC_BASE_APIC_BASE_BIT =                                 12 //col:7030
IA32_APIC_BASE_APIC_BASE_FLAG =                                0xFFFFFFFFF000 //col:7031
IA32_APIC_BASE_APIC_BASE_MASK =                                0xFFFFFFFFF //col:7032
IA32_APIC_BASE_APIC_BASE(_) =                                  (((_) >> 12) & 0xFFFFFFFFF) //col:7033
IA32_FEATURE_CONTROL =                                         0x0000003A //col:7046
IA32_FEATURE_CONTROL_LOCK_BIT_BIT =                            0 //col:7063
IA32_FEATURE_CONTROL_LOCK_BIT_FLAG =                           0x01 //col:7064
IA32_FEATURE_CONTROL_LOCK_BIT_MASK =                           0x01 //col:7065
IA32_FEATURE_CONTROL_LOCK_BIT(_) =                             (((_) >> 0) & 0x01) //col:7066
IA32_FEATURE_CONTROL_ENABLE_VMX_INSIDE_SMX_BIT =               1 //col:7078
IA32_FEATURE_CONTROL_ENABLE_VMX_INSIDE_SMX_FLAG =              0x02 //col:7079
IA32_FEATURE_CONTROL_ENABLE_VMX_INSIDE_SMX_MASK =              0x01 //col:7080
IA32_FEATURE_CONTROL_ENABLE_VMX_INSIDE_SMX(_) =                (((_) >> 1) & 0x01) //col:7081
IA32_FEATURE_CONTROL_ENABLE_VMX_OUTSIDE_SMX_BIT =              2 //col:7092
IA32_FEATURE_CONTROL_ENABLE_VMX_OUTSIDE_SMX_FLAG =             0x04 //col:7093
IA32_FEATURE_CONTROL_ENABLE_VMX_OUTSIDE_SMX_MASK =             0x01 //col:7094
IA32_FEATURE_CONTROL_ENABLE_VMX_OUTSIDE_SMX(_) =               (((_) >> 2) & 0x01) //col:7095
IA32_FEATURE_CONTROL_SENTER_LOCAL_FUNCTION_ENABLES_BIT =       8 //col:7107
IA32_FEATURE_CONTROL_SENTER_LOCAL_FUNCTION_ENABLES_FLAG =      0x7F00 //col:7108
IA32_FEATURE_CONTROL_SENTER_LOCAL_FUNCTION_ENABLES_MASK =      0x7F //col:7109
IA32_FEATURE_CONTROL_SENTER_LOCAL_FUNCTION_ENABLES(_) =        (((_) >> 8) & 0x7F) //col:7110
IA32_FEATURE_CONTROL_SENTER_GLOBAL_ENABLE_BIT =                15 //col:7120
IA32_FEATURE_CONTROL_SENTER_GLOBAL_ENABLE_FLAG =               0x8000 //col:7121
IA32_FEATURE_CONTROL_SENTER_GLOBAL_ENABLE_MASK =               0x01 //col:7122
IA32_FEATURE_CONTROL_SENTER_GLOBAL_ENABLE(_) =                 (((_) >> 15) & 0x01) //col:7123
IA32_FEATURE_CONTROL_SGX_LAUNCH_CONTROL_ENABLE_BIT =           17 //col:7134
IA32_FEATURE_CONTROL_SGX_LAUNCH_CONTROL_ENABLE_FLAG =          0x20000 //col:7135
IA32_FEATURE_CONTROL_SGX_LAUNCH_CONTROL_ENABLE_MASK =          0x01 //col:7136
IA32_FEATURE_CONTROL_SGX_LAUNCH_CONTROL_ENABLE(_) =            (((_) >> 17) & 0x01) //col:7137
IA32_FEATURE_CONTROL_SGX_GLOBAL_ENABLE_BIT =                   18 //col:7147
IA32_FEATURE_CONTROL_SGX_GLOBAL_ENABLE_FLAG =                  0x40000 //col:7148
IA32_FEATURE_CONTROL_SGX_GLOBAL_ENABLE_MASK =                  0x01 //col:7149
IA32_FEATURE_CONTROL_SGX_GLOBAL_ENABLE(_) =                    (((_) >> 18) & 0x01) //col:7150
IA32_FEATURE_CONTROL_LMCE_ON_BIT =                             20 //col:7162
IA32_FEATURE_CONTROL_LMCE_ON_FLAG =                            0x100000 //col:7163
IA32_FEATURE_CONTROL_LMCE_ON_MASK =                            0x01 //col:7164
IA32_FEATURE_CONTROL_LMCE_ON(_) =                              (((_) >> 20) & 0x01) //col:7165
IA32_TSC_ADJUST =                                              0x0000003B //col:7178
IA32_SPEC_CTRL =                                               0x00000048 //col:7196
IA32_SPEC_CTRL_IBRS_BIT =                                      0 //col:7207
IA32_SPEC_CTRL_IBRS_FLAG =                                     0x01 //col:7208
IA32_SPEC_CTRL_IBRS_MASK =                                     0x01 //col:7209
IA32_SPEC_CTRL_IBRS(_) =                                       (((_) >> 0) & 0x01) //col:7210
IA32_SPEC_CTRL_STIBP_BIT =                                     1 //col:7219
IA32_SPEC_CTRL_STIBP_FLAG =                                    0x02 //col:7220
IA32_SPEC_CTRL_STIBP_MASK =                                    0x01 //col:7221
IA32_SPEC_CTRL_STIBP(_) =                                      (((_) >> 1) & 0x01) //col:7222
IA32_SPEC_CTRL_SSBD_BIT =                                      2 //col:7231
IA32_SPEC_CTRL_SSBD_FLAG =                                     0x04 //col:7232
IA32_SPEC_CTRL_SSBD_MASK =                                     0x01 //col:7233
IA32_SPEC_CTRL_SSBD(_) =                                       (((_) >> 2) & 0x01) //col:7234
IA32_PRED_CMD =                                                0x00000049 //col:7247
IA32_PRED_CMD_IBPB_BIT =                                       0 //col:7258
IA32_PRED_CMD_IBPB_FLAG =                                      0x01 //col:7259
IA32_PRED_CMD_IBPB_MASK =                                      0x01 //col:7260
IA32_PRED_CMD_IBPB(_) =                                        (((_) >> 0) & 0x01) //col:7261
IA32_BIOS_UPDATE_TRIGGER =                                     0x00000079 //col:7278
IA32_BIOS_UPDATE_SIGNATURE =                                   0x0000008B //col:7288
IA32_BIOS_UPDATE_SIGNATURE_RESERVED_BIT =                      0 //col:7297
IA32_BIOS_UPDATE_SIGNATURE_RESERVED_FLAG =                     0xFFFFFFFF //col:7298
IA32_BIOS_UPDATE_SIGNATURE_RESERVED_MASK =                     0xFFFFFFFF //col:7299
IA32_BIOS_UPDATE_SIGNATURE_RESERVED(_) =                       (((_) >> 0) & 0xFFFFFFFF) //col:7300
IA32_BIOS_UPDATE_SIGNATURE_MICROCODE_UPDATE_SIGNATURE_BIT =    32 //col:7313
IA32_BIOS_UPDATE_SIGNATURE_MICROCODE_UPDATE_SIGNATURE_FLAG =   0xFFFFFFFF00000000 //col:7314
IA32_BIOS_UPDATE_SIGNATURE_MICROCODE_UPDATE_SIGNATURE_MASK =   0xFFFFFFFF //col:7315
IA32_BIOS_UPDATE_SIGNATURE_MICROCODE_UPDATE_SIGNATURE(_) =     (((_) >> 32) & 0xFFFFFFFF) //col:7316
IA32_SGXLEPUBKEYHASH0 =                                        0x0000008C //col:7333
IA32_SGXLEPUBKEYHASH1 =                                        0x0000008D //col:7334
IA32_SGXLEPUBKEYHASH2 =                                        0x0000008E //col:7335
IA32_SGXLEPUBKEYHASH3 =                                        0x0000008F //col:7336
IA32_SMM_MONITOR_CTL =                                         0x0000009B //col:7347
IA32_SMM_MONITOR_CTL_VALID_BIT =                               0 //col:7363
IA32_SMM_MONITOR_CTL_VALID_FLAG =                              0x01 //col:7364
IA32_SMM_MONITOR_CTL_VALID_MASK =                              0x01 //col:7365
IA32_SMM_MONITOR_CTL_VALID(_) =                                (((_) >> 0) & 0x01) //col:7366
IA32_SMM_MONITOR_CTL_SMI_UNBLOCKING_BY_VMXOFF_BIT =            2 //col:7380
IA32_SMM_MONITOR_CTL_SMI_UNBLOCKING_BY_VMXOFF_FLAG =           0x04 //col:7381
IA32_SMM_MONITOR_CTL_SMI_UNBLOCKING_BY_VMXOFF_MASK =           0x01 //col:7382
IA32_SMM_MONITOR_CTL_SMI_UNBLOCKING_BY_VMXOFF(_) =             (((_) >> 2) & 0x01) //col:7383
IA32_SMM_MONITOR_CTL_MSEG_BASE_BIT =                           12 //col:7394
IA32_SMM_MONITOR_CTL_MSEG_BASE_FLAG =                          0xFFFFF000 //col:7395
IA32_SMM_MONITOR_CTL_MSEG_BASE_MASK =                          0xFFFFF //col:7396
IA32_SMM_MONITOR_CTL_MSEG_BASE(_) =                            (((_) >> 12) & 0xFFFFF) //col:7397
IA32_STM_FEATURES_IA32E =                                      0x00000001 //col:7430
IA32_SMBASE =                                                  0x0000009E //col:7452
IA32_PMC0 =                                                    0x000000C1 //col:7462
IA32_PMC1 =                                                    0x000000C2 //col:7463
IA32_PMC2 =                                                    0x000000C3 //col:7464
IA32_PMC3 =                                                    0x000000C4 //col:7465
IA32_PMC4 =                                                    0x000000C5 //col:7466
IA32_PMC5 =                                                    0x000000C6 //col:7467
IA32_PMC6 =                                                    0x000000C7 //col:7468
IA32_PMC7 =                                                    0x000000C8 //col:7469
IA32_MPERF =                                                   0x000000E7 //col:7480
IA32_APERF =                                                   0x000000E8 //col:7498
IA32_MTRR_CAPABILITIES =                                       0x000000FE //col:7517
IA32_MTRR_CAPABILITIES_VARIABLE_RANGE_COUNT_BIT =              0 //col:7528
IA32_MTRR_CAPABILITIES_VARIABLE_RANGE_COUNT_FLAG =             0xFF //col:7529
IA32_MTRR_CAPABILITIES_VARIABLE_RANGE_COUNT_MASK =             0xFF //col:7530
IA32_MTRR_CAPABILITIES_VARIABLE_RANGE_COUNT(_) =               (((_) >> 0) & 0xFF) //col:7531
IA32_MTRR_CAPABILITIES_FIXED_RANGE_SUPPORTED_BIT =             8 //col:7540
IA32_MTRR_CAPABILITIES_FIXED_RANGE_SUPPORTED_FLAG =            0x100 //col:7541
IA32_MTRR_CAPABILITIES_FIXED_RANGE_SUPPORTED_MASK =            0x01 //col:7542
IA32_MTRR_CAPABILITIES_FIXED_RANGE_SUPPORTED(_) =              (((_) >> 8) & 0x01) //col:7543
IA32_MTRR_CAPABILITIES_WC_SUPPORTED_BIT =                      10 //col:7552
IA32_MTRR_CAPABILITIES_WC_SUPPORTED_FLAG =                     0x400 //col:7553
IA32_MTRR_CAPABILITIES_WC_SUPPORTED_MASK =                     0x01 //col:7554
IA32_MTRR_CAPABILITIES_WC_SUPPORTED(_) =                       (((_) >> 10) & 0x01) //col:7555
IA32_MTRR_CAPABILITIES_SMRR_SUPPORTED_BIT =                    11 //col:7564
IA32_MTRR_CAPABILITIES_SMRR_SUPPORTED_FLAG =                   0x800 //col:7565
IA32_MTRR_CAPABILITIES_SMRR_SUPPORTED_MASK =                   0x01 //col:7566
IA32_MTRR_CAPABILITIES_SMRR_SUPPORTED(_) =                     (((_) >> 11) & 0x01) //col:7567
IA32_ARCH_CAPABILITIES =                                       0x0000010A //col:7580
IA32_ARCH_CAPABILITIES_RDCL_NO_BIT =                           0 //col:7589
IA32_ARCH_CAPABILITIES_RDCL_NO_FLAG =                          0x01 //col:7590
IA32_ARCH_CAPABILITIES_RDCL_NO_MASK =                          0x01 //col:7591
IA32_ARCH_CAPABILITIES_RDCL_NO(_) =                            (((_) >> 0) & 0x01) //col:7592
IA32_ARCH_CAPABILITIES_IBRS_ALL_BIT =                          1 //col:7598
IA32_ARCH_CAPABILITIES_IBRS_ALL_FLAG =                         0x02 //col:7599
IA32_ARCH_CAPABILITIES_IBRS_ALL_MASK =                         0x01 //col:7600
IA32_ARCH_CAPABILITIES_IBRS_ALL(_) =                           (((_) >> 1) & 0x01) //col:7601
IA32_ARCH_CAPABILITIES_RSBA_BIT =                              2 //col:7608
IA32_ARCH_CAPABILITIES_RSBA_FLAG =                             0x04 //col:7609
IA32_ARCH_CAPABILITIES_RSBA_MASK =                             0x01 //col:7610
IA32_ARCH_CAPABILITIES_RSBA(_) =                               (((_) >> 2) & 0x01) //col:7611
IA32_ARCH_CAPABILITIES_SKIP_L1DFL_VMENTRY_BIT =                3 //col:7617
IA32_ARCH_CAPABILITIES_SKIP_L1DFL_VMENTRY_FLAG =               0x08 //col:7618
IA32_ARCH_CAPABILITIES_SKIP_L1DFL_VMENTRY_MASK =               0x01 //col:7619
IA32_ARCH_CAPABILITIES_SKIP_L1DFL_VMENTRY(_) =                 (((_) >> 3) & 0x01) //col:7620
IA32_ARCH_CAPABILITIES_SSB_NO_BIT =                            4 //col:7626
IA32_ARCH_CAPABILITIES_SSB_NO_FLAG =                           0x10 //col:7627
IA32_ARCH_CAPABILITIES_SSB_NO_MASK =                           0x01 //col:7628
IA32_ARCH_CAPABILITIES_SSB_NO(_) =                             (((_) >> 4) & 0x01) //col:7629
IA32_ARCH_CAPABILITIES_MDS_NO_BIT =                            5 //col:7635
IA32_ARCH_CAPABILITIES_MDS_NO_FLAG =                           0x20 //col:7636
IA32_ARCH_CAPABILITIES_MDS_NO_MASK =                           0x01 //col:7637
IA32_ARCH_CAPABILITIES_MDS_NO(_) =                             (((_) >> 5) & 0x01) //col:7638
IA32_ARCH_CAPABILITIES_IF_PSCHANGE_MC_NO_BIT =                 6 //col:7645
IA32_ARCH_CAPABILITIES_IF_PSCHANGE_MC_NO_FLAG =                0x40 //col:7646
IA32_ARCH_CAPABILITIES_IF_PSCHANGE_MC_NO_MASK =                0x01 //col:7647
IA32_ARCH_CAPABILITIES_IF_PSCHANGE_MC_NO(_) =                  (((_) >> 6) & 0x01) //col:7648
IA32_ARCH_CAPABILITIES_TSX_CTRL_BIT =                          7 //col:7654
IA32_ARCH_CAPABILITIES_TSX_CTRL_FLAG =                         0x80 //col:7655
IA32_ARCH_CAPABILITIES_TSX_CTRL_MASK =                         0x01 //col:7656
IA32_ARCH_CAPABILITIES_TSX_CTRL(_) =                           (((_) >> 7) & 0x01) //col:7657
IA32_ARCH_CAPABILITIES_TAA_NO_BIT =                            8 //col:7663
IA32_ARCH_CAPABILITIES_TAA_NO_FLAG =                           0x100 //col:7664
IA32_ARCH_CAPABILITIES_TAA_NO_MASK =                           0x01 //col:7665
IA32_ARCH_CAPABILITIES_TAA_NO(_) =                             (((_) >> 8) & 0x01) //col:7666
IA32_FLUSH_CMD =                                               0x0000010B //col:7679
IA32_FLUSH_CMD_L1D_FLUSH_BIT =                                 0 //col:7690
IA32_FLUSH_CMD_L1D_FLUSH_FLAG =                                0x01 //col:7691
IA32_FLUSH_CMD_L1D_FLUSH_MASK =                                0x01 //col:7692
IA32_FLUSH_CMD_L1D_FLUSH(_) =                                  (((_) >> 0) & 0x01) //col:7693
IA32_TSX_CTRL =                                                0x00000122 //col:7707
IA32_TSX_CTRL_RTM_DISABLE_BIT =                                0 //col:7716
IA32_TSX_CTRL_RTM_DISABLE_FLAG =                               0x01 //col:7717
IA32_TSX_CTRL_RTM_DISABLE_MASK =                               0x01 //col:7718
IA32_TSX_CTRL_RTM_DISABLE(_) =                                 (((_) >> 0) & 0x01) //col:7719
IA32_TSX_CTRL_TSX_CPUID_CLEAR_BIT =                            1 //col:7726
IA32_TSX_CTRL_TSX_CPUID_CLEAR_FLAG =                           0x02 //col:7727
IA32_TSX_CTRL_TSX_CPUID_CLEAR_MASK =                           0x01 //col:7728
IA32_TSX_CTRL_TSX_CPUID_CLEAR(_) =                             (((_) >> 1) & 0x01) //col:7729
IA32_SYSENTER_CS =                                             0x00000174 //col:7746
IA32_SYSENTER_CS_CS_SELECTOR_BIT =                             0 //col:7755
IA32_SYSENTER_CS_CS_SELECTOR_FLAG =                            0xFFFF //col:7756
IA32_SYSENTER_CS_CS_SELECTOR_MASK =                            0xFFFF //col:7757
IA32_SYSENTER_CS_CS_SELECTOR(_) =                              (((_) >> 0) & 0xFFFF) //col:7758
IA32_SYSENTER_CS_NOT_USED_1_BIT =                              16 //col:7766
IA32_SYSENTER_CS_NOT_USED_1_FLAG =                             0xFFFF0000 //col:7767
IA32_SYSENTER_CS_NOT_USED_1_MASK =                             0xFFFF //col:7768
IA32_SYSENTER_CS_NOT_USED_1(_) =                               (((_) >> 16) & 0xFFFF) //col:7769
IA32_SYSENTER_CS_NOT_USED_2_BIT =                              32 //col:7777
IA32_SYSENTER_CS_NOT_USED_2_FLAG =                             0xFFFFFFFF00000000 //col:7778
IA32_SYSENTER_CS_NOT_USED_2_MASK =                             0xFFFFFFFF //col:7779
IA32_SYSENTER_CS_NOT_USED_2(_) =                               (((_) >> 32) & 0xFFFFFFFF) //col:7780
IA32_SYSENTER_ESP =                                            0x00000175 //col:7796
IA32_SYSENTER_EIP =                                            0x00000176 //col:7807
IA32_MCG_CAP =                                                 0x00000179 //col:7814
IA32_MCG_CAP_COUNT_BIT =                                       0 //col:7823
IA32_MCG_CAP_COUNT_FLAG =                                      0xFF //col:7824
IA32_MCG_CAP_COUNT_MASK =                                      0xFF //col:7825
IA32_MCG_CAP_COUNT(_) =                                        (((_) >> 0) & 0xFF) //col:7826
IA32_MCG_CAP_MCG_CTL_P_BIT =                                   8 //col:7832
IA32_MCG_CAP_MCG_CTL_P_FLAG =                                  0x100 //col:7833
IA32_MCG_CAP_MCG_CTL_P_MASK =                                  0x01 //col:7834
IA32_MCG_CAP_MCG_CTL_P(_) =                                    (((_) >> 8) & 0x01) //col:7835
IA32_MCG_CAP_MCG_EXT_P_BIT =                                   9 //col:7841
IA32_MCG_CAP_MCG_EXT_P_FLAG =                                  0x200 //col:7842
IA32_MCG_CAP_MCG_EXT_P_MASK =                                  0x01 //col:7843
IA32_MCG_CAP_MCG_EXT_P(_) =                                    (((_) >> 9) & 0x01) //col:7844
IA32_MCG_CAP_MCP_CMCI_P_BIT =                                  10 //col:7852
IA32_MCG_CAP_MCP_CMCI_P_FLAG =                                 0x400 //col:7853
IA32_MCG_CAP_MCP_CMCI_P_MASK =                                 0x01 //col:7854
IA32_MCG_CAP_MCP_CMCI_P(_) =                                   (((_) >> 10) & 0x01) //col:7855
IA32_MCG_CAP_MCG_TES_P_BIT =                                   11 //col:7861
IA32_MCG_CAP_MCG_TES_P_FLAG =                                  0x800 //col:7862
IA32_MCG_CAP_MCG_TES_P_MASK =                                  0x01 //col:7863
IA32_MCG_CAP_MCG_TES_P(_) =                                    (((_) >> 11) & 0x01) //col:7864
IA32_MCG_CAP_MCG_EXT_CNT_BIT =                                 16 //col:7871
IA32_MCG_CAP_MCG_EXT_CNT_FLAG =                                0xFF0000 //col:7872
IA32_MCG_CAP_MCG_EXT_CNT_MASK =                                0xFF //col:7873
IA32_MCG_CAP_MCG_EXT_CNT(_) =                                  (((_) >> 16) & 0xFF) //col:7874
IA32_MCG_CAP_MCG_SER_P_BIT =                                   24 //col:7880
IA32_MCG_CAP_MCG_SER_P_FLAG =                                  0x1000000 //col:7881
IA32_MCG_CAP_MCG_SER_P_MASK =                                  0x01 //col:7882
IA32_MCG_CAP_MCG_SER_P(_) =                                    (((_) >> 24) & 0x01) //col:7883
IA32_MCG_CAP_MCG_ELOG_P_BIT =                                  26 //col:7894
IA32_MCG_CAP_MCG_ELOG_P_FLAG =                                 0x4000000 //col:7895
IA32_MCG_CAP_MCG_ELOG_P_MASK =                                 0x01 //col:7896
IA32_MCG_CAP_MCG_ELOG_P(_) =                                   (((_) >> 26) & 0x01) //col:7897
IA32_MCG_CAP_MCG_LMCE_P_BIT =                                  27 //col:7906
IA32_MCG_CAP_MCG_LMCE_P_FLAG =                                 0x8000000 //col:7907
IA32_MCG_CAP_MCG_LMCE_P_MASK =                                 0x01 //col:7908
IA32_MCG_CAP_MCG_LMCE_P(_) =                                   (((_) >> 27) & 0x01) //col:7909
IA32_MCG_STATUS =                                              0x0000017A //col:7922
IA32_MCG_STATUS_RIPV_BIT =                                     0 //col:7933
IA32_MCG_STATUS_RIPV_FLAG =                                    0x01 //col:7934
IA32_MCG_STATUS_RIPV_MASK =                                    0x01 //col:7935
IA32_MCG_STATUS_RIPV(_) =                                      (((_) >> 0) & 0x01) //col:7936
IA32_MCG_STATUS_EIPV_BIT =                                     1 //col:7944
IA32_MCG_STATUS_EIPV_FLAG =                                    0x02 //col:7945
IA32_MCG_STATUS_EIPV_MASK =                                    0x01 //col:7946
IA32_MCG_STATUS_EIPV(_) =                                      (((_) >> 1) & 0x01) //col:7947
IA32_MCG_STATUS_MCIP_BIT =                                     2 //col:7955
IA32_MCG_STATUS_MCIP_FLAG =                                    0x04 //col:7956
IA32_MCG_STATUS_MCIP_MASK =                                    0x01 //col:7957
IA32_MCG_STATUS_MCIP(_) =                                      (((_) >> 2) & 0x01) //col:7958
IA32_MCG_STATUS_LMCE_S_BIT =                                   3 //col:7964
IA32_MCG_STATUS_LMCE_S_FLAG =                                  0x08 //col:7965
IA32_MCG_STATUS_LMCE_S_MASK =                                  0x01 //col:7966
IA32_MCG_STATUS_LMCE_S(_) =                                    (((_) >> 3) & 0x01) //col:7967
IA32_MCG_CTL =                                                 0x0000017B //col:7980
IA32_PERFEVTSEL0 =                                             0x00000186 //col:7990
IA32_PERFEVTSEL1 =                                             0x00000187 //col:7991
IA32_PERFEVTSEL2 =                                             0x00000188 //col:7992
IA32_PERFEVTSEL3 =                                             0x00000189 //col:7993
IA32_PERFEVTSEL_EVENT_SELECT_BIT =                             0 //col:8002
IA32_PERFEVTSEL_EVENT_SELECT_FLAG =                            0xFF //col:8003
IA32_PERFEVTSEL_EVENT_SELECT_MASK =                            0xFF //col:8004
IA32_PERFEVTSEL_EVENT_SELECT(_) =                              (((_) >> 0) & 0xFF) //col:8005
IA32_PERFEVTSEL_U_MASK_BIT =                                   8 //col:8011
IA32_PERFEVTSEL_U_MASK_FLAG =                                  0xFF00 //col:8012
IA32_PERFEVTSEL_U_MASK_MASK =                                  0xFF //col:8013
IA32_PERFEVTSEL_U_MASK(_) =                                    (((_) >> 8) & 0xFF) //col:8014
IA32_PERFEVTSEL_USR_BIT =                                      16 //col:8020
IA32_PERFEVTSEL_USR_FLAG =                                     0x10000 //col:8021
IA32_PERFEVTSEL_USR_MASK =                                     0x01 //col:8022
IA32_PERFEVTSEL_USR(_) =                                       (((_) >> 16) & 0x01) //col:8023
IA32_PERFEVTSEL_OS_BIT =                                       17 //col:8029
IA32_PERFEVTSEL_OS_FLAG =                                      0x20000 //col:8030
IA32_PERFEVTSEL_OS_MASK =                                      0x01 //col:8031
IA32_PERFEVTSEL_OS(_) =                                        (((_) >> 17) & 0x01) //col:8032
IA32_PERFEVTSEL_EDGE_BIT =                                     18 //col:8038
IA32_PERFEVTSEL_EDGE_FLAG =                                    0x40000 //col:8039
IA32_PERFEVTSEL_EDGE_MASK =                                    0x01 //col:8040
IA32_PERFEVTSEL_EDGE(_) =                                      (((_) >> 18) & 0x01) //col:8041
IA32_PERFEVTSEL_PC_BIT =                                       19 //col:8047
IA32_PERFEVTSEL_PC_FLAG =                                      0x80000 //col:8048
IA32_PERFEVTSEL_PC_MASK =                                      0x01 //col:8049
IA32_PERFEVTSEL_PC(_) =                                        (((_) >> 19) & 0x01) //col:8050
IA32_PERFEVTSEL_INTR_BIT =                                     20 //col:8056
IA32_PERFEVTSEL_INTR_FLAG =                                    0x100000 //col:8057
IA32_PERFEVTSEL_INTR_MASK =                                    0x01 //col:8058
IA32_PERFEVTSEL_INTR(_) =                                      (((_) >> 20) & 0x01) //col:8059
IA32_PERFEVTSEL_ANY_THREAD_BIT =                               21 //col:8067
IA32_PERFEVTSEL_ANY_THREAD_FLAG =                              0x200000 //col:8068
IA32_PERFEVTSEL_ANY_THREAD_MASK =                              0x01 //col:8069
IA32_PERFEVTSEL_ANY_THREAD(_) =                                (((_) >> 21) & 0x01) //col:8070
IA32_PERFEVTSEL_EN_BIT =                                       22 //col:8076
IA32_PERFEVTSEL_EN_FLAG =                                      0x400000 //col:8077
IA32_PERFEVTSEL_EN_MASK =                                      0x01 //col:8078
IA32_PERFEVTSEL_EN(_) =                                        (((_) >> 22) & 0x01) //col:8079
IA32_PERFEVTSEL_INV_BIT =                                      23 //col:8085
IA32_PERFEVTSEL_INV_FLAG =                                     0x800000 //col:8086
IA32_PERFEVTSEL_INV_MASK =                                     0x01 //col:8087
IA32_PERFEVTSEL_INV(_) =                                       (((_) >> 23) & 0x01) //col:8088
IA32_PERFEVTSEL_CMASK_BIT =                                    24 //col:8095
IA32_PERFEVTSEL_CMASK_FLAG =                                   0xFF000000 //col:8096
IA32_PERFEVTSEL_CMASK_MASK =                                   0xFF //col:8097
IA32_PERFEVTSEL_CMASK(_) =                                     (((_) >> 24) & 0xFF) //col:8098
IA32_PERF_STATUS =                                             0x00000198 //col:8116
IA32_PERF_STATUS_STATE_VALUE_BIT =                             0 //col:8125
IA32_PERF_STATUS_STATE_VALUE_FLAG =                            0xFFFF //col:8126
IA32_PERF_STATUS_STATE_VALUE_MASK =                            0xFFFF //col:8127
IA32_PERF_STATUS_STATE_VALUE(_) =                              (((_) >> 0) & 0xFFFF) //col:8128
IA32_PERF_CTL =                                                0x00000199 //col:8144
IA32_PERF_CTL_TARGET_STATE_VALUE_BIT =                         0 //col:8153
IA32_PERF_CTL_TARGET_STATE_VALUE_FLAG =                        0xFFFF //col:8154
IA32_PERF_CTL_TARGET_STATE_VALUE_MASK =                        0xFFFF //col:8155
IA32_PERF_CTL_TARGET_STATE_VALUE(_) =                          (((_) >> 0) & 0xFFFF) //col:8156
IA32_PERF_CTL_IDA_ENGAGE_BIT =                                 32 //col:8165
IA32_PERF_CTL_IDA_ENGAGE_FLAG =                                0x100000000 //col:8166
IA32_PERF_CTL_IDA_ENGAGE_MASK =                                0x01 //col:8167
IA32_PERF_CTL_IDA_ENGAGE(_) =                                  (((_) >> 32) & 0x01) //col:8168
IA32_CLOCK_MODULATION =                                        0x0000019A //col:8182
IA32_CLOCK_MODULATION_EXTENDED_ON_DEMAND_CLOCK_MODULATION_DUTY_CYCLE_BIT = 0 //col:8193
IA32_CLOCK_MODULATION_EXTENDED_ON_DEMAND_CLOCK_MODULATION_DUTY_CYCLE_FLAG = 0x01 //col:8194
IA32_CLOCK_MODULATION_EXTENDED_ON_DEMAND_CLOCK_MODULATION_DUTY_CYCLE_MASK = 0x01 //col:8195
IA32_CLOCK_MODULATION_EXTENDED_ON_DEMAND_CLOCK_MODULATION_DUTY_CYCLE(_) = (((_) >> 0) & 0x01) //col:8196
IA32_CLOCK_MODULATION_ON_DEMAND_CLOCK_MODULATION_DUTY_CYCLE_BIT = 1 //col:8206
IA32_CLOCK_MODULATION_ON_DEMAND_CLOCK_MODULATION_DUTY_CYCLE_FLAG = 0x0E //col:8207
IA32_CLOCK_MODULATION_ON_DEMAND_CLOCK_MODULATION_DUTY_CYCLE_MASK = 0x07 //col:8208
IA32_CLOCK_MODULATION_ON_DEMAND_CLOCK_MODULATION_DUTY_CYCLE(_) = (((_) >> 1) & 0x07) //col:8209
IA32_CLOCK_MODULATION_ON_DEMAND_CLOCK_MODULATION_ENABLE_BIT =  4 //col:8219
IA32_CLOCK_MODULATION_ON_DEMAND_CLOCK_MODULATION_ENABLE_FLAG = 0x10 //col:8220
IA32_CLOCK_MODULATION_ON_DEMAND_CLOCK_MODULATION_ENABLE_MASK = 0x01 //col:8221
IA32_CLOCK_MODULATION_ON_DEMAND_CLOCK_MODULATION_ENABLE(_) =   (((_) >> 4) & 0x01) //col:8222
IA32_THERM_INTERRUPT =                                         0x0000019B //col:8239
IA32_THERM_INTERRUPT_HIGH_TEMPERATURE_INTERRUPT_ENABLE_BIT =   0 //col:8250
IA32_THERM_INTERRUPT_HIGH_TEMPERATURE_INTERRUPT_ENABLE_FLAG =  0x01 //col:8251
IA32_THERM_INTERRUPT_HIGH_TEMPERATURE_INTERRUPT_ENABLE_MASK =  0x01 //col:8252
IA32_THERM_INTERRUPT_HIGH_TEMPERATURE_INTERRUPT_ENABLE(_) =    (((_) >> 0) & 0x01) //col:8253
IA32_THERM_INTERRUPT_LOW_TEMPERATURE_INTERRUPT_ENABLE_BIT =    1 //col:8261
IA32_THERM_INTERRUPT_LOW_TEMPERATURE_INTERRUPT_ENABLE_FLAG =   0x02 //col:8262
IA32_THERM_INTERRUPT_LOW_TEMPERATURE_INTERRUPT_ENABLE_MASK =   0x01 //col:8263
IA32_THERM_INTERRUPT_LOW_TEMPERATURE_INTERRUPT_ENABLE(_) =     (((_) >> 1) & 0x01) //col:8264
IA32_THERM_INTERRUPT_PROCHOT_INTERRUPT_ENABLE_BIT =            2 //col:8272
IA32_THERM_INTERRUPT_PROCHOT_INTERRUPT_ENABLE_FLAG =           0x04 //col:8273
IA32_THERM_INTERRUPT_PROCHOT_INTERRUPT_ENABLE_MASK =           0x01 //col:8274
IA32_THERM_INTERRUPT_PROCHOT_INTERRUPT_ENABLE(_) =             (((_) >> 2) & 0x01) //col:8275
IA32_THERM_INTERRUPT_FORCEPR_INTERRUPT_ENABLE_BIT =            3 //col:8283
IA32_THERM_INTERRUPT_FORCEPR_INTERRUPT_ENABLE_FLAG =           0x08 //col:8284
IA32_THERM_INTERRUPT_FORCEPR_INTERRUPT_ENABLE_MASK =           0x01 //col:8285
IA32_THERM_INTERRUPT_FORCEPR_INTERRUPT_ENABLE(_) =             (((_) >> 3) & 0x01) //col:8286
IA32_THERM_INTERRUPT_CRITICAL_TEMPERATURE_INTERRUPT_ENABLE_BIT = 4 //col:8294
IA32_THERM_INTERRUPT_CRITICAL_TEMPERATURE_INTERRUPT_ENABLE_FLAG = 0x10 //col:8295
IA32_THERM_INTERRUPT_CRITICAL_TEMPERATURE_INTERRUPT_ENABLE_MASK = 0x01 //col:8296
IA32_THERM_INTERRUPT_CRITICAL_TEMPERATURE_INTERRUPT_ENABLE(_) = (((_) >> 4) & 0x01) //col:8297
IA32_THERM_INTERRUPT_THRESHOLD1_VALUE_BIT =                    8 //col:8306
IA32_THERM_INTERRUPT_THRESHOLD1_VALUE_FLAG =                   0x7F00 //col:8307
IA32_THERM_INTERRUPT_THRESHOLD1_VALUE_MASK =                   0x7F //col:8308
IA32_THERM_INTERRUPT_THRESHOLD1_VALUE(_) =                     (((_) >> 8) & 0x7F) //col:8309
IA32_THERM_INTERRUPT_THRESHOLD1_INTERRUPT_ENABLE_BIT =         15 //col:8317
IA32_THERM_INTERRUPT_THRESHOLD1_INTERRUPT_ENABLE_FLAG =        0x8000 //col:8318
IA32_THERM_INTERRUPT_THRESHOLD1_INTERRUPT_ENABLE_MASK =        0x01 //col:8319
IA32_THERM_INTERRUPT_THRESHOLD1_INTERRUPT_ENABLE(_) =          (((_) >> 15) & 0x01) //col:8320
IA32_THERM_INTERRUPT_THRESHOLD2_VALUE_BIT =                    16 //col:8328
IA32_THERM_INTERRUPT_THRESHOLD2_VALUE_FLAG =                   0x7F0000 //col:8329
IA32_THERM_INTERRUPT_THRESHOLD2_VALUE_MASK =                   0x7F //col:8330
IA32_THERM_INTERRUPT_THRESHOLD2_VALUE(_) =                     (((_) >> 16) & 0x7F) //col:8331
IA32_THERM_INTERRUPT_THRESHOLD2_INTERRUPT_ENABLE_BIT =         23 //col:8339
IA32_THERM_INTERRUPT_THRESHOLD2_INTERRUPT_ENABLE_FLAG =        0x800000 //col:8340
IA32_THERM_INTERRUPT_THRESHOLD2_INTERRUPT_ENABLE_MASK =        0x01 //col:8341
IA32_THERM_INTERRUPT_THRESHOLD2_INTERRUPT_ENABLE(_) =          (((_) >> 23) & 0x01) //col:8342
IA32_THERM_INTERRUPT_POWER_LIMIT_NOTIFICATION_ENABLE_BIT =     24 //col:8350
IA32_THERM_INTERRUPT_POWER_LIMIT_NOTIFICATION_ENABLE_FLAG =    0x1000000 //col:8351
IA32_THERM_INTERRUPT_POWER_LIMIT_NOTIFICATION_ENABLE_MASK =    0x01 //col:8352
IA32_THERM_INTERRUPT_POWER_LIMIT_NOTIFICATION_ENABLE(_) =      (((_) >> 24) & 0x01) //col:8353
IA32_THERM_STATUS =                                            0x0000019C //col:8370
IA32_THERM_STATUS_THERMAL_STATUS_BIT =                         0 //col:8381
IA32_THERM_STATUS_THERMAL_STATUS_FLAG =                        0x01 //col:8382
IA32_THERM_STATUS_THERMAL_STATUS_MASK =                        0x01 //col:8383
IA32_THERM_STATUS_THERMAL_STATUS(_) =                          (((_) >> 0) & 0x01) //col:8384
IA32_THERM_STATUS_THERMAL_STATUS_LOG_BIT =                     1 //col:8392
IA32_THERM_STATUS_THERMAL_STATUS_LOG_FLAG =                    0x02 //col:8393
IA32_THERM_STATUS_THERMAL_STATUS_LOG_MASK =                    0x01 //col:8394
IA32_THERM_STATUS_THERMAL_STATUS_LOG(_) =                      (((_) >> 1) & 0x01) //col:8395
IA32_THERM_STATUS_PROCHOT_FORCEPR_EVENT_BIT =                  2 //col:8403
IA32_THERM_STATUS_PROCHOT_FORCEPR_EVENT_FLAG =                 0x04 //col:8404
IA32_THERM_STATUS_PROCHOT_FORCEPR_EVENT_MASK =                 0x01 //col:8405
IA32_THERM_STATUS_PROCHOT_FORCEPR_EVENT(_) =                   (((_) >> 2) & 0x01) //col:8406
IA32_THERM_STATUS_PROCHOT_FORCEPR_LOG_BIT =                    3 //col:8414
IA32_THERM_STATUS_PROCHOT_FORCEPR_LOG_FLAG =                   0x08 //col:8415
IA32_THERM_STATUS_PROCHOT_FORCEPR_LOG_MASK =                   0x01 //col:8416
IA32_THERM_STATUS_PROCHOT_FORCEPR_LOG(_) =                     (((_) >> 3) & 0x01) //col:8417
IA32_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_BIT =            4 //col:8425
IA32_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_FLAG =           0x10 //col:8426
IA32_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_MASK =           0x01 //col:8427
IA32_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS(_) =             (((_) >> 4) & 0x01) //col:8428
IA32_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_LOG_BIT =        5 //col:8436
IA32_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_LOG_FLAG =       0x20 //col:8437
IA32_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_LOG_MASK =       0x01 //col:8438
IA32_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_LOG(_) =         (((_) >> 5) & 0x01) //col:8439
IA32_THERM_STATUS_THERMAL_THRESHOLD1_STATUS_BIT =              6 //col:8447
IA32_THERM_STATUS_THERMAL_THRESHOLD1_STATUS_FLAG =             0x40 //col:8448
IA32_THERM_STATUS_THERMAL_THRESHOLD1_STATUS_MASK =             0x01 //col:8449
IA32_THERM_STATUS_THERMAL_THRESHOLD1_STATUS(_) =               (((_) >> 6) & 0x01) //col:8450
IA32_THERM_STATUS_THERMAL_THRESHOLD1_LOG_BIT =                 7 //col:8458
IA32_THERM_STATUS_THERMAL_THRESHOLD1_LOG_FLAG =                0x80 //col:8459
IA32_THERM_STATUS_THERMAL_THRESHOLD1_LOG_MASK =                0x01 //col:8460
IA32_THERM_STATUS_THERMAL_THRESHOLD1_LOG(_) =                  (((_) >> 7) & 0x01) //col:8461
IA32_THERM_STATUS_THERMAL_THRESHOLD2_STATUS_BIT =              8 //col:8469
IA32_THERM_STATUS_THERMAL_THRESHOLD2_STATUS_FLAG =             0x100 //col:8470
IA32_THERM_STATUS_THERMAL_THRESHOLD2_STATUS_MASK =             0x01 //col:8471
IA32_THERM_STATUS_THERMAL_THRESHOLD2_STATUS(_) =               (((_) >> 8) & 0x01) //col:8472
IA32_THERM_STATUS_THERMAL_THRESHOLD2_LOG_BIT =                 9 //col:8480
IA32_THERM_STATUS_THERMAL_THRESHOLD2_LOG_FLAG =                0x200 //col:8481
IA32_THERM_STATUS_THERMAL_THRESHOLD2_LOG_MASK =                0x01 //col:8482
IA32_THERM_STATUS_THERMAL_THRESHOLD2_LOG(_) =                  (((_) >> 9) & 0x01) //col:8483
IA32_THERM_STATUS_POWER_LIMITATION_STATUS_BIT =                10 //col:8491
IA32_THERM_STATUS_POWER_LIMITATION_STATUS_FLAG =               0x400 //col:8492
IA32_THERM_STATUS_POWER_LIMITATION_STATUS_MASK =               0x01 //col:8493
IA32_THERM_STATUS_POWER_LIMITATION_STATUS(_) =                 (((_) >> 10) & 0x01) //col:8494
IA32_THERM_STATUS_POWER_LIMITATION_LOG_BIT =                   11 //col:8502
IA32_THERM_STATUS_POWER_LIMITATION_LOG_FLAG =                  0x800 //col:8503
IA32_THERM_STATUS_POWER_LIMITATION_LOG_MASK =                  0x01 //col:8504
IA32_THERM_STATUS_POWER_LIMITATION_LOG(_) =                    (((_) >> 11) & 0x01) //col:8505
IA32_THERM_STATUS_CURRENT_LIMIT_STATUS_BIT =                   12 //col:8513
IA32_THERM_STATUS_CURRENT_LIMIT_STATUS_FLAG =                  0x1000 //col:8514
IA32_THERM_STATUS_CURRENT_LIMIT_STATUS_MASK =                  0x01 //col:8515
IA32_THERM_STATUS_CURRENT_LIMIT_STATUS(_) =                    (((_) >> 12) & 0x01) //col:8516
IA32_THERM_STATUS_CURRENT_LIMIT_LOG_BIT =                      13 //col:8524
IA32_THERM_STATUS_CURRENT_LIMIT_LOG_FLAG =                     0x2000 //col:8525
IA32_THERM_STATUS_CURRENT_LIMIT_LOG_MASK =                     0x01 //col:8526
IA32_THERM_STATUS_CURRENT_LIMIT_LOG(_) =                       (((_) >> 13) & 0x01) //col:8527
IA32_THERM_STATUS_CROSS_DOMAIN_LIMIT_STATUS_BIT =              14 //col:8535
IA32_THERM_STATUS_CROSS_DOMAIN_LIMIT_STATUS_FLAG =             0x4000 //col:8536
IA32_THERM_STATUS_CROSS_DOMAIN_LIMIT_STATUS_MASK =             0x01 //col:8537
IA32_THERM_STATUS_CROSS_DOMAIN_LIMIT_STATUS(_) =               (((_) >> 14) & 0x01) //col:8538
IA32_THERM_STATUS_CROSS_DOMAIN_LIMIT_LOG_BIT =                 15 //col:8546
IA32_THERM_STATUS_CROSS_DOMAIN_LIMIT_LOG_FLAG =                0x8000 //col:8547
IA32_THERM_STATUS_CROSS_DOMAIN_LIMIT_LOG_MASK =                0x01 //col:8548
IA32_THERM_STATUS_CROSS_DOMAIN_LIMIT_LOG(_) =                  (((_) >> 15) & 0x01) //col:8549
IA32_THERM_STATUS_DIGITAL_READOUT_BIT =                        16 //col:8557
IA32_THERM_STATUS_DIGITAL_READOUT_FLAG =                       0x7F0000 //col:8558
IA32_THERM_STATUS_DIGITAL_READOUT_MASK =                       0x7F //col:8559
IA32_THERM_STATUS_DIGITAL_READOUT(_) =                         (((_) >> 16) & 0x7F) //col:8560
IA32_THERM_STATUS_RESOLUTION_IN_DEGREES_CELSIUS_BIT =          27 //col:8569
IA32_THERM_STATUS_RESOLUTION_IN_DEGREES_CELSIUS_FLAG =         0x78000000 //col:8570
IA32_THERM_STATUS_RESOLUTION_IN_DEGREES_CELSIUS_MASK =         0x0F //col:8571
IA32_THERM_STATUS_RESOLUTION_IN_DEGREES_CELSIUS(_) =           (((_) >> 27) & 0x0F) //col:8572
IA32_THERM_STATUS_READING_VALID_BIT =                          31 //col:8580
IA32_THERM_STATUS_READING_VALID_FLAG =                         0x80000000 //col:8581
IA32_THERM_STATUS_READING_VALID_MASK =                         0x01 //col:8582
IA32_THERM_STATUS_READING_VALID(_) =                           (((_) >> 31) & 0x01) //col:8583
IA32_MISC_ENABLE =                                             0x000001A0 //col:8596
IA32_MISC_ENABLE_FAST_STRINGS_ENABLE_BIT =                     0 //col:8610
IA32_MISC_ENABLE_FAST_STRINGS_ENABLE_FLAG =                    0x01 //col:8611
IA32_MISC_ENABLE_FAST_STRINGS_ENABLE_MASK =                    0x01 //col:8612
IA32_MISC_ENABLE_FAST_STRINGS_ENABLE(_) =                      (((_) >> 0) & 0x01) //col:8613
IA32_MISC_ENABLE_AUTOMATIC_THERMAL_CONTROL_CIRCUIT_ENABLE_BIT = 3 //col:8628
IA32_MISC_ENABLE_AUTOMATIC_THERMAL_CONTROL_CIRCUIT_ENABLE_FLAG = 0x08 //col:8629
IA32_MISC_ENABLE_AUTOMATIC_THERMAL_CONTROL_CIRCUIT_ENABLE_MASK = 0x01 //col:8630
IA32_MISC_ENABLE_AUTOMATIC_THERMAL_CONTROL_CIRCUIT_ENABLE(_) = (((_) >> 3) & 0x01) //col:8631
IA32_MISC_ENABLE_PERFORMANCE_MONITORING_AVAILABLE_BIT =        7 //col:8643
IA32_MISC_ENABLE_PERFORMANCE_MONITORING_AVAILABLE_FLAG =       0x80 //col:8644
IA32_MISC_ENABLE_PERFORMANCE_MONITORING_AVAILABLE_MASK =       0x01 //col:8645
IA32_MISC_ENABLE_PERFORMANCE_MONITORING_AVAILABLE(_) =         (((_) >> 7) & 0x01) //col:8646
IA32_MISC_ENABLE_BRANCH_TRACE_STORAGE_UNAVAILABLE_BIT =        11 //col:8658
IA32_MISC_ENABLE_BRANCH_TRACE_STORAGE_UNAVAILABLE_FLAG =       0x800 //col:8659
IA32_MISC_ENABLE_BRANCH_TRACE_STORAGE_UNAVAILABLE_MASK =       0x01 //col:8660
IA32_MISC_ENABLE_BRANCH_TRACE_STORAGE_UNAVAILABLE(_) =         (((_) >> 11) & 0x01) //col:8661
IA32_MISC_ENABLE_PROCESSOR_EVENT_BASED_SAMPLING_UNAVAILABLE_BIT = 12 //col:8672
IA32_MISC_ENABLE_PROCESSOR_EVENT_BASED_SAMPLING_UNAVAILABLE_FLAG = 0x1000 //col:8673
IA32_MISC_ENABLE_PROCESSOR_EVENT_BASED_SAMPLING_UNAVAILABLE_MASK = 0x01 //col:8674
IA32_MISC_ENABLE_PROCESSOR_EVENT_BASED_SAMPLING_UNAVAILABLE(_) = (((_) >> 12) & 0x01) //col:8675
IA32_MISC_ENABLE_ENHANCED_INTEL_SPEEDSTEP_TECHNOLOGY_ENABLE_BIT = 16 //col:8687
IA32_MISC_ENABLE_ENHANCED_INTEL_SPEEDSTEP_TECHNOLOGY_ENABLE_FLAG = 0x10000 //col:8688
IA32_MISC_ENABLE_ENHANCED_INTEL_SPEEDSTEP_TECHNOLOGY_ENABLE_MASK = 0x01 //col:8689
IA32_MISC_ENABLE_ENHANCED_INTEL_SPEEDSTEP_TECHNOLOGY_ENABLE(_) = (((_) >> 16) & 0x01) //col:8690
IA32_MISC_ENABLE_ENABLE_MONITOR_FSM_BIT =                      18 //col:8705
IA32_MISC_ENABLE_ENABLE_MONITOR_FSM_FLAG =                     0x40000 //col:8706
IA32_MISC_ENABLE_ENABLE_MONITOR_FSM_MASK =                     0x01 //col:8707
IA32_MISC_ENABLE_ENABLE_MONITOR_FSM(_) =                       (((_) >> 18) & 0x01) //col:8708
IA32_MISC_ENABLE_LIMIT_CPUID_MAXVAL_BIT =                      22 //col:8725
IA32_MISC_ENABLE_LIMIT_CPUID_MAXVAL_FLAG =                     0x400000 //col:8726
IA32_MISC_ENABLE_LIMIT_CPUID_MAXVAL_MASK =                     0x01 //col:8727
IA32_MISC_ENABLE_LIMIT_CPUID_MAXVAL(_) =                       (((_) >> 22) & 0x01) //col:8728
IA32_MISC_ENABLE_XTPR_MESSAGE_DISABLE_BIT =                    23 //col:8739
IA32_MISC_ENABLE_XTPR_MESSAGE_DISABLE_FLAG =                   0x800000 //col:8740
IA32_MISC_ENABLE_XTPR_MESSAGE_DISABLE_MASK =                   0x01 //col:8741
IA32_MISC_ENABLE_XTPR_MESSAGE_DISABLE(_) =                     (((_) >> 23) & 0x01) //col:8742
IA32_MISC_ENABLE_XD_BIT_DISABLE_BIT =                          34 //col:8758
IA32_MISC_ENABLE_XD_BIT_DISABLE_FLAG =                         0x400000000 //col:8759
IA32_MISC_ENABLE_XD_BIT_DISABLE_MASK =                         0x01 //col:8760
IA32_MISC_ENABLE_XD_BIT_DISABLE(_) =                           (((_) >> 34) & 0x01) //col:8761
IA32_ENERGY_PERF_BIAS =                                        0x000001B0 //col:8774
IA32_ENERGY_PERF_BIAS_POWER_POLICY_PREFERENCE_BIT =            0 //col:8786
IA32_ENERGY_PERF_BIAS_POWER_POLICY_PREFERENCE_FLAG =           0x0F //col:8787
IA32_ENERGY_PERF_BIAS_POWER_POLICY_PREFERENCE_MASK =           0x0F //col:8788
IA32_ENERGY_PERF_BIAS_POWER_POLICY_PREFERENCE(_) =             (((_) >> 0) & 0x0F) //col:8789
IA32_PACKAGE_THERM_STATUS =                                    0x000001B1 //col:8805
IA32_PACKAGE_THERM_STATUS_THERMAL_STATUS_BIT =                 0 //col:8814
IA32_PACKAGE_THERM_STATUS_THERMAL_STATUS_FLAG =                0x01 //col:8815
IA32_PACKAGE_THERM_STATUS_THERMAL_STATUS_MASK =                0x01 //col:8816
IA32_PACKAGE_THERM_STATUS_THERMAL_STATUS(_) =                  (((_) >> 0) & 0x01) //col:8817
IA32_PACKAGE_THERM_STATUS_THERMAL_STATUS_LOG_BIT =             1 //col:8823
IA32_PACKAGE_THERM_STATUS_THERMAL_STATUS_LOG_FLAG =            0x02 //col:8824
IA32_PACKAGE_THERM_STATUS_THERMAL_STATUS_LOG_MASK =            0x01 //col:8825
IA32_PACKAGE_THERM_STATUS_THERMAL_STATUS_LOG(_) =              (((_) >> 1) & 0x01) //col:8826
IA32_PACKAGE_THERM_STATUS_PROCHOT_EVENT_BIT =                  2 //col:8832
IA32_PACKAGE_THERM_STATUS_PROCHOT_EVENT_FLAG =                 0x04 //col:8833
IA32_PACKAGE_THERM_STATUS_PROCHOT_EVENT_MASK =                 0x01 //col:8834
IA32_PACKAGE_THERM_STATUS_PROCHOT_EVENT(_) =                   (((_) >> 2) & 0x01) //col:8835
IA32_PACKAGE_THERM_STATUS_PROCHOT_LOG_BIT =                    3 //col:8841
IA32_PACKAGE_THERM_STATUS_PROCHOT_LOG_FLAG =                   0x08 //col:8842
IA32_PACKAGE_THERM_STATUS_PROCHOT_LOG_MASK =                   0x01 //col:8843
IA32_PACKAGE_THERM_STATUS_PROCHOT_LOG(_) =                     (((_) >> 3) & 0x01) //col:8844
IA32_PACKAGE_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_BIT =    4 //col:8850
IA32_PACKAGE_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_FLAG =   0x10 //col:8851
IA32_PACKAGE_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_MASK =   0x01 //col:8852
IA32_PACKAGE_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS(_) =     (((_) >> 4) & 0x01) //col:8853
IA32_PACKAGE_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_LOG_BIT = 5 //col:8859
IA32_PACKAGE_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_LOG_FLAG = 0x20 //col:8860
IA32_PACKAGE_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_LOG_MASK = 0x01 //col:8861
IA32_PACKAGE_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_LOG(_) = (((_) >> 5) & 0x01) //col:8862
IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD1_STATUS_BIT =      6 //col:8868
IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD1_STATUS_FLAG =     0x40 //col:8869
IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD1_STATUS_MASK =     0x01 //col:8870
IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD1_STATUS(_) =       (((_) >> 6) & 0x01) //col:8871
IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD1_LOG_BIT =         7 //col:8877
IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD1_LOG_FLAG =        0x80 //col:8878
IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD1_LOG_MASK =        0x01 //col:8879
IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD1_LOG(_) =          (((_) >> 7) & 0x01) //col:8880
IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD2_STATUS_BIT =      8 //col:8886
IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD2_STATUS_FLAG =     0x100 //col:8887
IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD2_STATUS_MASK =     0x01 //col:8888
IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD2_STATUS(_) =       (((_) >> 8) & 0x01) //col:8889
IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD2_LOG_BIT =         9 //col:8895
IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD2_LOG_FLAG =        0x200 //col:8896
IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD2_LOG_MASK =        0x01 //col:8897
IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD2_LOG(_) =          (((_) >> 9) & 0x01) //col:8898
IA32_PACKAGE_THERM_STATUS_POWER_LIMITATION_STATUS_BIT =        10 //col:8904
IA32_PACKAGE_THERM_STATUS_POWER_LIMITATION_STATUS_FLAG =       0x400 //col:8905
IA32_PACKAGE_THERM_STATUS_POWER_LIMITATION_STATUS_MASK =       0x01 //col:8906
IA32_PACKAGE_THERM_STATUS_POWER_LIMITATION_STATUS(_) =         (((_) >> 10) & 0x01) //col:8907
IA32_PACKAGE_THERM_STATUS_POWER_LIMITATION_LOG_BIT =           11 //col:8913
IA32_PACKAGE_THERM_STATUS_POWER_LIMITATION_LOG_FLAG =          0x800 //col:8914
IA32_PACKAGE_THERM_STATUS_POWER_LIMITATION_LOG_MASK =          0x01 //col:8915
IA32_PACKAGE_THERM_STATUS_POWER_LIMITATION_LOG(_) =            (((_) >> 11) & 0x01) //col:8916
IA32_PACKAGE_THERM_STATUS_DIGITAL_READOUT_BIT =                16 //col:8923
IA32_PACKAGE_THERM_STATUS_DIGITAL_READOUT_FLAG =               0x7F0000 //col:8924
IA32_PACKAGE_THERM_STATUS_DIGITAL_READOUT_MASK =               0x7F //col:8925
IA32_PACKAGE_THERM_STATUS_DIGITAL_READOUT(_) =                 (((_) >> 16) & 0x7F) //col:8926
IA32_PACKAGE_THERM_INTERRUPT =                                 0x000001B2 //col:8943
IA32_PACKAGE_THERM_INTERRUPT_HIGH_TEMPERATURE_INTERRUPT_ENABLE_BIT = 0 //col:8952
IA32_PACKAGE_THERM_INTERRUPT_HIGH_TEMPERATURE_INTERRUPT_ENABLE_FLAG = 0x01 //col:8953
IA32_PACKAGE_THERM_INTERRUPT_HIGH_TEMPERATURE_INTERRUPT_ENABLE_MASK = 0x01 //col:8954
IA32_PACKAGE_THERM_INTERRUPT_HIGH_TEMPERATURE_INTERRUPT_ENABLE(_) = (((_) >> 0) & 0x01) //col:8955
IA32_PACKAGE_THERM_INTERRUPT_LOW_TEMPERATURE_INTERRUPT_ENABLE_BIT = 1 //col:8961
IA32_PACKAGE_THERM_INTERRUPT_LOW_TEMPERATURE_INTERRUPT_ENABLE_FLAG = 0x02 //col:8962
IA32_PACKAGE_THERM_INTERRUPT_LOW_TEMPERATURE_INTERRUPT_ENABLE_MASK = 0x01 //col:8963
IA32_PACKAGE_THERM_INTERRUPT_LOW_TEMPERATURE_INTERRUPT_ENABLE(_) = (((_) >> 1) & 0x01) //col:8964
IA32_PACKAGE_THERM_INTERRUPT_PROCHOT_INTERRUPT_ENABLE_BIT =    2 //col:8970
IA32_PACKAGE_THERM_INTERRUPT_PROCHOT_INTERRUPT_ENABLE_FLAG =   0x04 //col:8971
IA32_PACKAGE_THERM_INTERRUPT_PROCHOT_INTERRUPT_ENABLE_MASK =   0x01 //col:8972
IA32_PACKAGE_THERM_INTERRUPT_PROCHOT_INTERRUPT_ENABLE(_) =     (((_) >> 2) & 0x01) //col:8973
IA32_PACKAGE_THERM_INTERRUPT_OVERHEAT_INTERRUPT_ENABLE_BIT =   4 //col:8980
IA32_PACKAGE_THERM_INTERRUPT_OVERHEAT_INTERRUPT_ENABLE_FLAG =  0x10 //col:8981
IA32_PACKAGE_THERM_INTERRUPT_OVERHEAT_INTERRUPT_ENABLE_MASK =  0x01 //col:8982
IA32_PACKAGE_THERM_INTERRUPT_OVERHEAT_INTERRUPT_ENABLE(_) =    (((_) >> 4) & 0x01) //col:8983
IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD1_VALUE_BIT =            8 //col:8990
IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD1_VALUE_FLAG =           0x7F00 //col:8991
IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD1_VALUE_MASK =           0x7F //col:8992
IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD1_VALUE(_) =             (((_) >> 8) & 0x7F) //col:8993
IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD1_INTERRUPT_ENABLE_BIT = 15 //col:8999
IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD1_INTERRUPT_ENABLE_FLAG = 0x8000 //col:9000
IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD1_INTERRUPT_ENABLE_MASK = 0x01 //col:9001
IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD1_INTERRUPT_ENABLE(_) =  (((_) >> 15) & 0x01) //col:9002
IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD2_VALUE_BIT =            16 //col:9008
IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD2_VALUE_FLAG =           0x7F0000 //col:9009
IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD2_VALUE_MASK =           0x7F //col:9010
IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD2_VALUE(_) =             (((_) >> 16) & 0x7F) //col:9011
IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD2_INTERRUPT_ENABLE_BIT = 23 //col:9017
IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD2_INTERRUPT_ENABLE_FLAG = 0x800000 //col:9018
IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD2_INTERRUPT_ENABLE_MASK = 0x01 //col:9019
IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD2_INTERRUPT_ENABLE(_) =  (((_) >> 23) & 0x01) //col:9020
IA32_PACKAGE_THERM_INTERRUPT_POWER_LIMIT_NOTIFICATION_ENABLE_BIT = 24 //col:9026
IA32_PACKAGE_THERM_INTERRUPT_POWER_LIMIT_NOTIFICATION_ENABLE_FLAG = 0x1000000 //col:9027
IA32_PACKAGE_THERM_INTERRUPT_POWER_LIMIT_NOTIFICATION_ENABLE_MASK = 0x01 //col:9028
IA32_PACKAGE_THERM_INTERRUPT_POWER_LIMIT_NOTIFICATION_ENABLE(_) = (((_) >> 24) & 0x01) //col:9029
IA32_DEBUGCTL =                                                0x000001D9 //col:9042
IA32_DEBUGCTL_LBR_BIT =                                        0 //col:9054
IA32_DEBUGCTL_LBR_FLAG =                                       0x01 //col:9055
IA32_DEBUGCTL_LBR_MASK =                                       0x01 //col:9056
IA32_DEBUGCTL_LBR(_) =                                         (((_) >> 0) & 0x01) //col:9057
IA32_DEBUGCTL_BTF_BIT =                                        1 //col:9066
IA32_DEBUGCTL_BTF_FLAG =                                       0x02 //col:9067
IA32_DEBUGCTL_BTF_MASK =                                       0x01 //col:9068
IA32_DEBUGCTL_BTF(_) =                                         (((_) >> 1) & 0x01) //col:9069
IA32_DEBUGCTL_TR_BIT =                                         6 //col:9078
IA32_DEBUGCTL_TR_FLAG =                                        0x40 //col:9079
IA32_DEBUGCTL_TR_MASK =                                        0x01 //col:9080
IA32_DEBUGCTL_TR(_) =                                          (((_) >> 6) & 0x01) //col:9081
IA32_DEBUGCTL_BTS_BIT =                                        7 //col:9089
IA32_DEBUGCTL_BTS_FLAG =                                       0x80 //col:9090
IA32_DEBUGCTL_BTS_MASK =                                       0x01 //col:9091
IA32_DEBUGCTL_BTS(_) =                                         (((_) >> 7) & 0x01) //col:9092
IA32_DEBUGCTL_BTINT_BIT =                                      8 //col:9101
IA32_DEBUGCTL_BTINT_FLAG =                                     0x100 //col:9102
IA32_DEBUGCTL_BTINT_MASK =                                     0x01 //col:9103
IA32_DEBUGCTL_BTINT(_) =                                       (((_) >> 8) & 0x01) //col:9104
IA32_DEBUGCTL_BTS_OFF_OS_BIT =                                 9 //col:9112
IA32_DEBUGCTL_BTS_OFF_OS_FLAG =                                0x200 //col:9113
IA32_DEBUGCTL_BTS_OFF_OS_MASK =                                0x01 //col:9114
IA32_DEBUGCTL_BTS_OFF_OS(_) =                                  (((_) >> 9) & 0x01) //col:9115
IA32_DEBUGCTL_BTS_OFF_USR_BIT =                                10 //col:9123
IA32_DEBUGCTL_BTS_OFF_USR_FLAG =                               0x400 //col:9124
IA32_DEBUGCTL_BTS_OFF_USR_MASK =                               0x01 //col:9125
IA32_DEBUGCTL_BTS_OFF_USR(_) =                                 (((_) >> 10) & 0x01) //col:9126
IA32_DEBUGCTL_FREEZE_LBRS_ON_PMI_BIT =                         11 //col:9134
IA32_DEBUGCTL_FREEZE_LBRS_ON_PMI_FLAG =                        0x800 //col:9135
IA32_DEBUGCTL_FREEZE_LBRS_ON_PMI_MASK =                        0x01 //col:9136
IA32_DEBUGCTL_FREEZE_LBRS_ON_PMI(_) =                          (((_) >> 11) & 0x01) //col:9137
IA32_DEBUGCTL_FREEZE_PERFMON_ON_PMI_BIT =                      12 //col:9145
IA32_DEBUGCTL_FREEZE_PERFMON_ON_PMI_FLAG =                     0x1000 //col:9146
IA32_DEBUGCTL_FREEZE_PERFMON_ON_PMI_MASK =                     0x01 //col:9147
IA32_DEBUGCTL_FREEZE_PERFMON_ON_PMI(_) =                       (((_) >> 12) & 0x01) //col:9148
IA32_DEBUGCTL_ENABLE_UNCORE_PMI_BIT =                          13 //col:9156
IA32_DEBUGCTL_ENABLE_UNCORE_PMI_FLAG =                         0x2000 //col:9157
IA32_DEBUGCTL_ENABLE_UNCORE_PMI_MASK =                         0x01 //col:9158
IA32_DEBUGCTL_ENABLE_UNCORE_PMI(_) =                           (((_) >> 13) & 0x01) //col:9159
IA32_DEBUGCTL_FREEZE_WHILE_SMM_BIT =                           14 //col:9167
IA32_DEBUGCTL_FREEZE_WHILE_SMM_FLAG =                          0x4000 //col:9168
IA32_DEBUGCTL_FREEZE_WHILE_SMM_MASK =                          0x01 //col:9169
IA32_DEBUGCTL_FREEZE_WHILE_SMM(_) =                            (((_) >> 14) & 0x01) //col:9170
IA32_DEBUGCTL_RTM_DEBUG_BIT =                                  15 //col:9178
IA32_DEBUGCTL_RTM_DEBUG_FLAG =                                 0x8000 //col:9179
IA32_DEBUGCTL_RTM_DEBUG_MASK =                                 0x01 //col:9180
IA32_DEBUGCTL_RTM_DEBUG(_) =                                   (((_) >> 15) & 0x01) //col:9181
IA32_SMRR_PHYSBASE =                                           0x000001F2 //col:9196
IA32_SMRR_PHYSBASE_TYPE_BIT =                                  0 //col:9207
IA32_SMRR_PHYSBASE_TYPE_FLAG =                                 0xFF //col:9208
IA32_SMRR_PHYSBASE_TYPE_MASK =                                 0xFF //col:9209
IA32_SMRR_PHYSBASE_TYPE(_) =                                   (((_) >> 0) & 0xFF) //col:9210
IA32_SMRR_PHYSBASE_SMRR_PHYSICAL_BASE_ADDRESS_BIT =            12 //col:9217
IA32_SMRR_PHYSBASE_SMRR_PHYSICAL_BASE_ADDRESS_FLAG =           0xFFFFF000 //col:9218
IA32_SMRR_PHYSBASE_SMRR_PHYSICAL_BASE_ADDRESS_MASK =           0xFFFFF //col:9219
IA32_SMRR_PHYSBASE_SMRR_PHYSICAL_BASE_ADDRESS(_) =             (((_) >> 12) & 0xFFFFF) //col:9220
IA32_SMRR_PHYSMASK =                                           0x000001F3 //col:9235
IA32_SMRR_PHYSMASK_ENABLE_RANGE_MASK_BIT =                     11 //col:9246
IA32_SMRR_PHYSMASK_ENABLE_RANGE_MASK_FLAG =                    0x800 //col:9247
IA32_SMRR_PHYSMASK_ENABLE_RANGE_MASK_MASK =                    0x01 //col:9248
IA32_SMRR_PHYSMASK_ENABLE_RANGE_MASK(_) =                      (((_) >> 11) & 0x01) //col:9249
IA32_SMRR_PHYSMASK_SMRR_ADDRESS_RANGE_MASK_BIT =               12 //col:9255
IA32_SMRR_PHYSMASK_SMRR_ADDRESS_RANGE_MASK_FLAG =              0xFFFFF000 //col:9256
IA32_SMRR_PHYSMASK_SMRR_ADDRESS_RANGE_MASK_MASK =              0xFFFFF //col:9257
IA32_SMRR_PHYSMASK_SMRR_ADDRESS_RANGE_MASK(_) =                (((_) >> 12) & 0xFFFFF) //col:9258
IA32_PLATFORM_DCA_CAP =                                        0x000001F8 //col:9271
IA32_CPU_DCA_CAP =                                             0x000001F9 //col:9278
IA32_DCA_0_CAP =                                               0x000001FA //col:9285
IA32_DCA_0_CAP_DCA_ACTIVE_BIT =                                0 //col:9294
IA32_DCA_0_CAP_DCA_ACTIVE_FLAG =                               0x01 //col:9295
IA32_DCA_0_CAP_DCA_ACTIVE_MASK =                               0x01 //col:9296
IA32_DCA_0_CAP_DCA_ACTIVE(_) =                                 (((_) >> 0) & 0x01) //col:9297
IA32_DCA_0_CAP_TRANSACTION_BIT =                               1 //col:9303
IA32_DCA_0_CAP_TRANSACTION_FLAG =                              0x06 //col:9304
IA32_DCA_0_CAP_TRANSACTION_MASK =                              0x03 //col:9305
IA32_DCA_0_CAP_TRANSACTION(_) =                                (((_) >> 1) & 0x03) //col:9306
IA32_DCA_0_CAP_DCA_TYPE_BIT =                                  3 //col:9312
IA32_DCA_0_CAP_DCA_TYPE_FLAG =                                 0x78 //col:9313
IA32_DCA_0_CAP_DCA_TYPE_MASK =                                 0x0F //col:9314
IA32_DCA_0_CAP_DCA_TYPE(_) =                                   (((_) >> 3) & 0x0F) //col:9315
IA32_DCA_0_CAP_DCA_QUEUE_SIZE_BIT =                            7 //col:9321
IA32_DCA_0_CAP_DCA_QUEUE_SIZE_FLAG =                           0x780 //col:9322
IA32_DCA_0_CAP_DCA_QUEUE_SIZE_MASK =                           0x0F //col:9323
IA32_DCA_0_CAP_DCA_QUEUE_SIZE(_) =                             (((_) >> 7) & 0x0F) //col:9324
IA32_DCA_0_CAP_DCA_DELAY_BIT =                                 13 //col:9331
IA32_DCA_0_CAP_DCA_DELAY_FLAG =                                0x1E000 //col:9332
IA32_DCA_0_CAP_DCA_DELAY_MASK =                                0x0F //col:9333
IA32_DCA_0_CAP_DCA_DELAY(_) =                                  (((_) >> 13) & 0x0F) //col:9334
IA32_DCA_0_CAP_SW_BLOCK_BIT =                                  24 //col:9341
IA32_DCA_0_CAP_SW_BLOCK_FLAG =                                 0x1000000 //col:9342
IA32_DCA_0_CAP_SW_BLOCK_MASK =                                 0x01 //col:9343
IA32_DCA_0_CAP_SW_BLOCK(_) =                                   (((_) >> 24) & 0x01) //col:9344
IA32_DCA_0_CAP_HW_BLOCK_BIT =                                  26 //col:9351
IA32_DCA_0_CAP_HW_BLOCK_FLAG =                                 0x4000000 //col:9352
IA32_DCA_0_CAP_HW_BLOCK_MASK =                                 0x01 //col:9353
IA32_DCA_0_CAP_HW_BLOCK(_) =                                   (((_) >> 26) & 0x01) //col:9354
IA32_MTRR_PHYSBASE_TYPE_BIT =                                  0 //col:9379
IA32_MTRR_PHYSBASE_TYPE_FLAG =                                 0xFF //col:9380
IA32_MTRR_PHYSBASE_TYPE_MASK =                                 0xFF //col:9381
IA32_MTRR_PHYSBASE_TYPE(_) =                                   (((_) >> 0) & 0xFF) //col:9382
IA32_MTRR_PHYSBASE_PAGE_FRAME_NUMBER_BIT =                     12 //col:9391
IA32_MTRR_PHYSBASE_PAGE_FRAME_NUMBER_FLAG =                    0xFFFFFFFFF000 //col:9392
IA32_MTRR_PHYSBASE_PAGE_FRAME_NUMBER_MASK =                    0xFFFFFFFFF //col:9393
IA32_MTRR_PHYSBASE_PAGE_FRAME_NUMBER(_) =                      (((_) >> 12) & 0xFFFFFFFFF) //col:9394
IA32_MTRR_PHYSBASE0 =                                          0x00000200 //col:9401
IA32_MTRR_PHYSBASE1 =                                          0x00000202 //col:9402
IA32_MTRR_PHYSBASE2 =                                          0x00000204 //col:9403
IA32_MTRR_PHYSBASE3 =                                          0x00000206 //col:9404
IA32_MTRR_PHYSBASE4 =                                          0x00000208 //col:9405
IA32_MTRR_PHYSBASE5 =                                          0x0000020A //col:9406
IA32_MTRR_PHYSBASE6 =                                          0x0000020C //col:9407
IA32_MTRR_PHYSBASE7 =                                          0x0000020E //col:9408
IA32_MTRR_PHYSBASE8 =                                          0x00000210 //col:9409
IA32_MTRR_PHYSBASE9 =                                          0x00000212 //col:9410
IA32_MTRR_PHYSMASK_VALID_BIT =                                 11 //col:9435
IA32_MTRR_PHYSMASK_VALID_FLAG =                                0x800 //col:9436
IA32_MTRR_PHYSMASK_VALID_MASK =                                0x01 //col:9437
IA32_MTRR_PHYSMASK_VALID(_) =                                  (((_) >> 11) & 0x01) //col:9438
IA32_MTRR_PHYSMASK_PAGE_FRAME_NUMBER_BIT =                     12 //col:9453
IA32_MTRR_PHYSMASK_PAGE_FRAME_NUMBER_FLAG =                    0xFFFFFFFFF000 //col:9454
IA32_MTRR_PHYSMASK_PAGE_FRAME_NUMBER_MASK =                    0xFFFFFFFFF //col:9455
IA32_MTRR_PHYSMASK_PAGE_FRAME_NUMBER(_) =                      (((_) >> 12) & 0xFFFFFFFFF) //col:9456
IA32_MTRR_PHYSMASK0 =                                          0x00000201 //col:9463
IA32_MTRR_PHYSMASK1 =                                          0x00000203 //col:9464
IA32_MTRR_PHYSMASK2 =                                          0x00000205 //col:9465
IA32_MTRR_PHYSMASK3 =                                          0x00000207 //col:9466
IA32_MTRR_PHYSMASK4 =                                          0x00000209 //col:9467
IA32_MTRR_PHYSMASK5 =                                          0x0000020B //col:9468
IA32_MTRR_PHYSMASK6 =                                          0x0000020D //col:9469
IA32_MTRR_PHYSMASK7 =                                          0x0000020F //col:9470
IA32_MTRR_PHYSMASK8 =                                          0x00000211 //col:9471
IA32_MTRR_PHYSMASK9 =                                          0x00000213 //col:9472
IA32_MTRR_FIX64K_BASE =                                        0x00000000 //col:9494
IA32_MTRR_FIX64K_SIZE =                                        0x00010000 //col:9495
IA32_MTRR_FIX64K_00000 =                                       0x00000250 //col:9496
IA32_MTRR_FIX16K_BASE =                                        0x00080000 //col:9508
IA32_MTRR_FIX16K_SIZE =                                        0x00004000 //col:9509
IA32_MTRR_FIX16K_80000 =                                       0x00000258 //col:9510
IA32_MTRR_FIX16K_A0000 =                                       0x00000259 //col:9511
IA32_MTRR_FIX4K_BASE =                                         0x000C0000 //col:9523
IA32_MTRR_FIX4K_SIZE =                                         0x00001000 //col:9524
IA32_MTRR_FIX4K_C0000 =                                        0x00000268 //col:9525
IA32_MTRR_FIX4K_C8000 =                                        0x00000269 //col:9526
IA32_MTRR_FIX4K_D0000 =                                        0x0000026A //col:9527
IA32_MTRR_FIX4K_D8000 =                                        0x0000026B //col:9528
IA32_MTRR_FIX4K_E0000 =                                        0x0000026C //col:9529
IA32_MTRR_FIX4K_E8000 =                                        0x0000026D //col:9530
IA32_MTRR_FIX4K_F0000 =                                        0x0000026E //col:9531
IA32_MTRR_FIX4K_F8000 =                                        0x0000026F //col:9532
IA32_MTRR_FIX_COUNT =                                          ((1 + 2 + 8) * 8) //col:9540
IA32_MTRR_VARIABLE_COUNT =                                     0x0000000A //col:9547
IA32_MTRR_COUNT =                                              (IA32_MTRR_FIX_COUNT + IA32_MTRR_VARIABLE_COUNT) //col:9552
IA32_PAT =                                                     0x00000277 //col:9563
IA32_PAT_PA0_BIT =                                             0 //col:9572
IA32_PAT_PA0_FLAG =                                            0x07 //col:9573
IA32_PAT_PA0_MASK =                                            0x07 //col:9574
IA32_PAT_PA0(_) =                                              (((_) >> 0) & 0x07) //col:9575
IA32_PAT_PA1_BIT =                                             8 //col:9582
IA32_PAT_PA1_FLAG =                                            0x700 //col:9583
IA32_PAT_PA1_MASK =                                            0x07 //col:9584
IA32_PAT_PA1(_) =                                              (((_) >> 8) & 0x07) //col:9585
IA32_PAT_PA2_BIT =                                             16 //col:9592
IA32_PAT_PA2_FLAG =                                            0x70000 //col:9593
IA32_PAT_PA2_MASK =                                            0x07 //col:9594
IA32_PAT_PA2(_) =                                              (((_) >> 16) & 0x07) //col:9595
IA32_PAT_PA3_BIT =                                             24 //col:9602
IA32_PAT_PA3_FLAG =                                            0x7000000 //col:9603
IA32_PAT_PA3_MASK =                                            0x07 //col:9604
IA32_PAT_PA3(_) =                                              (((_) >> 24) & 0x07) //col:9605
IA32_PAT_PA4_BIT =                                             32 //col:9612
IA32_PAT_PA4_FLAG =                                            0x700000000 //col:9613
IA32_PAT_PA4_MASK =                                            0x07 //col:9614
IA32_PAT_PA4(_) =                                              (((_) >> 32) & 0x07) //col:9615
IA32_PAT_PA5_BIT =                                             40 //col:9622
IA32_PAT_PA5_FLAG =                                            0x70000000000 //col:9623
IA32_PAT_PA5_MASK =                                            0x07 //col:9624
IA32_PAT_PA5(_) =                                              (((_) >> 40) & 0x07) //col:9625
IA32_PAT_PA6_BIT =                                             48 //col:9632
IA32_PAT_PA6_FLAG =                                            0x7000000000000 //col:9633
IA32_PAT_PA6_MASK =                                            0x07 //col:9634
IA32_PAT_PA6(_) =                                              (((_) >> 48) & 0x07) //col:9635
IA32_PAT_PA7_BIT =                                             56 //col:9642
IA32_PAT_PA7_FLAG =                                            0x700000000000000 //col:9643
IA32_PAT_PA7_MASK =                                            0x07 //col:9644
IA32_PAT_PA7(_) =                                              (((_) >> 56) & 0x07) //col:9645
IA32_MC0_CTL2 =                                                0x00000280 //col:9662
IA32_MC1_CTL2 =                                                0x00000281 //col:9663
IA32_MC2_CTL2 =                                                0x00000282 //col:9664
IA32_MC3_CTL2 =                                                0x00000283 //col:9665
IA32_MC4_CTL2 =                                                0x00000284 //col:9666
IA32_MC5_CTL2 =                                                0x00000285 //col:9667
IA32_MC6_CTL2 =                                                0x00000286 //col:9668
IA32_MC7_CTL2 =                                                0x00000287 //col:9669
IA32_MC8_CTL2 =                                                0x00000288 //col:9670
IA32_MC9_CTL2 =                                                0x00000289 //col:9671
IA32_MC10_CTL2 =                                               0x0000028A //col:9672
IA32_MC11_CTL2 =                                               0x0000028B //col:9673
IA32_MC12_CTL2 =                                               0x0000028C //col:9674
IA32_MC13_CTL2 =                                               0x0000028D //col:9675
IA32_MC14_CTL2 =                                               0x0000028E //col:9676
IA32_MC15_CTL2 =                                               0x0000028F //col:9677
IA32_MC16_CTL2 =                                               0x00000290 //col:9678
IA32_MC17_CTL2 =                                               0x00000291 //col:9679
IA32_MC18_CTL2 =                                               0x00000292 //col:9680
IA32_MC19_CTL2 =                                               0x00000293 //col:9681
IA32_MC20_CTL2 =                                               0x00000294 //col:9682
IA32_MC21_CTL2 =                                               0x00000295 //col:9683
IA32_MC22_CTL2 =                                               0x00000296 //col:9684
IA32_MC23_CTL2 =                                               0x00000297 //col:9685
IA32_MC24_CTL2 =                                               0x00000298 //col:9686
IA32_MC25_CTL2 =                                               0x00000299 //col:9687
IA32_MC26_CTL2 =                                               0x0000029A //col:9688
IA32_MC27_CTL2 =                                               0x0000029B //col:9689
IA32_MC28_CTL2 =                                               0x0000029C //col:9690
IA32_MC29_CTL2 =                                               0x0000029D //col:9691
IA32_MC30_CTL2 =                                               0x0000029E //col:9692
IA32_MC31_CTL2 =                                               0x0000029F //col:9693
IA32_MC_CTL2_CORRECTED_ERROR_COUNT_THRESHOLD_BIT =             0 //col:9702
IA32_MC_CTL2_CORRECTED_ERROR_COUNT_THRESHOLD_FLAG =            0x7FFF //col:9703
IA32_MC_CTL2_CORRECTED_ERROR_COUNT_THRESHOLD_MASK =            0x7FFF //col:9704
IA32_MC_CTL2_CORRECTED_ERROR_COUNT_THRESHOLD(_) =              (((_) >> 0) & 0x7FFF) //col:9705
IA32_MC_CTL2_CMCI_EN_BIT =                                     30 //col:9712
IA32_MC_CTL2_CMCI_EN_FLAG =                                    0x40000000 //col:9713
IA32_MC_CTL2_CMCI_EN_MASK =                                    0x01 //col:9714
IA32_MC_CTL2_CMCI_EN(_) =                                      (((_) >> 30) & 0x01) //col:9715
IA32_MTRR_DEF_TYPE =                                           0x000002FF //col:9732
IA32_MTRR_DEF_TYPE_DEFAULT_MEMORY_TYPE_BIT =                   0 //col:9741
IA32_MTRR_DEF_TYPE_DEFAULT_MEMORY_TYPE_FLAG =                  0x07 //col:9742
IA32_MTRR_DEF_TYPE_DEFAULT_MEMORY_TYPE_MASK =                  0x07 //col:9743
IA32_MTRR_DEF_TYPE_DEFAULT_MEMORY_TYPE(_) =                    (((_) >> 0) & 0x07) //col:9744
IA32_MTRR_DEF_TYPE_FIXED_RANGE_MTRR_ENABLE_BIT =               10 //col:9751
IA32_MTRR_DEF_TYPE_FIXED_RANGE_MTRR_ENABLE_FLAG =              0x400 //col:9752
IA32_MTRR_DEF_TYPE_FIXED_RANGE_MTRR_ENABLE_MASK =              0x01 //col:9753
IA32_MTRR_DEF_TYPE_FIXED_RANGE_MTRR_ENABLE(_) =                (((_) >> 10) & 0x01) //col:9754
IA32_MTRR_DEF_TYPE_MTRR_ENABLE_BIT =                           11 //col:9760
IA32_MTRR_DEF_TYPE_MTRR_ENABLE_FLAG =                          0x800 //col:9761
IA32_MTRR_DEF_TYPE_MTRR_ENABLE_MASK =                          0x01 //col:9762
IA32_MTRR_DEF_TYPE_MTRR_ENABLE(_) =                            (((_) >> 11) & 0x01) //col:9763
IA32_FIXED_CTR0 =                                              0x00000309 //col:9782
IA32_FIXED_CTR1 =                                              0x0000030A //col:9787
IA32_FIXED_CTR2 =                                              0x0000030B //col:9792
IA32_PERF_CAPABILITIES =                                       0x00000345 //col:9803
IA32_PERF_CAPABILITIES_LBR_FORMAT_BIT =                        0 //col:9812
IA32_PERF_CAPABILITIES_LBR_FORMAT_FLAG =                       0x3F //col:9813
IA32_PERF_CAPABILITIES_LBR_FORMAT_MASK =                       0x3F //col:9814
IA32_PERF_CAPABILITIES_LBR_FORMAT(_) =                         (((_) >> 0) & 0x3F) //col:9815
IA32_PERF_CAPABILITIES_PEBS_TRAP_BIT =                         6 //col:9821
IA32_PERF_CAPABILITIES_PEBS_TRAP_FLAG =                        0x40 //col:9822
IA32_PERF_CAPABILITIES_PEBS_TRAP_MASK =                        0x01 //col:9823
IA32_PERF_CAPABILITIES_PEBS_TRAP(_) =                          (((_) >> 6) & 0x01) //col:9824
IA32_PERF_CAPABILITIES_PEBS_SAVE_ARCH_REGS_BIT =               7 //col:9830
IA32_PERF_CAPABILITIES_PEBS_SAVE_ARCH_REGS_FLAG =              0x80 //col:9831
IA32_PERF_CAPABILITIES_PEBS_SAVE_ARCH_REGS_MASK =              0x01 //col:9832
IA32_PERF_CAPABILITIES_PEBS_SAVE_ARCH_REGS(_) =                (((_) >> 7) & 0x01) //col:9833
IA32_PERF_CAPABILITIES_PEBS_RECORD_FORMAT_BIT =                8 //col:9839
IA32_PERF_CAPABILITIES_PEBS_RECORD_FORMAT_FLAG =               0xF00 //col:9840
IA32_PERF_CAPABILITIES_PEBS_RECORD_FORMAT_MASK =               0x0F //col:9841
IA32_PERF_CAPABILITIES_PEBS_RECORD_FORMAT(_) =                 (((_) >> 8) & 0x0F) //col:9842
IA32_PERF_CAPABILITIES_FREEZE_WHILE_SMM_IS_SUPPORTED_BIT =     12 //col:9848
IA32_PERF_CAPABILITIES_FREEZE_WHILE_SMM_IS_SUPPORTED_FLAG =    0x1000 //col:9849
IA32_PERF_CAPABILITIES_FREEZE_WHILE_SMM_IS_SUPPORTED_MASK =    0x01 //col:9850
IA32_PERF_CAPABILITIES_FREEZE_WHILE_SMM_IS_SUPPORTED(_) =      (((_) >> 12) & 0x01) //col:9851
IA32_PERF_CAPABILITIES_FULL_WIDTH_COUNTER_WRITE_BIT =          13 //col:9857
IA32_PERF_CAPABILITIES_FULL_WIDTH_COUNTER_WRITE_FLAG =         0x2000 //col:9858
IA32_PERF_CAPABILITIES_FULL_WIDTH_COUNTER_WRITE_MASK =         0x01 //col:9859
IA32_PERF_CAPABILITIES_FULL_WIDTH_COUNTER_WRITE(_) =           (((_) >> 13) & 0x01) //col:9860
IA32_FIXED_CTR_CTRL =                                          0x0000038D //col:9876
IA32_FIXED_CTR_CTRL_EN0_OS_BIT =                               0 //col:9885
IA32_FIXED_CTR_CTRL_EN0_OS_FLAG =                              0x01 //col:9886
IA32_FIXED_CTR_CTRL_EN0_OS_MASK =                              0x01 //col:9887
IA32_FIXED_CTR_CTRL_EN0_OS(_) =                                (((_) >> 0) & 0x01) //col:9888
IA32_FIXED_CTR_CTRL_EN0_USR_BIT =                              1 //col:9894
IA32_FIXED_CTR_CTRL_EN0_USR_FLAG =                             0x02 //col:9895
IA32_FIXED_CTR_CTRL_EN0_USR_MASK =                             0x01 //col:9896
IA32_FIXED_CTR_CTRL_EN0_USR(_) =                               (((_) >> 1) & 0x01) //col:9897
IA32_FIXED_CTR_CTRL_ANY_THREAD0_BIT =                          2 //col:9905
IA32_FIXED_CTR_CTRL_ANY_THREAD0_FLAG =                         0x04 //col:9906
IA32_FIXED_CTR_CTRL_ANY_THREAD0_MASK =                         0x01 //col:9907
IA32_FIXED_CTR_CTRL_ANY_THREAD0(_) =                           (((_) >> 2) & 0x01) //col:9908
IA32_FIXED_CTR_CTRL_EN0_PMI_BIT =                              3 //col:9914
IA32_FIXED_CTR_CTRL_EN0_PMI_FLAG =                             0x08 //col:9915
IA32_FIXED_CTR_CTRL_EN0_PMI_MASK =                             0x01 //col:9916
IA32_FIXED_CTR_CTRL_EN0_PMI(_) =                               (((_) >> 3) & 0x01) //col:9917
IA32_FIXED_CTR_CTRL_EN1_OS_BIT =                               4 //col:9923
IA32_FIXED_CTR_CTRL_EN1_OS_FLAG =                              0x10 //col:9924
IA32_FIXED_CTR_CTRL_EN1_OS_MASK =                              0x01 //col:9925
IA32_FIXED_CTR_CTRL_EN1_OS(_) =                                (((_) >> 4) & 0x01) //col:9926
IA32_FIXED_CTR_CTRL_EN1_USR_BIT =                              5 //col:9932
IA32_FIXED_CTR_CTRL_EN1_USR_FLAG =                             0x20 //col:9933
IA32_FIXED_CTR_CTRL_EN1_USR_MASK =                             0x01 //col:9934
IA32_FIXED_CTR_CTRL_EN1_USR(_) =                               (((_) >> 5) & 0x01) //col:9935
IA32_FIXED_CTR_CTRL_ANY_THREAD1_BIT =                          6 //col:9945
IA32_FIXED_CTR_CTRL_ANY_THREAD1_FLAG =                         0x40 //col:9946
IA32_FIXED_CTR_CTRL_ANY_THREAD1_MASK =                         0x01 //col:9947
IA32_FIXED_CTR_CTRL_ANY_THREAD1(_) =                           (((_) >> 6) & 0x01) //col:9948
IA32_FIXED_CTR_CTRL_EN1_PMI_BIT =                              7 //col:9954
IA32_FIXED_CTR_CTRL_EN1_PMI_FLAG =                             0x80 //col:9955
IA32_FIXED_CTR_CTRL_EN1_PMI_MASK =                             0x01 //col:9956
IA32_FIXED_CTR_CTRL_EN1_PMI(_) =                               (((_) >> 7) & 0x01) //col:9957
IA32_FIXED_CTR_CTRL_EN2_OS_BIT =                               8 //col:9963
IA32_FIXED_CTR_CTRL_EN2_OS_FLAG =                              0x100 //col:9964
IA32_FIXED_CTR_CTRL_EN2_OS_MASK =                              0x01 //col:9965
IA32_FIXED_CTR_CTRL_EN2_OS(_) =                                (((_) >> 8) & 0x01) //col:9966
IA32_FIXED_CTR_CTRL_EN2_USR_BIT =                              9 //col:9972
IA32_FIXED_CTR_CTRL_EN2_USR_FLAG =                             0x200 //col:9973
IA32_FIXED_CTR_CTRL_EN2_USR_MASK =                             0x01 //col:9974
IA32_FIXED_CTR_CTRL_EN2_USR(_) =                               (((_) >> 9) & 0x01) //col:9975
IA32_FIXED_CTR_CTRL_ANY_THREAD2_BIT =                          10 //col:9985
IA32_FIXED_CTR_CTRL_ANY_THREAD2_FLAG =                         0x400 //col:9986
IA32_FIXED_CTR_CTRL_ANY_THREAD2_MASK =                         0x01 //col:9987
IA32_FIXED_CTR_CTRL_ANY_THREAD2(_) =                           (((_) >> 10) & 0x01) //col:9988
IA32_FIXED_CTR_CTRL_EN2_PMI_BIT =                              11 //col:9994
IA32_FIXED_CTR_CTRL_EN2_PMI_FLAG =                             0x800 //col:9995
IA32_FIXED_CTR_CTRL_EN2_PMI_MASK =                             0x01 //col:9996
IA32_FIXED_CTR_CTRL_EN2_PMI(_) =                               (((_) >> 11) & 0x01) //col:9997
IA32_PERF_GLOBAL_STATUS =                                      0x0000038E //col:10010
IA32_PERF_GLOBAL_STATUS_OVF_PMC0_BIT =                         0 //col:10021
IA32_PERF_GLOBAL_STATUS_OVF_PMC0_FLAG =                        0x01 //col:10022
IA32_PERF_GLOBAL_STATUS_OVF_PMC0_MASK =                        0x01 //col:10023
IA32_PERF_GLOBAL_STATUS_OVF_PMC0(_) =                          (((_) >> 0) & 0x01) //col:10024
IA32_PERF_GLOBAL_STATUS_OVF_PMC1_BIT =                         1 //col:10032
IA32_PERF_GLOBAL_STATUS_OVF_PMC1_FLAG =                        0x02 //col:10033
IA32_PERF_GLOBAL_STATUS_OVF_PMC1_MASK =                        0x01 //col:10034
IA32_PERF_GLOBAL_STATUS_OVF_PMC1(_) =                          (((_) >> 1) & 0x01) //col:10035
IA32_PERF_GLOBAL_STATUS_OVF_PMC2_BIT =                         2 //col:10043
IA32_PERF_GLOBAL_STATUS_OVF_PMC2_FLAG =                        0x04 //col:10044
IA32_PERF_GLOBAL_STATUS_OVF_PMC2_MASK =                        0x01 //col:10045
IA32_PERF_GLOBAL_STATUS_OVF_PMC2(_) =                          (((_) >> 2) & 0x01) //col:10046
IA32_PERF_GLOBAL_STATUS_OVF_PMC3_BIT =                         3 //col:10054
IA32_PERF_GLOBAL_STATUS_OVF_PMC3_FLAG =                        0x08 //col:10055
IA32_PERF_GLOBAL_STATUS_OVF_PMC3_MASK =                        0x01 //col:10056
IA32_PERF_GLOBAL_STATUS_OVF_PMC3(_) =                          (((_) >> 3) & 0x01) //col:10057
IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR0_BIT =                    32 //col:10066
IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR0_FLAG =                   0x100000000 //col:10067
IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR0_MASK =                   0x01 //col:10068
IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR0(_) =                     (((_) >> 32) & 0x01) //col:10069
IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR1_BIT =                    33 //col:10077
IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR1_FLAG =                   0x200000000 //col:10078
IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR1_MASK =                   0x01 //col:10079
IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR1(_) =                     (((_) >> 33) & 0x01) //col:10080
IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR2_BIT =                    34 //col:10088
IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR2_FLAG =                   0x400000000 //col:10089
IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR2_MASK =                   0x01 //col:10090
IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR2(_) =                     (((_) >> 34) & 0x01) //col:10091
IA32_PERF_GLOBAL_STATUS_TRACE_TOPA_PMI_BIT =                   55 //col:10100
IA32_PERF_GLOBAL_STATUS_TRACE_TOPA_PMI_FLAG =                  0x80000000000000 //col:10101
IA32_PERF_GLOBAL_STATUS_TRACE_TOPA_PMI_MASK =                  0x01 //col:10102
IA32_PERF_GLOBAL_STATUS_TRACE_TOPA_PMI(_) =                    (((_) >> 55) & 0x01) //col:10103
IA32_PERF_GLOBAL_STATUS_LBR_FRZ_BIT =                          58 //col:10114
IA32_PERF_GLOBAL_STATUS_LBR_FRZ_FLAG =                         0x400000000000000 //col:10115
IA32_PERF_GLOBAL_STATUS_LBR_FRZ_MASK =                         0x01 //col:10116
IA32_PERF_GLOBAL_STATUS_LBR_FRZ(_) =                           (((_) >> 58) & 0x01) //col:10117
IA32_PERF_GLOBAL_STATUS_CTR_FRZ_BIT =                          59 //col:10127
IA32_PERF_GLOBAL_STATUS_CTR_FRZ_FLAG =                         0x800000000000000 //col:10128
IA32_PERF_GLOBAL_STATUS_CTR_FRZ_MASK =                         0x01 //col:10129
IA32_PERF_GLOBAL_STATUS_CTR_FRZ(_) =                           (((_) >> 59) & 0x01) //col:10130
IA32_PERF_GLOBAL_STATUS_ASCI_BIT =                             60 //col:10139
IA32_PERF_GLOBAL_STATUS_ASCI_FLAG =                            0x1000000000000000 //col:10140
IA32_PERF_GLOBAL_STATUS_ASCI_MASK =                            0x01 //col:10141
IA32_PERF_GLOBAL_STATUS_ASCI(_) =                              (((_) >> 60) & 0x01) //col:10142
IA32_PERF_GLOBAL_STATUS_OVF_UNCORE_BIT =                       61 //col:10150
IA32_PERF_GLOBAL_STATUS_OVF_UNCORE_FLAG =                      0x2000000000000000 //col:10151
IA32_PERF_GLOBAL_STATUS_OVF_UNCORE_MASK =                      0x01 //col:10152
IA32_PERF_GLOBAL_STATUS_OVF_UNCORE(_) =                        (((_) >> 61) & 0x01) //col:10153
IA32_PERF_GLOBAL_STATUS_OVF_BUF_BIT =                          62 //col:10161
IA32_PERF_GLOBAL_STATUS_OVF_BUF_FLAG =                         0x4000000000000000 //col:10162
IA32_PERF_GLOBAL_STATUS_OVF_BUF_MASK =                         0x01 //col:10163
IA32_PERF_GLOBAL_STATUS_OVF_BUF(_) =                           (((_) >> 62) & 0x01) //col:10164
IA32_PERF_GLOBAL_STATUS_COND_CHGD_BIT =                        63 //col:10172
IA32_PERF_GLOBAL_STATUS_COND_CHGD_FLAG =                       0x8000000000000000 //col:10173
IA32_PERF_GLOBAL_STATUS_COND_CHGD_MASK =                       0x01 //col:10174
IA32_PERF_GLOBAL_STATUS_COND_CHGD(_) =                         (((_) >> 63) & 0x01) //col:10175
IA32_PERF_GLOBAL_CTRL =                                        0x0000038F //col:10190
IA32_PERF_GLOBAL_CTRL_EN_PMCN_BIT =                            0 //col:10201
IA32_PERF_GLOBAL_CTRL_EN_PMCN_FLAG =                           0xFFFFFFFF //col:10202
IA32_PERF_GLOBAL_CTRL_EN_PMCN_MASK =                           0xFFFFFFFF //col:10203
IA32_PERF_GLOBAL_CTRL_EN_PMCN(_) =                             (((_) >> 0) & 0xFFFFFFFF) //col:10204
IA32_PERF_GLOBAL_CTRL_EN_FIXED_CTRN_BIT =                      32 //col:10212
IA32_PERF_GLOBAL_CTRL_EN_FIXED_CTRN_FLAG =                     0xFFFFFFFF00000000 //col:10213
IA32_PERF_GLOBAL_CTRL_EN_FIXED_CTRN_MASK =                     0xFFFFFFFF //col:10214
IA32_PERF_GLOBAL_CTRL_EN_FIXED_CTRN(_) =                       (((_) >> 32) & 0xFFFFFFFF) //col:10215
IA32_PERF_GLOBAL_STATUS_RESET =                                0x00000390 //col:10227
IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_PMCN_BIT =             0 //col:10238
IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_PMCN_FLAG =            0xFFFFFFFF //col:10239
IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_PMCN_MASK =            0xFFFFFFFF //col:10240
IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_PMCN(_) =              (((_) >> 0) & 0xFFFFFFFF) //col:10241
IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_FIXED_CTRN_BIT =       32 //col:10250
IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_FIXED_CTRN_FLAG =      0x700000000 //col:10251
IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_FIXED_CTRN_MASK =      0x07 //col:10252
IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_FIXED_CTRN(_) =        (((_) >> 32) & 0x07) //col:10253
IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_TRACE_TOPA_PMI_BIT =       55 //col:10262
IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_TRACE_TOPA_PMI_FLAG =      0x80000000000000 //col:10263
IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_TRACE_TOPA_PMI_MASK =      0x01 //col:10264
IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_TRACE_TOPA_PMI(_) =        (((_) >> 55) & 0x01) //col:10265
IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_LBR_FRZ_BIT =              58 //col:10274
IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_LBR_FRZ_FLAG =             0x400000000000000 //col:10275
IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_LBR_FRZ_MASK =             0x01 //col:10276
IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_LBR_FRZ(_) =               (((_) >> 58) & 0x01) //col:10277
IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_CTR_FRZ_BIT =              59 //col:10285
IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_CTR_FRZ_FLAG =             0x800000000000000 //col:10286
IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_CTR_FRZ_MASK =             0x01 //col:10287
IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_CTR_FRZ(_) =               (((_) >> 59) & 0x01) //col:10288
IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_ASCI_BIT =                 60 //col:10296
IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_ASCI_FLAG =                0x1000000000000000 //col:10297
IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_ASCI_MASK =                0x01 //col:10298
IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_ASCI(_) =                  (((_) >> 60) & 0x01) //col:10299
IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_UNCORE_BIT =           61 //col:10307
IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_UNCORE_FLAG =          0x2000000000000000 //col:10308
IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_UNCORE_MASK =          0x01 //col:10309
IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_UNCORE(_) =            (((_) >> 61) & 0x01) //col:10310
IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_BUF_BIT =              62 //col:10318
IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_BUF_FLAG =             0x4000000000000000 //col:10319
IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_BUF_MASK =             0x01 //col:10320
IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_BUF(_) =               (((_) >> 62) & 0x01) //col:10321
IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_COND_CHGD_BIT =            63 //col:10329
IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_COND_CHGD_FLAG =           0x8000000000000000 //col:10330
IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_COND_CHGD_MASK =           0x01 //col:10331
IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_COND_CHGD(_) =             (((_) >> 63) & 0x01) //col:10332
IA32_PERF_GLOBAL_STATUS_SET =                                  0x00000391 //col:10344
IA32_PERF_GLOBAL_STATUS_SET_OVF_PMCN_BIT =                     0 //col:10355
IA32_PERF_GLOBAL_STATUS_SET_OVF_PMCN_FLAG =                    0xFFFFFFFF //col:10356
IA32_PERF_GLOBAL_STATUS_SET_OVF_PMCN_MASK =                    0xFFFFFFFF //col:10357
IA32_PERF_GLOBAL_STATUS_SET_OVF_PMCN(_) =                      (((_) >> 0) & 0xFFFFFFFF) //col:10358
IA32_PERF_GLOBAL_STATUS_SET_OVF_FIXED_CTRN_BIT =               32 //col:10367
IA32_PERF_GLOBAL_STATUS_SET_OVF_FIXED_CTRN_FLAG =              0x700000000 //col:10368
IA32_PERF_GLOBAL_STATUS_SET_OVF_FIXED_CTRN_MASK =              0x07 //col:10369
IA32_PERF_GLOBAL_STATUS_SET_OVF_FIXED_CTRN(_) =                (((_) >> 32) & 0x07) //col:10370
IA32_PERF_GLOBAL_STATUS_SET_TRACE_TOPA_PMI_BIT =               55 //col:10379
IA32_PERF_GLOBAL_STATUS_SET_TRACE_TOPA_PMI_FLAG =              0x80000000000000 //col:10380
IA32_PERF_GLOBAL_STATUS_SET_TRACE_TOPA_PMI_MASK =              0x01 //col:10381
IA32_PERF_GLOBAL_STATUS_SET_TRACE_TOPA_PMI(_) =                (((_) >> 55) & 0x01) //col:10382
IA32_PERF_GLOBAL_STATUS_SET_LBR_FRZ_BIT =                      58 //col:10391
IA32_PERF_GLOBAL_STATUS_SET_LBR_FRZ_FLAG =                     0x400000000000000 //col:10392
IA32_PERF_GLOBAL_STATUS_SET_LBR_FRZ_MASK =                     0x01 //col:10393
IA32_PERF_GLOBAL_STATUS_SET_LBR_FRZ(_) =                       (((_) >> 58) & 0x01) //col:10394
IA32_PERF_GLOBAL_STATUS_SET_CTR_FRZ_BIT =                      59 //col:10402
IA32_PERF_GLOBAL_STATUS_SET_CTR_FRZ_FLAG =                     0x800000000000000 //col:10403
IA32_PERF_GLOBAL_STATUS_SET_CTR_FRZ_MASK =                     0x01 //col:10404
IA32_PERF_GLOBAL_STATUS_SET_CTR_FRZ(_) =                       (((_) >> 59) & 0x01) //col:10405
IA32_PERF_GLOBAL_STATUS_SET_ASCI_BIT =                         60 //col:10413
IA32_PERF_GLOBAL_STATUS_SET_ASCI_FLAG =                        0x1000000000000000 //col:10414
IA32_PERF_GLOBAL_STATUS_SET_ASCI_MASK =                        0x01 //col:10415
IA32_PERF_GLOBAL_STATUS_SET_ASCI(_) =                          (((_) >> 60) & 0x01) //col:10416
IA32_PERF_GLOBAL_STATUS_SET_OVF_UNCORE_BIT =                   61 //col:10424
IA32_PERF_GLOBAL_STATUS_SET_OVF_UNCORE_FLAG =                  0x2000000000000000 //col:10425
IA32_PERF_GLOBAL_STATUS_SET_OVF_UNCORE_MASK =                  0x01 //col:10426
IA32_PERF_GLOBAL_STATUS_SET_OVF_UNCORE(_) =                    (((_) >> 61) & 0x01) //col:10427
IA32_PERF_GLOBAL_STATUS_SET_OVF_BUF_BIT =                      62 //col:10435
IA32_PERF_GLOBAL_STATUS_SET_OVF_BUF_FLAG =                     0x4000000000000000 //col:10436
IA32_PERF_GLOBAL_STATUS_SET_OVF_BUF_MASK =                     0x01 //col:10437
IA32_PERF_GLOBAL_STATUS_SET_OVF_BUF(_) =                       (((_) >> 62) & 0x01) //col:10438
IA32_PERF_GLOBAL_INUSE =                                       0x00000392 //col:10451
IA32_PERF_GLOBAL_INUSE_IA32_PERFEVTSELN_IN_USE_BIT =           0 //col:10462
IA32_PERF_GLOBAL_INUSE_IA32_PERFEVTSELN_IN_USE_FLAG =          0xFFFFFFFF //col:10463
IA32_PERF_GLOBAL_INUSE_IA32_PERFEVTSELN_IN_USE_MASK =          0xFFFFFFFF //col:10464
IA32_PERF_GLOBAL_INUSE_IA32_PERFEVTSELN_IN_USE(_) =            (((_) >> 0) & 0xFFFFFFFF) //col:10465
IA32_PERF_GLOBAL_INUSE_IA32_FIXED_CTRN_IN_USE_BIT =            32 //col:10471
IA32_PERF_GLOBAL_INUSE_IA32_FIXED_CTRN_IN_USE_FLAG =           0x700000000 //col:10472
IA32_PERF_GLOBAL_INUSE_IA32_FIXED_CTRN_IN_USE_MASK =           0x07 //col:10473
IA32_PERF_GLOBAL_INUSE_IA32_FIXED_CTRN_IN_USE(_) =             (((_) >> 32) & 0x07) //col:10474
IA32_PERF_GLOBAL_INUSE_PMI_IN_USE_BIT =                        63 //col:10481
IA32_PERF_GLOBAL_INUSE_PMI_IN_USE_FLAG =                       0x8000000000000000 //col:10482
IA32_PERF_GLOBAL_INUSE_PMI_IN_USE_MASK =                       0x01 //col:10483
IA32_PERF_GLOBAL_INUSE_PMI_IN_USE(_) =                         (((_) >> 63) & 0x01) //col:10484
IA32_PEBS_ENABLE =                                             0x000003F1 //col:10496
IA32_PEBS_ENABLE_ENABLE_PEBS_BIT =                             0 //col:10507
IA32_PEBS_ENABLE_ENABLE_PEBS_FLAG =                            0x01 //col:10508
IA32_PEBS_ENABLE_ENABLE_PEBS_MASK =                            0x01 //col:10509
IA32_PEBS_ENABLE_ENABLE_PEBS(_) =                              (((_) >> 0) & 0x01) //col:10510
IA32_PEBS_ENABLE_RESERVEDORMODELSPECIFIC1_BIT =                1 //col:10516
IA32_PEBS_ENABLE_RESERVEDORMODELSPECIFIC1_FLAG =               0x0E //col:10517
IA32_PEBS_ENABLE_RESERVEDORMODELSPECIFIC1_MASK =               0x07 //col:10518
IA32_PEBS_ENABLE_RESERVEDORMODELSPECIFIC1(_) =                 (((_) >> 1) & 0x07) //col:10519
IA32_PEBS_ENABLE_RESERVEDORMODELSPECIFIC2_BIT =                32 //col:10526
IA32_PEBS_ENABLE_RESERVEDORMODELSPECIFIC2_FLAG =               0xF00000000 //col:10527
IA32_PEBS_ENABLE_RESERVEDORMODELSPECIFIC2_MASK =               0x0F //col:10528
IA32_PEBS_ENABLE_RESERVEDORMODELSPECIFIC2(_) =                 (((_) >> 32) & 0x0F) //col:10529
IA32_MC0_CTL =                                                 0x00000400 //col:10545
IA32_MC1_CTL =                                                 0x00000404 //col:10546
IA32_MC2_CTL =                                                 0x00000408 //col:10547
IA32_MC3_CTL =                                                 0x0000040C //col:10548
IA32_MC4_CTL =                                                 0x00000410 //col:10549
IA32_MC5_CTL =                                                 0x00000414 //col:10550
IA32_MC6_CTL =                                                 0x00000418 //col:10551
IA32_MC7_CTL =                                                 0x0000041C //col:10552
IA32_MC8_CTL =                                                 0x00000420 //col:10553
IA32_MC9_CTL =                                                 0x00000424 //col:10554
IA32_MC10_CTL =                                                0x00000428 //col:10555
IA32_MC11_CTL =                                                0x0000042C //col:10556
IA32_MC12_CTL =                                                0x00000430 //col:10557
IA32_MC13_CTL =                                                0x00000434 //col:10558
IA32_MC14_CTL =                                                0x00000438 //col:10559
IA32_MC15_CTL =                                                0x0000043C //col:10560
IA32_MC16_CTL =                                                0x00000440 //col:10561
IA32_MC17_CTL =                                                0x00000444 //col:10562
IA32_MC18_CTL =                                                0x00000448 //col:10563
IA32_MC19_CTL =                                                0x0000044C //col:10564
IA32_MC20_CTL =                                                0x00000450 //col:10565
IA32_MC21_CTL =                                                0x00000454 //col:10566
IA32_MC22_CTL =                                                0x00000458 //col:10567
IA32_MC23_CTL =                                                0x0000045C //col:10568
IA32_MC24_CTL =                                                0x00000460 //col:10569
IA32_MC25_CTL =                                                0x00000464 //col:10570
IA32_MC26_CTL =                                                0x00000468 //col:10571
IA32_MC27_CTL =                                                0x0000046C //col:10572
IA32_MC28_CTL =                                                0x00000470 //col:10573
IA32_MC0_STATUS =                                              0x00000401 //col:10587
IA32_MC1_STATUS =                                              0x00000405 //col:10588
IA32_MC2_STATUS =                                              0x00000409 //col:10589
IA32_MC3_STATUS =                                              0x0000040D //col:10590
IA32_MC4_STATUS =                                              0x00000411 //col:10591
IA32_MC5_STATUS =                                              0x00000415 //col:10592
IA32_MC6_STATUS =                                              0x00000419 //col:10593
IA32_MC7_STATUS =                                              0x0000041D //col:10594
IA32_MC8_STATUS =                                              0x00000421 //col:10595
IA32_MC9_STATUS =                                              0x00000425 //col:10596
IA32_MC10_STATUS =                                             0x00000429 //col:10597
IA32_MC11_STATUS =                                             0x0000042D //col:10598
IA32_MC12_STATUS =                                             0x00000431 //col:10599
IA32_MC13_STATUS =                                             0x00000435 //col:10600
IA32_MC14_STATUS =                                             0x00000439 //col:10601
IA32_MC15_STATUS =                                             0x0000043D //col:10602
IA32_MC16_STATUS =                                             0x00000441 //col:10603
IA32_MC17_STATUS =                                             0x00000445 //col:10604
IA32_MC18_STATUS =                                             0x00000449 //col:10605
IA32_MC19_STATUS =                                             0x0000044D //col:10606
IA32_MC20_STATUS =                                             0x00000451 //col:10607
IA32_MC21_STATUS =                                             0x00000455 //col:10608
IA32_MC22_STATUS =                                             0x00000459 //col:10609
IA32_MC23_STATUS =                                             0x0000045D //col:10610
IA32_MC24_STATUS =                                             0x00000461 //col:10611
IA32_MC25_STATUS =                                             0x00000465 //col:10612
IA32_MC26_STATUS =                                             0x00000469 //col:10613
IA32_MC27_STATUS =                                             0x0000046D //col:10614
IA32_MC28_STATUS =                                             0x00000471 //col:10615
IA32_MC0_ADDR =                                                0x00000402 //col:10629
IA32_MC1_ADDR =                                                0x00000406 //col:10630
IA32_MC2_ADDR =                                                0x0000040A //col:10631
IA32_MC3_ADDR =                                                0x0000040E //col:10632
IA32_MC4_ADDR =                                                0x00000412 //col:10633
IA32_MC5_ADDR =                                                0x00000416 //col:10634
IA32_MC6_ADDR =                                                0x0000041A //col:10635
IA32_MC7_ADDR =                                                0x0000041E //col:10636
IA32_MC8_ADDR =                                                0x00000422 //col:10637
IA32_MC9_ADDR =                                                0x00000426 //col:10638
IA32_MC10_ADDR =                                               0x0000042A //col:10639
IA32_MC11_ADDR =                                               0x0000042E //col:10640
IA32_MC12_ADDR =                                               0x00000432 //col:10641
IA32_MC13_ADDR =                                               0x00000436 //col:10642
IA32_MC14_ADDR =                                               0x0000043A //col:10643
IA32_MC15_ADDR =                                               0x0000043E //col:10644
IA32_MC16_ADDR =                                               0x00000442 //col:10645
IA32_MC17_ADDR =                                               0x00000446 //col:10646
IA32_MC18_ADDR =                                               0x0000044A //col:10647
IA32_MC19_ADDR =                                               0x0000044E //col:10648
IA32_MC20_ADDR =                                               0x00000452 //col:10649
IA32_MC21_ADDR =                                               0x00000456 //col:10650
IA32_MC22_ADDR =                                               0x0000045A //col:10651
IA32_MC23_ADDR =                                               0x0000045E //col:10652
IA32_MC24_ADDR =                                               0x00000462 //col:10653
IA32_MC25_ADDR =                                               0x00000466 //col:10654
IA32_MC26_ADDR =                                               0x0000046A //col:10655
IA32_MC27_ADDR =                                               0x0000046E //col:10656
IA32_MC28_ADDR =                                               0x00000472 //col:10657
IA32_MC0_MISC =                                                0x00000403 //col:10671
IA32_MC1_MISC =                                                0x00000407 //col:10672
IA32_MC2_MISC =                                                0x0000040B //col:10673
IA32_MC3_MISC =                                                0x0000040F //col:10674
IA32_MC4_MISC =                                                0x00000413 //col:10675
IA32_MC5_MISC =                                                0x00000417 //col:10676
IA32_MC6_MISC =                                                0x0000041B //col:10677
IA32_MC7_MISC =                                                0x0000041F //col:10678
IA32_MC8_MISC =                                                0x00000423 //col:10679
IA32_MC9_MISC =                                                0x00000427 //col:10680
IA32_MC10_MISC =                                               0x0000042B //col:10681
IA32_MC11_MISC =                                               0x0000042F //col:10682
IA32_MC12_MISC =                                               0x00000433 //col:10683
IA32_MC13_MISC =                                               0x00000437 //col:10684
IA32_MC14_MISC =                                               0x0000043B //col:10685
IA32_MC15_MISC =                                               0x0000043F //col:10686
IA32_MC16_MISC =                                               0x00000443 //col:10687
IA32_MC17_MISC =                                               0x00000447 //col:10688
IA32_MC18_MISC =                                               0x0000044B //col:10689
IA32_MC19_MISC =                                               0x0000044F //col:10690
IA32_MC20_MISC =                                               0x00000453 //col:10691
IA32_MC21_MISC =                                               0x00000457 //col:10692
IA32_MC22_MISC =                                               0x0000045B //col:10693
IA32_MC23_MISC =                                               0x0000045F //col:10694
IA32_MC24_MISC =                                               0x00000463 //col:10695
IA32_MC25_MISC =                                               0x00000467 //col:10696
IA32_MC26_MISC =                                               0x0000046B //col:10697
IA32_MC27_MISC =                                               0x0000046F //col:10698
IA32_MC28_MISC =                                               0x00000473 //col:10699
IA32_VMX_BASIC =                                               0x00000480 //col:10712
IA32_VMX_BASIC_VMCS_REVISION_ID_BIT =                          0 //col:10724
IA32_VMX_BASIC_VMCS_REVISION_ID_FLAG =                         0x7FFFFFFF //col:10725
IA32_VMX_BASIC_VMCS_REVISION_ID_MASK =                         0x7FFFFFFF //col:10726
IA32_VMX_BASIC_VMCS_REVISION_ID(_) =                           (((_) >> 0) & 0x7FFFFFFF) //col:10727
IA32_VMX_BASIC_MUST_BE_ZERO_BIT =                              31 //col:10733
IA32_VMX_BASIC_MUST_BE_ZERO_FLAG =                             0x80000000 //col:10734
IA32_VMX_BASIC_MUST_BE_ZERO_MASK =                             0x01 //col:10735
IA32_VMX_BASIC_MUST_BE_ZERO(_) =                               (((_) >> 31) & 0x01) //col:10736
IA32_VMX_BASIC_VMCS_SIZE_IN_BYTES_BIT =                        32 //col:10745
IA32_VMX_BASIC_VMCS_SIZE_IN_BYTES_FLAG =                       0x1FFF00000000 //col:10746
IA32_VMX_BASIC_VMCS_SIZE_IN_BYTES_MASK =                       0x1FFF //col:10747
IA32_VMX_BASIC_VMCS_SIZE_IN_BYTES(_) =                         (((_) >> 32) & 0x1FFF) //col:10748
IA32_VMX_BASIC_VMCS_PHYSICAL_ADDRESS_WIDTH_BIT =               48 //col:10762
IA32_VMX_BASIC_VMCS_PHYSICAL_ADDRESS_WIDTH_FLAG =              0x1000000000000 //col:10763
IA32_VMX_BASIC_VMCS_PHYSICAL_ADDRESS_WIDTH_MASK =              0x01 //col:10764
IA32_VMX_BASIC_VMCS_PHYSICAL_ADDRESS_WIDTH(_) =                (((_) >> 48) & 0x01) //col:10765
IA32_VMX_BASIC_DUAL_MONITOR_SUPPORT_BIT =                      49 //col:10777
IA32_VMX_BASIC_DUAL_MONITOR_SUPPORT_FLAG =                     0x2000000000000 //col:10778
IA32_VMX_BASIC_DUAL_MONITOR_SUPPORT_MASK =                     0x01 //col:10779
IA32_VMX_BASIC_DUAL_MONITOR_SUPPORT(_) =                       (((_) >> 49) & 0x01) //col:10780
IA32_VMX_BASIC_MEMORY_TYPE_BIT =                               50 //col:10793
IA32_VMX_BASIC_MEMORY_TYPE_FLAG =                              0x3C000000000000 //col:10794
IA32_VMX_BASIC_MEMORY_TYPE_MASK =                              0x0F //col:10795
IA32_VMX_BASIC_MEMORY_TYPE(_) =                                (((_) >> 50) & 0x0F) //col:10796
IA32_VMX_BASIC_INS_OUTS_REPORTING_BIT =                        54 //col:10807
IA32_VMX_BASIC_INS_OUTS_REPORTING_FLAG =                       0x40000000000000 //col:10808
IA32_VMX_BASIC_INS_OUTS_REPORTING_MASK =                       0x01 //col:10809
IA32_VMX_BASIC_INS_OUTS_REPORTING(_) =                         (((_) >> 54) & 0x01) //col:10810
IA32_VMX_BASIC_VMX_CONTROLS_BIT =                              55 //col:10827
IA32_VMX_BASIC_VMX_CONTROLS_FLAG =                             0x80000000000000 //col:10828
IA32_VMX_BASIC_VMX_CONTROLS_MASK =                             0x01 //col:10829
IA32_VMX_BASIC_VMX_CONTROLS(_) =                               (((_) >> 55) & 0x01) //col:10830
IA32_VMX_PINBASED_CTLS =                                       0x00000481 //col:10845
IA32_VMX_PINBASED_CTLS_EXTERNAL_INTERRUPT_EXITING_BIT =        0 //col:10857
IA32_VMX_PINBASED_CTLS_EXTERNAL_INTERRUPT_EXITING_FLAG =       0x01 //col:10858
IA32_VMX_PINBASED_CTLS_EXTERNAL_INTERRUPT_EXITING_MASK =       0x01 //col:10859
IA32_VMX_PINBASED_CTLS_EXTERNAL_INTERRUPT_EXITING(_) =         (((_) >> 0) & 0x01) //col:10860
IA32_VMX_PINBASED_CTLS_NMI_EXITING_BIT =                       3 //col:10872
IA32_VMX_PINBASED_CTLS_NMI_EXITING_FLAG =                      0x08 //col:10873
IA32_VMX_PINBASED_CTLS_NMI_EXITING_MASK =                      0x01 //col:10874
IA32_VMX_PINBASED_CTLS_NMI_EXITING(_) =                        (((_) >> 3) & 0x01) //col:10875
IA32_VMX_PINBASED_CTLS_VIRTUAL_NMI_BIT =                       5 //col:10887
IA32_VMX_PINBASED_CTLS_VIRTUAL_NMI_FLAG =                      0x20 //col:10888
IA32_VMX_PINBASED_CTLS_VIRTUAL_NMI_MASK =                      0x01 //col:10889
IA32_VMX_PINBASED_CTLS_VIRTUAL_NMI(_) =                        (((_) >> 5) & 0x01) //col:10890
IA32_VMX_PINBASED_CTLS_ACTIVATE_VMX_PREEMPTION_TIMER_BIT =     6 //col:10902
IA32_VMX_PINBASED_CTLS_ACTIVATE_VMX_PREEMPTION_TIMER_FLAG =    0x40 //col:10903
IA32_VMX_PINBASED_CTLS_ACTIVATE_VMX_PREEMPTION_TIMER_MASK =    0x01 //col:10904
IA32_VMX_PINBASED_CTLS_ACTIVATE_VMX_PREEMPTION_TIMER(_) =      (((_) >> 6) & 0x01) //col:10905
IA32_VMX_PINBASED_CTLS_PROCESS_POSTED_INTERRUPTS_BIT =         7 //col:10917
IA32_VMX_PINBASED_CTLS_PROCESS_POSTED_INTERRUPTS_FLAG =        0x80 //col:10918
IA32_VMX_PINBASED_CTLS_PROCESS_POSTED_INTERRUPTS_MASK =        0x01 //col:10919
IA32_VMX_PINBASED_CTLS_PROCESS_POSTED_INTERRUPTS(_) =          (((_) >> 7) & 0x01) //col:10920
IA32_VMX_PROCBASED_CTLS =                                      0x00000482 //col:10935
IA32_VMX_PROCBASED_CTLS_INTERRUPT_WINDOW_EXITING_BIT =         2 //col:10951
IA32_VMX_PROCBASED_CTLS_INTERRUPT_WINDOW_EXITING_FLAG =        0x04 //col:10952
IA32_VMX_PROCBASED_CTLS_INTERRUPT_WINDOW_EXITING_MASK =        0x01 //col:10953
IA32_VMX_PROCBASED_CTLS_INTERRUPT_WINDOW_EXITING(_) =          (((_) >> 2) & 0x01) //col:10954
IA32_VMX_PROCBASED_CTLS_USE_TSC_OFFSETTING_BIT =               3 //col:10966
IA32_VMX_PROCBASED_CTLS_USE_TSC_OFFSETTING_FLAG =              0x08 //col:10967
IA32_VMX_PROCBASED_CTLS_USE_TSC_OFFSETTING_MASK =              0x01 //col:10968
IA32_VMX_PROCBASED_CTLS_USE_TSC_OFFSETTING(_) =                (((_) >> 3) & 0x01) //col:10969
IA32_VMX_PROCBASED_CTLS_HLT_EXITING_BIT =                      7 //col:10978
IA32_VMX_PROCBASED_CTLS_HLT_EXITING_FLAG =                     0x80 //col:10979
IA32_VMX_PROCBASED_CTLS_HLT_EXITING_MASK =                     0x01 //col:10980
IA32_VMX_PROCBASED_CTLS_HLT_EXITING(_) =                       (((_) >> 7) & 0x01) //col:10981
IA32_VMX_PROCBASED_CTLS_INVLPG_EXITING_BIT =                   9 //col:10990
IA32_VMX_PROCBASED_CTLS_INVLPG_EXITING_FLAG =                  0x200 //col:10991
IA32_VMX_PROCBASED_CTLS_INVLPG_EXITING_MASK =                  0x01 //col:10992
IA32_VMX_PROCBASED_CTLS_INVLPG_EXITING(_) =                    (((_) >> 9) & 0x01) //col:10993
IA32_VMX_PROCBASED_CTLS_MWAIT_EXITING_BIT =                    10 //col:11001
IA32_VMX_PROCBASED_CTLS_MWAIT_EXITING_FLAG =                   0x400 //col:11002
IA32_VMX_PROCBASED_CTLS_MWAIT_EXITING_MASK =                   0x01 //col:11003
IA32_VMX_PROCBASED_CTLS_MWAIT_EXITING(_) =                     (((_) >> 10) & 0x01) //col:11004
IA32_VMX_PROCBASED_CTLS_RDPMC_EXITING_BIT =                    11 //col:11012
IA32_VMX_PROCBASED_CTLS_RDPMC_EXITING_FLAG =                   0x800 //col:11013
IA32_VMX_PROCBASED_CTLS_RDPMC_EXITING_MASK =                   0x01 //col:11014
IA32_VMX_PROCBASED_CTLS_RDPMC_EXITING(_) =                     (((_) >> 11) & 0x01) //col:11015
IA32_VMX_PROCBASED_CTLS_RDTSC_EXITING_BIT =                    12 //col:11023
IA32_VMX_PROCBASED_CTLS_RDTSC_EXITING_FLAG =                   0x1000 //col:11024
IA32_VMX_PROCBASED_CTLS_RDTSC_EXITING_MASK =                   0x01 //col:11025
IA32_VMX_PROCBASED_CTLS_RDTSC_EXITING(_) =                     (((_) >> 12) & 0x01) //col:11026
IA32_VMX_PROCBASED_CTLS_CR3_LOAD_EXITING_BIT =                 15 //col:11040
IA32_VMX_PROCBASED_CTLS_CR3_LOAD_EXITING_FLAG =                0x8000 //col:11041
IA32_VMX_PROCBASED_CTLS_CR3_LOAD_EXITING_MASK =                0x01 //col:11042
IA32_VMX_PROCBASED_CTLS_CR3_LOAD_EXITING(_) =                  (((_) >> 15) & 0x01) //col:11043
IA32_VMX_PROCBASED_CTLS_CR3_STORE_EXITING_BIT =                16 //col:11053
IA32_VMX_PROCBASED_CTLS_CR3_STORE_EXITING_FLAG =               0x10000 //col:11054
IA32_VMX_PROCBASED_CTLS_CR3_STORE_EXITING_MASK =               0x01 //col:11055
IA32_VMX_PROCBASED_CTLS_CR3_STORE_EXITING(_) =                 (((_) >> 16) & 0x01) //col:11056
IA32_VMX_PROCBASED_CTLS_ACTIVATE_TERTIARY_CONTROLS_BIT =       17 //col:11065
IA32_VMX_PROCBASED_CTLS_ACTIVATE_TERTIARY_CONTROLS_FLAG =      0x20000 //col:11066
IA32_VMX_PROCBASED_CTLS_ACTIVATE_TERTIARY_CONTROLS_MASK =      0x01 //col:11067
IA32_VMX_PROCBASED_CTLS_ACTIVATE_TERTIARY_CONTROLS(_) =        (((_) >> 17) & 0x01) //col:11068
IA32_VMX_PROCBASED_CTLS_CR8_LOAD_EXITING_BIT =                 19 //col:11077
IA32_VMX_PROCBASED_CTLS_CR8_LOAD_EXITING_FLAG =                0x80000 //col:11078
IA32_VMX_PROCBASED_CTLS_CR8_LOAD_EXITING_MASK =                0x01 //col:11079
IA32_VMX_PROCBASED_CTLS_CR8_LOAD_EXITING(_) =                  (((_) >> 19) & 0x01) //col:11080
IA32_VMX_PROCBASED_CTLS_CR8_STORE_EXITING_BIT =                20 //col:11088
IA32_VMX_PROCBASED_CTLS_CR8_STORE_EXITING_FLAG =               0x100000 //col:11089
IA32_VMX_PROCBASED_CTLS_CR8_STORE_EXITING_MASK =               0x01 //col:11090
IA32_VMX_PROCBASED_CTLS_CR8_STORE_EXITING(_) =                 (((_) >> 20) & 0x01) //col:11091
IA32_VMX_PROCBASED_CTLS_USE_TPR_SHADOW_BIT =                   21 //col:11101
IA32_VMX_PROCBASED_CTLS_USE_TPR_SHADOW_FLAG =                  0x200000 //col:11102
IA32_VMX_PROCBASED_CTLS_USE_TPR_SHADOW_MASK =                  0x01 //col:11103
IA32_VMX_PROCBASED_CTLS_USE_TPR_SHADOW(_) =                    (((_) >> 21) & 0x01) //col:11104
IA32_VMX_PROCBASED_CTLS_NMI_WINDOW_EXITING_BIT =               22 //col:11114
IA32_VMX_PROCBASED_CTLS_NMI_WINDOW_EXITING_FLAG =              0x400000 //col:11115
IA32_VMX_PROCBASED_CTLS_NMI_WINDOW_EXITING_MASK =              0x01 //col:11116
IA32_VMX_PROCBASED_CTLS_NMI_WINDOW_EXITING(_) =                (((_) >> 22) & 0x01) //col:11117
IA32_VMX_PROCBASED_CTLS_MOV_DR_EXITING_BIT =                   23 //col:11125
IA32_VMX_PROCBASED_CTLS_MOV_DR_EXITING_FLAG =                  0x800000 //col:11126
IA32_VMX_PROCBASED_CTLS_MOV_DR_EXITING_MASK =                  0x01 //col:11127
IA32_VMX_PROCBASED_CTLS_MOV_DR_EXITING(_) =                    (((_) >> 23) & 0x01) //col:11128
IA32_VMX_PROCBASED_CTLS_UNCONDITIONAL_IO_EXITING_BIT =         24 //col:11137
IA32_VMX_PROCBASED_CTLS_UNCONDITIONAL_IO_EXITING_FLAG =        0x1000000 //col:11138
IA32_VMX_PROCBASED_CTLS_UNCONDITIONAL_IO_EXITING_MASK =        0x01 //col:11139
IA32_VMX_PROCBASED_CTLS_UNCONDITIONAL_IO_EXITING(_) =          (((_) >> 24) & 0x01) //col:11140
IA32_VMX_PROCBASED_CTLS_USE_IO_BITMAPS_BIT =                   25 //col:11153
IA32_VMX_PROCBASED_CTLS_USE_IO_BITMAPS_FLAG =                  0x2000000 //col:11154
IA32_VMX_PROCBASED_CTLS_USE_IO_BITMAPS_MASK =                  0x01 //col:11155
IA32_VMX_PROCBASED_CTLS_USE_IO_BITMAPS(_) =                    (((_) >> 25) & 0x01) //col:11156
IA32_VMX_PROCBASED_CTLS_MONITOR_TRAP_FLAG_BIT =                27 //col:11167
IA32_VMX_PROCBASED_CTLS_MONITOR_TRAP_FLAG_FLAG =               0x8000000 //col:11168
IA32_VMX_PROCBASED_CTLS_MONITOR_TRAP_FLAG_MASK =               0x01 //col:11169
IA32_VMX_PROCBASED_CTLS_MONITOR_TRAP_FLAG(_) =                 (((_) >> 27) & 0x01) //col:11170
IA32_VMX_PROCBASED_CTLS_USE_MSR_BITMAPS_BIT =                  28 //col:11183
IA32_VMX_PROCBASED_CTLS_USE_MSR_BITMAPS_FLAG =                 0x10000000 //col:11184
IA32_VMX_PROCBASED_CTLS_USE_MSR_BITMAPS_MASK =                 0x01 //col:11185
IA32_VMX_PROCBASED_CTLS_USE_MSR_BITMAPS(_) =                   (((_) >> 28) & 0x01) //col:11186
IA32_VMX_PROCBASED_CTLS_MONITOR_EXITING_BIT =                  29 //col:11194
IA32_VMX_PROCBASED_CTLS_MONITOR_EXITING_FLAG =                 0x20000000 //col:11195
IA32_VMX_PROCBASED_CTLS_MONITOR_EXITING_MASK =                 0x01 //col:11196
IA32_VMX_PROCBASED_CTLS_MONITOR_EXITING(_) =                   (((_) >> 29) & 0x01) //col:11197
IA32_VMX_PROCBASED_CTLS_PAUSE_EXITING_BIT =                    30 //col:11205
IA32_VMX_PROCBASED_CTLS_PAUSE_EXITING_FLAG =                   0x40000000 //col:11206
IA32_VMX_PROCBASED_CTLS_PAUSE_EXITING_MASK =                   0x01 //col:11207
IA32_VMX_PROCBASED_CTLS_PAUSE_EXITING(_) =                     (((_) >> 30) & 0x01) //col:11208
IA32_VMX_PROCBASED_CTLS_ACTIVATE_SECONDARY_CONTROLS_BIT =      31 //col:11217
IA32_VMX_PROCBASED_CTLS_ACTIVATE_SECONDARY_CONTROLS_FLAG =     0x80000000 //col:11218
IA32_VMX_PROCBASED_CTLS_ACTIVATE_SECONDARY_CONTROLS_MASK =     0x01 //col:11219
IA32_VMX_PROCBASED_CTLS_ACTIVATE_SECONDARY_CONTROLS(_) =       (((_) >> 31) & 0x01) //col:11220
IA32_VMX_EXIT_CTLS =                                           0x00000483 //col:11235
IA32_VMX_EXIT_CTLS_SAVE_DEBUG_CONTROLS_BIT =                   2 //col:11250
IA32_VMX_EXIT_CTLS_SAVE_DEBUG_CONTROLS_FLAG =                  0x04 //col:11251
IA32_VMX_EXIT_CTLS_SAVE_DEBUG_CONTROLS_MASK =                  0x01 //col:11252
IA32_VMX_EXIT_CTLS_SAVE_DEBUG_CONTROLS(_) =                    (((_) >> 2) & 0x01) //col:11253
IA32_VMX_EXIT_CTLS_HOST_ADDRESS_SPACE_SIZE_BIT =               9 //col:11264
IA32_VMX_EXIT_CTLS_HOST_ADDRESS_SPACE_SIZE_FLAG =              0x200 //col:11265
IA32_VMX_EXIT_CTLS_HOST_ADDRESS_SPACE_SIZE_MASK =              0x01 //col:11266
IA32_VMX_EXIT_CTLS_HOST_ADDRESS_SPACE_SIZE(_) =                (((_) >> 9) & 0x01) //col:11267
IA32_VMX_EXIT_CTLS_LOAD_IA32_PERF_GLOBAL_CTRL_BIT =            12 //col:11276
IA32_VMX_EXIT_CTLS_LOAD_IA32_PERF_GLOBAL_CTRL_FLAG =           0x1000 //col:11277
IA32_VMX_EXIT_CTLS_LOAD_IA32_PERF_GLOBAL_CTRL_MASK =           0x01 //col:11278
IA32_VMX_EXIT_CTLS_LOAD_IA32_PERF_GLOBAL_CTRL(_) =             (((_) >> 12) & 0x01) //col:11279
IA32_VMX_EXIT_CTLS_ACKNOWLEDGE_INTERRUPT_ON_EXIT_BIT =         15 //col:11292
IA32_VMX_EXIT_CTLS_ACKNOWLEDGE_INTERRUPT_ON_EXIT_FLAG =        0x8000 //col:11293
IA32_VMX_EXIT_CTLS_ACKNOWLEDGE_INTERRUPT_ON_EXIT_MASK =        0x01 //col:11294
IA32_VMX_EXIT_CTLS_ACKNOWLEDGE_INTERRUPT_ON_EXIT(_) =          (((_) >> 15) & 0x01) //col:11295
IA32_VMX_EXIT_CTLS_SAVE_IA32_PAT_BIT =                         18 //col:11304
IA32_VMX_EXIT_CTLS_SAVE_IA32_PAT_FLAG =                        0x40000 //col:11305
IA32_VMX_EXIT_CTLS_SAVE_IA32_PAT_MASK =                        0x01 //col:11306
IA32_VMX_EXIT_CTLS_SAVE_IA32_PAT(_) =                          (((_) >> 18) & 0x01) //col:11307
IA32_VMX_EXIT_CTLS_LOAD_IA32_PAT_BIT =                         19 //col:11315
IA32_VMX_EXIT_CTLS_LOAD_IA32_PAT_FLAG =                        0x80000 //col:11316
IA32_VMX_EXIT_CTLS_LOAD_IA32_PAT_MASK =                        0x01 //col:11317
IA32_VMX_EXIT_CTLS_LOAD_IA32_PAT(_) =                          (((_) >> 19) & 0x01) //col:11318
IA32_VMX_EXIT_CTLS_SAVE_IA32_EFER_BIT =                        20 //col:11326
IA32_VMX_EXIT_CTLS_SAVE_IA32_EFER_FLAG =                       0x100000 //col:11327
IA32_VMX_EXIT_CTLS_SAVE_IA32_EFER_MASK =                       0x01 //col:11328
IA32_VMX_EXIT_CTLS_SAVE_IA32_EFER(_) =                         (((_) >> 20) & 0x01) //col:11329
IA32_VMX_EXIT_CTLS_LOAD_IA32_EFER_BIT =                        21 //col:11337
IA32_VMX_EXIT_CTLS_LOAD_IA32_EFER_FLAG =                       0x200000 //col:11338
IA32_VMX_EXIT_CTLS_LOAD_IA32_EFER_MASK =                       0x01 //col:11339
IA32_VMX_EXIT_CTLS_LOAD_IA32_EFER(_) =                         (((_) >> 21) & 0x01) //col:11340
IA32_VMX_EXIT_CTLS_SAVE_VMX_PREEMPTION_TIMER_VALUE_BIT =       22 //col:11348
IA32_VMX_EXIT_CTLS_SAVE_VMX_PREEMPTION_TIMER_VALUE_FLAG =      0x400000 //col:11349
IA32_VMX_EXIT_CTLS_SAVE_VMX_PREEMPTION_TIMER_VALUE_MASK =      0x01 //col:11350
IA32_VMX_EXIT_CTLS_SAVE_VMX_PREEMPTION_TIMER_VALUE(_) =        (((_) >> 22) & 0x01) //col:11351
IA32_VMX_EXIT_CTLS_CLEAR_IA32_BNDCFGS_BIT =                    23 //col:11357
IA32_VMX_EXIT_CTLS_CLEAR_IA32_BNDCFGS_FLAG =                   0x800000 //col:11358
IA32_VMX_EXIT_CTLS_CLEAR_IA32_BNDCFGS_MASK =                   0x01 //col:11359
IA32_VMX_EXIT_CTLS_CLEAR_IA32_BNDCFGS(_) =                     (((_) >> 23) & 0x01) //col:11360
IA32_VMX_EXIT_CTLS_CONCEAL_VMX_FROM_PT_BIT =                   24 //col:11369
IA32_VMX_EXIT_CTLS_CONCEAL_VMX_FROM_PT_FLAG =                  0x1000000 //col:11370
IA32_VMX_EXIT_CTLS_CONCEAL_VMX_FROM_PT_MASK =                  0x01 //col:11371
IA32_VMX_EXIT_CTLS_CONCEAL_VMX_FROM_PT(_) =                    (((_) >> 24) & 0x01) //col:11372
IA32_VMX_EXIT_CTLS_CLEAR_IA32_RTIT_CTL_BIT =                   25 //col:11380
IA32_VMX_EXIT_CTLS_CLEAR_IA32_RTIT_CTL_FLAG =                  0x2000000 //col:11381
IA32_VMX_EXIT_CTLS_CLEAR_IA32_RTIT_CTL_MASK =                  0x01 //col:11382
IA32_VMX_EXIT_CTLS_CLEAR_IA32_RTIT_CTL(_) =                    (((_) >> 25) & 0x01) //col:11383
IA32_VMX_EXIT_CTLS_CLEAR_IA32_LBR_CTL_BIT =                    26 //col:11389
IA32_VMX_EXIT_CTLS_CLEAR_IA32_LBR_CTL_FLAG =                   0x4000000 //col:11390
IA32_VMX_EXIT_CTLS_CLEAR_IA32_LBR_CTL_MASK =                   0x01 //col:11391
IA32_VMX_EXIT_CTLS_CLEAR_IA32_LBR_CTL(_) =                     (((_) >> 26) & 0x01) //col:11392
IA32_VMX_EXIT_CTLS_LOAD_IA32_CET_STATE_BIT =                   28 //col:11401
IA32_VMX_EXIT_CTLS_LOAD_IA32_CET_STATE_FLAG =                  0x10000000 //col:11402
IA32_VMX_EXIT_CTLS_LOAD_IA32_CET_STATE_MASK =                  0x01 //col:11403
IA32_VMX_EXIT_CTLS_LOAD_IA32_CET_STATE(_) =                    (((_) >> 28) & 0x01) //col:11404
IA32_VMX_EXIT_CTLS_LOAD_IA32_PKRS_BIT =                        29 //col:11410
IA32_VMX_EXIT_CTLS_LOAD_IA32_PKRS_FLAG =                       0x20000000 //col:11411
IA32_VMX_EXIT_CTLS_LOAD_IA32_PKRS_MASK =                       0x01 //col:11412
IA32_VMX_EXIT_CTLS_LOAD_IA32_PKRS(_) =                         (((_) >> 29) & 0x01) //col:11413
IA32_VMX_EXIT_CTLS_ACTIVATE_SECONDARY_CONTROLS_BIT =           31 //col:11421
IA32_VMX_EXIT_CTLS_ACTIVATE_SECONDARY_CONTROLS_FLAG =          0x80000000 //col:11422
IA32_VMX_EXIT_CTLS_ACTIVATE_SECONDARY_CONTROLS_MASK =          0x01 //col:11423
IA32_VMX_EXIT_CTLS_ACTIVATE_SECONDARY_CONTROLS(_) =            (((_) >> 31) & 0x01) //col:11424
IA32_VMX_ENTRY_CTLS =                                          0x00000484 //col:11439
IA32_VMX_ENTRY_CTLS_LOAD_DEBUG_CONTROLS_BIT =                  2 //col:11454
IA32_VMX_ENTRY_CTLS_LOAD_DEBUG_CONTROLS_FLAG =                 0x04 //col:11455
IA32_VMX_ENTRY_CTLS_LOAD_DEBUG_CONTROLS_MASK =                 0x01 //col:11456
IA32_VMX_ENTRY_CTLS_LOAD_DEBUG_CONTROLS(_) =                   (((_) >> 2) & 0x01) //col:11457
IA32_VMX_ENTRY_CTLS_IA32E_MODE_GUEST_BIT =                     9 //col:11468
IA32_VMX_ENTRY_CTLS_IA32E_MODE_GUEST_FLAG =                    0x200 //col:11469
IA32_VMX_ENTRY_CTLS_IA32E_MODE_GUEST_MASK =                    0x01 //col:11470
IA32_VMX_ENTRY_CTLS_IA32E_MODE_GUEST(_) =                      (((_) >> 9) & 0x01) //col:11471
IA32_VMX_ENTRY_CTLS_ENTRY_TO_SMM_BIT =                         10 //col:11480
IA32_VMX_ENTRY_CTLS_ENTRY_TO_SMM_FLAG =                        0x400 //col:11481
IA32_VMX_ENTRY_CTLS_ENTRY_TO_SMM_MASK =                        0x01 //col:11482
IA32_VMX_ENTRY_CTLS_ENTRY_TO_SMM(_) =                          (((_) >> 10) & 0x01) //col:11483
IA32_VMX_ENTRY_CTLS_DEACTIVATE_DUAL_MONITOR_TREATMENT_BIT =    11 //col:11494
IA32_VMX_ENTRY_CTLS_DEACTIVATE_DUAL_MONITOR_TREATMENT_FLAG =   0x800 //col:11495
IA32_VMX_ENTRY_CTLS_DEACTIVATE_DUAL_MONITOR_TREATMENT_MASK =   0x01 //col:11496
IA32_VMX_ENTRY_CTLS_DEACTIVATE_DUAL_MONITOR_TREATMENT(_) =     (((_) >> 11) & 0x01) //col:11497
IA32_VMX_ENTRY_CTLS_LOAD_IA32_PERF_GLOBAL_CTRL_BIT =           13 //col:11506
IA32_VMX_ENTRY_CTLS_LOAD_IA32_PERF_GLOBAL_CTRL_FLAG =          0x2000 //col:11507
IA32_VMX_ENTRY_CTLS_LOAD_IA32_PERF_GLOBAL_CTRL_MASK =          0x01 //col:11508
IA32_VMX_ENTRY_CTLS_LOAD_IA32_PERF_GLOBAL_CTRL(_) =            (((_) >> 13) & 0x01) //col:11509
IA32_VMX_ENTRY_CTLS_LOAD_IA32_PAT_BIT =                        14 //col:11517
IA32_VMX_ENTRY_CTLS_LOAD_IA32_PAT_FLAG =                       0x4000 //col:11518
IA32_VMX_ENTRY_CTLS_LOAD_IA32_PAT_MASK =                       0x01 //col:11519
IA32_VMX_ENTRY_CTLS_LOAD_IA32_PAT(_) =                         (((_) >> 14) & 0x01) //col:11520
IA32_VMX_ENTRY_CTLS_LOAD_IA32_EFER_BIT =                       15 //col:11528
IA32_VMX_ENTRY_CTLS_LOAD_IA32_EFER_FLAG =                      0x8000 //col:11529
IA32_VMX_ENTRY_CTLS_LOAD_IA32_EFER_MASK =                      0x01 //col:11530
IA32_VMX_ENTRY_CTLS_LOAD_IA32_EFER(_) =                        (((_) >> 15) & 0x01) //col:11531
IA32_VMX_ENTRY_CTLS_LOAD_IA32_BNDCFGS_BIT =                    16 //col:11537
IA32_VMX_ENTRY_CTLS_LOAD_IA32_BNDCFGS_FLAG =                   0x10000 //col:11538
IA32_VMX_ENTRY_CTLS_LOAD_IA32_BNDCFGS_MASK =                   0x01 //col:11539
IA32_VMX_ENTRY_CTLS_LOAD_IA32_BNDCFGS(_) =                     (((_) >> 16) & 0x01) //col:11540
IA32_VMX_ENTRY_CTLS_CONCEAL_VMX_FROM_PT_BIT =                  17 //col:11549
IA32_VMX_ENTRY_CTLS_CONCEAL_VMX_FROM_PT_FLAG =                 0x20000 //col:11550
IA32_VMX_ENTRY_CTLS_CONCEAL_VMX_FROM_PT_MASK =                 0x01 //col:11551
IA32_VMX_ENTRY_CTLS_CONCEAL_VMX_FROM_PT(_) =                   (((_) >> 17) & 0x01) //col:11552
IA32_VMX_ENTRY_CTLS_LOAD_IA32_RTIT_CTL_BIT =                   18 //col:11558
IA32_VMX_ENTRY_CTLS_LOAD_IA32_RTIT_CTL_FLAG =                  0x40000 //col:11559
IA32_VMX_ENTRY_CTLS_LOAD_IA32_RTIT_CTL_MASK =                  0x01 //col:11560
IA32_VMX_ENTRY_CTLS_LOAD_IA32_RTIT_CTL(_) =                    (((_) >> 18) & 0x01) //col:11561
IA32_VMX_ENTRY_CTLS_LOAD_CET_STATE_BIT =                       20 //col:11568
IA32_VMX_ENTRY_CTLS_LOAD_CET_STATE_FLAG =                      0x100000 //col:11569
IA32_VMX_ENTRY_CTLS_LOAD_CET_STATE_MASK =                      0x01 //col:11570
IA32_VMX_ENTRY_CTLS_LOAD_CET_STATE(_) =                        (((_) >> 20) & 0x01) //col:11571
IA32_VMX_ENTRY_CTLS_LOAD_IA32_LBR_CTL_BIT =                    21 //col:11577
IA32_VMX_ENTRY_CTLS_LOAD_IA32_LBR_CTL_FLAG =                   0x200000 //col:11578
IA32_VMX_ENTRY_CTLS_LOAD_IA32_LBR_CTL_MASK =                   0x01 //col:11579
IA32_VMX_ENTRY_CTLS_LOAD_IA32_LBR_CTL(_) =                     (((_) >> 21) & 0x01) //col:11580
IA32_VMX_ENTRY_CTLS_LOAD_IA32_PKRS_BIT =                       22 //col:11586
IA32_VMX_ENTRY_CTLS_LOAD_IA32_PKRS_FLAG =                      0x400000 //col:11587
IA32_VMX_ENTRY_CTLS_LOAD_IA32_PKRS_MASK =                      0x01 //col:11588
IA32_VMX_ENTRY_CTLS_LOAD_IA32_PKRS(_) =                        (((_) >> 22) & 0x01) //col:11589
IA32_VMX_MISC =                                                0x00000485 //col:11604
IA32_VMX_MISC_PREEMPTION_TIMER_TSC_RELATIONSHIP_BIT =          0 //col:11617
IA32_VMX_MISC_PREEMPTION_TIMER_TSC_RELATIONSHIP_FLAG =         0x1F //col:11618
IA32_VMX_MISC_PREEMPTION_TIMER_TSC_RELATIONSHIP_MASK =         0x1F //col:11619
IA32_VMX_MISC_PREEMPTION_TIMER_TSC_RELATIONSHIP(_) =           (((_) >> 0) & 0x1F) //col:11620
IA32_VMX_MISC_STORE_EFER_LMA_ON_VMEXIT_BIT =                   5 //col:11631
IA32_VMX_MISC_STORE_EFER_LMA_ON_VMEXIT_FLAG =                  0x20 //col:11632
IA32_VMX_MISC_STORE_EFER_LMA_ON_VMEXIT_MASK =                  0x01 //col:11633
IA32_VMX_MISC_STORE_EFER_LMA_ON_VMEXIT(_) =                    (((_) >> 5) & 0x01) //col:11634
IA32_VMX_MISC_ACTIVITY_STATES_BIT =                            6 //col:11647
IA32_VMX_MISC_ACTIVITY_STATES_FLAG =                           0x1C0 //col:11648
IA32_VMX_MISC_ACTIVITY_STATES_MASK =                           0x07 //col:11649
IA32_VMX_MISC_ACTIVITY_STATES(_) =                             (((_) >> 6) & 0x07) //col:11650
IA32_VMX_MISC_INTEL_PT_AVAILABLE_IN_VMX_BIT =                  14 //col:11663
IA32_VMX_MISC_INTEL_PT_AVAILABLE_IN_VMX_FLAG =                 0x4000 //col:11664
IA32_VMX_MISC_INTEL_PT_AVAILABLE_IN_VMX_MASK =                 0x01 //col:11665
IA32_VMX_MISC_INTEL_PT_AVAILABLE_IN_VMX(_) =                   (((_) >> 14) & 0x01) //col:11666
IA32_VMX_MISC_RDMSR_CAN_READ_IA32_SMBASE_MSR_IN_SMM_BIT =      15 //col:11677
IA32_VMX_MISC_RDMSR_CAN_READ_IA32_SMBASE_MSR_IN_SMM_FLAG =     0x8000 //col:11678
IA32_VMX_MISC_RDMSR_CAN_READ_IA32_SMBASE_MSR_IN_SMM_MASK =     0x01 //col:11679
IA32_VMX_MISC_RDMSR_CAN_READ_IA32_SMBASE_MSR_IN_SMM(_) =       (((_) >> 15) & 0x01) //col:11680
IA32_VMX_MISC_CR3_TARGET_COUNT_BIT =                           16 //col:11689
IA32_VMX_MISC_CR3_TARGET_COUNT_FLAG =                          0x1FF0000 //col:11690
IA32_VMX_MISC_CR3_TARGET_COUNT_MASK =                          0x1FF //col:11691
IA32_VMX_MISC_CR3_TARGET_COUNT(_) =                            (((_) >> 16) & 0x1FF) //col:11692
IA32_VMX_MISC_MAX_NUMBER_OF_MSR_BIT =                          25 //col:11703
IA32_VMX_MISC_MAX_NUMBER_OF_MSR_FLAG =                         0xE000000 //col:11704
IA32_VMX_MISC_MAX_NUMBER_OF_MSR_MASK =                         0x07 //col:11705
IA32_VMX_MISC_MAX_NUMBER_OF_MSR(_) =                           (((_) >> 25) & 0x07) //col:11706
IA32_VMX_MISC_SMM_MONITOR_CTL_B2_BIT =                         28 //col:11717
IA32_VMX_MISC_SMM_MONITOR_CTL_B2_FLAG =                        0x10000000 //col:11718
IA32_VMX_MISC_SMM_MONITOR_CTL_B2_MASK =                        0x01 //col:11719
IA32_VMX_MISC_SMM_MONITOR_CTL_B2(_) =                          (((_) >> 28) & 0x01) //col:11720
IA32_VMX_MISC_VMWRITE_VMEXIT_INFO_BIT =                        29 //col:11729
IA32_VMX_MISC_VMWRITE_VMEXIT_INFO_FLAG =                       0x20000000 //col:11730
IA32_VMX_MISC_VMWRITE_VMEXIT_INFO_MASK =                       0x01 //col:11731
IA32_VMX_MISC_VMWRITE_VMEXIT_INFO(_) =                         (((_) >> 29) & 0x01) //col:11732
IA32_VMX_MISC_ZERO_LENGTH_INSTRUCTION_VMENTRY_INJECTION_BIT =  30 //col:11739
IA32_VMX_MISC_ZERO_LENGTH_INSTRUCTION_VMENTRY_INJECTION_FLAG = 0x40000000 //col:11740
IA32_VMX_MISC_ZERO_LENGTH_INSTRUCTION_VMENTRY_INJECTION_MASK = 0x01 //col:11741
IA32_VMX_MISC_ZERO_LENGTH_INSTRUCTION_VMENTRY_INJECTION(_) =   (((_) >> 30) & 0x01) //col:11742
IA32_VMX_MISC_MSEG_ID_BIT =                                    32 //col:11751
IA32_VMX_MISC_MSEG_ID_FLAG =                                   0xFFFFFFFF00000000 //col:11752
IA32_VMX_MISC_MSEG_ID_MASK =                                   0xFFFFFFFF //col:11753
IA32_VMX_MISC_MSEG_ID(_) =                                     (((_) >> 32) & 0xFFFFFFFF) //col:11754
IA32_VMX_CR0_FIXED0 =                                          0x00000486 //col:11768
IA32_VMX_CR0_FIXED1 =                                          0x00000487 //col:11777
IA32_VMX_CR4_FIXED0 =                                          0x00000488 //col:11786
IA32_VMX_CR4_FIXED1 =                                          0x00000489 //col:11795
IA32_VMX_VMCS_ENUM =                                           0x0000048A //col:11804
IA32_VMX_VMCS_ENUM_ACCESS_TYPE_BIT =                           0 //col:11813
IA32_VMX_VMCS_ENUM_ACCESS_TYPE_FLAG =                          0x01 //col:11814
IA32_VMX_VMCS_ENUM_ACCESS_TYPE_MASK =                          0x01 //col:11815
IA32_VMX_VMCS_ENUM_ACCESS_TYPE(_) =                            (((_) >> 0) & 0x01) //col:11816
IA32_VMX_VMCS_ENUM_HIGHEST_INDEX_VALUE_BIT =                   1 //col:11822
IA32_VMX_VMCS_ENUM_HIGHEST_INDEX_VALUE_FLAG =                  0x3FE //col:11823
IA32_VMX_VMCS_ENUM_HIGHEST_INDEX_VALUE_MASK =                  0x1FF //col:11824
IA32_VMX_VMCS_ENUM_HIGHEST_INDEX_VALUE(_) =                    (((_) >> 1) & 0x1FF) //col:11825
IA32_VMX_VMCS_ENUM_FIELD_TYPE_BIT =                            10 //col:11831
IA32_VMX_VMCS_ENUM_FIELD_TYPE_FLAG =                           0xC00 //col:11832
IA32_VMX_VMCS_ENUM_FIELD_TYPE_MASK =                           0x03 //col:11833
IA32_VMX_VMCS_ENUM_FIELD_TYPE(_) =                             (((_) >> 10) & 0x03) //col:11834
IA32_VMX_VMCS_ENUM_FIELD_WIDTH_BIT =                           13 //col:11841
IA32_VMX_VMCS_ENUM_FIELD_WIDTH_FLAG =                          0x6000 //col:11842
IA32_VMX_VMCS_ENUM_FIELD_WIDTH_MASK =                          0x03 //col:11843
IA32_VMX_VMCS_ENUM_FIELD_WIDTH(_) =                            (((_) >> 13) & 0x03) //col:11844
IA32_VMX_PROCBASED_CTLS2 =                                     0x0000048B //col:11859
IA32_VMX_PROCBASED_CTLS2_VIRTUALIZE_APIC_ACCESSES_BIT =        0 //col:11872
IA32_VMX_PROCBASED_CTLS2_VIRTUALIZE_APIC_ACCESSES_FLAG =       0x01 //col:11873
IA32_VMX_PROCBASED_CTLS2_VIRTUALIZE_APIC_ACCESSES_MASK =       0x01 //col:11874
IA32_VMX_PROCBASED_CTLS2_VIRTUALIZE_APIC_ACCESSES(_) =         (((_) >> 0) & 0x01) //col:11875
IA32_VMX_PROCBASED_CTLS2_ENABLE_EPT_BIT =                      1 //col:11885
IA32_VMX_PROCBASED_CTLS2_ENABLE_EPT_FLAG =                     0x02 //col:11886
IA32_VMX_PROCBASED_CTLS2_ENABLE_EPT_MASK =                     0x01 //col:11887
IA32_VMX_PROCBASED_CTLS2_ENABLE_EPT(_) =                       (((_) >> 1) & 0x01) //col:11888
IA32_VMX_PROCBASED_CTLS2_DESCRIPTOR_TABLE_EXITING_BIT =        2 //col:11896
IA32_VMX_PROCBASED_CTLS2_DESCRIPTOR_TABLE_EXITING_FLAG =       0x04 //col:11897
IA32_VMX_PROCBASED_CTLS2_DESCRIPTOR_TABLE_EXITING_MASK =       0x01 //col:11898
IA32_VMX_PROCBASED_CTLS2_DESCRIPTOR_TABLE_EXITING(_) =         (((_) >> 2) & 0x01) //col:11899
IA32_VMX_PROCBASED_CTLS2_ENABLE_RDTSCP_BIT =                   3 //col:11907
IA32_VMX_PROCBASED_CTLS2_ENABLE_RDTSCP_FLAG =                  0x08 //col:11908
IA32_VMX_PROCBASED_CTLS2_ENABLE_RDTSCP_MASK =                  0x01 //col:11909
IA32_VMX_PROCBASED_CTLS2_ENABLE_RDTSCP(_) =                    (((_) >> 3) & 0x01) //col:11910
IA32_VMX_PROCBASED_CTLS2_VIRTUALIZE_X2APIC_MODE_BIT =          4 //col:11921
IA32_VMX_PROCBASED_CTLS2_VIRTUALIZE_X2APIC_MODE_FLAG =         0x10 //col:11922
IA32_VMX_PROCBASED_CTLS2_VIRTUALIZE_X2APIC_MODE_MASK =         0x01 //col:11923
IA32_VMX_PROCBASED_CTLS2_VIRTUALIZE_X2APIC_MODE(_) =           (((_) >> 4) & 0x01) //col:11924
IA32_VMX_PROCBASED_CTLS2_ENABLE_VPID_BIT =                     5 //col:11935
IA32_VMX_PROCBASED_CTLS2_ENABLE_VPID_FLAG =                    0x20 //col:11936
IA32_VMX_PROCBASED_CTLS2_ENABLE_VPID_MASK =                    0x01 //col:11937
IA32_VMX_PROCBASED_CTLS2_ENABLE_VPID(_) =                      (((_) >> 5) & 0x01) //col:11938
IA32_VMX_PROCBASED_CTLS2_WBINVD_EXITING_BIT =                  6 //col:11946
IA32_VMX_PROCBASED_CTLS2_WBINVD_EXITING_FLAG =                 0x40 //col:11947
IA32_VMX_PROCBASED_CTLS2_WBINVD_EXITING_MASK =                 0x01 //col:11948
IA32_VMX_PROCBASED_CTLS2_WBINVD_EXITING(_) =                   (((_) >> 6) & 0x01) //col:11949
IA32_VMX_PROCBASED_CTLS2_UNRESTRICTED_GUEST_BIT =              7 //col:11957
IA32_VMX_PROCBASED_CTLS2_UNRESTRICTED_GUEST_FLAG =             0x80 //col:11958
IA32_VMX_PROCBASED_CTLS2_UNRESTRICTED_GUEST_MASK =             0x01 //col:11959
IA32_VMX_PROCBASED_CTLS2_UNRESTRICTED_GUEST(_) =               (((_) >> 7) & 0x01) //col:11960
IA32_VMX_PROCBASED_CTLS2_APIC_REGISTER_VIRTUALIZATION_BIT =    8 //col:11971
IA32_VMX_PROCBASED_CTLS2_APIC_REGISTER_VIRTUALIZATION_FLAG =   0x100 //col:11972
IA32_VMX_PROCBASED_CTLS2_APIC_REGISTER_VIRTUALIZATION_MASK =   0x01 //col:11973
IA32_VMX_PROCBASED_CTLS2_APIC_REGISTER_VIRTUALIZATION(_) =     (((_) >> 8) & 0x01) //col:11974
IA32_VMX_PROCBASED_CTLS2_VIRTUAL_INTERRUPT_DELIVERY_BIT =      9 //col:11983
IA32_VMX_PROCBASED_CTLS2_VIRTUAL_INTERRUPT_DELIVERY_FLAG =     0x200 //col:11984
IA32_VMX_PROCBASED_CTLS2_VIRTUAL_INTERRUPT_DELIVERY_MASK =     0x01 //col:11985
IA32_VMX_PROCBASED_CTLS2_VIRTUAL_INTERRUPT_DELIVERY(_) =       (((_) >> 9) & 0x01) //col:11986
IA32_VMX_PROCBASED_CTLS2_PAUSE_LOOP_EXITING_BIT =              10 //col:11997
IA32_VMX_PROCBASED_CTLS2_PAUSE_LOOP_EXITING_FLAG =             0x400 //col:11998
IA32_VMX_PROCBASED_CTLS2_PAUSE_LOOP_EXITING_MASK =             0x01 //col:11999
IA32_VMX_PROCBASED_CTLS2_PAUSE_LOOP_EXITING(_) =               (((_) >> 10) & 0x01) //col:12000
IA32_VMX_PROCBASED_CTLS2_RDRAND_EXITING_BIT =                  11 //col:12008
IA32_VMX_PROCBASED_CTLS2_RDRAND_EXITING_FLAG =                 0x800 //col:12009
IA32_VMX_PROCBASED_CTLS2_RDRAND_EXITING_MASK =                 0x01 //col:12010
IA32_VMX_PROCBASED_CTLS2_RDRAND_EXITING(_) =                   (((_) >> 11) & 0x01) //col:12011
IA32_VMX_PROCBASED_CTLS2_ENABLE_INVPCID_BIT =                  12 //col:12019
IA32_VMX_PROCBASED_CTLS2_ENABLE_INVPCID_FLAG =                 0x1000 //col:12020
IA32_VMX_PROCBASED_CTLS2_ENABLE_INVPCID_MASK =                 0x01 //col:12021
IA32_VMX_PROCBASED_CTLS2_ENABLE_INVPCID(_) =                   (((_) >> 12) & 0x01) //col:12022
IA32_VMX_PROCBASED_CTLS2_ENABLE_VM_FUNCTIONS_BIT =             13 //col:12032
IA32_VMX_PROCBASED_CTLS2_ENABLE_VM_FUNCTIONS_FLAG =            0x2000 //col:12033
IA32_VMX_PROCBASED_CTLS2_ENABLE_VM_FUNCTIONS_MASK =            0x01 //col:12034
IA32_VMX_PROCBASED_CTLS2_ENABLE_VM_FUNCTIONS(_) =              (((_) >> 13) & 0x01) //col:12035
IA32_VMX_PROCBASED_CTLS2_VMCS_SHADOWING_BIT =                  14 //col:12047
IA32_VMX_PROCBASED_CTLS2_VMCS_SHADOWING_FLAG =                 0x4000 //col:12048
IA32_VMX_PROCBASED_CTLS2_VMCS_SHADOWING_MASK =                 0x01 //col:12049
IA32_VMX_PROCBASED_CTLS2_VMCS_SHADOWING(_) =                   (((_) >> 14) & 0x01) //col:12050
IA32_VMX_PROCBASED_CTLS2_ENABLE_ENCLS_EXITING_BIT =            15 //col:12062
IA32_VMX_PROCBASED_CTLS2_ENABLE_ENCLS_EXITING_FLAG =           0x8000 //col:12063
IA32_VMX_PROCBASED_CTLS2_ENABLE_ENCLS_EXITING_MASK =           0x01 //col:12064
IA32_VMX_PROCBASED_CTLS2_ENABLE_ENCLS_EXITING(_) =             (((_) >> 15) & 0x01) //col:12065
IA32_VMX_PROCBASED_CTLS2_RDSEED_EXITING_BIT =                  16 //col:12073
IA32_VMX_PROCBASED_CTLS2_RDSEED_EXITING_FLAG =                 0x10000 //col:12074
IA32_VMX_PROCBASED_CTLS2_RDSEED_EXITING_MASK =                 0x01 //col:12075
IA32_VMX_PROCBASED_CTLS2_RDSEED_EXITING(_) =                   (((_) >> 16) & 0x01) //col:12076
IA32_VMX_PROCBASED_CTLS2_ENABLE_PML_BIT =                      17 //col:12087
IA32_VMX_PROCBASED_CTLS2_ENABLE_PML_FLAG =                     0x20000 //col:12088
IA32_VMX_PROCBASED_CTLS2_ENABLE_PML_MASK =                     0x01 //col:12089
IA32_VMX_PROCBASED_CTLS2_ENABLE_PML(_) =                       (((_) >> 17) & 0x01) //col:12090
IA32_VMX_PROCBASED_CTLS2_EPT_VIOLATION_BIT =                   18 //col:12100
IA32_VMX_PROCBASED_CTLS2_EPT_VIOLATION_FLAG =                  0x40000 //col:12101
IA32_VMX_PROCBASED_CTLS2_EPT_VIOLATION_MASK =                  0x01 //col:12102
IA32_VMX_PROCBASED_CTLS2_EPT_VIOLATION(_) =                    (((_) >> 18) & 0x01) //col:12103
IA32_VMX_PROCBASED_CTLS2_CONCEAL_VMX_FROM_PT_BIT =             19 //col:12114
IA32_VMX_PROCBASED_CTLS2_CONCEAL_VMX_FROM_PT_FLAG =            0x80000 //col:12115
IA32_VMX_PROCBASED_CTLS2_CONCEAL_VMX_FROM_PT_MASK =            0x01 //col:12116
IA32_VMX_PROCBASED_CTLS2_CONCEAL_VMX_FROM_PT(_) =              (((_) >> 19) & 0x01) //col:12117
IA32_VMX_PROCBASED_CTLS2_ENABLE_XSAVES_BIT =                   20 //col:12125
IA32_VMX_PROCBASED_CTLS2_ENABLE_XSAVES_FLAG =                  0x100000 //col:12126
IA32_VMX_PROCBASED_CTLS2_ENABLE_XSAVES_MASK =                  0x01 //col:12127
IA32_VMX_PROCBASED_CTLS2_ENABLE_XSAVES(_) =                    (((_) >> 20) & 0x01) //col:12128
IA32_VMX_PROCBASED_CTLS2_MODE_BASED_EXECUTE_CONTROL_FOR_EPT_BIT = 22 //col:12138
IA32_VMX_PROCBASED_CTLS2_MODE_BASED_EXECUTE_CONTROL_FOR_EPT_FLAG = 0x400000 //col:12139
IA32_VMX_PROCBASED_CTLS2_MODE_BASED_EXECUTE_CONTROL_FOR_EPT_MASK = 0x01 //col:12140
IA32_VMX_PROCBASED_CTLS2_MODE_BASED_EXECUTE_CONTROL_FOR_EPT(_) = (((_) >> 22) & 0x01) //col:12141
IA32_VMX_PROCBASED_CTLS2_SUB_PAGE_WRITE_PERMISSIONS_FOR_EPT_BIT = 23 //col:12149
IA32_VMX_PROCBASED_CTLS2_SUB_PAGE_WRITE_PERMISSIONS_FOR_EPT_FLAG = 0x800000 //col:12150
IA32_VMX_PROCBASED_CTLS2_SUB_PAGE_WRITE_PERMISSIONS_FOR_EPT_MASK = 0x01 //col:12151
IA32_VMX_PROCBASED_CTLS2_SUB_PAGE_WRITE_PERMISSIONS_FOR_EPT(_) = (((_) >> 23) & 0x01) //col:12152
IA32_VMX_PROCBASED_CTLS2_PT_USES_GUEST_PHYSICAL_ADDRESSES_BIT = 24 //col:12161
IA32_VMX_PROCBASED_CTLS2_PT_USES_GUEST_PHYSICAL_ADDRESSES_FLAG = 0x1000000 //col:12162
IA32_VMX_PROCBASED_CTLS2_PT_USES_GUEST_PHYSICAL_ADDRESSES_MASK = 0x01 //col:12163
IA32_VMX_PROCBASED_CTLS2_PT_USES_GUEST_PHYSICAL_ADDRESSES(_) = (((_) >> 24) & 0x01) //col:12164
IA32_VMX_PROCBASED_CTLS2_USE_TSC_SCALING_BIT =                 25 //col:12176
IA32_VMX_PROCBASED_CTLS2_USE_TSC_SCALING_FLAG =                0x2000000 //col:12177
IA32_VMX_PROCBASED_CTLS2_USE_TSC_SCALING_MASK =                0x01 //col:12178
IA32_VMX_PROCBASED_CTLS2_USE_TSC_SCALING(_) =                  (((_) >> 25) & 0x01) //col:12179
IA32_VMX_PROCBASED_CTLS2_ENABLE_USER_WAIT_PAUSE_BIT =          26 //col:12187
IA32_VMX_PROCBASED_CTLS2_ENABLE_USER_WAIT_PAUSE_FLAG =         0x4000000 //col:12188
IA32_VMX_PROCBASED_CTLS2_ENABLE_USER_WAIT_PAUSE_MASK =         0x01 //col:12189
IA32_VMX_PROCBASED_CTLS2_ENABLE_USER_WAIT_PAUSE(_) =           (((_) >> 26) & 0x01) //col:12190
IA32_VMX_PROCBASED_CTLS2_ENABLE_ENCLV_EXITING_BIT =            28 //col:12203
IA32_VMX_PROCBASED_CTLS2_ENABLE_ENCLV_EXITING_FLAG =           0x10000000 //col:12204
IA32_VMX_PROCBASED_CTLS2_ENABLE_ENCLV_EXITING_MASK =           0x01 //col:12205
IA32_VMX_PROCBASED_CTLS2_ENABLE_ENCLV_EXITING(_) =             (((_) >> 28) & 0x01) //col:12206
IA32_VMX_EPT_VPID_CAP =                                        0x0000048C //col:12222
IA32_VMX_EPT_VPID_CAP_EXECUTE_ONLY_PAGES_BIT =                 0 //col:12233
IA32_VMX_EPT_VPID_CAP_EXECUTE_ONLY_PAGES_FLAG =                0x01 //col:12234
IA32_VMX_EPT_VPID_CAP_EXECUTE_ONLY_PAGES_MASK =                0x01 //col:12235
IA32_VMX_EPT_VPID_CAP_EXECUTE_ONLY_PAGES(_) =                  (((_) >> 0) & 0x01) //col:12236
IA32_VMX_EPT_VPID_CAP_PAGE_WALK_LENGTH_4_BIT =                 6 //col:12243
IA32_VMX_EPT_VPID_CAP_PAGE_WALK_LENGTH_4_FLAG =                0x40 //col:12244
IA32_VMX_EPT_VPID_CAP_PAGE_WALK_LENGTH_4_MASK =                0x01 //col:12245
IA32_VMX_EPT_VPID_CAP_PAGE_WALK_LENGTH_4(_) =                  (((_) >> 6) & 0x01) //col:12246
IA32_VMX_EPT_VPID_CAP_MEMORY_TYPE_UNCACHEABLE_BIT =            8 //col:12256
IA32_VMX_EPT_VPID_CAP_MEMORY_TYPE_UNCACHEABLE_FLAG =           0x100 //col:12257
IA32_VMX_EPT_VPID_CAP_MEMORY_TYPE_UNCACHEABLE_MASK =           0x01 //col:12258
IA32_VMX_EPT_VPID_CAP_MEMORY_TYPE_UNCACHEABLE(_) =             (((_) >> 8) & 0x01) //col:12259
IA32_VMX_EPT_VPID_CAP_MEMORY_TYPE_WRITE_BACK_BIT =             14 //col:12267
IA32_VMX_EPT_VPID_CAP_MEMORY_TYPE_WRITE_BACK_FLAG =            0x4000 //col:12268
IA32_VMX_EPT_VPID_CAP_MEMORY_TYPE_WRITE_BACK_MASK =            0x01 //col:12269
IA32_VMX_EPT_VPID_CAP_MEMORY_TYPE_WRITE_BACK(_) =              (((_) >> 14) & 0x01) //col:12270
IA32_VMX_EPT_VPID_CAP_PDE_2MB_PAGES_BIT =                      16 //col:12278
IA32_VMX_EPT_VPID_CAP_PDE_2MB_PAGES_FLAG =                     0x10000 //col:12279
IA32_VMX_EPT_VPID_CAP_PDE_2MB_PAGES_MASK =                     0x01 //col:12280
IA32_VMX_EPT_VPID_CAP_PDE_2MB_PAGES(_) =                       (((_) >> 16) & 0x01) //col:12281
IA32_VMX_EPT_VPID_CAP_PDPTE_1GB_PAGES_BIT =                    17 //col:12288
IA32_VMX_EPT_VPID_CAP_PDPTE_1GB_PAGES_FLAG =                   0x20000 //col:12289
IA32_VMX_EPT_VPID_CAP_PDPTE_1GB_PAGES_MASK =                   0x01 //col:12290
IA32_VMX_EPT_VPID_CAP_PDPTE_1GB_PAGES(_) =                     (((_) >> 17) & 0x01) //col:12291
IA32_VMX_EPT_VPID_CAP_INVEPT_BIT =                             20 //col:12301
IA32_VMX_EPT_VPID_CAP_INVEPT_FLAG =                            0x100000 //col:12302
IA32_VMX_EPT_VPID_CAP_INVEPT_MASK =                            0x01 //col:12303
IA32_VMX_EPT_VPID_CAP_INVEPT(_) =                              (((_) >> 20) & 0x01) //col:12304
IA32_VMX_EPT_VPID_CAP_EPT_ACCESSED_AND_DIRTY_FLAGS_BIT =       21 //col:12312
IA32_VMX_EPT_VPID_CAP_EPT_ACCESSED_AND_DIRTY_FLAGS_FLAG =      0x200000 //col:12313
IA32_VMX_EPT_VPID_CAP_EPT_ACCESSED_AND_DIRTY_FLAGS_MASK =      0x01 //col:12314
IA32_VMX_EPT_VPID_CAP_EPT_ACCESSED_AND_DIRTY_FLAGS(_) =        (((_) >> 21) & 0x01) //col:12315
IA32_VMX_EPT_VPID_CAP_ADVANCED_VMEXIT_EPT_VIOLATIONS_INFORMATION_BIT = 22 //col:12324
IA32_VMX_EPT_VPID_CAP_ADVANCED_VMEXIT_EPT_VIOLATIONS_INFORMATION_FLAG = 0x400000 //col:12325
IA32_VMX_EPT_VPID_CAP_ADVANCED_VMEXIT_EPT_VIOLATIONS_INFORMATION_MASK = 0x01 //col:12326
IA32_VMX_EPT_VPID_CAP_ADVANCED_VMEXIT_EPT_VIOLATIONS_INFORMATION(_) = (((_) >> 22) & 0x01) //col:12327
IA32_VMX_EPT_VPID_CAP_SUPERVISOR_SHADOW_STACK_BIT =            23 //col:12335
IA32_VMX_EPT_VPID_CAP_SUPERVISOR_SHADOW_STACK_FLAG =           0x800000 //col:12336
IA32_VMX_EPT_VPID_CAP_SUPERVISOR_SHADOW_STACK_MASK =           0x01 //col:12337
IA32_VMX_EPT_VPID_CAP_SUPERVISOR_SHADOW_STACK(_) =             (((_) >> 23) & 0x01) //col:12338
IA32_VMX_EPT_VPID_CAP_INVEPT_SINGLE_CONTEXT_BIT =              25 //col:12348
IA32_VMX_EPT_VPID_CAP_INVEPT_SINGLE_CONTEXT_FLAG =             0x2000000 //col:12349
IA32_VMX_EPT_VPID_CAP_INVEPT_SINGLE_CONTEXT_MASK =             0x01 //col:12350
IA32_VMX_EPT_VPID_CAP_INVEPT_SINGLE_CONTEXT(_) =               (((_) >> 25) & 0x01) //col:12351
IA32_VMX_EPT_VPID_CAP_INVEPT_ALL_CONTEXTS_BIT =                26 //col:12360
IA32_VMX_EPT_VPID_CAP_INVEPT_ALL_CONTEXTS_FLAG =               0x4000000 //col:12361
IA32_VMX_EPT_VPID_CAP_INVEPT_ALL_CONTEXTS_MASK =               0x01 //col:12362
IA32_VMX_EPT_VPID_CAP_INVEPT_ALL_CONTEXTS(_) =                 (((_) >> 26) & 0x01) //col:12363
IA32_VMX_EPT_VPID_CAP_INVVPID_BIT =                            32 //col:12370
IA32_VMX_EPT_VPID_CAP_INVVPID_FLAG =                           0x100000000 //col:12371
IA32_VMX_EPT_VPID_CAP_INVVPID_MASK =                           0x01 //col:12372
IA32_VMX_EPT_VPID_CAP_INVVPID(_) =                             (((_) >> 32) & 0x01) //col:12373
IA32_VMX_EPT_VPID_CAP_INVVPID_INDIVIDUAL_ADDRESS_BIT =         40 //col:12380
IA32_VMX_EPT_VPID_CAP_INVVPID_INDIVIDUAL_ADDRESS_FLAG =        0x10000000000 //col:12381
IA32_VMX_EPT_VPID_CAP_INVVPID_INDIVIDUAL_ADDRESS_MASK =        0x01 //col:12382
IA32_VMX_EPT_VPID_CAP_INVVPID_INDIVIDUAL_ADDRESS(_) =          (((_) >> 40) & 0x01) //col:12383
IA32_VMX_EPT_VPID_CAP_INVVPID_SINGLE_CONTEXT_BIT =             41 //col:12389
IA32_VMX_EPT_VPID_CAP_INVVPID_SINGLE_CONTEXT_FLAG =            0x20000000000 //col:12390
IA32_VMX_EPT_VPID_CAP_INVVPID_SINGLE_CONTEXT_MASK =            0x01 //col:12391
IA32_VMX_EPT_VPID_CAP_INVVPID_SINGLE_CONTEXT(_) =              (((_) >> 41) & 0x01) //col:12392
IA32_VMX_EPT_VPID_CAP_INVVPID_ALL_CONTEXTS_BIT =               42 //col:12398
IA32_VMX_EPT_VPID_CAP_INVVPID_ALL_CONTEXTS_FLAG =              0x40000000000 //col:12399
IA32_VMX_EPT_VPID_CAP_INVVPID_ALL_CONTEXTS_MASK =              0x01 //col:12400
IA32_VMX_EPT_VPID_CAP_INVVPID_ALL_CONTEXTS(_) =                (((_) >> 42) & 0x01) //col:12401
IA32_VMX_EPT_VPID_CAP_INVVPID_SINGLE_CONTEXT_RETAIN_GLOBALS_BIT = 43 //col:12407
IA32_VMX_EPT_VPID_CAP_INVVPID_SINGLE_CONTEXT_RETAIN_GLOBALS_FLAG = 0x80000000000 //col:12408
IA32_VMX_EPT_VPID_CAP_INVVPID_SINGLE_CONTEXT_RETAIN_GLOBALS_MASK = 0x01 //col:12409
IA32_VMX_EPT_VPID_CAP_INVVPID_SINGLE_CONTEXT_RETAIN_GLOBALS(_) = (((_) >> 43) & 0x01) //col:12410
IA32_VMX_EPT_VPID_CAP_MAX_HLAT_PREFIX_SIZE_BIT =               48 //col:12420
IA32_VMX_EPT_VPID_CAP_MAX_HLAT_PREFIX_SIZE_FLAG =              0x3F000000000000 //col:12421
IA32_VMX_EPT_VPID_CAP_MAX_HLAT_PREFIX_SIZE_MASK =              0x3F //col:12422
IA32_VMX_EPT_VPID_CAP_MAX_HLAT_PREFIX_SIZE(_) =                (((_) >> 48) & 0x3F) //col:12423
IA32_VMX_TRUE_PINBASED_CTLS =                                  0x0000048D //col:12448
IA32_VMX_TRUE_PROCBASED_CTLS =                                 0x0000048E //col:12449
IA32_VMX_TRUE_EXIT_CTLS =                                      0x0000048F //col:12450
IA32_VMX_TRUE_ENTRY_CTLS =                                     0x00000490 //col:12451
IA32_VMX_TRUE_CTLS_ALLOWED_0_SETTINGS_BIT =                    0 //col:12461
IA32_VMX_TRUE_CTLS_ALLOWED_0_SETTINGS_FLAG =                   0xFFFFFFFF //col:12462
IA32_VMX_TRUE_CTLS_ALLOWED_0_SETTINGS_MASK =                   0xFFFFFFFF //col:12463
IA32_VMX_TRUE_CTLS_ALLOWED_0_SETTINGS(_) =                     (((_) >> 0) & 0xFFFFFFFF) //col:12464
IA32_VMX_TRUE_CTLS_ALLOWED_1_SETTINGS_BIT =                    32 //col:12471
IA32_VMX_TRUE_CTLS_ALLOWED_1_SETTINGS_FLAG =                   0xFFFFFFFF00000000 //col:12472
IA32_VMX_TRUE_CTLS_ALLOWED_1_SETTINGS_MASK =                   0xFFFFFFFF //col:12473
IA32_VMX_TRUE_CTLS_ALLOWED_1_SETTINGS(_) =                     (((_) >> 32) & 0xFFFFFFFF) //col:12474
IA32_VMX_VMFUNC =                                              0x00000491 //col:12492
IA32_VMX_VMFUNC_EPTP_SWITCHING_BIT =                           0 //col:12503
IA32_VMX_VMFUNC_EPTP_SWITCHING_FLAG =                          0x01 //col:12504
IA32_VMX_VMFUNC_EPTP_SWITCHING_MASK =                          0x01 //col:12505
IA32_VMX_VMFUNC_EPTP_SWITCHING(_) =                            (((_) >> 0) & 0x01) //col:12506
IA32_VMX_PROCBASED_CTLS3 =                                     0x00000492 //col:12521
IA32_VMX_PROCBASED_CTLS3_LOADIWKEY_EXITING_BIT =               0 //col:12532
IA32_VMX_PROCBASED_CTLS3_LOADIWKEY_EXITING_FLAG =              0x01 //col:12533
IA32_VMX_PROCBASED_CTLS3_LOADIWKEY_EXITING_MASK =              0x01 //col:12534
IA32_VMX_PROCBASED_CTLS3_LOADIWKEY_EXITING(_) =                (((_) >> 0) & 0x01) //col:12535
IA32_VMX_PROCBASED_CTLS3_ENABLE_HLAT_BIT =                     1 //col:12545
IA32_VMX_PROCBASED_CTLS3_ENABLE_HLAT_FLAG =                    0x02 //col:12546
IA32_VMX_PROCBASED_CTLS3_ENABLE_HLAT_MASK =                    0x01 //col:12547
IA32_VMX_PROCBASED_CTLS3_ENABLE_HLAT(_) =                      (((_) >> 1) & 0x01) //col:12548
IA32_VMX_PROCBASED_CTLS3_EPT_PAGING_WRITE_BIT =                2 //col:12558
IA32_VMX_PROCBASED_CTLS3_EPT_PAGING_WRITE_FLAG =               0x04 //col:12559
IA32_VMX_PROCBASED_CTLS3_EPT_PAGING_WRITE_MASK =               0x01 //col:12560
IA32_VMX_PROCBASED_CTLS3_EPT_PAGING_WRITE(_) =                 (((_) >> 2) & 0x01) //col:12561
IA32_VMX_PROCBASED_CTLS3_GUEST_PAGING_BIT =                    3 //col:12570
IA32_VMX_PROCBASED_CTLS3_GUEST_PAGING_FLAG =                   0x08 //col:12571
IA32_VMX_PROCBASED_CTLS3_GUEST_PAGING_MASK =                   0x01 //col:12572
IA32_VMX_PROCBASED_CTLS3_GUEST_PAGING(_) =                     (((_) >> 3) & 0x01) //col:12573
IA32_VMX_EXIT_CTLS2 =                                          0x00000493 //col:12588
IA32_VMX_EXIT_CTLS2_RESERVED_BIT =                             0 //col:12594
IA32_VMX_EXIT_CTLS2_RESERVED_FLAG =                            0xFFFFFFFFFFFFFFFF //col:12595
IA32_VMX_EXIT_CTLS2_RESERVED_MASK =                            0xFFFFFFFFFFFFFFFF //col:12596
IA32_VMX_EXIT_CTLS2_RESERVED(_) =                              (((_) >> 0) & 0xFFFFFFFFFFFFFFFF) //col:12597
IA32_A_PMC0 =                                                  0x000004C1 //col:12612
IA32_A_PMC1 =                                                  0x000004C2 //col:12613
IA32_A_PMC2 =                                                  0x000004C3 //col:12614
IA32_A_PMC3 =                                                  0x000004C4 //col:12615
IA32_A_PMC4 =                                                  0x000004C5 //col:12616
IA32_A_PMC5 =                                                  0x000004C6 //col:12617
IA32_A_PMC6 =                                                  0x000004C7 //col:12618
IA32_A_PMC7 =                                                  0x000004C8 //col:12619
IA32_MCG_EXT_CTL =                                             0x000004D0 //col:12631
IA32_MCG_EXT_CTL_LMCE_EN_BIT =                                 0 //col:12637
IA32_MCG_EXT_CTL_LMCE_EN_FLAG =                                0x01 //col:12638
IA32_MCG_EXT_CTL_LMCE_EN_MASK =                                0x01 //col:12639
IA32_MCG_EXT_CTL_LMCE_EN(_) =                                  (((_) >> 0) & 0x01) //col:12640
IA32_SGX_SVN_STATUS =                                          0x00000500 //col:12660
IA32_SGX_SVN_STATUS_LOCK_BIT =                                 0 //col:12675
IA32_SGX_SVN_STATUS_LOCK_FLAG =                                0x01 //col:12676
IA32_SGX_SVN_STATUS_LOCK_MASK =                                0x01 //col:12677
IA32_SGX_SVN_STATUS_LOCK(_) =                                  (((_) >> 0) & 0x01) //col:12678
IA32_SGX_SVN_STATUS_SGX_SVN_SINIT_BIT =                        16 //col:12690
IA32_SGX_SVN_STATUS_SGX_SVN_SINIT_FLAG =                       0xFF0000 //col:12691
IA32_SGX_SVN_STATUS_SGX_SVN_SINIT_MASK =                       0xFF //col:12692
IA32_SGX_SVN_STATUS_SGX_SVN_SINIT(_) =                         (((_) >> 16) & 0xFF) //col:12693
IA32_RTIT_OUTPUT_BASE =                                        0x00000560 //col:12708
IA32_RTIT_OUTPUT_BASE_BASE_PHYSICAL_ADDRESS_BIT =              7 //col:12730
IA32_RTIT_OUTPUT_BASE_BASE_PHYSICAL_ADDRESS_FLAG =             0xFFFFFFFFFF80 //col:12731
IA32_RTIT_OUTPUT_BASE_BASE_PHYSICAL_ADDRESS_MASK =             0x1FFFFFFFFFF //col:12732
IA32_RTIT_OUTPUT_BASE_BASE_PHYSICAL_ADDRESS(_) =               (((_) >> 7) & 0x1FFFFFFFFFF) //col:12733
IA32_RTIT_OUTPUT_MASK_PTRS =                                   0x00000561 //col:12748
IA32_RTIT_OUTPUT_MASK_PTRS_LOWER_MASK_BIT =                    0 //col:12757
IA32_RTIT_OUTPUT_MASK_PTRS_LOWER_MASK_FLAG =                   0x7F //col:12758
IA32_RTIT_OUTPUT_MASK_PTRS_LOWER_MASK_MASK =                   0x7F //col:12759
IA32_RTIT_OUTPUT_MASK_PTRS_LOWER_MASK(_) =                     (((_) >> 0) & 0x7F) //col:12760
IA32_RTIT_OUTPUT_MASK_PTRS_MASK_OR_TABLE_OFFSET_BIT =          7 //col:12779
IA32_RTIT_OUTPUT_MASK_PTRS_MASK_OR_TABLE_OFFSET_FLAG =         0xFFFFFF80 //col:12780
IA32_RTIT_OUTPUT_MASK_PTRS_MASK_OR_TABLE_OFFSET_MASK =         0x1FFFFFF //col:12781
IA32_RTIT_OUTPUT_MASK_PTRS_MASK_OR_TABLE_OFFSET(_) =           (((_) >> 7) & 0x1FFFFFF) //col:12782
IA32_RTIT_OUTPUT_MASK_PTRS_OUTPUT_OFFSET_BIT =                 32 //col:12800
IA32_RTIT_OUTPUT_MASK_PTRS_OUTPUT_OFFSET_FLAG =                0xFFFFFFFF00000000 //col:12801
IA32_RTIT_OUTPUT_MASK_PTRS_OUTPUT_OFFSET_MASK =                0xFFFFFFFF //col:12802
IA32_RTIT_OUTPUT_MASK_PTRS_OUTPUT_OFFSET(_) =                  (((_) >> 32) & 0xFFFFFFFF) //col:12803
IA32_RTIT_CTL =                                                0x00000570 //col:12816
IA32_RTIT_CTL_TRACE_ENABLED_BIT =                              0 //col:12834
IA32_RTIT_CTL_TRACE_ENABLED_FLAG =                             0x01 //col:12835
IA32_RTIT_CTL_TRACE_ENABLED_MASK =                             0x01 //col:12836
IA32_RTIT_CTL_TRACE_ENABLED(_) =                               (((_) >> 0) & 0x01) //col:12837
IA32_RTIT_CTL_CYC_ENABLED_BIT =                                1 //col:12849
IA32_RTIT_CTL_CYC_ENABLED_FLAG =                               0x02 //col:12850
IA32_RTIT_CTL_CYC_ENABLED_MASK =                               0x01 //col:12851
IA32_RTIT_CTL_CYC_ENABLED(_) =                                 (((_) >> 1) & 0x01) //col:12852
IA32_RTIT_CTL_OS_BIT =                                         2 //col:12861
IA32_RTIT_CTL_OS_FLAG =                                        0x04 //col:12862
IA32_RTIT_CTL_OS_MASK =                                        0x01 //col:12863
IA32_RTIT_CTL_OS(_) =                                          (((_) >> 2) & 0x01) //col:12864
IA32_RTIT_CTL_USER_BIT =                                       3 //col:12873
IA32_RTIT_CTL_USER_FLAG =                                      0x08 //col:12874
IA32_RTIT_CTL_USER_MASK =                                      0x01 //col:12875
IA32_RTIT_CTL_USER(_) =                                        (((_) >> 3) & 0x01) //col:12876
IA32_RTIT_CTL_POWER_EVENT_TRACE_ENABLED_BIT =                  4 //col:12887
IA32_RTIT_CTL_POWER_EVENT_TRACE_ENABLED_FLAG =                 0x10 //col:12888
IA32_RTIT_CTL_POWER_EVENT_TRACE_ENABLED_MASK =                 0x01 //col:12889
IA32_RTIT_CTL_POWER_EVENT_TRACE_ENABLED(_) =                   (((_) >> 4) & 0x01) //col:12890
IA32_RTIT_CTL_FUP_ON_PTW_BIT =                                 5 //col:12899
IA32_RTIT_CTL_FUP_ON_PTW_FLAG =                                0x20 //col:12900
IA32_RTIT_CTL_FUP_ON_PTW_MASK =                                0x01 //col:12901
IA32_RTIT_CTL_FUP_ON_PTW(_) =                                  (((_) >> 5) & 0x01) //col:12902
IA32_RTIT_CTL_FABRIC_ENABLED_BIT =                             6 //col:12913
IA32_RTIT_CTL_FABRIC_ENABLED_FLAG =                            0x40 //col:12914
IA32_RTIT_CTL_FABRIC_ENABLED_MASK =                            0x01 //col:12915
IA32_RTIT_CTL_FABRIC_ENABLED(_) =                              (((_) >> 6) & 0x01) //col:12916
IA32_RTIT_CTL_CR3_FILTER_BIT =                                 7 //col:12925
IA32_RTIT_CTL_CR3_FILTER_FLAG =                                0x80 //col:12926
IA32_RTIT_CTL_CR3_FILTER_MASK =                                0x01 //col:12927
IA32_RTIT_CTL_CR3_FILTER(_) =                                  (((_) >> 7) & 0x01) //col:12928
IA32_RTIT_CTL_TOPA_BIT =                                       8 //col:12944
IA32_RTIT_CTL_TOPA_FLAG =                                      0x100 //col:12945
IA32_RTIT_CTL_TOPA_MASK =                                      0x01 //col:12946
IA32_RTIT_CTL_TOPA(_) =                                        (((_) >> 8) & 0x01) //col:12947
IA32_RTIT_CTL_MTC_ENABLED_BIT =                                9 //col:12959
IA32_RTIT_CTL_MTC_ENABLED_FLAG =                               0x200 //col:12960
IA32_RTIT_CTL_MTC_ENABLED_MASK =                               0x01 //col:12961
IA32_RTIT_CTL_MTC_ENABLED(_) =                                 (((_) >> 9) & 0x01) //col:12962
IA32_RTIT_CTL_TSC_ENABLED_BIT =                                10 //col:12973
IA32_RTIT_CTL_TSC_ENABLED_FLAG =                               0x400 //col:12974
IA32_RTIT_CTL_TSC_ENABLED_MASK =                               0x01 //col:12975
IA32_RTIT_CTL_TSC_ENABLED(_) =                                 (((_) >> 10) & 0x01) //col:12976
IA32_RTIT_CTL_RET_COMPRESSION_DISABLED_BIT =                   11 //col:12987
IA32_RTIT_CTL_RET_COMPRESSION_DISABLED_FLAG =                  0x800 //col:12988
IA32_RTIT_CTL_RET_COMPRESSION_DISABLED_MASK =                  0x01 //col:12989
IA32_RTIT_CTL_RET_COMPRESSION_DISABLED(_) =                    (((_) >> 11) & 0x01) //col:12990
IA32_RTIT_CTL_PTW_ENABLED_BIT =                                12 //col:12999
IA32_RTIT_CTL_PTW_ENABLED_FLAG =                               0x1000 //col:13000
IA32_RTIT_CTL_PTW_ENABLED_MASK =                               0x01 //col:13001
IA32_RTIT_CTL_PTW_ENABLED(_) =                                 (((_) >> 12) & 0x01) //col:13002
IA32_RTIT_CTL_BRANCH_ENABLED_BIT =                             13 //col:13013
IA32_RTIT_CTL_BRANCH_ENABLED_FLAG =                            0x2000 //col:13014
IA32_RTIT_CTL_BRANCH_ENABLED_MASK =                            0x01 //col:13015
IA32_RTIT_CTL_BRANCH_ENABLED(_) =                              (((_) >> 13) & 0x01) //col:13016
IA32_RTIT_CTL_MTC_FREQUENCY_BIT =                              14 //col:13030
IA32_RTIT_CTL_MTC_FREQUENCY_FLAG =                             0x3C000 //col:13031
IA32_RTIT_CTL_MTC_FREQUENCY_MASK =                             0x0F //col:13032
IA32_RTIT_CTL_MTC_FREQUENCY(_) =                               (((_) >> 14) & 0x0F) //col:13033
IA32_RTIT_CTL_CYC_THRESHOLD_BIT =                              19 //col:13050
IA32_RTIT_CTL_CYC_THRESHOLD_FLAG =                             0x780000 //col:13051
IA32_RTIT_CTL_CYC_THRESHOLD_MASK =                             0x0F //col:13052
IA32_RTIT_CTL_CYC_THRESHOLD(_) =                               (((_) >> 19) & 0x0F) //col:13053
IA32_RTIT_CTL_PSB_FREQUENCY_BIT =                              24 //col:13070
IA32_RTIT_CTL_PSB_FREQUENCY_FLAG =                             0xF000000 //col:13071
IA32_RTIT_CTL_PSB_FREQUENCY_MASK =                             0x0F //col:13072
IA32_RTIT_CTL_PSB_FREQUENCY(_) =                               (((_) >> 24) & 0x0F) //col:13073
IA32_RTIT_CTL_ADDR0_CFG_BIT =                                  32 //col:13092
IA32_RTIT_CTL_ADDR0_CFG_FLAG =                                 0xF00000000 //col:13093
IA32_RTIT_CTL_ADDR0_CFG_MASK =                                 0x0F //col:13094
IA32_RTIT_CTL_ADDR0_CFG(_) =                                   (((_) >> 32) & 0x0F) //col:13095
IA32_RTIT_CTL_ADDR1_CFG_BIT =                                  36 //col:13113
IA32_RTIT_CTL_ADDR1_CFG_FLAG =                                 0xF000000000 //col:13114
IA32_RTIT_CTL_ADDR1_CFG_MASK =                                 0x0F //col:13115
IA32_RTIT_CTL_ADDR1_CFG(_) =                                   (((_) >> 36) & 0x0F) //col:13116
IA32_RTIT_CTL_ADDR2_CFG_BIT =                                  40 //col:13134
IA32_RTIT_CTL_ADDR2_CFG_FLAG =                                 0xF0000000000 //col:13135
IA32_RTIT_CTL_ADDR2_CFG_MASK =                                 0x0F //col:13136
IA32_RTIT_CTL_ADDR2_CFG(_) =                                   (((_) >> 40) & 0x0F) //col:13137
IA32_RTIT_CTL_ADDR3_CFG_BIT =                                  44 //col:13155
IA32_RTIT_CTL_ADDR3_CFG_FLAG =                                 0xF00000000000 //col:13156
IA32_RTIT_CTL_ADDR3_CFG_MASK =                                 0x0F //col:13157
IA32_RTIT_CTL_ADDR3_CFG(_) =                                   (((_) >> 44) & 0x0F) //col:13158
IA32_RTIT_CTL_INJECT_PSB_PMI_ON_ENABLE_BIT =                   56 //col:13171
IA32_RTIT_CTL_INJECT_PSB_PMI_ON_ENABLE_FLAG =                  0x100000000000000 //col:13172
IA32_RTIT_CTL_INJECT_PSB_PMI_ON_ENABLE_MASK =                  0x01 //col:13173
IA32_RTIT_CTL_INJECT_PSB_PMI_ON_ENABLE(_) =                    (((_) >> 56) & 0x01) //col:13174
IA32_RTIT_STATUS =                                             0x00000571 //col:13187
IA32_RTIT_STATUS_FILTER_ENABLED_BIT =                          0 //col:13202
IA32_RTIT_STATUS_FILTER_ENABLED_FLAG =                         0x01 //col:13203
IA32_RTIT_STATUS_FILTER_ENABLED_MASK =                         0x01 //col:13204
IA32_RTIT_STATUS_FILTER_ENABLED(_) =                           (((_) >> 0) & 0x01) //col:13205
IA32_RTIT_STATUS_CONTEXT_ENABLED_BIT =                         1 //col:13215
IA32_RTIT_STATUS_CONTEXT_ENABLED_FLAG =                        0x02 //col:13216
IA32_RTIT_STATUS_CONTEXT_ENABLED_MASK =                        0x01 //col:13217
IA32_RTIT_STATUS_CONTEXT_ENABLED(_) =                          (((_) >> 1) & 0x01) //col:13218
IA32_RTIT_STATUS_TRIGGER_ENABLED_BIT =                         2 //col:13228
IA32_RTIT_STATUS_TRIGGER_ENABLED_FLAG =                        0x04 //col:13229
IA32_RTIT_STATUS_TRIGGER_ENABLED_MASK =                        0x01 //col:13230
IA32_RTIT_STATUS_TRIGGER_ENABLED(_) =                          (((_) >> 2) & 0x01) //col:13231
IA32_RTIT_STATUS_ERROR_BIT =                                   4 //col:13245
IA32_RTIT_STATUS_ERROR_FLAG =                                  0x10 //col:13246
IA32_RTIT_STATUS_ERROR_MASK =                                  0x01 //col:13247
IA32_RTIT_STATUS_ERROR(_) =                                    (((_) >> 4) & 0x01) //col:13248
IA32_RTIT_STATUS_STOPPED_BIT =                                 5 //col:13261
IA32_RTIT_STATUS_STOPPED_FLAG =                                0x20 //col:13262
IA32_RTIT_STATUS_STOPPED_MASK =                                0x01 //col:13263
IA32_RTIT_STATUS_STOPPED(_) =                                  (((_) >> 5) & 0x01) //col:13264
IA32_RTIT_STATUS_PEND_PSB_BIT =                                6 //col:13277
IA32_RTIT_STATUS_PEND_PSB_FLAG =                               0x40 //col:13278
IA32_RTIT_STATUS_PEND_PSB_MASK =                               0x01 //col:13279
IA32_RTIT_STATUS_PEND_PSB(_) =                                 (((_) >> 6) & 0x01) //col:13280
IA32_RTIT_STATUS_PEND_TOPA_PMI_BIT =                           7 //col:13293
IA32_RTIT_STATUS_PEND_TOPA_PMI_FLAG =                          0x80 //col:13294
IA32_RTIT_STATUS_PEND_TOPA_PMI_MASK =                          0x01 //col:13295
IA32_RTIT_STATUS_PEND_TOPA_PMI(_) =                            (((_) >> 7) & 0x01) //col:13296
IA32_RTIT_STATUS_PACKET_BYTE_COUNT_BIT =                       32 //col:13311
IA32_RTIT_STATUS_PACKET_BYTE_COUNT_FLAG =                      0x1FFFF00000000 //col:13312
IA32_RTIT_STATUS_PACKET_BYTE_COUNT_MASK =                      0x1FFFF //col:13313
IA32_RTIT_STATUS_PACKET_BYTE_COUNT(_) =                        (((_) >> 32) & 0x1FFFF) //col:13314
IA32_RTIT_CR3_MATCH =                                          0x00000572 //col:13332
IA32_RTIT_CR3_MATCH_CR3_VALUE_TO_MATCH_BIT =                   5 //col:13343
IA32_RTIT_CR3_MATCH_CR3_VALUE_TO_MATCH_FLAG =                  0xFFFFFFFFFFFFFFE0 //col:13344
IA32_RTIT_CR3_MATCH_CR3_VALUE_TO_MATCH_MASK =                  0x7FFFFFFFFFFFFFF //col:13345
IA32_RTIT_CR3_MATCH_CR3_VALUE_TO_MATCH(_) =                    (((_) >> 5) & 0x7FFFFFFFFFFFFFF) //col:13346
IA32_RTIT_ADDR0_A =                                            0x00000580 //col:13373
IA32_RTIT_ADDR1_A =                                            0x00000582 //col:13374
IA32_RTIT_ADDR2_A =                                            0x00000584 //col:13375
IA32_RTIT_ADDR3_A =                                            0x00000586 //col:13376
IA32_RTIT_ADDR0_B =                                            0x00000581 //col:13390
IA32_RTIT_ADDR1_B =                                            0x00000583 //col:13391
IA32_RTIT_ADDR2_B =                                            0x00000585 //col:13392
IA32_RTIT_ADDR3_B =                                            0x00000587 //col:13393
IA32_RTIT_ADDR_VIRTUAL_ADDRESS_BIT =                           0 //col:13406
IA32_RTIT_ADDR_VIRTUAL_ADDRESS_FLAG =                          0xFFFFFFFFFFFF //col:13407
IA32_RTIT_ADDR_VIRTUAL_ADDRESS_MASK =                          0xFFFFFFFFFFFF //col:13408
IA32_RTIT_ADDR_VIRTUAL_ADDRESS(_) =                            (((_) >> 0) & 0xFFFFFFFFFFFF) //col:13409
IA32_RTIT_ADDR_SIGN_EXT_VA_BIT =                               48 //col:13415
IA32_RTIT_ADDR_SIGN_EXT_VA_FLAG =                              0xFFFF000000000000 //col:13416
IA32_RTIT_ADDR_SIGN_EXT_VA_MASK =                              0xFFFF //col:13417
IA32_RTIT_ADDR_SIGN_EXT_VA(_) =                                (((_) >> 48) & 0xFFFF) //col:13418
IA32_DS_AREA =                                                 0x00000600 //col:13440
IA32_U_CET =                                                   0x000006A0 //col:13448
IA32_U_CET_SH_STK_EN_BIT =                                     0 //col:13459
IA32_U_CET_SH_STK_EN_FLAG =                                    0x01 //col:13460
IA32_U_CET_SH_STK_EN_MASK =                                    0x01 //col:13461
IA32_U_CET_SH_STK_EN(_) =                                      (((_) >> 0) & 0x01) //col:13462
IA32_U_CET_WR_SHSTK_EN_BIT =                                   1 //col:13470
IA32_U_CET_WR_SHSTK_EN_FLAG =                                  0x02 //col:13471
IA32_U_CET_WR_SHSTK_EN_MASK =                                  0x01 //col:13472
IA32_U_CET_WR_SHSTK_EN(_) =                                    (((_) >> 1) & 0x01) //col:13473
IA32_U_CET_ENDBR_EN_BIT =                                      2 //col:13481
IA32_U_CET_ENDBR_EN_FLAG =                                     0x04 //col:13482
IA32_U_CET_ENDBR_EN_MASK =                                     0x01 //col:13483
IA32_U_CET_ENDBR_EN(_) =                                       (((_) >> 2) & 0x01) //col:13484
IA32_U_CET_LEG_IW_EN_BIT =                                     3 //col:13492
IA32_U_CET_LEG_IW_EN_FLAG =                                    0x08 //col:13493
IA32_U_CET_LEG_IW_EN_MASK =                                    0x01 //col:13494
IA32_U_CET_LEG_IW_EN(_) =                                      (((_) >> 3) & 0x01) //col:13495
IA32_U_CET_NO_TRACK_EN_BIT =                                   4 //col:13503
IA32_U_CET_NO_TRACK_EN_FLAG =                                  0x10 //col:13504
IA32_U_CET_NO_TRACK_EN_MASK =                                  0x01 //col:13505
IA32_U_CET_NO_TRACK_EN(_) =                                    (((_) >> 4) & 0x01) //col:13506
IA32_U_CET_SUPPRESS_DIS_BIT =                                  5 //col:13514
IA32_U_CET_SUPPRESS_DIS_FLAG =                                 0x20 //col:13515
IA32_U_CET_SUPPRESS_DIS_MASK =                                 0x01 //col:13516
IA32_U_CET_SUPPRESS_DIS(_) =                                   (((_) >> 5) & 0x01) //col:13517
IA32_U_CET_SUPPRESS_BIT =                                      10 //col:13527
IA32_U_CET_SUPPRESS_FLAG =                                     0x400 //col:13528
IA32_U_CET_SUPPRESS_MASK =                                     0x01 //col:13529
IA32_U_CET_SUPPRESS(_) =                                       (((_) >> 10) & 0x01) //col:13530
IA32_U_CET_TRACKER_BIT =                                       11 //col:13538
IA32_U_CET_TRACKER_FLAG =                                      0x800 //col:13539
IA32_U_CET_TRACKER_MASK =                                      0x01 //col:13540
IA32_U_CET_TRACKER(_) =                                        (((_) >> 11) & 0x01) //col:13541
IA32_U_CET_EB_LEG_BITMAP_BASE_BIT =                            12 //col:13553
IA32_U_CET_EB_LEG_BITMAP_BASE_FLAG =                           0xFFFFFFFFFFFFF000 //col:13554
IA32_U_CET_EB_LEG_BITMAP_BASE_MASK =                           0xFFFFFFFFFFFFF //col:13555
IA32_U_CET_EB_LEG_BITMAP_BASE(_) =                             (((_) >> 12) & 0xFFFFFFFFFFFFF) //col:13556
IA32_S_CET =                                                   0x000006A2 //col:13569
IA32_S_CET_SH_STK_EN_BIT =                                     0 //col:13580
IA32_S_CET_SH_STK_EN_FLAG =                                    0x01 //col:13581
IA32_S_CET_SH_STK_EN_MASK =                                    0x01 //col:13582
IA32_S_CET_SH_STK_EN(_) =                                      (((_) >> 0) & 0x01) //col:13583
IA32_S_CET_WR_SHSTK_EN_BIT =                                   1 //col:13591
IA32_S_CET_WR_SHSTK_EN_FLAG =                                  0x02 //col:13592
IA32_S_CET_WR_SHSTK_EN_MASK =                                  0x01 //col:13593
IA32_S_CET_WR_SHSTK_EN(_) =                                    (((_) >> 1) & 0x01) //col:13594
IA32_S_CET_ENDBR_EN_BIT =                                      2 //col:13602
IA32_S_CET_ENDBR_EN_FLAG =                                     0x04 //col:13603
IA32_S_CET_ENDBR_EN_MASK =                                     0x01 //col:13604
IA32_S_CET_ENDBR_EN(_) =                                       (((_) >> 2) & 0x01) //col:13605
IA32_S_CET_LEG_IW_EN_BIT =                                     3 //col:13613
IA32_S_CET_LEG_IW_EN_FLAG =                                    0x08 //col:13614
IA32_S_CET_LEG_IW_EN_MASK =                                    0x01 //col:13615
IA32_S_CET_LEG_IW_EN(_) =                                      (((_) >> 3) & 0x01) //col:13616
IA32_S_CET_NO_TRACK_EN_BIT =                                   4 //col:13624
IA32_S_CET_NO_TRACK_EN_FLAG =                                  0x10 //col:13625
IA32_S_CET_NO_TRACK_EN_MASK =                                  0x01 //col:13626
IA32_S_CET_NO_TRACK_EN(_) =                                    (((_) >> 4) & 0x01) //col:13627
IA32_S_CET_SUPPRESS_DIS_BIT =                                  5 //col:13635
IA32_S_CET_SUPPRESS_DIS_FLAG =                                 0x20 //col:13636
IA32_S_CET_SUPPRESS_DIS_MASK =                                 0x01 //col:13637
IA32_S_CET_SUPPRESS_DIS(_) =                                   (((_) >> 5) & 0x01) //col:13638
IA32_S_CET_SUPPRESS_BIT =                                      10 //col:13648
IA32_S_CET_SUPPRESS_FLAG =                                     0x400 //col:13649
IA32_S_CET_SUPPRESS_MASK =                                     0x01 //col:13650
IA32_S_CET_SUPPRESS(_) =                                       (((_) >> 10) & 0x01) //col:13651
IA32_S_CET_TRACKER_BIT =                                       11 //col:13659
IA32_S_CET_TRACKER_FLAG =                                      0x800 //col:13660
IA32_S_CET_TRACKER_MASK =                                      0x01 //col:13661
IA32_S_CET_TRACKER(_) =                                        (((_) >> 11) & 0x01) //col:13662
IA32_S_CET_EB_LEG_BITMAP_BASE_BIT =                            12 //col:13674
IA32_S_CET_EB_LEG_BITMAP_BASE_FLAG =                           0xFFFFFFFFFFFFF000 //col:13675
IA32_S_CET_EB_LEG_BITMAP_BASE_MASK =                           0xFFFFFFFFFFFFF //col:13676
IA32_S_CET_EB_LEG_BITMAP_BASE(_) =                             (((_) >> 12) & 0xFFFFFFFFFFFFF) //col:13677
IA32_PL0_SSP =                                                 0x000006A4 //col:13693
IA32_PL1_SSP =                                                 0x000006A5 //col:13704
IA32_PL2_SSP =                                                 0x000006A6 //col:13715
IA32_PL3_SSP =                                                 0x000006A7 //col:13726
IA32_INTERRUPT_SSP_TABLE_ADDR =                                0x000006A8 //col:13736
IA32_TSC_DEADLINE =                                            0x000006E0 //col:13743
IA32_PM_ENABLE =                                               0x00000770 //col:13750
IA32_PM_ENABLE_HWP_ENABLE_BIT =                                0 //col:13762
IA32_PM_ENABLE_HWP_ENABLE_FLAG =                               0x01 //col:13763
IA32_PM_ENABLE_HWP_ENABLE_MASK =                               0x01 //col:13764
IA32_PM_ENABLE_HWP_ENABLE(_) =                                 (((_) >> 0) & 0x01) //col:13765
IA32_HWP_CAPABILITIES =                                        0x00000771 //col:13778
IA32_HWP_CAPABILITIES_HIGHEST_PERFORMANCE_BIT =                0 //col:13790
IA32_HWP_CAPABILITIES_HIGHEST_PERFORMANCE_FLAG =               0xFF //col:13791
IA32_HWP_CAPABILITIES_HIGHEST_PERFORMANCE_MASK =               0xFF //col:13792
IA32_HWP_CAPABILITIES_HIGHEST_PERFORMANCE(_) =                 (((_) >> 0) & 0xFF) //col:13793
IA32_HWP_CAPABILITIES_GUARANTEED_PERFORMANCE_BIT =             8 //col:13802
IA32_HWP_CAPABILITIES_GUARANTEED_PERFORMANCE_FLAG =            0xFF00 //col:13803
IA32_HWP_CAPABILITIES_GUARANTEED_PERFORMANCE_MASK =            0xFF //col:13804
IA32_HWP_CAPABILITIES_GUARANTEED_PERFORMANCE(_) =              (((_) >> 8) & 0xFF) //col:13805
IA32_HWP_CAPABILITIES_MOST_EFFICIENT_PERFORMANCE_BIT =         16 //col:13814
IA32_HWP_CAPABILITIES_MOST_EFFICIENT_PERFORMANCE_FLAG =        0xFF0000 //col:13815
IA32_HWP_CAPABILITIES_MOST_EFFICIENT_PERFORMANCE_MASK =        0xFF //col:13816
IA32_HWP_CAPABILITIES_MOST_EFFICIENT_PERFORMANCE(_) =          (((_) >> 16) & 0xFF) //col:13817
IA32_HWP_CAPABILITIES_LOWEST_PERFORMANCE_BIT =                 24 //col:13826
IA32_HWP_CAPABILITIES_LOWEST_PERFORMANCE_FLAG =                0xFF000000 //col:13827
IA32_HWP_CAPABILITIES_LOWEST_PERFORMANCE_MASK =                0xFF //col:13828
IA32_HWP_CAPABILITIES_LOWEST_PERFORMANCE(_) =                  (((_) >> 24) & 0xFF) //col:13829
IA32_HWP_REQUEST_PKG =                                         0x00000772 //col:13842
IA32_HWP_REQUEST_PKG_MINIMUM_PERFORMANCE_BIT =                 0 //col:13854
IA32_HWP_REQUEST_PKG_MINIMUM_PERFORMANCE_FLAG =                0xFF //col:13855
IA32_HWP_REQUEST_PKG_MINIMUM_PERFORMANCE_MASK =                0xFF //col:13856
IA32_HWP_REQUEST_PKG_MINIMUM_PERFORMANCE(_) =                  (((_) >> 0) & 0xFF) //col:13857
IA32_HWP_REQUEST_PKG_MAXIMUM_PERFORMANCE_BIT =                 8 //col:13866
IA32_HWP_REQUEST_PKG_MAXIMUM_PERFORMANCE_FLAG =                0xFF00 //col:13867
IA32_HWP_REQUEST_PKG_MAXIMUM_PERFORMANCE_MASK =                0xFF //col:13868
IA32_HWP_REQUEST_PKG_MAXIMUM_PERFORMANCE(_) =                  (((_) >> 8) & 0xFF) //col:13869
IA32_HWP_REQUEST_PKG_DESIRED_PERFORMANCE_BIT =                 16 //col:13878
IA32_HWP_REQUEST_PKG_DESIRED_PERFORMANCE_FLAG =                0xFF0000 //col:13879
IA32_HWP_REQUEST_PKG_DESIRED_PERFORMANCE_MASK =                0xFF //col:13880
IA32_HWP_REQUEST_PKG_DESIRED_PERFORMANCE(_) =                  (((_) >> 16) & 0xFF) //col:13881
IA32_HWP_REQUEST_PKG_ENERGY_PERFORMANCE_PREFERENCE_BIT =       24 //col:13890
IA32_HWP_REQUEST_PKG_ENERGY_PERFORMANCE_PREFERENCE_FLAG =      0xFF000000 //col:13891
IA32_HWP_REQUEST_PKG_ENERGY_PERFORMANCE_PREFERENCE_MASK =      0xFF //col:13892
IA32_HWP_REQUEST_PKG_ENERGY_PERFORMANCE_PREFERENCE(_) =        (((_) >> 24) & 0xFF) //col:13893
IA32_HWP_REQUEST_PKG_ACTIVITY_WINDOW_BIT =                     32 //col:13902
IA32_HWP_REQUEST_PKG_ACTIVITY_WINDOW_FLAG =                    0x3FF00000000 //col:13903
IA32_HWP_REQUEST_PKG_ACTIVITY_WINDOW_MASK =                    0x3FF //col:13904
IA32_HWP_REQUEST_PKG_ACTIVITY_WINDOW(_) =                      (((_) >> 32) & 0x3FF) //col:13905
IA32_HWP_INTERRUPT =                                           0x00000773 //col:13918
IA32_HWP_INTERRUPT_EN_GUARANTEED_PERFORMANCE_CHANGE_BIT =      0 //col:13930
IA32_HWP_INTERRUPT_EN_GUARANTEED_PERFORMANCE_CHANGE_FLAG =     0x01 //col:13931
IA32_HWP_INTERRUPT_EN_GUARANTEED_PERFORMANCE_CHANGE_MASK =     0x01 //col:13932
IA32_HWP_INTERRUPT_EN_GUARANTEED_PERFORMANCE_CHANGE(_) =       (((_) >> 0) & 0x01) //col:13933
IA32_HWP_INTERRUPT_EN_EXCURSION_MINIMUM_BIT =                  1 //col:13942
IA32_HWP_INTERRUPT_EN_EXCURSION_MINIMUM_FLAG =                 0x02 //col:13943
IA32_HWP_INTERRUPT_EN_EXCURSION_MINIMUM_MASK =                 0x01 //col:13944
IA32_HWP_INTERRUPT_EN_EXCURSION_MINIMUM(_) =                   (((_) >> 1) & 0x01) //col:13945
IA32_HWP_REQUEST =                                             0x00000774 //col:13958
IA32_HWP_REQUEST_MINIMUM_PERFORMANCE_BIT =                     0 //col:13970
IA32_HWP_REQUEST_MINIMUM_PERFORMANCE_FLAG =                    0xFF //col:13971
IA32_HWP_REQUEST_MINIMUM_PERFORMANCE_MASK =                    0xFF //col:13972
IA32_HWP_REQUEST_MINIMUM_PERFORMANCE(_) =                      (((_) >> 0) & 0xFF) //col:13973
IA32_HWP_REQUEST_MAXIMUM_PERFORMANCE_BIT =                     8 //col:13982
IA32_HWP_REQUEST_MAXIMUM_PERFORMANCE_FLAG =                    0xFF00 //col:13983
IA32_HWP_REQUEST_MAXIMUM_PERFORMANCE_MASK =                    0xFF //col:13984
IA32_HWP_REQUEST_MAXIMUM_PERFORMANCE(_) =                      (((_) >> 8) & 0xFF) //col:13985
IA32_HWP_REQUEST_DESIRED_PERFORMANCE_BIT =                     16 //col:13994
IA32_HWP_REQUEST_DESIRED_PERFORMANCE_FLAG =                    0xFF0000 //col:13995
IA32_HWP_REQUEST_DESIRED_PERFORMANCE_MASK =                    0xFF //col:13996
IA32_HWP_REQUEST_DESIRED_PERFORMANCE(_) =                      (((_) >> 16) & 0xFF) //col:13997
IA32_HWP_REQUEST_ENERGY_PERFORMANCE_PREFERENCE_BIT =           24 //col:14006
IA32_HWP_REQUEST_ENERGY_PERFORMANCE_PREFERENCE_FLAG =          0xFF000000 //col:14007
IA32_HWP_REQUEST_ENERGY_PERFORMANCE_PREFERENCE_MASK =          0xFF //col:14008
IA32_HWP_REQUEST_ENERGY_PERFORMANCE_PREFERENCE(_) =            (((_) >> 24) & 0xFF) //col:14009
IA32_HWP_REQUEST_ACTIVITY_WINDOW_BIT =                         32 //col:14018
IA32_HWP_REQUEST_ACTIVITY_WINDOW_FLAG =                        0x3FF00000000 //col:14019
IA32_HWP_REQUEST_ACTIVITY_WINDOW_MASK =                        0x3FF //col:14020
IA32_HWP_REQUEST_ACTIVITY_WINDOW(_) =                          (((_) >> 32) & 0x3FF) //col:14021
IA32_HWP_REQUEST_PACKAGE_CONTROL_BIT =                         42 //col:14030
IA32_HWP_REQUEST_PACKAGE_CONTROL_FLAG =                        0x40000000000 //col:14031
IA32_HWP_REQUEST_PACKAGE_CONTROL_MASK =                        0x01 //col:14032
IA32_HWP_REQUEST_PACKAGE_CONTROL(_) =                          (((_) >> 42) & 0x01) //col:14033
IA32_HWP_STATUS =                                              0x00000777 //col:14046
IA32_HWP_STATUS_GUARANTEED_PERFORMANCE_CHANGE_BIT =            0 //col:14058
IA32_HWP_STATUS_GUARANTEED_PERFORMANCE_CHANGE_FLAG =           0x01 //col:14059
IA32_HWP_STATUS_GUARANTEED_PERFORMANCE_CHANGE_MASK =           0x01 //col:14060
IA32_HWP_STATUS_GUARANTEED_PERFORMANCE_CHANGE(_) =             (((_) >> 0) & 0x01) //col:14061
IA32_HWP_STATUS_EXCURSION_TO_MINIMUM_BIT =                     2 //col:14071
IA32_HWP_STATUS_EXCURSION_TO_MINIMUM_FLAG =                    0x04 //col:14072
IA32_HWP_STATUS_EXCURSION_TO_MINIMUM_MASK =                    0x01 //col:14073
IA32_HWP_STATUS_EXCURSION_TO_MINIMUM(_) =                      (((_) >> 2) & 0x01) //col:14074
IA32_X2APIC_APICID =                                           0x00000802 //col:14088
IA32_X2APIC_VERSION =                                          0x00000803 //col:14095
IA32_X2APIC_TPR =                                              0x00000808 //col:14102
IA32_X2APIC_PPR =                                              0x0000080A //col:14109
IA32_X2APIC_EOI =                                              0x0000080B //col:14116
IA32_X2APIC_LDR =                                              0x0000080D //col:14123
IA32_X2APIC_SIVR =                                             0x0000080F //col:14130
IA32_X2APIC_ISR0 =                                             0x00000810 //col:14140
IA32_X2APIC_ISR1 =                                             0x00000811 //col:14141
IA32_X2APIC_ISR2 =                                             0x00000812 //col:14142
IA32_X2APIC_ISR3 =                                             0x00000813 //col:14143
IA32_X2APIC_ISR4 =                                             0x00000814 //col:14144
IA32_X2APIC_ISR5 =                                             0x00000815 //col:14145
IA32_X2APIC_ISR6 =                                             0x00000816 //col:14146
IA32_X2APIC_ISR7 =                                             0x00000817 //col:14147
IA32_X2APIC_TMR0 =                                             0x00000818 //col:14161
IA32_X2APIC_TMR1 =                                             0x00000819 //col:14162
IA32_X2APIC_TMR2 =                                             0x0000081A //col:14163
IA32_X2APIC_TMR3 =                                             0x0000081B //col:14164
IA32_X2APIC_TMR4 =                                             0x0000081C //col:14165
IA32_X2APIC_TMR5 =                                             0x0000081D //col:14166
IA32_X2APIC_TMR6 =                                             0x0000081E //col:14167
IA32_X2APIC_TMR7 =                                             0x0000081F //col:14168
IA32_X2APIC_IRR0 =                                             0x00000820 //col:14182
IA32_X2APIC_IRR1 =                                             0x00000821 //col:14183
IA32_X2APIC_IRR2 =                                             0x00000822 //col:14184
IA32_X2APIC_IRR3 =                                             0x00000823 //col:14185
IA32_X2APIC_IRR4 =                                             0x00000824 //col:14186
IA32_X2APIC_IRR5 =                                             0x00000825 //col:14187
IA32_X2APIC_IRR6 =                                             0x00000826 //col:14188
IA32_X2APIC_IRR7 =                                             0x00000827 //col:14189
IA32_X2APIC_ESR =                                              0x00000828 //col:14200
IA32_X2APIC_LVT_CMCI =                                         0x0000082F //col:14207
IA32_X2APIC_ICR =                                              0x00000830 //col:14214
IA32_X2APIC_LVT_TIMER =                                        0x00000832 //col:14221
IA32_X2APIC_LVT_THERMAL =                                      0x00000833 //col:14228
IA32_X2APIC_LVT_PMI =                                          0x00000834 //col:14235
IA32_X2APIC_LVT_LINT0 =                                        0x00000835 //col:14242
IA32_X2APIC_LVT_LINT1 =                                        0x00000836 //col:14249
IA32_X2APIC_LVT_ERROR =                                        0x00000837 //col:14256
IA32_X2APIC_INIT_COUNT =                                       0x00000838 //col:14263
IA32_X2APIC_CUR_COUNT =                                        0x00000839 //col:14270
IA32_X2APIC_DIV_CONF =                                         0x0000083E //col:14277
IA32_X2APIC_SELF_IPI =                                         0x0000083F //col:14284
IA32_DEBUG_INTERFACE =                                         0x00000C80 //col:14291
IA32_DEBUG_INTERFACE_ENABLE_BIT =                              0 //col:14304
IA32_DEBUG_INTERFACE_ENABLE_FLAG =                             0x01 //col:14305
IA32_DEBUG_INTERFACE_ENABLE_MASK =                             0x01 //col:14306
IA32_DEBUG_INTERFACE_ENABLE(_) =                               (((_) >> 0) & 0x01) //col:14307
IA32_DEBUG_INTERFACE_LOCK_BIT =                                30 //col:14319
IA32_DEBUG_INTERFACE_LOCK_FLAG =                               0x40000000 //col:14320
IA32_DEBUG_INTERFACE_LOCK_MASK =                               0x01 //col:14321
IA32_DEBUG_INTERFACE_LOCK(_) =                                 (((_) >> 30) & 0x01) //col:14322
IA32_DEBUG_INTERFACE_DEBUG_OCCURRED_BIT =                      31 //col:14332
IA32_DEBUG_INTERFACE_DEBUG_OCCURRED_FLAG =                     0x80000000 //col:14333
IA32_DEBUG_INTERFACE_DEBUG_OCCURRED_MASK =                     0x01 //col:14334
IA32_DEBUG_INTERFACE_DEBUG_OCCURRED(_) =                       (((_) >> 31) & 0x01) //col:14335
IA32_L3_QOS_CFG =                                              0x00000C81 //col:14348
IA32_L3_QOS_CFG_ENABLE_BIT =                                   0 //col:14359
IA32_L3_QOS_CFG_ENABLE_FLAG =                                  0x01 //col:14360
IA32_L3_QOS_CFG_ENABLE_MASK =                                  0x01 //col:14361
IA32_L3_QOS_CFG_ENABLE(_) =                                    (((_) >> 0) & 0x01) //col:14362
IA32_L2_QOS_CFG =                                              0x00000C82 //col:14375
IA32_L2_QOS_CFG_ENABLE_BIT =                                   0 //col:14386
IA32_L2_QOS_CFG_ENABLE_FLAG =                                  0x01 //col:14387
IA32_L2_QOS_CFG_ENABLE_MASK =                                  0x01 //col:14388
IA32_L2_QOS_CFG_ENABLE(_) =                                    (((_) >> 0) & 0x01) //col:14389
IA32_QM_EVTSEL =                                               0x00000C8D //col:14402
IA32_QM_EVTSEL_EVENT_ID_BIT =                                  0 //col:14413
IA32_QM_EVTSEL_EVENT_ID_FLAG =                                 0xFF //col:14414
IA32_QM_EVTSEL_EVENT_ID_MASK =                                 0xFF //col:14415
IA32_QM_EVTSEL_EVENT_ID(_) =                                   (((_) >> 0) & 0xFF) //col:14416
IA32_QM_EVTSEL_RESOURCE_MONITORING_ID_BIT =                    32 //col:14427
IA32_QM_EVTSEL_RESOURCE_MONITORING_ID_FLAG =                   0xFFFFFFFF00000000 //col:14428
IA32_QM_EVTSEL_RESOURCE_MONITORING_ID_MASK =                   0xFFFFFFFF //col:14429
IA32_QM_EVTSEL_RESOURCE_MONITORING_ID(_) =                     (((_) >> 32) & 0xFFFFFFFF) //col:14430
IA32_QM_CTR =                                                  0x00000C8E //col:14442
IA32_QM_CTR_RESOURCE_MONITORED_DATA_BIT =                      0 //col:14451
IA32_QM_CTR_RESOURCE_MONITORED_DATA_FLAG =                     0x3FFFFFFFFFFFFFFF //col:14452
IA32_QM_CTR_RESOURCE_MONITORED_DATA_MASK =                     0x3FFFFFFFFFFFFFFF //col:14453
IA32_QM_CTR_RESOURCE_MONITORED_DATA(_) =                       (((_) >> 0) & 0x3FFFFFFFFFFFFFFF) //col:14454
IA32_QM_CTR_UNAVAILABLE_BIT =                                  62 //col:14462
IA32_QM_CTR_UNAVAILABLE_FLAG =                                 0x4000000000000000 //col:14463
IA32_QM_CTR_UNAVAILABLE_MASK =                                 0x01 //col:14464
IA32_QM_CTR_UNAVAILABLE(_) =                                   (((_) >> 62) & 0x01) //col:14465
IA32_QM_CTR_ERROR_BIT =                                        63 //col:14473
IA32_QM_CTR_ERROR_FLAG =                                       0x8000000000000000 //col:14474
IA32_QM_CTR_ERROR_MASK =                                       0x01 //col:14475
IA32_QM_CTR_ERROR(_) =                                         (((_) >> 63) & 0x01) //col:14476
IA32_PQR_ASSOC =                                               0x00000C8F //col:14488
IA32_PQR_ASSOC_RESOURCE_MONITORING_ID_BIT =                    0 //col:14501
IA32_PQR_ASSOC_RESOURCE_MONITORING_ID_FLAG =                   0xFFFFFFFF //col:14502
IA32_PQR_ASSOC_RESOURCE_MONITORING_ID_MASK =                   0xFFFFFFFF //col:14503
IA32_PQR_ASSOC_RESOURCE_MONITORING_ID(_) =                     (((_) >> 0) & 0xFFFFFFFF) //col:14504
IA32_PQR_ASSOC_COS_BIT =                                       32 //col:14514
IA32_PQR_ASSOC_COS_FLAG =                                      0xFFFFFFFF00000000 //col:14515
IA32_PQR_ASSOC_COS_MASK =                                      0xFFFFFFFF //col:14516
IA32_PQR_ASSOC_COS(_) =                                        (((_) >> 32) & 0xFFFFFFFF) //col:14517
IA32_BNDCFGS =                                                 0x00000D90 //col:14529
IA32_BNDCFGS_ENABLE_BIT =                                      0 //col:14538
IA32_BNDCFGS_ENABLE_FLAG =                                     0x01 //col:14539
IA32_BNDCFGS_ENABLE_MASK =                                     0x01 //col:14540
IA32_BNDCFGS_ENABLE(_) =                                       (((_) >> 0) & 0x01) //col:14541
IA32_BNDCFGS_BND_PRESERVE_BIT =                                1 //col:14547
IA32_BNDCFGS_BND_PRESERVE_FLAG =                               0x02 //col:14548
IA32_BNDCFGS_BND_PRESERVE_MASK =                               0x01 //col:14549
IA32_BNDCFGS_BND_PRESERVE(_) =                                 (((_) >> 1) & 0x01) //col:14550
IA32_BNDCFGS_BOUND_DIRECTORY_BASE_ADDRESS_BIT =                12 //col:14557
IA32_BNDCFGS_BOUND_DIRECTORY_BASE_ADDRESS_FLAG =               0xFFFFFFFFFFFFF000 //col:14558
IA32_BNDCFGS_BOUND_DIRECTORY_BASE_ADDRESS_MASK =               0xFFFFFFFFFFFFF //col:14559
IA32_BNDCFGS_BOUND_DIRECTORY_BASE_ADDRESS(_) =                 (((_) >> 12) & 0xFFFFFFFFFFFFF) //col:14560
IA32_XSS =                                                     0x00000DA0 //col:14572
IA32_XSS_TRACE_PACKET_CONFIGURATION_STATE_BIT =                8 //col:14583
IA32_XSS_TRACE_PACKET_CONFIGURATION_STATE_FLAG =               0x100 //col:14584
IA32_XSS_TRACE_PACKET_CONFIGURATION_STATE_MASK =               0x01 //col:14585
IA32_XSS_TRACE_PACKET_CONFIGURATION_STATE(_) =                 (((_) >> 8) & 0x01) //col:14586
IA32_PKG_HDC_CTL =                                             0x00000DB0 //col:14599
IA32_PKG_HDC_CTL_HDC_PKG_ENABLE_BIT =                          0 //col:14613
IA32_PKG_HDC_CTL_HDC_PKG_ENABLE_FLAG =                         0x01 //col:14614
IA32_PKG_HDC_CTL_HDC_PKG_ENABLE_MASK =                         0x01 //col:14615
IA32_PKG_HDC_CTL_HDC_PKG_ENABLE(_) =                           (((_) >> 0) & 0x01) //col:14616
IA32_PM_CTL1 =                                                 0x00000DB1 //col:14629
IA32_PM_CTL1_HDC_ALLOW_BLOCK_BIT =                             0 //col:14643
IA32_PM_CTL1_HDC_ALLOW_BLOCK_FLAG =                            0x01 //col:14644
IA32_PM_CTL1_HDC_ALLOW_BLOCK_MASK =                            0x01 //col:14645
IA32_PM_CTL1_HDC_ALLOW_BLOCK(_) =                              (((_) >> 0) & 0x01) //col:14646
IA32_THREAD_STALL =                                            0x00000DB2 //col:14659
IA32_EFER =                                                    0xC0000080 //col:14679
IA32_EFER_SYSCALL_ENABLE_BIT =                                 0 //col:14690
IA32_EFER_SYSCALL_ENABLE_FLAG =                                0x01 //col:14691
IA32_EFER_SYSCALL_ENABLE_MASK =                                0x01 //col:14692
IA32_EFER_SYSCALL_ENABLE(_) =                                  (((_) >> 0) & 0x01) //col:14693
IA32_EFER_IA32E_MODE_ENABLE_BIT =                              8 //col:14702
IA32_EFER_IA32E_MODE_ENABLE_FLAG =                             0x100 //col:14703
IA32_EFER_IA32E_MODE_ENABLE_MASK =                             0x01 //col:14704
IA32_EFER_IA32E_MODE_ENABLE(_) =                               (((_) >> 8) & 0x01) //col:14705
IA32_EFER_IA32E_MODE_ACTIVE_BIT =                              10 //col:14714
IA32_EFER_IA32E_MODE_ACTIVE_FLAG =                             0x400 //col:14715
IA32_EFER_IA32E_MODE_ACTIVE_MASK =                             0x01 //col:14716
IA32_EFER_IA32E_MODE_ACTIVE(_) =                               (((_) >> 10) & 0x01) //col:14717
IA32_EFER_EXECUTE_DISABLE_BIT_ENABLE_BIT =                     11 //col:14723
IA32_EFER_EXECUTE_DISABLE_BIT_ENABLE_FLAG =                    0x800 //col:14724
IA32_EFER_EXECUTE_DISABLE_BIT_ENABLE_MASK =                    0x01 //col:14725
IA32_EFER_EXECUTE_DISABLE_BIT_ENABLE(_) =                      (((_) >> 11) & 0x01) //col:14726
IA32_STAR =                                                    0xC0000081 //col:14739
IA32_LSTAR =                                                   0xC0000082 //col:14748
IA32_CSTAR =                                                   0xC0000083 //col:14757
IA32_FMASK =                                                   0xC0000084 //col:14764
IA32_FS_BASE =                                                 0xC0000100 //col:14771
IA32_GS_BASE =                                                 0xC0000101 //col:14778
IA32_KERNEL_GS_BASE =                                          0xC0000102 //col:14785
IA32_TSC_AUX =                                                 0xC0000103 //col:14792
IA32_TSC_AUX_TSC_AUXILIARY_SIGNATURE_BIT =                     0 //col:14801
IA32_TSC_AUX_TSC_AUXILIARY_SIGNATURE_FLAG =                    0xFFFFFFFF //col:14802
IA32_TSC_AUX_TSC_AUXILIARY_SIGNATURE_MASK =                    0xFFFFFFFF //col:14803
IA32_TSC_AUX_TSC_AUXILIARY_SIGNATURE(_) =                      (((_) >> 0) & 0xFFFFFFFF) //col:14804
PDE_4MB_32_PRESENT_BIT =                                       0 //col:14845
PDE_4MB_32_PRESENT_FLAG =                                      0x01 //col:14846
PDE_4MB_32_PRESENT_MASK =                                      0x01 //col:14847
PDE_4MB_32_PRESENT(_) =                                        (((_) >> 0) & 0x01) //col:14848
PDE_4MB_32_WRITE_BIT =                                         1 //col:14856
PDE_4MB_32_WRITE_FLAG =                                        0x02 //col:14857
PDE_4MB_32_WRITE_MASK =                                        0x01 //col:14858
PDE_4MB_32_WRITE(_) =                                          (((_) >> 1) & 0x01) //col:14859
PDE_4MB_32_SUPERVISOR_BIT =                                    2 //col:14867
PDE_4MB_32_SUPERVISOR_FLAG =                                   0x04 //col:14868
PDE_4MB_32_SUPERVISOR_MASK =                                   0x01 //col:14869
PDE_4MB_32_SUPERVISOR(_) =                                     (((_) >> 2) & 0x01) //col:14870
PDE_4MB_32_PAGE_LEVEL_WRITE_THROUGH_BIT =                      3 //col:14879
PDE_4MB_32_PAGE_LEVEL_WRITE_THROUGH_FLAG =                     0x08 //col:14880
PDE_4MB_32_PAGE_LEVEL_WRITE_THROUGH_MASK =                     0x01 //col:14881
PDE_4MB_32_PAGE_LEVEL_WRITE_THROUGH(_) =                       (((_) >> 3) & 0x01) //col:14882
PDE_4MB_32_PAGE_LEVEL_CACHE_DISABLE_BIT =                      4 //col:14891
PDE_4MB_32_PAGE_LEVEL_CACHE_DISABLE_FLAG =                     0x10 //col:14892
PDE_4MB_32_PAGE_LEVEL_CACHE_DISABLE_MASK =                     0x01 //col:14893
PDE_4MB_32_PAGE_LEVEL_CACHE_DISABLE(_) =                       (((_) >> 4) & 0x01) //col:14894
PDE_4MB_32_ACCESSED_BIT =                                      5 //col:14902
PDE_4MB_32_ACCESSED_FLAG =                                     0x20 //col:14903
PDE_4MB_32_ACCESSED_MASK =                                     0x01 //col:14904
PDE_4MB_32_ACCESSED(_) =                                       (((_) >> 5) & 0x01) //col:14905
PDE_4MB_32_DIRTY_BIT =                                         6 //col:14913
PDE_4MB_32_DIRTY_FLAG =                                        0x40 //col:14914
PDE_4MB_32_DIRTY_MASK =                                        0x01 //col:14915
PDE_4MB_32_DIRTY(_) =                                          (((_) >> 6) & 0x01) //col:14916
PDE_4MB_32_LARGE_PAGE_BIT =                                    7 //col:14922
PDE_4MB_32_LARGE_PAGE_FLAG =                                   0x80 //col:14923
PDE_4MB_32_LARGE_PAGE_MASK =                                   0x01 //col:14924
PDE_4MB_32_LARGE_PAGE(_) =                                     (((_) >> 7) & 0x01) //col:14925
PDE_4MB_32_GLOBAL_BIT =                                        8 //col:14933
PDE_4MB_32_GLOBAL_FLAG =                                       0x100 //col:14934
PDE_4MB_32_GLOBAL_MASK =                                       0x01 //col:14935
PDE_4MB_32_GLOBAL(_) =                                         (((_) >> 8) & 0x01) //col:14936
PDE_4MB_32_IGNORED_1_BIT =                                     9 //col:14942
PDE_4MB_32_IGNORED_1_FLAG =                                    0xE00 //col:14943
PDE_4MB_32_IGNORED_1_MASK =                                    0x07 //col:14944
PDE_4MB_32_IGNORED_1(_) =                                      (((_) >> 9) & 0x07) //col:14945
PDE_4MB_32_PAT_BIT =                                           12 //col:14953
PDE_4MB_32_PAT_FLAG =                                          0x1000 //col:14954
PDE_4MB_32_PAT_MASK =                                          0x01 //col:14955
PDE_4MB_32_PAT(_) =                                            (((_) >> 12) & 0x01) //col:14956
PDE_4MB_32_PAGE_FRAME_NUMBER_LOW_BIT =                         13 //col:14962
PDE_4MB_32_PAGE_FRAME_NUMBER_LOW_FLAG =                        0x1FE000 //col:14963
PDE_4MB_32_PAGE_FRAME_NUMBER_LOW_MASK =                        0xFF //col:14964
PDE_4MB_32_PAGE_FRAME_NUMBER_LOW(_) =                          (((_) >> 13) & 0xFF) //col:14965
PDE_4MB_32_PAGE_FRAME_NUMBER_HIGH_BIT =                        22 //col:14972
PDE_4MB_32_PAGE_FRAME_NUMBER_HIGH_FLAG =                       0xFFC00000 //col:14973
PDE_4MB_32_PAGE_FRAME_NUMBER_HIGH_MASK =                       0x3FF //col:14974
PDE_4MB_32_PAGE_FRAME_NUMBER_HIGH(_) =                         (((_) >> 22) & 0x3FF) //col:14975
PDE_32_PRESENT_BIT =                                           0 //col:14992
PDE_32_PRESENT_FLAG =                                          0x01 //col:14993
PDE_32_PRESENT_MASK =                                          0x01 //col:14994
PDE_32_PRESENT(_) =                                            (((_) >> 0) & 0x01) //col:14995
PDE_32_WRITE_BIT =                                             1 //col:15003
PDE_32_WRITE_FLAG =                                            0x02 //col:15004
PDE_32_WRITE_MASK =                                            0x01 //col:15005
PDE_32_WRITE(_) =                                              (((_) >> 1) & 0x01) //col:15006
PDE_32_SUPERVISOR_BIT =                                        2 //col:15014
PDE_32_SUPERVISOR_FLAG =                                       0x04 //col:15015
PDE_32_SUPERVISOR_MASK =                                       0x01 //col:15016
PDE_32_SUPERVISOR(_) =                                         (((_) >> 2) & 0x01) //col:15017
PDE_32_PAGE_LEVEL_WRITE_THROUGH_BIT =                          3 //col:15026
PDE_32_PAGE_LEVEL_WRITE_THROUGH_FLAG =                         0x08 //col:15027
PDE_32_PAGE_LEVEL_WRITE_THROUGH_MASK =                         0x01 //col:15028
PDE_32_PAGE_LEVEL_WRITE_THROUGH(_) =                           (((_) >> 3) & 0x01) //col:15029
PDE_32_PAGE_LEVEL_CACHE_DISABLE_BIT =                          4 //col:15038
PDE_32_PAGE_LEVEL_CACHE_DISABLE_FLAG =                         0x10 //col:15039
PDE_32_PAGE_LEVEL_CACHE_DISABLE_MASK =                         0x01 //col:15040
PDE_32_PAGE_LEVEL_CACHE_DISABLE(_) =                           (((_) >> 4) & 0x01) //col:15041
PDE_32_ACCESSED_BIT =                                          5 //col:15049
PDE_32_ACCESSED_FLAG =                                         0x20 //col:15050
PDE_32_ACCESSED_MASK =                                         0x01 //col:15051
PDE_32_ACCESSED(_) =                                           (((_) >> 5) & 0x01) //col:15052
PDE_32_IGNORED_1_BIT =                                         6 //col:15058
PDE_32_IGNORED_1_FLAG =                                        0x40 //col:15059
PDE_32_IGNORED_1_MASK =                                        0x01 //col:15060
PDE_32_IGNORED_1(_) =                                          (((_) >> 6) & 0x01) //col:15061
PDE_32_LARGE_PAGE_BIT =                                        7 //col:15067
PDE_32_LARGE_PAGE_FLAG =                                       0x80 //col:15068
PDE_32_LARGE_PAGE_MASK =                                       0x01 //col:15069
PDE_32_LARGE_PAGE(_) =                                         (((_) >> 7) & 0x01) //col:15070
PDE_32_IGNORED_2_BIT =                                         8 //col:15076
PDE_32_IGNORED_2_FLAG =                                        0xF00 //col:15077
PDE_32_IGNORED_2_MASK =                                        0x0F //col:15078
PDE_32_IGNORED_2(_) =                                          (((_) >> 8) & 0x0F) //col:15079
PDE_32_PAGE_FRAME_NUMBER_BIT =                                 12 //col:15085
PDE_32_PAGE_FRAME_NUMBER_FLAG =                                0xFFFFF000 //col:15086
PDE_32_PAGE_FRAME_NUMBER_MASK =                                0xFFFFF //col:15087
PDE_32_PAGE_FRAME_NUMBER(_) =                                  (((_) >> 12) & 0xFFFFF) //col:15088
PTE_32_PRESENT_BIT =                                           0 //col:15105
PTE_32_PRESENT_FLAG =                                          0x01 //col:15106
PTE_32_PRESENT_MASK =                                          0x01 //col:15107
PTE_32_PRESENT(_) =                                            (((_) >> 0) & 0x01) //col:15108
PTE_32_WRITE_BIT =                                             1 //col:15116
PTE_32_WRITE_FLAG =                                            0x02 //col:15117
PTE_32_WRITE_MASK =                                            0x01 //col:15118
PTE_32_WRITE(_) =                                              (((_) >> 1) & 0x01) //col:15119
PTE_32_SUPERVISOR_BIT =                                        2 //col:15127
PTE_32_SUPERVISOR_FLAG =                                       0x04 //col:15128
PTE_32_SUPERVISOR_MASK =                                       0x01 //col:15129
PTE_32_SUPERVISOR(_) =                                         (((_) >> 2) & 0x01) //col:15130
PTE_32_PAGE_LEVEL_WRITE_THROUGH_BIT =                          3 //col:15139
PTE_32_PAGE_LEVEL_WRITE_THROUGH_FLAG =                         0x08 //col:15140
PTE_32_PAGE_LEVEL_WRITE_THROUGH_MASK =                         0x01 //col:15141
PTE_32_PAGE_LEVEL_WRITE_THROUGH(_) =                           (((_) >> 3) & 0x01) //col:15142
PTE_32_PAGE_LEVEL_CACHE_DISABLE_BIT =                          4 //col:15151
PTE_32_PAGE_LEVEL_CACHE_DISABLE_FLAG =                         0x10 //col:15152
PTE_32_PAGE_LEVEL_CACHE_DISABLE_MASK =                         0x01 //col:15153
PTE_32_PAGE_LEVEL_CACHE_DISABLE(_) =                           (((_) >> 4) & 0x01) //col:15154
PTE_32_ACCESSED_BIT =                                          5 //col:15162
PTE_32_ACCESSED_FLAG =                                         0x20 //col:15163
PTE_32_ACCESSED_MASK =                                         0x01 //col:15164
PTE_32_ACCESSED(_) =                                           (((_) >> 5) & 0x01) //col:15165
PTE_32_DIRTY_BIT =                                             6 //col:15173
PTE_32_DIRTY_FLAG =                                            0x40 //col:15174
PTE_32_DIRTY_MASK =                                            0x01 //col:15175
PTE_32_DIRTY(_) =                                              (((_) >> 6) & 0x01) //col:15176
PTE_32_PAT_BIT =                                               7 //col:15184
PTE_32_PAT_FLAG =                                              0x80 //col:15185
PTE_32_PAT_MASK =                                              0x01 //col:15186
PTE_32_PAT(_) =                                                (((_) >> 7) & 0x01) //col:15187
PTE_32_GLOBAL_BIT =                                            8 //col:15195
PTE_32_GLOBAL_FLAG =                                           0x100 //col:15196
PTE_32_GLOBAL_MASK =                                           0x01 //col:15197
PTE_32_GLOBAL(_) =                                             (((_) >> 8) & 0x01) //col:15198
PTE_32_IGNORED_1_BIT =                                         9 //col:15204
PTE_32_IGNORED_1_FLAG =                                        0xE00 //col:15205
PTE_32_IGNORED_1_MASK =                                        0x07 //col:15206
PTE_32_IGNORED_1(_) =                                          (((_) >> 9) & 0x07) //col:15207
PTE_32_PAGE_FRAME_NUMBER_BIT =                                 12 //col:15213
PTE_32_PAGE_FRAME_NUMBER_FLAG =                                0xFFFFF000 //col:15214
PTE_32_PAGE_FRAME_NUMBER_MASK =                                0xFFFFF //col:15215
PTE_32_PAGE_FRAME_NUMBER(_) =                                  (((_) >> 12) & 0xFFFFF) //col:15216
PT_ENTRY_32_PRESENT_BIT =                                      0 //col:15230
PT_ENTRY_32_PRESENT_FLAG =                                     0x01 //col:15231
PT_ENTRY_32_PRESENT_MASK =                                     0x01 //col:15232
PT_ENTRY_32_PRESENT(_) =                                       (((_) >> 0) & 0x01) //col:15233
PT_ENTRY_32_WRITE_BIT =                                        1 //col:15235
PT_ENTRY_32_WRITE_FLAG =                                       0x02 //col:15236
PT_ENTRY_32_WRITE_MASK =                                       0x01 //col:15237
PT_ENTRY_32_WRITE(_) =                                         (((_) >> 1) & 0x01) //col:15238
PT_ENTRY_32_SUPERVISOR_BIT =                                   2 //col:15240
PT_ENTRY_32_SUPERVISOR_FLAG =                                  0x04 //col:15241
PT_ENTRY_32_SUPERVISOR_MASK =                                  0x01 //col:15242
PT_ENTRY_32_SUPERVISOR(_) =                                    (((_) >> 2) & 0x01) //col:15243
PT_ENTRY_32_PAGE_LEVEL_WRITE_THROUGH_BIT =                     3 //col:15245
PT_ENTRY_32_PAGE_LEVEL_WRITE_THROUGH_FLAG =                    0x08 //col:15246
PT_ENTRY_32_PAGE_LEVEL_WRITE_THROUGH_MASK =                    0x01 //col:15247
PT_ENTRY_32_PAGE_LEVEL_WRITE_THROUGH(_) =                      (((_) >> 3) & 0x01) //col:15248
PT_ENTRY_32_PAGE_LEVEL_CACHE_DISABLE_BIT =                     4 //col:15250
PT_ENTRY_32_PAGE_LEVEL_CACHE_DISABLE_FLAG =                    0x10 //col:15251
PT_ENTRY_32_PAGE_LEVEL_CACHE_DISABLE_MASK =                    0x01 //col:15252
PT_ENTRY_32_PAGE_LEVEL_CACHE_DISABLE(_) =                      (((_) >> 4) & 0x01) //col:15253
PT_ENTRY_32_ACCESSED_BIT =                                     5 //col:15255
PT_ENTRY_32_ACCESSED_FLAG =                                    0x20 //col:15256
PT_ENTRY_32_ACCESSED_MASK =                                    0x01 //col:15257
PT_ENTRY_32_ACCESSED(_) =                                      (((_) >> 5) & 0x01) //col:15258
PT_ENTRY_32_DIRTY_BIT =                                        6 //col:15260
PT_ENTRY_32_DIRTY_FLAG =                                       0x40 //col:15261
PT_ENTRY_32_DIRTY_MASK =                                       0x01 //col:15262
PT_ENTRY_32_DIRTY(_) =                                         (((_) >> 6) & 0x01) //col:15263
PT_ENTRY_32_LARGE_PAGE_BIT =                                   7 //col:15265
PT_ENTRY_32_LARGE_PAGE_FLAG =                                  0x80 //col:15266
PT_ENTRY_32_LARGE_PAGE_MASK =                                  0x01 //col:15267
PT_ENTRY_32_LARGE_PAGE(_) =                                    (((_) >> 7) & 0x01) //col:15268
PT_ENTRY_32_GLOBAL_BIT =                                       8 //col:15270
PT_ENTRY_32_GLOBAL_FLAG =                                      0x100 //col:15271
PT_ENTRY_32_GLOBAL_MASK =                                      0x01 //col:15272
PT_ENTRY_32_GLOBAL(_) =                                        (((_) >> 8) & 0x01) //col:15273
PT_ENTRY_32_IGNORED_1_BIT =                                    9 //col:15279
PT_ENTRY_32_IGNORED_1_FLAG =                                   0xE00 //col:15280
PT_ENTRY_32_IGNORED_1_MASK =                                   0x07 //col:15281
PT_ENTRY_32_IGNORED_1(_) =                                     (((_) >> 9) & 0x07) //col:15282
PT_ENTRY_32_PAGE_FRAME_NUMBER_BIT =                            12 //col:15288
PT_ENTRY_32_PAGE_FRAME_NUMBER_FLAG =                           0xFFFFF000 //col:15289
PT_ENTRY_32_PAGE_FRAME_NUMBER_MASK =                           0xFFFFF //col:15290
PT_ENTRY_32_PAGE_FRAME_NUMBER(_) =                             (((_) >> 12) & 0xFFFFF) //col:15291
PDE_ENTRY_COUNT_32 =                                           0x00000400 //col:15304
PTE_ENTRY_COUNT_32 =                                           0x00000400 //col:15305
PML4E_64_PRESENT_BIT =                                         0 //col:15340
PML4E_64_PRESENT_FLAG =                                        0x01 //col:15341
PML4E_64_PRESENT_MASK =                                        0x01 //col:15342
PML4E_64_PRESENT(_) =                                          (((_) >> 0) & 0x01) //col:15343
PML4E_64_WRITE_BIT =                                           1 //col:15351
PML4E_64_WRITE_FLAG =                                          0x02 //col:15352
PML4E_64_WRITE_MASK =                                          0x01 //col:15353
PML4E_64_WRITE(_) =                                            (((_) >> 1) & 0x01) //col:15354
PML4E_64_SUPERVISOR_BIT =                                      2 //col:15362
PML4E_64_SUPERVISOR_FLAG =                                     0x04 //col:15363
PML4E_64_SUPERVISOR_MASK =                                     0x01 //col:15364
PML4E_64_SUPERVISOR(_) =                                       (((_) >> 2) & 0x01) //col:15365
PML4E_64_PAGE_LEVEL_WRITE_THROUGH_BIT =                        3 //col:15374
PML4E_64_PAGE_LEVEL_WRITE_THROUGH_FLAG =                       0x08 //col:15375
PML4E_64_PAGE_LEVEL_WRITE_THROUGH_MASK =                       0x01 //col:15376
PML4E_64_PAGE_LEVEL_WRITE_THROUGH(_) =                         (((_) >> 3) & 0x01) //col:15377
PML4E_64_PAGE_LEVEL_CACHE_DISABLE_BIT =                        4 //col:15386
PML4E_64_PAGE_LEVEL_CACHE_DISABLE_FLAG =                       0x10 //col:15387
PML4E_64_PAGE_LEVEL_CACHE_DISABLE_MASK =                       0x01 //col:15388
PML4E_64_PAGE_LEVEL_CACHE_DISABLE(_) =                         (((_) >> 4) & 0x01) //col:15389
PML4E_64_ACCESSED_BIT =                                        5 //col:15397
PML4E_64_ACCESSED_FLAG =                                       0x20 //col:15398
PML4E_64_ACCESSED_MASK =                                       0x01 //col:15399
PML4E_64_ACCESSED(_) =                                         (((_) >> 5) & 0x01) //col:15400
PML4E_64_MUST_BE_ZERO_BIT =                                    7 //col:15407
PML4E_64_MUST_BE_ZERO_FLAG =                                   0x80 //col:15408
PML4E_64_MUST_BE_ZERO_MASK =                                   0x01 //col:15409
PML4E_64_MUST_BE_ZERO(_) =                                     (((_) >> 7) & 0x01) //col:15410
PML4E_64_IGNORED_1_BIT =                                       8 //col:15416
PML4E_64_IGNORED_1_FLAG =                                      0x700 //col:15417
PML4E_64_IGNORED_1_MASK =                                      0x07 //col:15418
PML4E_64_IGNORED_1(_) =                                        (((_) >> 8) & 0x07) //col:15419
PML4E_64_RESTART_BIT =                                         11 //col:15428
PML4E_64_RESTART_FLAG =                                        0x800 //col:15429
PML4E_64_RESTART_MASK =                                        0x01 //col:15430
PML4E_64_RESTART(_) =                                          (((_) >> 11) & 0x01) //col:15431
PML4E_64_PAGE_FRAME_NUMBER_BIT =                               12 //col:15437
PML4E_64_PAGE_FRAME_NUMBER_FLAG =                              0xFFFFFFFFF000 //col:15438
PML4E_64_PAGE_FRAME_NUMBER_MASK =                              0xFFFFFFFFF //col:15439
PML4E_64_PAGE_FRAME_NUMBER(_) =                                (((_) >> 12) & 0xFFFFFFFFF) //col:15440
PML4E_64_IGNORED_2_BIT =                                       52 //col:15447
PML4E_64_IGNORED_2_FLAG =                                      0x7FF0000000000000 //col:15448
PML4E_64_IGNORED_2_MASK =                                      0x7FF //col:15449
PML4E_64_IGNORED_2(_) =                                        (((_) >> 52) & 0x7FF) //col:15450
PML4E_64_EXECUTE_DISABLE_BIT =                                 63 //col:15459
PML4E_64_EXECUTE_DISABLE_FLAG =                                0x8000000000000000 //col:15460
PML4E_64_EXECUTE_DISABLE_MASK =                                0x01 //col:15461
PML4E_64_EXECUTE_DISABLE(_) =                                  (((_) >> 63) & 0x01) //col:15462
PDPTE_1GB_64_PRESENT_BIT =                                     0 //col:15479
PDPTE_1GB_64_PRESENT_FLAG =                                    0x01 //col:15480
PDPTE_1GB_64_PRESENT_MASK =                                    0x01 //col:15481
PDPTE_1GB_64_PRESENT(_) =                                      (((_) >> 0) & 0x01) //col:15482
PDPTE_1GB_64_WRITE_BIT =                                       1 //col:15490
PDPTE_1GB_64_WRITE_FLAG =                                      0x02 //col:15491
PDPTE_1GB_64_WRITE_MASK =                                      0x01 //col:15492
PDPTE_1GB_64_WRITE(_) =                                        (((_) >> 1) & 0x01) //col:15493
PDPTE_1GB_64_SUPERVISOR_BIT =                                  2 //col:15501
PDPTE_1GB_64_SUPERVISOR_FLAG =                                 0x04 //col:15502
PDPTE_1GB_64_SUPERVISOR_MASK =                                 0x01 //col:15503
PDPTE_1GB_64_SUPERVISOR(_) =                                   (((_) >> 2) & 0x01) //col:15504
PDPTE_1GB_64_PAGE_LEVEL_WRITE_THROUGH_BIT =                    3 //col:15513
PDPTE_1GB_64_PAGE_LEVEL_WRITE_THROUGH_FLAG =                   0x08 //col:15514
PDPTE_1GB_64_PAGE_LEVEL_WRITE_THROUGH_MASK =                   0x01 //col:15515
PDPTE_1GB_64_PAGE_LEVEL_WRITE_THROUGH(_) =                     (((_) >> 3) & 0x01) //col:15516
PDPTE_1GB_64_PAGE_LEVEL_CACHE_DISABLE_BIT =                    4 //col:15525
PDPTE_1GB_64_PAGE_LEVEL_CACHE_DISABLE_FLAG =                   0x10 //col:15526
PDPTE_1GB_64_PAGE_LEVEL_CACHE_DISABLE_MASK =                   0x01 //col:15527
PDPTE_1GB_64_PAGE_LEVEL_CACHE_DISABLE(_) =                     (((_) >> 4) & 0x01) //col:15528
PDPTE_1GB_64_ACCESSED_BIT =                                    5 //col:15536
PDPTE_1GB_64_ACCESSED_FLAG =                                   0x20 //col:15537
PDPTE_1GB_64_ACCESSED_MASK =                                   0x01 //col:15538
PDPTE_1GB_64_ACCESSED(_) =                                     (((_) >> 5) & 0x01) //col:15539
PDPTE_1GB_64_DIRTY_BIT =                                       6 //col:15547
PDPTE_1GB_64_DIRTY_FLAG =                                      0x40 //col:15548
PDPTE_1GB_64_DIRTY_MASK =                                      0x01 //col:15549
PDPTE_1GB_64_DIRTY(_) =                                        (((_) >> 6) & 0x01) //col:15550
PDPTE_1GB_64_LARGE_PAGE_BIT =                                  7 //col:15556
PDPTE_1GB_64_LARGE_PAGE_FLAG =                                 0x80 //col:15557
PDPTE_1GB_64_LARGE_PAGE_MASK =                                 0x01 //col:15558
PDPTE_1GB_64_LARGE_PAGE(_) =                                   (((_) >> 7) & 0x01) //col:15559
PDPTE_1GB_64_GLOBAL_BIT =                                      8 //col:15567
PDPTE_1GB_64_GLOBAL_FLAG =                                     0x100 //col:15568
PDPTE_1GB_64_GLOBAL_MASK =                                     0x01 //col:15569
PDPTE_1GB_64_GLOBAL(_) =                                       (((_) >> 8) & 0x01) //col:15570
PDPTE_1GB_64_IGNORED_1_BIT =                                   9 //col:15576
PDPTE_1GB_64_IGNORED_1_FLAG =                                  0x600 //col:15577
PDPTE_1GB_64_IGNORED_1_MASK =                                  0x03 //col:15578
PDPTE_1GB_64_IGNORED_1(_) =                                    (((_) >> 9) & 0x03) //col:15579
PDPTE_1GB_64_RESTART_BIT =                                     11 //col:15588
PDPTE_1GB_64_RESTART_FLAG =                                    0x800 //col:15589
PDPTE_1GB_64_RESTART_MASK =                                    0x01 //col:15590
PDPTE_1GB_64_RESTART(_) =                                      (((_) >> 11) & 0x01) //col:15591
PDPTE_1GB_64_PAT_BIT =                                         12 //col:15600
PDPTE_1GB_64_PAT_FLAG =                                        0x1000 //col:15601
PDPTE_1GB_64_PAT_MASK =                                        0x01 //col:15602
PDPTE_1GB_64_PAT(_) =                                          (((_) >> 12) & 0x01) //col:15603
PDPTE_1GB_64_PAGE_FRAME_NUMBER_BIT =                           30 //col:15610
PDPTE_1GB_64_PAGE_FRAME_NUMBER_FLAG =                          0xFFFFC0000000 //col:15611
PDPTE_1GB_64_PAGE_FRAME_NUMBER_MASK =                          0x3FFFF //col:15612
PDPTE_1GB_64_PAGE_FRAME_NUMBER(_) =                            (((_) >> 30) & 0x3FFFF) //col:15613
PDPTE_1GB_64_IGNORED_2_BIT =                                   52 //col:15620
PDPTE_1GB_64_IGNORED_2_FLAG =                                  0x7F0000000000000 //col:15621
PDPTE_1GB_64_IGNORED_2_MASK =                                  0x7F //col:15622
PDPTE_1GB_64_IGNORED_2(_) =                                    (((_) >> 52) & 0x7F) //col:15623
PDPTE_1GB_64_PROTECTION_KEY_BIT =                              59 //col:15631
PDPTE_1GB_64_PROTECTION_KEY_FLAG =                             0x7800000000000000 //col:15632
PDPTE_1GB_64_PROTECTION_KEY_MASK =                             0x0F //col:15633
PDPTE_1GB_64_PROTECTION_KEY(_) =                               (((_) >> 59) & 0x0F) //col:15634
PDPTE_1GB_64_EXECUTE_DISABLE_BIT =                             63 //col:15643
PDPTE_1GB_64_EXECUTE_DISABLE_FLAG =                            0x8000000000000000 //col:15644
PDPTE_1GB_64_EXECUTE_DISABLE_MASK =                            0x01 //col:15645
PDPTE_1GB_64_EXECUTE_DISABLE(_) =                              (((_) >> 63) & 0x01) //col:15646
PDPTE_64_PRESENT_BIT =                                         0 //col:15663
PDPTE_64_PRESENT_FLAG =                                        0x01 //col:15664
PDPTE_64_PRESENT_MASK =                                        0x01 //col:15665
PDPTE_64_PRESENT(_) =                                          (((_) >> 0) & 0x01) //col:15666
PDPTE_64_WRITE_BIT =                                           1 //col:15674
PDPTE_64_WRITE_FLAG =                                          0x02 //col:15675
PDPTE_64_WRITE_MASK =                                          0x01 //col:15676
PDPTE_64_WRITE(_) =                                            (((_) >> 1) & 0x01) //col:15677
PDPTE_64_SUPERVISOR_BIT =                                      2 //col:15685
PDPTE_64_SUPERVISOR_FLAG =                                     0x04 //col:15686
PDPTE_64_SUPERVISOR_MASK =                                     0x01 //col:15687
PDPTE_64_SUPERVISOR(_) =                                       (((_) >> 2) & 0x01) //col:15688
PDPTE_64_PAGE_LEVEL_WRITE_THROUGH_BIT =                        3 //col:15697
PDPTE_64_PAGE_LEVEL_WRITE_THROUGH_FLAG =                       0x08 //col:15698
PDPTE_64_PAGE_LEVEL_WRITE_THROUGH_MASK =                       0x01 //col:15699
PDPTE_64_PAGE_LEVEL_WRITE_THROUGH(_) =                         (((_) >> 3) & 0x01) //col:15700
PDPTE_64_PAGE_LEVEL_CACHE_DISABLE_BIT =                        4 //col:15709
PDPTE_64_PAGE_LEVEL_CACHE_DISABLE_FLAG =                       0x10 //col:15710
PDPTE_64_PAGE_LEVEL_CACHE_DISABLE_MASK =                       0x01 //col:15711
PDPTE_64_PAGE_LEVEL_CACHE_DISABLE(_) =                         (((_) >> 4) & 0x01) //col:15712
PDPTE_64_ACCESSED_BIT =                                        5 //col:15720
PDPTE_64_ACCESSED_FLAG =                                       0x20 //col:15721
PDPTE_64_ACCESSED_MASK =                                       0x01 //col:15722
PDPTE_64_ACCESSED(_) =                                         (((_) >> 5) & 0x01) //col:15723
PDPTE_64_LARGE_PAGE_BIT =                                      7 //col:15730
PDPTE_64_LARGE_PAGE_FLAG =                                     0x80 //col:15731
PDPTE_64_LARGE_PAGE_MASK =                                     0x01 //col:15732
PDPTE_64_LARGE_PAGE(_) =                                       (((_) >> 7) & 0x01) //col:15733
PDPTE_64_IGNORED_1_BIT =                                       8 //col:15739
PDPTE_64_IGNORED_1_FLAG =                                      0x700 //col:15740
PDPTE_64_IGNORED_1_MASK =                                      0x07 //col:15741
PDPTE_64_IGNORED_1(_) =                                        (((_) >> 8) & 0x07) //col:15742
PDPTE_64_RESTART_BIT =                                         11 //col:15751
PDPTE_64_RESTART_FLAG =                                        0x800 //col:15752
PDPTE_64_RESTART_MASK =                                        0x01 //col:15753
PDPTE_64_RESTART(_) =                                          (((_) >> 11) & 0x01) //col:15754
PDPTE_64_PAGE_FRAME_NUMBER_BIT =                               12 //col:15760
PDPTE_64_PAGE_FRAME_NUMBER_FLAG =                              0xFFFFFFFFF000 //col:15761
PDPTE_64_PAGE_FRAME_NUMBER_MASK =                              0xFFFFFFFFF //col:15762
PDPTE_64_PAGE_FRAME_NUMBER(_) =                                (((_) >> 12) & 0xFFFFFFFFF) //col:15763
PDPTE_64_IGNORED_2_BIT =                                       52 //col:15770
PDPTE_64_IGNORED_2_FLAG =                                      0x7FF0000000000000 //col:15771
PDPTE_64_IGNORED_2_MASK =                                      0x7FF //col:15772
PDPTE_64_IGNORED_2(_) =                                        (((_) >> 52) & 0x7FF) //col:15773
PDPTE_64_EXECUTE_DISABLE_BIT =                                 63 //col:15782
PDPTE_64_EXECUTE_DISABLE_FLAG =                                0x8000000000000000 //col:15783
PDPTE_64_EXECUTE_DISABLE_MASK =                                0x01 //col:15784
PDPTE_64_EXECUTE_DISABLE(_) =                                  (((_) >> 63) & 0x01) //col:15785
PDE_2MB_64_PRESENT_BIT =                                       0 //col:15802
PDE_2MB_64_PRESENT_FLAG =                                      0x01 //col:15803
PDE_2MB_64_PRESENT_MASK =                                      0x01 //col:15804
PDE_2MB_64_PRESENT(_) =                                        (((_) >> 0) & 0x01) //col:15805
PDE_2MB_64_WRITE_BIT =                                         1 //col:15813
PDE_2MB_64_WRITE_FLAG =                                        0x02 //col:15814
PDE_2MB_64_WRITE_MASK =                                        0x01 //col:15815
PDE_2MB_64_WRITE(_) =                                          (((_) >> 1) & 0x01) //col:15816
PDE_2MB_64_SUPERVISOR_BIT =                                    2 //col:15824
PDE_2MB_64_SUPERVISOR_FLAG =                                   0x04 //col:15825
PDE_2MB_64_SUPERVISOR_MASK =                                   0x01 //col:15826
PDE_2MB_64_SUPERVISOR(_) =                                     (((_) >> 2) & 0x01) //col:15827
PDE_2MB_64_PAGE_LEVEL_WRITE_THROUGH_BIT =                      3 //col:15836
PDE_2MB_64_PAGE_LEVEL_WRITE_THROUGH_FLAG =                     0x08 //col:15837
PDE_2MB_64_PAGE_LEVEL_WRITE_THROUGH_MASK =                     0x01 //col:15838
PDE_2MB_64_PAGE_LEVEL_WRITE_THROUGH(_) =                       (((_) >> 3) & 0x01) //col:15839
PDE_2MB_64_PAGE_LEVEL_CACHE_DISABLE_BIT =                      4 //col:15848
PDE_2MB_64_PAGE_LEVEL_CACHE_DISABLE_FLAG =                     0x10 //col:15849
PDE_2MB_64_PAGE_LEVEL_CACHE_DISABLE_MASK =                     0x01 //col:15850
PDE_2MB_64_PAGE_LEVEL_CACHE_DISABLE(_) =                       (((_) >> 4) & 0x01) //col:15851
PDE_2MB_64_ACCESSED_BIT =                                      5 //col:15859
PDE_2MB_64_ACCESSED_FLAG =                                     0x20 //col:15860
PDE_2MB_64_ACCESSED_MASK =                                     0x01 //col:15861
PDE_2MB_64_ACCESSED(_) =                                       (((_) >> 5) & 0x01) //col:15862
PDE_2MB_64_DIRTY_BIT =                                         6 //col:15870
PDE_2MB_64_DIRTY_FLAG =                                        0x40 //col:15871
PDE_2MB_64_DIRTY_MASK =                                        0x01 //col:15872
PDE_2MB_64_DIRTY(_) =                                          (((_) >> 6) & 0x01) //col:15873
PDE_2MB_64_LARGE_PAGE_BIT =                                    7 //col:15879
PDE_2MB_64_LARGE_PAGE_FLAG =                                   0x80 //col:15880
PDE_2MB_64_LARGE_PAGE_MASK =                                   0x01 //col:15881
PDE_2MB_64_LARGE_PAGE(_) =                                     (((_) >> 7) & 0x01) //col:15882
PDE_2MB_64_GLOBAL_BIT =                                        8 //col:15890
PDE_2MB_64_GLOBAL_FLAG =                                       0x100 //col:15891
PDE_2MB_64_GLOBAL_MASK =                                       0x01 //col:15892
PDE_2MB_64_GLOBAL(_) =                                         (((_) >> 8) & 0x01) //col:15893
PDE_2MB_64_IGNORED_1_BIT =                                     9 //col:15899
PDE_2MB_64_IGNORED_1_FLAG =                                    0x600 //col:15900
PDE_2MB_64_IGNORED_1_MASK =                                    0x03 //col:15901
PDE_2MB_64_IGNORED_1(_) =                                      (((_) >> 9) & 0x03) //col:15902
PDE_2MB_64_RESTART_BIT =                                       11 //col:15911
PDE_2MB_64_RESTART_FLAG =                                      0x800 //col:15912
PDE_2MB_64_RESTART_MASK =                                      0x01 //col:15913
PDE_2MB_64_RESTART(_) =                                        (((_) >> 11) & 0x01) //col:15914
PDE_2MB_64_PAT_BIT =                                           12 //col:15923
PDE_2MB_64_PAT_FLAG =                                          0x1000 //col:15924
PDE_2MB_64_PAT_MASK =                                          0x01 //col:15925
PDE_2MB_64_PAT(_) =                                            (((_) >> 12) & 0x01) //col:15926
PDE_2MB_64_PAGE_FRAME_NUMBER_BIT =                             21 //col:15933
PDE_2MB_64_PAGE_FRAME_NUMBER_FLAG =                            0xFFFFFFE00000 //col:15934
PDE_2MB_64_PAGE_FRAME_NUMBER_MASK =                            0x7FFFFFF //col:15935
PDE_2MB_64_PAGE_FRAME_NUMBER(_) =                              (((_) >> 21) & 0x7FFFFFF) //col:15936
PDE_2MB_64_IGNORED_2_BIT =                                     52 //col:15943
PDE_2MB_64_IGNORED_2_FLAG =                                    0x7F0000000000000 //col:15944
PDE_2MB_64_IGNORED_2_MASK =                                    0x7F //col:15945
PDE_2MB_64_IGNORED_2(_) =                                      (((_) >> 52) & 0x7F) //col:15946
PDE_2MB_64_PROTECTION_KEY_BIT =                                59 //col:15954
PDE_2MB_64_PROTECTION_KEY_FLAG =                               0x7800000000000000 //col:15955
PDE_2MB_64_PROTECTION_KEY_MASK =                               0x0F //col:15956
PDE_2MB_64_PROTECTION_KEY(_) =                                 (((_) >> 59) & 0x0F) //col:15957
PDE_2MB_64_EXECUTE_DISABLE_BIT =                               63 //col:15966
PDE_2MB_64_EXECUTE_DISABLE_FLAG =                              0x8000000000000000 //col:15967
PDE_2MB_64_EXECUTE_DISABLE_MASK =                              0x01 //col:15968
PDE_2MB_64_EXECUTE_DISABLE(_) =                                (((_) >> 63) & 0x01) //col:15969
PDE_64_PRESENT_BIT =                                           0 //col:15986
PDE_64_PRESENT_FLAG =                                          0x01 //col:15987
PDE_64_PRESENT_MASK =                                          0x01 //col:15988
PDE_64_PRESENT(_) =                                            (((_) >> 0) & 0x01) //col:15989
PDE_64_WRITE_BIT =                                             1 //col:15997
PDE_64_WRITE_FLAG =                                            0x02 //col:15998
PDE_64_WRITE_MASK =                                            0x01 //col:15999
PDE_64_WRITE(_) =                                              (((_) >> 1) & 0x01) //col:16000
PDE_64_SUPERVISOR_BIT =                                        2 //col:16008
PDE_64_SUPERVISOR_FLAG =                                       0x04 //col:16009
PDE_64_SUPERVISOR_MASK =                                       0x01 //col:16010
PDE_64_SUPERVISOR(_) =                                         (((_) >> 2) & 0x01) //col:16011
PDE_64_PAGE_LEVEL_WRITE_THROUGH_BIT =                          3 //col:16020
PDE_64_PAGE_LEVEL_WRITE_THROUGH_FLAG =                         0x08 //col:16021
PDE_64_PAGE_LEVEL_WRITE_THROUGH_MASK =                         0x01 //col:16022
PDE_64_PAGE_LEVEL_WRITE_THROUGH(_) =                           (((_) >> 3) & 0x01) //col:16023
PDE_64_PAGE_LEVEL_CACHE_DISABLE_BIT =                          4 //col:16032
PDE_64_PAGE_LEVEL_CACHE_DISABLE_FLAG =                         0x10 //col:16033
PDE_64_PAGE_LEVEL_CACHE_DISABLE_MASK =                         0x01 //col:16034
PDE_64_PAGE_LEVEL_CACHE_DISABLE(_) =                           (((_) >> 4) & 0x01) //col:16035
PDE_64_ACCESSED_BIT =                                          5 //col:16043
PDE_64_ACCESSED_FLAG =                                         0x20 //col:16044
PDE_64_ACCESSED_MASK =                                         0x01 //col:16045
PDE_64_ACCESSED(_) =                                           (((_) >> 5) & 0x01) //col:16046
PDE_64_LARGE_PAGE_BIT =                                        7 //col:16053
PDE_64_LARGE_PAGE_FLAG =                                       0x80 //col:16054
PDE_64_LARGE_PAGE_MASK =                                       0x01 //col:16055
PDE_64_LARGE_PAGE(_) =                                         (((_) >> 7) & 0x01) //col:16056
PDE_64_IGNORED_1_BIT =                                         8 //col:16062
PDE_64_IGNORED_1_FLAG =                                        0x700 //col:16063
PDE_64_IGNORED_1_MASK =                                        0x07 //col:16064
PDE_64_IGNORED_1(_) =                                          (((_) >> 8) & 0x07) //col:16065
PDE_64_RESTART_BIT =                                           11 //col:16074
PDE_64_RESTART_FLAG =                                          0x800 //col:16075
PDE_64_RESTART_MASK =                                          0x01 //col:16076
PDE_64_RESTART(_) =                                            (((_) >> 11) & 0x01) //col:16077
PDE_64_PAGE_FRAME_NUMBER_BIT =                                 12 //col:16083
PDE_64_PAGE_FRAME_NUMBER_FLAG =                                0xFFFFFFFFF000 //col:16084
PDE_64_PAGE_FRAME_NUMBER_MASK =                                0xFFFFFFFFF //col:16085
PDE_64_PAGE_FRAME_NUMBER(_) =                                  (((_) >> 12) & 0xFFFFFFFFF) //col:16086
PDE_64_IGNORED_2_BIT =                                         52 //col:16093
PDE_64_IGNORED_2_FLAG =                                        0x7FF0000000000000 //col:16094
PDE_64_IGNORED_2_MASK =                                        0x7FF //col:16095
PDE_64_IGNORED_2(_) =                                          (((_) >> 52) & 0x7FF) //col:16096
PDE_64_EXECUTE_DISABLE_BIT =                                   63 //col:16105
PDE_64_EXECUTE_DISABLE_FLAG =                                  0x8000000000000000 //col:16106
PDE_64_EXECUTE_DISABLE_MASK =                                  0x01 //col:16107
PDE_64_EXECUTE_DISABLE(_) =                                    (((_) >> 63) & 0x01) //col:16108
PTE_64_PRESENT_BIT =                                           0 //col:16125
PTE_64_PRESENT_FLAG =                                          0x01 //col:16126
PTE_64_PRESENT_MASK =                                          0x01 //col:16127
PTE_64_PRESENT(_) =                                            (((_) >> 0) & 0x01) //col:16128
PTE_64_WRITE_BIT =                                             1 //col:16136
PTE_64_WRITE_FLAG =                                            0x02 //col:16137
PTE_64_WRITE_MASK =                                            0x01 //col:16138
PTE_64_WRITE(_) =                                              (((_) >> 1) & 0x01) //col:16139
PTE_64_SUPERVISOR_BIT =                                        2 //col:16147
PTE_64_SUPERVISOR_FLAG =                                       0x04 //col:16148
PTE_64_SUPERVISOR_MASK =                                       0x01 //col:16149
PTE_64_SUPERVISOR(_) =                                         (((_) >> 2) & 0x01) //col:16150
PTE_64_PAGE_LEVEL_WRITE_THROUGH_BIT =                          3 //col:16159
PTE_64_PAGE_LEVEL_WRITE_THROUGH_FLAG =                         0x08 //col:16160
PTE_64_PAGE_LEVEL_WRITE_THROUGH_MASK =                         0x01 //col:16161
PTE_64_PAGE_LEVEL_WRITE_THROUGH(_) =                           (((_) >> 3) & 0x01) //col:16162
PTE_64_PAGE_LEVEL_CACHE_DISABLE_BIT =                          4 //col:16171
PTE_64_PAGE_LEVEL_CACHE_DISABLE_FLAG =                         0x10 //col:16172
PTE_64_PAGE_LEVEL_CACHE_DISABLE_MASK =                         0x01 //col:16173
PTE_64_PAGE_LEVEL_CACHE_DISABLE(_) =                           (((_) >> 4) & 0x01) //col:16174
PTE_64_ACCESSED_BIT =                                          5 //col:16182
PTE_64_ACCESSED_FLAG =                                         0x20 //col:16183
PTE_64_ACCESSED_MASK =                                         0x01 //col:16184
PTE_64_ACCESSED(_) =                                           (((_) >> 5) & 0x01) //col:16185
PTE_64_DIRTY_BIT =                                             6 //col:16193
PTE_64_DIRTY_FLAG =                                            0x40 //col:16194
PTE_64_DIRTY_MASK =                                            0x01 //col:16195
PTE_64_DIRTY(_) =                                              (((_) >> 6) & 0x01) //col:16196
PTE_64_PAT_BIT =                                               7 //col:16204
PTE_64_PAT_FLAG =                                              0x80 //col:16205
PTE_64_PAT_MASK =                                              0x01 //col:16206
PTE_64_PAT(_) =                                                (((_) >> 7) & 0x01) //col:16207
PTE_64_GLOBAL_BIT =                                            8 //col:16215
PTE_64_GLOBAL_FLAG =                                           0x100 //col:16216
PTE_64_GLOBAL_MASK =                                           0x01 //col:16217
PTE_64_GLOBAL(_) =                                             (((_) >> 8) & 0x01) //col:16218
PTE_64_IGNORED_1_BIT =                                         9 //col:16224
PTE_64_IGNORED_1_FLAG =                                        0x600 //col:16225
PTE_64_IGNORED_1_MASK =                                        0x03 //col:16226
PTE_64_IGNORED_1(_) =                                          (((_) >> 9) & 0x03) //col:16227
PTE_64_RESTART_BIT =                                           11 //col:16236
PTE_64_RESTART_FLAG =                                          0x800 //col:16237
PTE_64_RESTART_MASK =                                          0x01 //col:16238
PTE_64_RESTART(_) =                                            (((_) >> 11) & 0x01) //col:16239
PTE_64_PAGE_FRAME_NUMBER_BIT =                                 12 //col:16245
PTE_64_PAGE_FRAME_NUMBER_FLAG =                                0xFFFFFFFFF000 //col:16246
PTE_64_PAGE_FRAME_NUMBER_MASK =                                0xFFFFFFFFF //col:16247
PTE_64_PAGE_FRAME_NUMBER(_) =                                  (((_) >> 12) & 0xFFFFFFFFF) //col:16248
PTE_64_IGNORED_2_BIT =                                         52 //col:16255
PTE_64_IGNORED_2_FLAG =                                        0x7F0000000000000 //col:16256
PTE_64_IGNORED_2_MASK =                                        0x7F //col:16257
PTE_64_IGNORED_2(_) =                                          (((_) >> 52) & 0x7F) //col:16258
PTE_64_PROTECTION_KEY_BIT =                                    59 //col:16266
PTE_64_PROTECTION_KEY_FLAG =                                   0x7800000000000000 //col:16267
PTE_64_PROTECTION_KEY_MASK =                                   0x0F //col:16268
PTE_64_PROTECTION_KEY(_) =                                     (((_) >> 59) & 0x0F) //col:16269
PTE_64_EXECUTE_DISABLE_BIT =                                   63 //col:16278
PTE_64_EXECUTE_DISABLE_FLAG =                                  0x8000000000000000 //col:16279
PTE_64_EXECUTE_DISABLE_MASK =                                  0x01 //col:16280
PTE_64_EXECUTE_DISABLE(_) =                                    (((_) >> 63) & 0x01) //col:16281
PT_ENTRY_64_PRESENT_BIT =                                      0 //col:16295
PT_ENTRY_64_PRESENT_FLAG =                                     0x01 //col:16296
PT_ENTRY_64_PRESENT_MASK =                                     0x01 //col:16297
PT_ENTRY_64_PRESENT(_) =                                       (((_) >> 0) & 0x01) //col:16298
PT_ENTRY_64_WRITE_BIT =                                        1 //col:16300
PT_ENTRY_64_WRITE_FLAG =                                       0x02 //col:16301
PT_ENTRY_64_WRITE_MASK =                                       0x01 //col:16302
PT_ENTRY_64_WRITE(_) =                                         (((_) >> 1) & 0x01) //col:16303
PT_ENTRY_64_SUPERVISOR_BIT =                                   2 //col:16305
PT_ENTRY_64_SUPERVISOR_FLAG =                                  0x04 //col:16306
PT_ENTRY_64_SUPERVISOR_MASK =                                  0x01 //col:16307
PT_ENTRY_64_SUPERVISOR(_) =                                    (((_) >> 2) & 0x01) //col:16308
PT_ENTRY_64_PAGE_LEVEL_WRITE_THROUGH_BIT =                     3 //col:16310
PT_ENTRY_64_PAGE_LEVEL_WRITE_THROUGH_FLAG =                    0x08 //col:16311
PT_ENTRY_64_PAGE_LEVEL_WRITE_THROUGH_MASK =                    0x01 //col:16312
PT_ENTRY_64_PAGE_LEVEL_WRITE_THROUGH(_) =                      (((_) >> 3) & 0x01) //col:16313
PT_ENTRY_64_PAGE_LEVEL_CACHE_DISABLE_BIT =                     4 //col:16315
PT_ENTRY_64_PAGE_LEVEL_CACHE_DISABLE_FLAG =                    0x10 //col:16316
PT_ENTRY_64_PAGE_LEVEL_CACHE_DISABLE_MASK =                    0x01 //col:16317
PT_ENTRY_64_PAGE_LEVEL_CACHE_DISABLE(_) =                      (((_) >> 4) & 0x01) //col:16318
PT_ENTRY_64_ACCESSED_BIT =                                     5 //col:16320
PT_ENTRY_64_ACCESSED_FLAG =                                    0x20 //col:16321
PT_ENTRY_64_ACCESSED_MASK =                                    0x01 //col:16322
PT_ENTRY_64_ACCESSED(_) =                                      (((_) >> 5) & 0x01) //col:16323
PT_ENTRY_64_DIRTY_BIT =                                        6 //col:16325
PT_ENTRY_64_DIRTY_FLAG =                                       0x40 //col:16326
PT_ENTRY_64_DIRTY_MASK =                                       0x01 //col:16327
PT_ENTRY_64_DIRTY(_) =                                         (((_) >> 6) & 0x01) //col:16328
PT_ENTRY_64_LARGE_PAGE_BIT =                                   7 //col:16330
PT_ENTRY_64_LARGE_PAGE_FLAG =                                  0x80 //col:16331
PT_ENTRY_64_LARGE_PAGE_MASK =                                  0x01 //col:16332
PT_ENTRY_64_LARGE_PAGE(_) =                                    (((_) >> 7) & 0x01) //col:16333
PT_ENTRY_64_GLOBAL_BIT =                                       8 //col:16335
PT_ENTRY_64_GLOBAL_FLAG =                                      0x100 //col:16336
PT_ENTRY_64_GLOBAL_MASK =                                      0x01 //col:16337
PT_ENTRY_64_GLOBAL(_) =                                        (((_) >> 8) & 0x01) //col:16338
PT_ENTRY_64_IGNORED_1_BIT =                                    9 //col:16344
PT_ENTRY_64_IGNORED_1_FLAG =                                   0x600 //col:16345
PT_ENTRY_64_IGNORED_1_MASK =                                   0x03 //col:16346
PT_ENTRY_64_IGNORED_1(_) =                                     (((_) >> 9) & 0x03) //col:16347
PT_ENTRY_64_RESTART_BIT =                                      11 //col:16349
PT_ENTRY_64_RESTART_FLAG =                                     0x800 //col:16350
PT_ENTRY_64_RESTART_MASK =                                     0x01 //col:16351
PT_ENTRY_64_RESTART(_) =                                       (((_) >> 11) & 0x01) //col:16352
PT_ENTRY_64_PAGE_FRAME_NUMBER_BIT =                            12 //col:16358
PT_ENTRY_64_PAGE_FRAME_NUMBER_FLAG =                           0xFFFFFFFFF000 //col:16359
PT_ENTRY_64_PAGE_FRAME_NUMBER_MASK =                           0xFFFFFFFFF //col:16360
PT_ENTRY_64_PAGE_FRAME_NUMBER(_) =                             (((_) >> 12) & 0xFFFFFFFFF) //col:16361
PT_ENTRY_64_IGNORED_2_BIT =                                    52 //col:16368
PT_ENTRY_64_IGNORED_2_FLAG =                                   0x7F0000000000000 //col:16369
PT_ENTRY_64_IGNORED_2_MASK =                                   0x7F //col:16370
PT_ENTRY_64_IGNORED_2(_) =                                     (((_) >> 52) & 0x7F) //col:16371
PT_ENTRY_64_PROTECTION_KEY_BIT =                               59 //col:16373
PT_ENTRY_64_PROTECTION_KEY_FLAG =                              0x7800000000000000 //col:16374
PT_ENTRY_64_PROTECTION_KEY_MASK =                              0x0F //col:16375
PT_ENTRY_64_PROTECTION_KEY(_) =                                (((_) >> 59) & 0x0F) //col:16376
PT_ENTRY_64_EXECUTE_DISABLE_BIT =                              63 //col:16378
PT_ENTRY_64_EXECUTE_DISABLE_FLAG =                             0x8000000000000000 //col:16379
PT_ENTRY_64_EXECUTE_DISABLE_MASK =                             0x01 //col:16380
PT_ENTRY_64_EXECUTE_DISABLE(_) =                               (((_) >> 63) & 0x01) //col:16381
PML4E_ENTRY_COUNT_64 =                                         0x00000200 //col:16394
PDPTE_ENTRY_COUNT_64 =                                         0x00000200 //col:16395
PDE_ENTRY_COUNT_64 =                                           0x00000200 //col:16396
PTE_ENTRY_COUNT_64 =                                           0x00000200 //col:16397
INVPCID_DESCRIPTOR_PCID_BIT =                                  0 //col:16445
INVPCID_DESCRIPTOR_PCID_FLAG =                                 0xFFF //col:16446
INVPCID_DESCRIPTOR_PCID_MASK =                                 0xFFF //col:16447
INVPCID_DESCRIPTOR_PCID(_) =                                   (((_) >> 0) & 0xFFF) //col:16448
INVPCID_DESCRIPTOR_RESERVED1_BIT =                             12 //col:16454
INVPCID_DESCRIPTOR_RESERVED1_FLAG =                            0xFFFFFFFFFFFFF000 //col:16455
INVPCID_DESCRIPTOR_RESERVED1_MASK =                            0xFFFFFFFFFFFFF //col:16456
INVPCID_DESCRIPTOR_RESERVED1(_) =                              (((_) >> 12) & 0xFFFFFFFFFFFFF) //col:16457
INVPCID_DESCRIPTOR_LINEAR_ADDRESS_BIT =                        64 //col:16459
INVPCID_DESCRIPTOR_LINEAR_ADDRESS_FLAG =                       0xFFFFFFFFFFFFFFFF0000000000000000 //col:16460
INVPCID_DESCRIPTOR_LINEAR_ADDRESS_MASK =                       0xFFFFFFFFFFFFFFFF //col:16461
INVPCID_DESCRIPTOR_LINEAR_ADDRESS(_) =                         (((_) >> 64) & 0xFFFFFFFFFFFFFFFF) //col:16462
SEGMENT_ACCESS_RIGHTS_TYPE_BIT =                               8 //col:16535
SEGMENT_ACCESS_RIGHTS_TYPE_FLAG =                              0xF00 //col:16536
SEGMENT_ACCESS_RIGHTS_TYPE_MASK =                              0x0F //col:16537
SEGMENT_ACCESS_RIGHTS_TYPE(_) =                                (((_) >> 8) & 0x0F) //col:16538
SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_TYPE_BIT =                    12 //col:16547
SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_TYPE_FLAG =                   0x1000 //col:16548
SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_TYPE_MASK =                   0x01 //col:16549
SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_TYPE(_) =                     (((_) >> 12) & 0x01) //col:16550
SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_PRIVILEGE_LEVEL_BIT =         13 //col:16560
SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_PRIVILEGE_LEVEL_FLAG =        0x6000 //col:16561
SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_PRIVILEGE_LEVEL_MASK =        0x03 //col:16562
SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_PRIVILEGE_LEVEL(_) =          (((_) >> 13) & 0x03) //col:16563
SEGMENT_ACCESS_RIGHTS_PRESENT_BIT =                            15 //col:16574
SEGMENT_ACCESS_RIGHTS_PRESENT_FLAG =                           0x8000 //col:16575
SEGMENT_ACCESS_RIGHTS_PRESENT_MASK =                           0x01 //col:16576
SEGMENT_ACCESS_RIGHTS_PRESENT(_) =                             (((_) >> 15) & 0x01) //col:16577
SEGMENT_ACCESS_RIGHTS_SYSTEM_BIT =                             20 //col:16586
SEGMENT_ACCESS_RIGHTS_SYSTEM_FLAG =                            0x100000 //col:16587
SEGMENT_ACCESS_RIGHTS_SYSTEM_MASK =                            0x01 //col:16588
SEGMENT_ACCESS_RIGHTS_SYSTEM(_) =                              (((_) >> 20) & 0x01) //col:16589
SEGMENT_ACCESS_RIGHTS_LONG_MODE_BIT =                          21 //col:16601
SEGMENT_ACCESS_RIGHTS_LONG_MODE_FLAG =                         0x200000 //col:16602
SEGMENT_ACCESS_RIGHTS_LONG_MODE_MASK =                         0x01 //col:16603
SEGMENT_ACCESS_RIGHTS_LONG_MODE(_) =                           (((_) >> 21) & 0x01) //col:16604
SEGMENT_ACCESS_RIGHTS_DEFAULT_BIG_BIT =                        22 //col:16626
SEGMENT_ACCESS_RIGHTS_DEFAULT_BIG_FLAG =                       0x400000 //col:16627
SEGMENT_ACCESS_RIGHTS_DEFAULT_BIG_MASK =                       0x01 //col:16628
SEGMENT_ACCESS_RIGHTS_DEFAULT_BIG(_) =                         (((_) >> 22) & 0x01) //col:16629
SEGMENT_ACCESS_RIGHTS_GRANULARITY_BIT =                        23 //col:16641
SEGMENT_ACCESS_RIGHTS_GRANULARITY_FLAG =                       0x800000 //col:16642
SEGMENT_ACCESS_RIGHTS_GRANULARITY_MASK =                       0x01 //col:16643
SEGMENT_ACCESS_RIGHTS_GRANULARITY(_) =                         (((_) >> 23) & 0x01) //col:16644
SEGMENT__BASE_ADDRESS_MIDDLE_BIT =                             0 //col:16711
SEGMENT__BASE_ADDRESS_MIDDLE_FLAG =                            0xFF //col:16712
SEGMENT__BASE_ADDRESS_MIDDLE_MASK =                            0xFF //col:16713
SEGMENT__BASE_ADDRESS_MIDDLE(_) =                              (((_) >> 0) & 0xFF) //col:16714
SEGMENT__TYPE_BIT =                                            8 //col:16727
SEGMENT__TYPE_FLAG =                                           0xF00 //col:16728
SEGMENT__TYPE_MASK =                                           0x0F //col:16729
SEGMENT__TYPE(_) =                                             (((_) >> 8) & 0x0F) //col:16730
SEGMENT__DESCRIPTOR_TYPE_BIT =                                 12 //col:16739
SEGMENT__DESCRIPTOR_TYPE_FLAG =                                0x1000 //col:16740
SEGMENT__DESCRIPTOR_TYPE_MASK =                                0x01 //col:16741
SEGMENT__DESCRIPTOR_TYPE(_) =                                  (((_) >> 12) & 0x01) //col:16742
SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL_BIT =                      13 //col:16752
SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL_FLAG =                     0x6000 //col:16753
SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL_MASK =                     0x03 //col:16754
SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL(_) =                       (((_) >> 13) & 0x03) //col:16755
SEGMENT__PRESENT_BIT =                                         15 //col:16766
SEGMENT__PRESENT_FLAG =                                        0x8000 //col:16767
SEGMENT__PRESENT_MASK =                                        0x01 //col:16768
SEGMENT__PRESENT(_) =                                          (((_) >> 15) & 0x01) //col:16769
SEGMENT__SEGMENT_LIMIT_HIGH_BIT =                              16 //col:16775
SEGMENT__SEGMENT_LIMIT_HIGH_FLAG =                             0xF0000 //col:16776
SEGMENT__SEGMENT_LIMIT_HIGH_MASK =                             0x0F //col:16777
SEGMENT__SEGMENT_LIMIT_HIGH(_) =                               (((_) >> 16) & 0x0F) //col:16778
SEGMENT__SYSTEM_BIT =                                          20 //col:16786
SEGMENT__SYSTEM_FLAG =                                         0x100000 //col:16787
SEGMENT__SYSTEM_MASK =                                         0x01 //col:16788
SEGMENT__SYSTEM(_) =                                           (((_) >> 20) & 0x01) //col:16789
SEGMENT__LONG_MODE_BIT =                                       21 //col:16801
SEGMENT__LONG_MODE_FLAG =                                      0x200000 //col:16802
SEGMENT__LONG_MODE_MASK =                                      0x01 //col:16803
SEGMENT__LONG_MODE(_) =                                        (((_) >> 21) & 0x01) //col:16804
SEGMENT__DEFAULT_BIG_BIT =                                     22 //col:16826
SEGMENT__DEFAULT_BIG_FLAG =                                    0x400000 //col:16827
SEGMENT__DEFAULT_BIG_MASK =                                    0x01 //col:16828
SEGMENT__DEFAULT_BIG(_) =                                      (((_) >> 22) & 0x01) //col:16829
SEGMENT__GRANULARITY_BIT =                                     23 //col:16841
SEGMENT__GRANULARITY_FLAG =                                    0x800000 //col:16842
SEGMENT__GRANULARITY_MASK =                                    0x01 //col:16843
SEGMENT__GRANULARITY(_) =                                      (((_) >> 23) & 0x01) //col:16844
SEGMENT__BASE_ADDRESS_HIGH_BIT =                               24 //col:16850
SEGMENT__BASE_ADDRESS_HIGH_FLAG =                              0xFF000000 //col:16851
SEGMENT__BASE_ADDRESS_HIGH_MASK =                              0xFF //col:16852
SEGMENT__BASE_ADDRESS_HIGH(_) =                                (((_) >> 24) & 0xFF) //col:16853
SEGMENT__BASE_ADDRESS_MIDDLE_BIT =                             0 //col:16913
SEGMENT__BASE_ADDRESS_MIDDLE_FLAG =                            0xFF //col:16914
SEGMENT__BASE_ADDRESS_MIDDLE_MASK =                            0xFF //col:16915
SEGMENT__BASE_ADDRESS_MIDDLE(_) =                              (((_) >> 0) & 0xFF) //col:16916
SEGMENT__TYPE_BIT =                                            8 //col:16929
SEGMENT__TYPE_FLAG =                                           0xF00 //col:16930
SEGMENT__TYPE_MASK =                                           0x0F //col:16931
SEGMENT__TYPE(_) =                                             (((_) >> 8) & 0x0F) //col:16932
SEGMENT__DESCRIPTOR_TYPE_BIT =                                 12 //col:16941
SEGMENT__DESCRIPTOR_TYPE_FLAG =                                0x1000 //col:16942
SEGMENT__DESCRIPTOR_TYPE_MASK =                                0x01 //col:16943
SEGMENT__DESCRIPTOR_TYPE(_) =                                  (((_) >> 12) & 0x01) //col:16944
SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL_BIT =                      13 //col:16954
SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL_FLAG =                     0x6000 //col:16955
SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL_MASK =                     0x03 //col:16956
SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL(_) =                       (((_) >> 13) & 0x03) //col:16957
SEGMENT__PRESENT_BIT =                                         15 //col:16968
SEGMENT__PRESENT_FLAG =                                        0x8000 //col:16969
SEGMENT__PRESENT_MASK =                                        0x01 //col:16970
SEGMENT__PRESENT(_) =                                          (((_) >> 15) & 0x01) //col:16971
SEGMENT__SEGMENT_LIMIT_HIGH_BIT =                              16 //col:16977
SEGMENT__SEGMENT_LIMIT_HIGH_FLAG =                             0xF0000 //col:16978
SEGMENT__SEGMENT_LIMIT_HIGH_MASK =                             0x0F //col:16979
SEGMENT__SEGMENT_LIMIT_HIGH(_) =                               (((_) >> 16) & 0x0F) //col:16980
SEGMENT__SYSTEM_BIT =                                          20 //col:16988
SEGMENT__SYSTEM_FLAG =                                         0x100000 //col:16989
SEGMENT__SYSTEM_MASK =                                         0x01 //col:16990
SEGMENT__SYSTEM(_) =                                           (((_) >> 20) & 0x01) //col:16991
SEGMENT__LONG_MODE_BIT =                                       21 //col:17003
SEGMENT__LONG_MODE_FLAG =                                      0x200000 //col:17004
SEGMENT__LONG_MODE_MASK =                                      0x01 //col:17005
SEGMENT__LONG_MODE(_) =                                        (((_) >> 21) & 0x01) //col:17006
SEGMENT__DEFAULT_BIG_BIT =                                     22 //col:17028
SEGMENT__DEFAULT_BIG_FLAG =                                    0x400000 //col:17029
SEGMENT__DEFAULT_BIG_MASK =                                    0x01 //col:17030
SEGMENT__DEFAULT_BIG(_) =                                      (((_) >> 22) & 0x01) //col:17031
SEGMENT__GRANULARITY_BIT =                                     23 //col:17043
SEGMENT__GRANULARITY_FLAG =                                    0x800000 //col:17044
SEGMENT__GRANULARITY_MASK =                                    0x01 //col:17045
SEGMENT__GRANULARITY(_) =                                      (((_) >> 23) & 0x01) //col:17046
SEGMENT__BASE_ADDRESS_HIGH_BIT =                               24 //col:17052
SEGMENT__BASE_ADDRESS_HIGH_FLAG =                              0xFF000000 //col:17053
SEGMENT__BASE_ADDRESS_HIGH_MASK =                              0xFF //col:17054
SEGMENT__BASE_ADDRESS_HIGH(_) =                                (((_) >> 24) & 0xFF) //col:17055
SEGMENT__INTERRUPT_STACK_TABLE_BIT =                           0 //col:17097
SEGMENT__INTERRUPT_STACK_TABLE_FLAG =                          0x07 //col:17098
SEGMENT__INTERRUPT_STACK_TABLE_MASK =                          0x07 //col:17099
SEGMENT__INTERRUPT_STACK_TABLE(_) =                            (((_) >> 0) & 0x07) //col:17100
SEGMENT__MUST_BE_ZERO_0_BIT =                                  3 //col:17106
SEGMENT__MUST_BE_ZERO_0_FLAG =                                 0xF8 //col:17107
SEGMENT__MUST_BE_ZERO_0_MASK =                                 0x1F //col:17108
SEGMENT__MUST_BE_ZERO_0(_) =                                   (((_) >> 3) & 0x1F) //col:17109
SEGMENT__TYPE_BIT =                                            8 //col:17115
SEGMENT__TYPE_FLAG =                                           0xF00 //col:17116
SEGMENT__TYPE_MASK =                                           0x0F //col:17117
SEGMENT__TYPE(_) =                                             (((_) >> 8) & 0x0F) //col:17118
SEGMENT__MUST_BE_ZERO_1_BIT =                                  12 //col:17124
SEGMENT__MUST_BE_ZERO_1_FLAG =                                 0x1000 //col:17125
SEGMENT__MUST_BE_ZERO_1_MASK =                                 0x01 //col:17126
SEGMENT__MUST_BE_ZERO_1(_) =                                   (((_) >> 12) & 0x01) //col:17127
SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL_BIT =                      13 //col:17133
SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL_FLAG =                     0x6000 //col:17134
SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL_MASK =                     0x03 //col:17135
SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL(_) =                       (((_) >> 13) & 0x03) //col:17136
SEGMENT__PRESENT_BIT =                                         15 //col:17142
SEGMENT__PRESENT_FLAG =                                        0x8000 //col:17143
SEGMENT__PRESENT_MASK =                                        0x01 //col:17144
SEGMENT__PRESENT(_) =                                          (((_) >> 15) & 0x01) //col:17145
SEGMENT__OFFSET_MIDDLE_BIT =                                   16 //col:17151
SEGMENT__OFFSET_MIDDLE_FLAG =                                  0xFFFF0000 //col:17152
SEGMENT__OFFSET_MIDDLE_MASK =                                  0xFFFF //col:17153
SEGMENT__OFFSET_MIDDLE(_) =                                    (((_) >> 16) & 0xFFFF) //col:17154
SEGMENT_DESCRIPTOR_TYPE_SYSTEM =                               0x00000000 //col:17168
SEGMENT_DESCRIPTOR_TYPE_CODE_OR_DATA =                         0x00000001 //col:17169
SEGMENT_DESCRIPTOR_TYPE_DATA_READ_ONLY =                       0x00000000 //col:17187
SEGMENT_DESCRIPTOR_TYPE_DATA_READ_ONLY_ACCESSED =              0x00000001 //col:17192
SEGMENT_DESCRIPTOR_TYPE_DATA_READ_WRITE =                      0x00000002 //col:17197
SEGMENT_DESCRIPTOR_TYPE_DATA_READ_WRITE_ACCESSED =             0x00000003 //col:17202
SEGMENT_DESCRIPTOR_TYPE_DATA_READ_ONLY_EXPAND_DOWN =           0x00000004 //col:17207
SEGMENT_DESCRIPTOR_TYPE_DATA_READ_ONLY_EXPAND_DOWN_ACCESSED =  0x00000005 //col:17212
SEGMENT_DESCRIPTOR_TYPE_DATA_READ_WRITE_EXPAND_DOWN =          0x00000006 //col:17217
SEGMENT_DESCRIPTOR_TYPE_DATA_READ_WRITE_EXPAND_DOWN_ACCESSED = 0x00000007 //col:17222
SEGMENT_DESCRIPTOR_TYPE_CODE_EXECUTE_ONLY =                    0x00000008 //col:17227
SEGMENT_DESCRIPTOR_TYPE_CODE_EXECUTE_ONLY_ACCESSED =           0x00000009 //col:17232
SEGMENT_DESCRIPTOR_TYPE_CODE_EXECUTE_READ =                    0x0000000A //col:17237
SEGMENT_DESCRIPTOR_TYPE_CODE_EXECUTE_READ_ACCESSED =           0x0000000B //col:17242
SEGMENT_DESCRIPTOR_TYPE_CODE_EXECUTE_ONLY_CONFORMING =         0x0000000C //col:17247
SEGMENT_DESCRIPTOR_TYPE_CODE_EXECUTE_ONLY_CONFORMING_ACCESSED = 0x0000000D //col:17252
SEGMENT_DESCRIPTOR_TYPE_CODE_EXECUTE_READ_CONFORMING =         0x0000000E //col:17257
SEGMENT_DESCRIPTOR_TYPE_CODE_EXECUTE_READ_CONFORMING_ACCESSED = 0x0000000F //col:17262
SEGMENT_DESCRIPTOR_TYPE_RESERVED_1 =                           0x00000000 //col:17291
SEGMENT_DESCRIPTOR_TYPE_TSS_16_AVAILABLE =                     0x00000001 //col:17297
SEGMENT_DESCRIPTOR_TYPE_LDT =                                  0x00000002 //col:17303
SEGMENT_DESCRIPTOR_TYPE_TSS_16_BUSY =                          0x00000003 //col:17309
SEGMENT_DESCRIPTOR_TYPE_CALL_GATE_16 =                         0x00000004 //col:17315
SEGMENT_DESCRIPTOR_TYPE_TASK_GATE =                            0x00000005 //col:17321
SEGMENT_DESCRIPTOR_TYPE_INTERRUPT_GATE_16 =                    0x00000006 //col:17327
SEGMENT_DESCRIPTOR_TYPE_TRAP_GATE_16 =                         0x00000007 //col:17333
SEGMENT_DESCRIPTOR_TYPE_RESERVED_2 =                           0x00000008 //col:17339
SEGMENT_DESCRIPTOR_TYPE_TSS_AVAILABLE =                        0x00000009 //col:17345
SEGMENT_DESCRIPTOR_TYPE_RESERVED_3 =                           0x0000000A //col:17351
SEGMENT_DESCRIPTOR_TYPE_TSS_BUSY =                             0x0000000B //col:17357
SEGMENT_DESCRIPTOR_TYPE_CALL_GATE =                            0x0000000C //col:17363
SEGMENT_DESCRIPTOR_TYPE_RESERVED_4 =                           0x0000000D //col:17369
SEGMENT_DESCRIPTOR_TYPE_INTERRUPT_GATE =                       0x0000000E //col:17375
SEGMENT_DESCRIPTOR_TYPE_TRAP_GATE =                            0x0000000F //col:17381
SEGMENT_SELECTOR_REQUEST_PRIVILEGE_LEVEL_BIT =                 0 //col:17403
SEGMENT_SELECTOR_REQUEST_PRIVILEGE_LEVEL_FLAG =                0x03 //col:17404
SEGMENT_SELECTOR_REQUEST_PRIVILEGE_LEVEL_MASK =                0x03 //col:17405
SEGMENT_SELECTOR_REQUEST_PRIVILEGE_LEVEL(_) =                  (((_) >> 0) & 0x03) //col:17406
SEGMENT_SELECTOR_TABLE_BIT =                                   2 //col:17413
SEGMENT_SELECTOR_TABLE_FLAG =                                  0x04 //col:17414
SEGMENT_SELECTOR_TABLE_MASK =                                  0x01 //col:17415
SEGMENT_SELECTOR_TABLE(_) =                                    (((_) >> 2) & 0x01) //col:17416
SEGMENT_SELECTOR_INDEX_BIT =                                   3 //col:17424
SEGMENT_SELECTOR_INDEX_FLAG =                                  0xFFF8 //col:17425
SEGMENT_SELECTOR_INDEX_MASK =                                  0x1FFF //col:17426
SEGMENT_SELECTOR_INDEX(_) =                                    (((_) >> 3) & 0x1FFF) //col:17427
VMX_EXIT_REASON_EXCEPTION_OR_NMI =                             0x00000000 //col:17548
VMX_EXIT_REASON_EXTERNAL_INTERRUPT =                           0x00000001 //col:17555
VMX_EXIT_REASON_TRIPLE_FAULT =                                 0x00000002 //col:17563
VMX_EXIT_REASON_INIT_SIGNAL =                                  0x00000003 //col:17570
VMX_EXIT_REASON_STARTUP_IPI =                                  0x00000004 //col:17577
VMX_EXIT_REASON_IO_SMI =                                       0x00000005 //col:17586
VMX_EXIT_REASON_SMI =                                          0x00000006 //col:17595
VMX_EXIT_REASON_INTERRUPT_WINDOW =                             0x00000007 //col:17603
VMX_EXIT_REASON_NMI_WINDOW =                                   0x00000008 //col:17611
VMX_EXIT_REASON_TASK_SWITCH =                                  0x00000009 //col:17618
VMX_EXIT_REASON_EXECUTE_CPUID =                                0x0000000A //col:17625
VMX_EXIT_REASON_EXECUTE_GETSEC =                               0x0000000B //col:17632
VMX_EXIT_REASON_EXECUTE_HLT =                                  0x0000000C //col:17639
VMX_EXIT_REASON_EXECUTE_INVD =                                 0x0000000D //col:17646
VMX_EXIT_REASON_EXECUTE_INVLPG =                               0x0000000E //col:17653
VMX_EXIT_REASON_EXECUTE_RDPMC =                                0x0000000F //col:17660
VMX_EXIT_REASON_EXECUTE_RDTSC =                                0x00000010 //col:17667
VMX_EXIT_REASON_EXECUTE_RSM_IN_SMM =                           0x00000011 //col:17674
VMX_EXIT_REASON_EXECUTE_VMCALL =                               0x00000012 //col:17684
VMX_EXIT_REASON_EXECUTE_VMCLEAR =                              0x00000013 //col:17691
VMX_EXIT_REASON_EXECUTE_VMLAUNCH =                             0x00000014 //col:17698
VMX_EXIT_REASON_EXECUTE_VMPTRLD =                              0x00000015 //col:17705
VMX_EXIT_REASON_EXECUTE_VMPTRST =                              0x00000016 //col:17712
VMX_EXIT_REASON_EXECUTE_VMREAD =                               0x00000017 //col:17719
VMX_EXIT_REASON_EXECUTE_VMRESUME =                             0x00000018 //col:17726
VMX_EXIT_REASON_EXECUTE_VMWRITE =                              0x00000019 //col:17733
VMX_EXIT_REASON_EXECUTE_VMXOFF =                               0x0000001A //col:17740
VMX_EXIT_REASON_EXECUTE_VMXON =                                0x0000001B //col:17747
VMX_EXIT_REASON_MOV_CR =                                       0x0000001C //col:17759
VMX_EXIT_REASON_MOV_DR =                                       0x0000001D //col:17766
VMX_EXIT_REASON_EXECUTE_IO_INSTRUCTION =                       0x0000001E //col:17776
VMX_EXIT_REASON_EXECUTE_RDMSR =                                0x0000001F //col:17789
VMX_EXIT_REASON_EXECUTE_WRMSR =                                0x00000020 //col:17802
VMX_EXIT_REASON_ERROR_INVALID_GUEST_STATE =                    0x00000021 //col:17809
VMX_EXIT_REASON_ERROR_MSR_LOAD =                               0x00000022 //col:17816
VMX_EXIT_REASON_EXECUTE_MWAIT =                                0x00000024 //col:17823
VMX_EXIT_REASON_MONITOR_TRAP_FLAG =                            0x00000025 //col:17833
VMX_EXIT_REASON_EXECUTE_MONITOR =                              0x00000027 //col:17840
VMX_EXIT_REASON_EXECUTE_PAUSE =                                0x00000028 //col:17850
VMX_EXIT_REASON_ERROR_MACHINE_CHECK =                          0x00000029 //col:17859
VMX_EXIT_REASON_TPR_BELOW_THRESHOLD =                          0x0000002B //col:17871
VMX_EXIT_REASON_APIC_ACCESS =                                  0x0000002C //col:17881
VMX_EXIT_REASON_VIRTUALIZED_EOI =                              0x0000002D //col:17888
VMX_EXIT_REASON_GDTR_IDTR_ACCESS =                             0x0000002E //col:17896
VMX_EXIT_REASON_LDTR_TR_ACCESS =                               0x0000002F //col:17904
VMX_EXIT_REASON_EPT_VIOLATION =                                0x00000030 //col:17912
VMX_EXIT_REASON_EPT_MISCONFIGURATION =                         0x00000031 //col:17919
VMX_EXIT_REASON_EXECUTE_INVEPT =                               0x00000032 //col:17926
VMX_EXIT_REASON_EXECUTE_RDTSCP =                               0x00000033 //col:17934
VMX_EXIT_REASON_VMX_PREEMPTION_TIMER_EXPIRED =                 0x00000034 //col:17941
VMX_EXIT_REASON_EXECUTE_INVVPID =                              0x00000035 //col:17948
VMX_EXIT_REASON_EXECUTE_WBINVD =                               0x00000036 //col:17955
VMX_EXIT_REASON_EXECUTE_XSETBV =                               0x00000037 //col:17962
VMX_EXIT_REASON_APIC_WRITE =                                   0x00000038 //col:17971
VMX_EXIT_REASON_EXECUTE_RDRAND =                               0x00000039 //col:17978
VMX_EXIT_REASON_EXECUTE_INVPCID =                              0x0000003A //col:17986
VMX_EXIT_REASON_EXECUTE_VMFUNC =                               0x0000003B //col:17994
VMX_EXIT_REASON_EXECUTE_ENCLS =                                0x0000003C //col:18003
VMX_EXIT_REASON_EXECUTE_RDSEED =                               0x0000003D //col:18010
VMX_EXIT_REASON_PAGE_MODIFICATION_LOG_FULL =                   0x0000003E //col:18018
VMX_EXIT_REASON_EXECUTE_XSAVES =                               0x0000003F //col:18026
VMX_EXIT_REASON_EXECUTE_XRSTORS =                              0x00000040 //col:18034
VMX_ERROR_VMCALL_IN_VMX_ROOT_OPERATION =                       0x00000001 //col:18051
VMX_ERROR_VMCLEAR_INVALID_PHYSICAL_ADDRESS =                   0x00000002 //col:18056
VMX_ERROR_VMCLEAR_INVALID_VMXON_POINTER =                      0x00000003 //col:18061
VMX_ERROR_VMLAUCH_NON_CLEAR_VMCS =                             0x00000004 //col:18066
VMX_ERROR_VMRESUME_NON_LAUNCHED_VMCS =                         0x00000005 //col:18071
VMX_ERROR_VMRESUME_AFTER_VMXOFF =                              0x00000006 //col:18076
VMX_ERROR_VMENTRY_INVALID_CONTROL_FIELDS =                     0x00000007 //col:18081
VMX_ERROR_VMENTRY_INVALID_HOST_STATE =                         0x00000008 //col:18086
VMX_ERROR_VMPTRLD_INVALID_PHYSICAL_ADDRESS =                   0x00000009 //col:18091
VMX_ERROR_VMPTRLD_VMXON_POINTER =                              0x0000000A //col:18096
VMX_ERROR_VMPTRLD_INCORRECT_VMCS_REVISION_ID =                 0x0000000B //col:18101
VMX_ERROR_VMREAD_VMWRITE_INVALID_COMPONENT =                   0x0000000C //col:18106
VMX_ERROR_VMWRITE_READONLY_COMPONENT =                         0x0000000D //col:18111
VMX_ERROR_VMXON_IN_VMX_ROOT_OP =                               0x0000000F //col:18116
VMX_ERROR_VMENTRY_INVALID_VMCS_EXECUTIVE_POINTER =             0x00000010 //col:18121
VMX_ERROR_VMENTRY_NON_LAUNCHED_EXECUTIVE_VMCS =                0x00000011 //col:18126
VMX_ERROR_VMENTRY_EXECUTIVE_VMCS_PTR =                         0x00000012 //col:18132
VMX_ERROR_VMCALL_NON_CLEAR_VMCS =                              0x00000013 //col:18137
VMX_ERROR_VMCALL_INVALID_VMEXIT_FIELDS =                       0x00000014 //col:18142
VMX_ERROR_VMCALL_INVALID_MSEG_REVISION_ID =                    0x00000016 //col:18147
VMX_ERROR_VMXOFF_DUAL_MONITOR =                                0x00000017 //col:18152
VMX_ERROR_VMCALL_INVALID_SMM_MONITOR =                         0x00000018 //col:18157
VMX_ERROR_VMENTRY_INVALID_VM_EXECUTION_CONTROL =               0x00000019 //col:18162
VMX_ERROR_VMENTRY_MOV_SS =                                     0x0000001A //col:18167
VMX_ERROR_INVEPT_INVVPID_INVALID_OPERAND =                     0x0000001C //col:18172
VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_BREAKPOINT_CONDITION_BIT = 0 //col:18253
VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_BREAKPOINT_CONDITION_FLAG = 0x0F //col:18254
VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_BREAKPOINT_CONDITION_MASK = 0x0F //col:18255
VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_BREAKPOINT_CONDITION(_) = (((_) >> 0) & 0x0F) //col:18256
VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_DEBUG_REGISTER_ACCESS_DETECTED_BIT = 13 //col:18265
VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_DEBUG_REGISTER_ACCESS_DETECTED_FLAG = 0x2000 //col:18266
VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_DEBUG_REGISTER_ACCESS_DETECTED_MASK = 0x01 //col:18267
VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_DEBUG_REGISTER_ACCESS_DETECTED(_) = (((_) >> 13) & 0x01) //col:18268
VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_SINGLE_INSTRUCTION_BIT = 14 //col:18277
VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_SINGLE_INSTRUCTION_FLAG = 0x4000 //col:18278
VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_SINGLE_INSTRUCTION_MASK = 0x01 //col:18279
VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_SINGLE_INSTRUCTION(_) = (((_) >> 14) & 0x01) //col:18280
VMX_EXIT_QUALIFICATION_TASK_SWITCH_SELECTOR_BIT =              0 //col:18298
VMX_EXIT_QUALIFICATION_TASK_SWITCH_SELECTOR_FLAG =             0xFFFF //col:18299
VMX_EXIT_QUALIFICATION_TASK_SWITCH_SELECTOR_MASK =             0xFFFF //col:18300
VMX_EXIT_QUALIFICATION_TASK_SWITCH_SELECTOR(_) =               (((_) >> 0) & 0xFFFF) //col:18301
VMX_EXIT_QUALIFICATION_TASK_SWITCH_SOURCE_BIT =                30 //col:18308
VMX_EXIT_QUALIFICATION_TASK_SWITCH_SOURCE_FLAG =               0xC0000000 //col:18309
VMX_EXIT_QUALIFICATION_TASK_SWITCH_SOURCE_MASK =               0x03 //col:18310
VMX_EXIT_QUALIFICATION_TASK_SWITCH_SOURCE(_) =                 (((_) >> 30) & 0x03) //col:18311
VMX_EXIT_QUALIFICATION_TYPE_CALL_INSTRUCTION =                 0x00000000 //col:18312
VMX_EXIT_QUALIFICATION_TYPE_IRET_INSTRUCTION =                 0x00000001 //col:18313
VMX_EXIT_QUALIFICATION_TYPE_JMP_INSTRUCTION =                  0x00000002 //col:18314
VMX_EXIT_QUALIFICATION_TYPE_TASK_GATE_IN_IDT =                 0x00000003 //col:18315
VMX_EXIT_QUALIFICATION_MOV_CR_CONTROL_REGISTER_BIT =           0 //col:18334
VMX_EXIT_QUALIFICATION_MOV_CR_CONTROL_REGISTER_FLAG =          0x0F //col:18335
VMX_EXIT_QUALIFICATION_MOV_CR_CONTROL_REGISTER_MASK =          0x0F //col:18336
VMX_EXIT_QUALIFICATION_MOV_CR_CONTROL_REGISTER(_) =            (((_) >> 0) & 0x0F) //col:18337
VMX_EXIT_QUALIFICATION_REGISTER_CR0 =                          0x00000000 //col:18338
VMX_EXIT_QUALIFICATION_REGISTER_CR2 =                          0x00000002 //col:18339
VMX_EXIT_QUALIFICATION_REGISTER_CR3 =                          0x00000003 //col:18340
VMX_EXIT_QUALIFICATION_REGISTER_CR4 =                          0x00000004 //col:18341
VMX_EXIT_QUALIFICATION_REGISTER_CR8 =                          0x00000008 //col:18342
VMX_EXIT_QUALIFICATION_MOV_CR_ACCESS_TYPE_BIT =                4 //col:18348
VMX_EXIT_QUALIFICATION_MOV_CR_ACCESS_TYPE_FLAG =               0x30 //col:18349
VMX_EXIT_QUALIFICATION_MOV_CR_ACCESS_TYPE_MASK =               0x03 //col:18350
VMX_EXIT_QUALIFICATION_MOV_CR_ACCESS_TYPE(_) =                 (((_) >> 4) & 0x03) //col:18351
VMX_EXIT_QUALIFICATION_ACCESS_MOV_TO_CR =                      0x00000000 //col:18352
VMX_EXIT_QUALIFICATION_ACCESS_MOV_FROM_CR =                    0x00000001 //col:18353
VMX_EXIT_QUALIFICATION_ACCESS_CLTS =                           0x00000002 //col:18354
VMX_EXIT_QUALIFICATION_ACCESS_LMSW =                           0x00000003 //col:18355
VMX_EXIT_QUALIFICATION_MOV_CR_LMSW_OPERAND_TYPE_BIT =          6 //col:18361
VMX_EXIT_QUALIFICATION_MOV_CR_LMSW_OPERAND_TYPE_FLAG =         0x40 //col:18362
VMX_EXIT_QUALIFICATION_MOV_CR_LMSW_OPERAND_TYPE_MASK =         0x01 //col:18363
VMX_EXIT_QUALIFICATION_MOV_CR_LMSW_OPERAND_TYPE(_) =           (((_) >> 6) & 0x01) //col:18364
VMX_EXIT_QUALIFICATION_LMSW_OP_REGISTER =                      0x00000000 //col:18365
VMX_EXIT_QUALIFICATION_LMSW_OP_MEMORY =                        0x00000001 //col:18366
VMX_EXIT_QUALIFICATION_MOV_CR_GENERAL_PURPOSE_REGISTER_BIT =   8 //col:18373
VMX_EXIT_QUALIFICATION_MOV_CR_GENERAL_PURPOSE_REGISTER_FLAG =  0xF00 //col:18374
VMX_EXIT_QUALIFICATION_MOV_CR_GENERAL_PURPOSE_REGISTER_MASK =  0x0F //col:18375
VMX_EXIT_QUALIFICATION_MOV_CR_GENERAL_PURPOSE_REGISTER(_) =    (((_) >> 8) & 0x0F) //col:18376
VMX_EXIT_QUALIFICATION_GENREG_RAX =                            0x00000000 //col:18377
VMX_EXIT_QUALIFICATION_GENREG_RCX =                            0x00000001 //col:18378
VMX_EXIT_QUALIFICATION_GENREG_RDX =                            0x00000002 //col:18379
VMX_EXIT_QUALIFICATION_GENREG_RBX =                            0x00000003 //col:18380
VMX_EXIT_QUALIFICATION_GENREG_RSP =                            0x00000004 //col:18381
VMX_EXIT_QUALIFICATION_GENREG_RBP =                            0x00000005 //col:18382
VMX_EXIT_QUALIFICATION_GENREG_RSI =                            0x00000006 //col:18383
VMX_EXIT_QUALIFICATION_GENREG_RDI =                            0x00000007 //col:18384
VMX_EXIT_QUALIFICATION_GENREG_R8 =                             0x00000008 //col:18385
VMX_EXIT_QUALIFICATION_GENREG_R9 =                             0x00000009 //col:18386
VMX_EXIT_QUALIFICATION_GENREG_R10 =                            0x0000000A //col:18387
VMX_EXIT_QUALIFICATION_GENREG_R11 =                            0x0000000B //col:18388
VMX_EXIT_QUALIFICATION_GENREG_R12 =                            0x0000000C //col:18389
VMX_EXIT_QUALIFICATION_GENREG_R13 =                            0x0000000D //col:18390
VMX_EXIT_QUALIFICATION_GENREG_R14 =                            0x0000000E //col:18391
VMX_EXIT_QUALIFICATION_GENREG_R15 =                            0x0000000F //col:18392
VMX_EXIT_QUALIFICATION_MOV_CR_LMSW_SOURCE_DATA_BIT =           16 //col:18399
VMX_EXIT_QUALIFICATION_MOV_CR_LMSW_SOURCE_DATA_FLAG =          0xFFFF0000 //col:18400
VMX_EXIT_QUALIFICATION_MOV_CR_LMSW_SOURCE_DATA_MASK =          0xFFFF //col:18401
VMX_EXIT_QUALIFICATION_MOV_CR_LMSW_SOURCE_DATA(_) =            (((_) >> 16) & 0xFFFF) //col:18402
VMX_EXIT_QUALIFICATION_MOV_DR_DEBUG_REGISTER_BIT =             0 //col:18420
VMX_EXIT_QUALIFICATION_MOV_DR_DEBUG_REGISTER_FLAG =            0x07 //col:18421
VMX_EXIT_QUALIFICATION_MOV_DR_DEBUG_REGISTER_MASK =            0x07 //col:18422
VMX_EXIT_QUALIFICATION_MOV_DR_DEBUG_REGISTER(_) =              (((_) >> 0) & 0x07) //col:18423
VMX_EXIT_QUALIFICATION_REGISTER_DR0 =                          0x00000000 //col:18424
VMX_EXIT_QUALIFICATION_REGISTER_DR1 =                          0x00000001 //col:18425
VMX_EXIT_QUALIFICATION_REGISTER_DR2 =                          0x00000002 //col:18426
VMX_EXIT_QUALIFICATION_REGISTER_DR3 =                          0x00000003 //col:18427
VMX_EXIT_QUALIFICATION_REGISTER_DR6 =                          0x00000006 //col:18428
VMX_EXIT_QUALIFICATION_REGISTER_DR7 =                          0x00000007 //col:18429
VMX_EXIT_QUALIFICATION_MOV_DR_DIRECTION_OF_ACCESS_BIT =        4 //col:18436
VMX_EXIT_QUALIFICATION_MOV_DR_DIRECTION_OF_ACCESS_FLAG =       0x10 //col:18437
VMX_EXIT_QUALIFICATION_MOV_DR_DIRECTION_OF_ACCESS_MASK =       0x01 //col:18438
VMX_EXIT_QUALIFICATION_MOV_DR_DIRECTION_OF_ACCESS(_) =         (((_) >> 4) & 0x01) //col:18439
VMX_EXIT_QUALIFICATION_DIRECTION_MOV_TO_DR =                   0x00000000 //col:18440
VMX_EXIT_QUALIFICATION_DIRECTION_MOV_FROM_DR =                 0x00000001 //col:18441
VMX_EXIT_QUALIFICATION_MOV_DR_GENERAL_PURPOSE_REGISTER_BIT =   8 //col:18448
VMX_EXIT_QUALIFICATION_MOV_DR_GENERAL_PURPOSE_REGISTER_FLAG =  0xF00 //col:18449
VMX_EXIT_QUALIFICATION_MOV_DR_GENERAL_PURPOSE_REGISTER_MASK =  0x0F //col:18450
VMX_EXIT_QUALIFICATION_MOV_DR_GENERAL_PURPOSE_REGISTER(_) =    (((_) >> 8) & 0x0F) //col:18451
VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_SIZE_OF_ACCESS_BIT =     0 //col:18469
VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_SIZE_OF_ACCESS_FLAG =    0x07 //col:18470
VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_SIZE_OF_ACCESS_MASK =    0x07 //col:18471
VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_SIZE_OF_ACCESS(_) =      (((_) >> 0) & 0x07) //col:18472
VMX_EXIT_QUALIFICATION_WIDTH_1_BYTE =                          0x00000000 //col:18473
VMX_EXIT_QUALIFICATION_WIDTH_2_BYTE =                          0x00000001 //col:18474
VMX_EXIT_QUALIFICATION_WIDTH_4_BYTE =                          0x00000003 //col:18475
VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_DIRECTION_OF_ACCESS_BIT = 3 //col:18481
VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_DIRECTION_OF_ACCESS_FLAG = 0x08 //col:18482
VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_DIRECTION_OF_ACCESS_MASK = 0x01 //col:18483
VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_DIRECTION_OF_ACCESS(_) = (((_) >> 3) & 0x01) //col:18484
VMX_EXIT_QUALIFICATION_DIRECTION_OUT =                         0x00000000 //col:18485
VMX_EXIT_QUALIFICATION_DIRECTION_IN =                          0x00000001 //col:18486
VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_STRING_INSTRUCTION_BIT = 4 //col:18492
VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_STRING_INSTRUCTION_FLAG = 0x10 //col:18493
VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_STRING_INSTRUCTION_MASK = 0x01 //col:18494
VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_STRING_INSTRUCTION(_) =  (((_) >> 4) & 0x01) //col:18495
VMX_EXIT_QUALIFICATION_IS_STRING_NOT_STRING =                  0x00000000 //col:18496
VMX_EXIT_QUALIFICATION_IS_STRING_STRING =                      0x00000001 //col:18497
VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_REP_PREFIXED_BIT =       5 //col:18503
VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_REP_PREFIXED_FLAG =      0x20 //col:18504
VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_REP_PREFIXED_MASK =      0x01 //col:18505
VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_REP_PREFIXED(_) =        (((_) >> 5) & 0x01) //col:18506
VMX_EXIT_QUALIFICATION_IS_REP_NOT_REP =                        0x00000000 //col:18507
VMX_EXIT_QUALIFICATION_IS_REP_REP =                            0x00000001 //col:18508
VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_OPERAND_ENCODING_BIT =   6 //col:18514
VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_OPERAND_ENCODING_FLAG =  0x40 //col:18515
VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_OPERAND_ENCODING_MASK =  0x01 //col:18516
VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_OPERAND_ENCODING(_) =    (((_) >> 6) & 0x01) //col:18517
VMX_EXIT_QUALIFICATION_ENCODING_DX =                           0x00000000 //col:18518
VMX_EXIT_QUALIFICATION_ENCODING_IMMEDIATE =                    0x00000001 //col:18519
VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_PORT_NUMBER_BIT =        16 //col:18526
VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_PORT_NUMBER_FLAG =       0xFFFF0000 //col:18527
VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_PORT_NUMBER_MASK =       0xFFFF //col:18528
VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_PORT_NUMBER(_) =         (((_) >> 16) & 0xFFFF) //col:18529
VMX_EXIT_QUALIFICATION_APIC_ACCESS_PAGE_OFFSET_BIT =           0 //col:18548
VMX_EXIT_QUALIFICATION_APIC_ACCESS_PAGE_OFFSET_FLAG =          0xFFF //col:18549
VMX_EXIT_QUALIFICATION_APIC_ACCESS_PAGE_OFFSET_MASK =          0xFFF //col:18550
VMX_EXIT_QUALIFICATION_APIC_ACCESS_PAGE_OFFSET(_) =            (((_) >> 0) & 0xFFF) //col:18551
VMX_EXIT_QUALIFICATION_APIC_ACCESS_ACCESS_TYPE_BIT =           12 //col:18557
VMX_EXIT_QUALIFICATION_APIC_ACCESS_ACCESS_TYPE_FLAG =          0xF000 //col:18558
VMX_EXIT_QUALIFICATION_APIC_ACCESS_ACCESS_TYPE_MASK =          0x0F //col:18559
VMX_EXIT_QUALIFICATION_APIC_ACCESS_ACCESS_TYPE(_) =            (((_) >> 12) & 0x0F) //col:18560
VMX_EXIT_QUALIFICATION_TYPE_LINEAR_READ =                      0x00000000 //col:18564
VMX_EXIT_QUALIFICATION_TYPE_LINEAR_WRITE =                     0x00000001 //col:18569
VMX_EXIT_QUALIFICATION_TYPE_LINEAR_INSTRUCTION_FETCH =         0x00000002 //col:18574
VMX_EXIT_QUALIFICATION_TYPE_LINEAR_EVENT_DELIVERY =            0x00000003 //col:18579
VMX_EXIT_QUALIFICATION_TYPE_PHYSICAL_EVENT_DELIVERY =          0x0000000A //col:18584
VMX_EXIT_QUALIFICATION_TYPE_PHYSICAL_INSTRUCTION_FETCH =       0x0000000F //col:18589
VMX_EXIT_QUALIFICATION_EPT_VIOLATION_READ_ACCESS_BIT =         0 //col:18607
VMX_EXIT_QUALIFICATION_EPT_VIOLATION_READ_ACCESS_FLAG =        0x01 //col:18608
VMX_EXIT_QUALIFICATION_EPT_VIOLATION_READ_ACCESS_MASK =        0x01 //col:18609
VMX_EXIT_QUALIFICATION_EPT_VIOLATION_READ_ACCESS(_) =          (((_) >> 0) & 0x01) //col:18610
VMX_EXIT_QUALIFICATION_EPT_VIOLATION_WRITE_ACCESS_BIT =        1 //col:18616
VMX_EXIT_QUALIFICATION_EPT_VIOLATION_WRITE_ACCESS_FLAG =       0x02 //col:18617
VMX_EXIT_QUALIFICATION_EPT_VIOLATION_WRITE_ACCESS_MASK =       0x01 //col:18618
VMX_EXIT_QUALIFICATION_EPT_VIOLATION_WRITE_ACCESS(_) =         (((_) >> 1) & 0x01) //col:18619
VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EXECUTE_ACCESS_BIT =      2 //col:18625
VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EXECUTE_ACCESS_FLAG =     0x04 //col:18626
VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EXECUTE_ACCESS_MASK =     0x01 //col:18627
VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EXECUTE_ACCESS(_) =       (((_) >> 2) & 0x01) //col:18628
VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_READABLE_BIT =        3 //col:18635
VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_READABLE_FLAG =       0x08 //col:18636
VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_READABLE_MASK =       0x01 //col:18637
VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_READABLE(_) =         (((_) >> 3) & 0x01) //col:18638
VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_WRITEABLE_BIT =       4 //col:18645
VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_WRITEABLE_FLAG =      0x10 //col:18646
VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_WRITEABLE_MASK =      0x01 //col:18647
VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_WRITEABLE(_) =        (((_) >> 4) & 0x01) //col:18648
VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_EXECUTABLE_BIT =      5 //col:18658
VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_EXECUTABLE_FLAG =     0x20 //col:18659
VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_EXECUTABLE_MASK =     0x01 //col:18660
VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_EXECUTABLE(_) =       (((_) >> 5) & 0x01) //col:18661
VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_EXECUTABLE_FOR_USER_MODE_BIT = 6 //col:18670
VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_EXECUTABLE_FOR_USER_MODE_FLAG = 0x40 //col:18671
VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_EXECUTABLE_FOR_USER_MODE_MASK = 0x01 //col:18672
VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_EXECUTABLE_FOR_USER_MODE(_) = (((_) >> 6) & 0x01) //col:18673
VMX_EXIT_QUALIFICATION_EPT_VIOLATION_VALID_GUEST_LINEAR_ADDRESS_BIT = 7 //col:18680
VMX_EXIT_QUALIFICATION_EPT_VIOLATION_VALID_GUEST_LINEAR_ADDRESS_FLAG = 0x80 //col:18681
VMX_EXIT_QUALIFICATION_EPT_VIOLATION_VALID_GUEST_LINEAR_ADDRESS_MASK = 0x01 //col:18682
VMX_EXIT_QUALIFICATION_EPT_VIOLATION_VALID_GUEST_LINEAR_ADDRESS(_) = (((_) >> 7) & 0x01) //col:18683
VMX_EXIT_QUALIFICATION_EPT_VIOLATION_CAUSED_BY_TRANSLATION_BIT = 8 //col:18694
VMX_EXIT_QUALIFICATION_EPT_VIOLATION_CAUSED_BY_TRANSLATION_FLAG = 0x100 //col:18695
VMX_EXIT_QUALIFICATION_EPT_VIOLATION_CAUSED_BY_TRANSLATION_MASK = 0x01 //col:18696
VMX_EXIT_QUALIFICATION_EPT_VIOLATION_CAUSED_BY_TRANSLATION(_) = (((_) >> 8) & 0x01) //col:18697
VMX_EXIT_QUALIFICATION_EPT_VIOLATION_USER_MODE_LINEAR_ADDRESS_BIT = 9 //col:18707
VMX_EXIT_QUALIFICATION_EPT_VIOLATION_USER_MODE_LINEAR_ADDRESS_FLAG = 0x200 //col:18708
VMX_EXIT_QUALIFICATION_EPT_VIOLATION_USER_MODE_LINEAR_ADDRESS_MASK = 0x01 //col:18709
VMX_EXIT_QUALIFICATION_EPT_VIOLATION_USER_MODE_LINEAR_ADDRESS(_) = (((_) >> 9) & 0x01) //col:18710
VMX_EXIT_QUALIFICATION_EPT_VIOLATION_READABLE_WRITABLE_PAGE_BIT = 10 //col:18720
VMX_EXIT_QUALIFICATION_EPT_VIOLATION_READABLE_WRITABLE_PAGE_FLAG = 0x400 //col:18721
VMX_EXIT_QUALIFICATION_EPT_VIOLATION_READABLE_WRITABLE_PAGE_MASK = 0x01 //col:18722
VMX_EXIT_QUALIFICATION_EPT_VIOLATION_READABLE_WRITABLE_PAGE(_) = (((_) >> 10) & 0x01) //col:18723
VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EXECUTE_DISABLE_PAGE_BIT = 11 //col:18733
VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EXECUTE_DISABLE_PAGE_FLAG = 0x800 //col:18734
VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EXECUTE_DISABLE_PAGE_MASK = 0x01 //col:18735
VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EXECUTE_DISABLE_PAGE(_) = (((_) >> 11) & 0x01) //col:18736
VMX_EXIT_QUALIFICATION_EPT_VIOLATION_NMI_UNBLOCKING_BIT =      12 //col:18742
VMX_EXIT_QUALIFICATION_EPT_VIOLATION_NMI_UNBLOCKING_FLAG =     0x1000 //col:18743
VMX_EXIT_QUALIFICATION_EPT_VIOLATION_NMI_UNBLOCKING_MASK =     0x01 //col:18744
VMX_EXIT_QUALIFICATION_EPT_VIOLATION_NMI_UNBLOCKING(_) =       (((_) >> 12) & 0x01) //col:18745
VMX_EXIT_QUALIFICATION_EPT_VIOLATION_SHADOW_STACK_ACCESS_BIT = 13 //col:18751
VMX_EXIT_QUALIFICATION_EPT_VIOLATION_SHADOW_STACK_ACCESS_FLAG = 0x2000 //col:18752
VMX_EXIT_QUALIFICATION_EPT_VIOLATION_SHADOW_STACK_ACCESS_MASK = 0x01 //col:18753
VMX_EXIT_QUALIFICATION_EPT_VIOLATION_SHADOW_STACK_ACCESS(_) =  (((_) >> 13) & 0x01) //col:18754
VMX_EXIT_QUALIFICATION_EPT_VIOLATION_SUPERVISOR_SHADOW_STACK_BIT = 14 //col:18763
VMX_EXIT_QUALIFICATION_EPT_VIOLATION_SUPERVISOR_SHADOW_STACK_FLAG = 0x4000 //col:18764
VMX_EXIT_QUALIFICATION_EPT_VIOLATION_SUPERVISOR_SHADOW_STACK_MASK = 0x01 //col:18765
VMX_EXIT_QUALIFICATION_EPT_VIOLATION_SUPERVISOR_SHADOW_STACK(_) = (((_) >> 14) & 0x01) //col:18766
VMX_EXIT_QUALIFICATION_EPT_VIOLATION_GUEST_PAGING_VERIFICATION_BIT = 15 //col:18772
VMX_EXIT_QUALIFICATION_EPT_VIOLATION_GUEST_PAGING_VERIFICATION_FLAG = 0x8000 //col:18773
VMX_EXIT_QUALIFICATION_EPT_VIOLATION_GUEST_PAGING_VERIFICATION_MASK = 0x01 //col:18774
VMX_EXIT_QUALIFICATION_EPT_VIOLATION_GUEST_PAGING_VERIFICATION(_) = (((_) >> 15) & 0x01) //col:18775
VMX_EXIT_QUALIFICATION_EPT_VIOLATION_ASYNCHRONOUS_TO_INSTRUCTION_BIT = 16 //col:18782
VMX_EXIT_QUALIFICATION_EPT_VIOLATION_ASYNCHRONOUS_TO_INSTRUCTION_FLAG = 0x10000 //col:18783
VMX_EXIT_QUALIFICATION_EPT_VIOLATION_ASYNCHRONOUS_TO_INSTRUCTION_MASK = 0x01 //col:18784
VMX_EXIT_QUALIFICATION_EPT_VIOLATION_ASYNCHRONOUS_TO_INSTRUCTION(_) = (((_) >> 16) & 0x01) //col:18785
VMX_VMEXIT_INSTRUCTION_INFO_INS_OUTS_ADDRESS_SIZE_BIT =        7 //col:18823
VMX_VMEXIT_INSTRUCTION_INFO_INS_OUTS_ADDRESS_SIZE_FLAG =       0x380 //col:18824
VMX_VMEXIT_INSTRUCTION_INFO_INS_OUTS_ADDRESS_SIZE_MASK =       0x07 //col:18825
VMX_VMEXIT_INSTRUCTION_INFO_INS_OUTS_ADDRESS_SIZE(_) =         (((_) >> 7) & 0x07) //col:18826
VMX_VMEXIT_INSTRUCTION_INFO_INS_OUTS_SEGMENT_REGISTER_BIT =    15 //col:18841
VMX_VMEXIT_INSTRUCTION_INFO_INS_OUTS_SEGMENT_REGISTER_FLAG =   0x38000 //col:18842
VMX_VMEXIT_INSTRUCTION_INFO_INS_OUTS_SEGMENT_REGISTER_MASK =   0x07 //col:18843
VMX_VMEXIT_INSTRUCTION_INFO_INS_OUTS_SEGMENT_REGISTER(_) =     (((_) >> 15) & 0x07) //col:18844
VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_SCALING_BIT =           0 //col:18868
VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_SCALING_FLAG =          0x03 //col:18869
VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_SCALING_MASK =          0x03 //col:18870
VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_SCALING(_) =            (((_) >> 0) & 0x03) //col:18871
VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_ADDRESS_SIZE_BIT =      7 //col:18883
VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_ADDRESS_SIZE_FLAG =     0x380 //col:18884
VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_ADDRESS_SIZE_MASK =     0x07 //col:18885
VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_ADDRESS_SIZE(_) =       (((_) >> 7) & 0x07) //col:18886
VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_SEGMENT_REGISTER_BIT =  15 //col:18901
VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_SEGMENT_REGISTER_FLAG = 0x38000 //col:18902
VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_SEGMENT_REGISTER_MASK = 0x07 //col:18903
VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_SEGMENT_REGISTER(_) =   (((_) >> 15) & 0x07) //col:18904
VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_GENERAL_PURPOSE_REGISTER_BIT = 18 //col:18910
VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_GENERAL_PURPOSE_REGISTER_FLAG = 0x3C0000 //col:18911
VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_GENERAL_PURPOSE_REGISTER_MASK = 0x0F //col:18912
VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_GENERAL_PURPOSE_REGISTER(_) = (((_) >> 18) & 0x0F) //col:18913
VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_GENERAL_PURPOSE_REGISTER_INVALID_BIT = 22 //col:18919
VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_GENERAL_PURPOSE_REGISTER_INVALID_FLAG = 0x400000 //col:18920
VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_GENERAL_PURPOSE_REGISTER_INVALID_MASK = 0x01 //col:18921
VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_GENERAL_PURPOSE_REGISTER_INVALID(_) = (((_) >> 22) & 0x01) //col:18922
VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_BASE_REGISTER_BIT =     23 //col:18929
VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_BASE_REGISTER_FLAG =    0x7800000 //col:18930
VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_BASE_REGISTER_MASK =    0x0F //col:18931
VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_BASE_REGISTER(_) =      (((_) >> 23) & 0x0F) //col:18932
VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_BASE_REGISTER_INVALID_BIT = 27 //col:18938
VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_BASE_REGISTER_INVALID_FLAG = 0x8000000 //col:18939
VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_BASE_REGISTER_INVALID_MASK = 0x01 //col:18940
VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_BASE_REGISTER_INVALID(_) = (((_) >> 27) & 0x01) //col:18941
VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_REGISTER_2_BIT =        28 //col:18947
VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_REGISTER_2_FLAG =       0xF0000000 //col:18948
VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_REGISTER_2_MASK =       0x0F //col:18949
VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_REGISTER_2(_) =         (((_) >> 28) & 0x0F) //col:18950
VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_SCALING_BIT =     0 //col:18974
VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_SCALING_FLAG =    0x03 //col:18975
VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_SCALING_MASK =    0x03 //col:18976
VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_SCALING(_) =      (((_) >> 0) & 0x03) //col:18977
VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_ADDRESS_SIZE_BIT = 7 //col:18989
VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_ADDRESS_SIZE_FLAG = 0x380 //col:18990
VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_ADDRESS_SIZE_MASK = 0x07 //col:18991
VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_ADDRESS_SIZE(_) = (((_) >> 7) & 0x07) //col:18992
VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_OPERAND_SIZE_BIT = 11 //col:19003
VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_OPERAND_SIZE_FLAG = 0x800 //col:19004
VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_OPERAND_SIZE_MASK = 0x01 //col:19005
VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_OPERAND_SIZE(_) = (((_) >> 11) & 0x01) //col:19006
VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_SEGMENT_REGISTER_BIT = 15 //col:19021
VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_SEGMENT_REGISTER_FLAG = 0x38000 //col:19022
VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_SEGMENT_REGISTER_MASK = 0x07 //col:19023
VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_SEGMENT_REGISTER(_) = (((_) >> 15) & 0x07) //col:19024
VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_GENERAL_PURPOSE_REGISTER_BIT = 18 //col:19030
VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_GENERAL_PURPOSE_REGISTER_FLAG = 0x3C0000 //col:19031
VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_GENERAL_PURPOSE_REGISTER_MASK = 0x0F //col:19032
VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_GENERAL_PURPOSE_REGISTER(_) = (((_) >> 18) & 0x0F) //col:19033
VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_GENERAL_PURPOSE_REGISTER_INVALID_BIT = 22 //col:19039
VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_GENERAL_PURPOSE_REGISTER_INVALID_FLAG = 0x400000 //col:19040
VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_GENERAL_PURPOSE_REGISTER_INVALID_MASK = 0x01 //col:19041
VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_GENERAL_PURPOSE_REGISTER_INVALID(_) = (((_) >> 22) & 0x01) //col:19042
VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_BASE_REGISTER_BIT = 23 //col:19049
VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_BASE_REGISTER_FLAG = 0x7800000 //col:19050
VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_BASE_REGISTER_MASK = 0x0F //col:19051
VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_BASE_REGISTER(_) = (((_) >> 23) & 0x0F) //col:19052
VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_BASE_REGISTER_INVALID_BIT = 27 //col:19058
VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_BASE_REGISTER_INVALID_FLAG = 0x8000000 //col:19059
VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_BASE_REGISTER_INVALID_MASK = 0x01 //col:19060
VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_BASE_REGISTER_INVALID(_) = (((_) >> 27) & 0x01) //col:19061
VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_INSTRUCTION_BIT = 28 //col:19072
VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_INSTRUCTION_FLAG = 0x30000000 //col:19073
VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_INSTRUCTION_MASK = 0x03 //col:19074
VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_INSTRUCTION(_) =  (((_) >> 28) & 0x03) //col:19075
VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_SCALING_BIT =       0 //col:19099
VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_SCALING_FLAG =      0x03 //col:19100
VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_SCALING_MASK =      0x03 //col:19101
VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_SCALING(_) =        (((_) >> 0) & 0x03) //col:19102
VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_REG_1_BIT =         3 //col:19109
VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_REG_1_FLAG =        0x78 //col:19110
VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_REG_1_MASK =        0x0F //col:19111
VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_REG_1(_) =          (((_) >> 3) & 0x0F) //col:19112
VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_ADDRESS_SIZE_BIT =  7 //col:19123
VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_ADDRESS_SIZE_FLAG = 0x380 //col:19124
VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_ADDRESS_SIZE_MASK = 0x07 //col:19125
VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_ADDRESS_SIZE(_) =   (((_) >> 7) & 0x07) //col:19126
VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_MEMORY_REGISTER_BIT = 10 //col:19132
VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_MEMORY_REGISTER_FLAG = 0x400 //col:19133
VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_MEMORY_REGISTER_MASK = 0x01 //col:19134
VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_MEMORY_REGISTER(_) = (((_) >> 10) & 0x01) //col:19135
VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_SEGMENT_REGISTER_BIT = 15 //col:19150
VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_SEGMENT_REGISTER_FLAG = 0x38000 //col:19151
VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_SEGMENT_REGISTER_MASK = 0x07 //col:19152
VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_SEGMENT_REGISTER(_) = (((_) >> 15) & 0x07) //col:19153
VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_GENERAL_PURPOSE_REGISTER_BIT = 18 //col:19160
VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_GENERAL_PURPOSE_REGISTER_FLAG = 0x3C0000 //col:19161
VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_GENERAL_PURPOSE_REGISTER_MASK = 0x0F //col:19162
VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_GENERAL_PURPOSE_REGISTER(_) = (((_) >> 18) & 0x0F) //col:19163
VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_GENERAL_PURPOSE_REGISTER_INVALID_BIT = 22 //col:19169
VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_GENERAL_PURPOSE_REGISTER_INVALID_FLAG = 0x400000 //col:19170
VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_GENERAL_PURPOSE_REGISTER_INVALID_MASK = 0x01 //col:19171
VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_GENERAL_PURPOSE_REGISTER_INVALID(_) = (((_) >> 22) & 0x01) //col:19172
VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_BASE_REGISTER_BIT = 23 //col:19179
VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_BASE_REGISTER_FLAG = 0x7800000 //col:19180
VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_BASE_REGISTER_MASK = 0x0F //col:19181
VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_BASE_REGISTER(_) =  (((_) >> 23) & 0x0F) //col:19182
VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_BASE_REGISTER_INVALID_BIT = 27 //col:19188
VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_BASE_REGISTER_INVALID_FLAG = 0x8000000 //col:19189
VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_BASE_REGISTER_INVALID_MASK = 0x01 //col:19190
VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_BASE_REGISTER_INVALID(_) = (((_) >> 27) & 0x01) //col:19191
VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_INSTRUCTION_BIT =   28 //col:19202
VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_INSTRUCTION_FLAG =  0x30000000 //col:19203
VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_INSTRUCTION_MASK =  0x03 //col:19204
VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_INSTRUCTION(_) =    (((_) >> 28) & 0x03) //col:19205
VMX_VMEXIT_INSTRUCTION_INFO_RDRAND_RDSEED_DESTINATION_REGISTER_BIT = 3 //col:19225
VMX_VMEXIT_INSTRUCTION_INFO_RDRAND_RDSEED_DESTINATION_REGISTER_FLAG = 0x78 //col:19226
VMX_VMEXIT_INSTRUCTION_INFO_RDRAND_RDSEED_DESTINATION_REGISTER_MASK = 0x0F //col:19227
VMX_VMEXIT_INSTRUCTION_INFO_RDRAND_RDSEED_DESTINATION_REGISTER(_) = (((_) >> 3) & 0x0F) //col:19228
VMX_VMEXIT_INSTRUCTION_INFO_RDRAND_RDSEED_OPERAND_SIZE_BIT =   11 //col:19240
VMX_VMEXIT_INSTRUCTION_INFO_RDRAND_RDSEED_OPERAND_SIZE_FLAG =  0x1800 //col:19241
VMX_VMEXIT_INSTRUCTION_INFO_RDRAND_RDSEED_OPERAND_SIZE_MASK =  0x03 //col:19242
VMX_VMEXIT_INSTRUCTION_INFO_RDRAND_RDSEED_OPERAND_SIZE(_) =    (((_) >> 11) & 0x03) //col:19243
VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_SCALING_BIT =       0 //col:19267
VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_SCALING_FLAG =      0x03 //col:19268
VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_SCALING_MASK =      0x03 //col:19269
VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_SCALING(_) =        (((_) >> 0) & 0x03) //col:19270
VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_ADDRESS_SIZE_BIT =  7 //col:19282
VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_ADDRESS_SIZE_FLAG = 0x380 //col:19283
VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_ADDRESS_SIZE_MASK = 0x07 //col:19284
VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_ADDRESS_SIZE(_) =   (((_) >> 7) & 0x07) //col:19285
VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_SEGMENT_REGISTER_BIT = 15 //col:19300
VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_SEGMENT_REGISTER_FLAG = 0x38000 //col:19301
VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_SEGMENT_REGISTER_MASK = 0x07 //col:19302
VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_SEGMENT_REGISTER(_) = (((_) >> 15) & 0x07) //col:19303
VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_GENERAL_PURPOSE_REGISTER_BIT = 18 //col:19309
VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_GENERAL_PURPOSE_REGISTER_FLAG = 0x3C0000 //col:19310
VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_GENERAL_PURPOSE_REGISTER_MASK = 0x0F //col:19311
VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_GENERAL_PURPOSE_REGISTER(_) = (((_) >> 18) & 0x0F) //col:19312
VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_GENERAL_PURPOSE_REGISTER_INVALID_BIT = 22 //col:19318
VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_GENERAL_PURPOSE_REGISTER_INVALID_FLAG = 0x400000 //col:19319
VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_GENERAL_PURPOSE_REGISTER_INVALID_MASK = 0x01 //col:19320
VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_GENERAL_PURPOSE_REGISTER_INVALID(_) = (((_) >> 22) & 0x01) //col:19321
VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_BASE_REGISTER_BIT = 23 //col:19328
VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_BASE_REGISTER_FLAG = 0x7800000 //col:19329
VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_BASE_REGISTER_MASK = 0x0F //col:19330
VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_BASE_REGISTER(_) =  (((_) >> 23) & 0x0F) //col:19331
VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_BASE_REGISTER_INVALID_BIT = 27 //col:19337
VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_BASE_REGISTER_INVALID_FLAG = 0x8000000 //col:19338
VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_BASE_REGISTER_INVALID_MASK = 0x01 //col:19339
VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_BASE_REGISTER_INVALID(_) = (((_) >> 27) & 0x01) //col:19340
VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_SCALING_BIT =       0 //col:19365
VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_SCALING_FLAG =      0x03 //col:19366
VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_SCALING_MASK =      0x03 //col:19367
VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_SCALING(_) =        (((_) >> 0) & 0x03) //col:19368
VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_REGISTER_1_BIT =    3 //col:19375
VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_REGISTER_1_FLAG =   0x78 //col:19376
VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_REGISTER_1_MASK =   0x0F //col:19377
VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_REGISTER_1(_) =     (((_) >> 3) & 0x0F) //col:19378
VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_ADDRESS_SIZE_BIT =  7 //col:19389
VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_ADDRESS_SIZE_FLAG = 0x380 //col:19390
VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_ADDRESS_SIZE_MASK = 0x07 //col:19391
VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_ADDRESS_SIZE(_) =   (((_) >> 7) & 0x07) //col:19392
VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_MEMORY_REGISTER_BIT = 10 //col:19398
VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_MEMORY_REGISTER_FLAG = 0x400 //col:19399
VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_MEMORY_REGISTER_MASK = 0x01 //col:19400
VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_MEMORY_REGISTER(_) = (((_) >> 10) & 0x01) //col:19401
VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_SEGMENT_REGISTER_BIT = 15 //col:19416
VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_SEGMENT_REGISTER_FLAG = 0x38000 //col:19417
VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_SEGMENT_REGISTER_MASK = 0x07 //col:19418
VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_SEGMENT_REGISTER(_) = (((_) >> 15) & 0x07) //col:19419
VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_GENERAL_PURPOSE_REGISTER_BIT = 18 //col:19426
VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_GENERAL_PURPOSE_REGISTER_FLAG = 0x3C0000 //col:19427
VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_GENERAL_PURPOSE_REGISTER_MASK = 0x0F //col:19428
VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_GENERAL_PURPOSE_REGISTER(_) = (((_) >> 18) & 0x0F) //col:19429
VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_GENERAL_PURPOSE_REGISTER_INVALID_BIT = 22 //col:19435
VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_GENERAL_PURPOSE_REGISTER_INVALID_FLAG = 0x400000 //col:19436
VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_GENERAL_PURPOSE_REGISTER_INVALID_MASK = 0x01 //col:19437
VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_GENERAL_PURPOSE_REGISTER_INVALID(_) = (((_) >> 22) & 0x01) //col:19438
VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_BASE_REGISTER_BIT = 23 //col:19445
VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_BASE_REGISTER_FLAG = 0x7800000 //col:19446
VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_BASE_REGISTER_MASK = 0x0F //col:19447
VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_BASE_REGISTER(_) =  (((_) >> 23) & 0x0F) //col:19448
VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_BASE_REGISTER_INVALID_BIT = 27 //col:19454
VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_BASE_REGISTER_INVALID_FLAG = 0x8000000 //col:19455
VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_BASE_REGISTER_INVALID_MASK = 0x01 //col:19456
VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_BASE_REGISTER_INVALID(_) = (((_) >> 27) & 0x01) //col:19457
VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_REGISTER_2_BIT =    28 //col:19463
VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_REGISTER_2_FLAG =   0xF0000000 //col:19464
VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_REGISTER_2_MASK =   0x0F //col:19465
VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_REGISTER_2(_) =     (((_) >> 28) & 0x0F) //col:19466
VMX_SEGMENT_ACCESS_RIGHTS_TYPE_BIT =                           0 //col:19501
VMX_SEGMENT_ACCESS_RIGHTS_TYPE_FLAG =                          0x0F //col:19502
VMX_SEGMENT_ACCESS_RIGHTS_TYPE_MASK =                          0x0F //col:19503
VMX_SEGMENT_ACCESS_RIGHTS_TYPE(_) =                            (((_) >> 0) & 0x0F) //col:19504
VMX_SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_TYPE_BIT =                4 //col:19510
VMX_SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_TYPE_FLAG =               0x10 //col:19511
VMX_SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_TYPE_MASK =               0x01 //col:19512
VMX_SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_TYPE(_) =                 (((_) >> 4) & 0x01) //col:19513
VMX_SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_PRIVILEGE_LEVEL_BIT =     5 //col:19519
VMX_SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_PRIVILEGE_LEVEL_FLAG =    0x60 //col:19520
VMX_SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_PRIVILEGE_LEVEL_MASK =    0x03 //col:19521
VMX_SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_PRIVILEGE_LEVEL(_) =      (((_) >> 5) & 0x03) //col:19522
VMX_SEGMENT_ACCESS_RIGHTS_PRESENT_BIT =                        7 //col:19528
VMX_SEGMENT_ACCESS_RIGHTS_PRESENT_FLAG =                       0x80 //col:19529
VMX_SEGMENT_ACCESS_RIGHTS_PRESENT_MASK =                       0x01 //col:19530
VMX_SEGMENT_ACCESS_RIGHTS_PRESENT(_) =                         (((_) >> 7) & 0x01) //col:19531
VMX_SEGMENT_ACCESS_RIGHTS_AVAILABLE_BIT_BIT =                  12 //col:19538
VMX_SEGMENT_ACCESS_RIGHTS_AVAILABLE_BIT_FLAG =                 0x1000 //col:19539
VMX_SEGMENT_ACCESS_RIGHTS_AVAILABLE_BIT_MASK =                 0x01 //col:19540
VMX_SEGMENT_ACCESS_RIGHTS_AVAILABLE_BIT(_) =                   (((_) >> 12) & 0x01) //col:19541
VMX_SEGMENT_ACCESS_RIGHTS_LONG_MODE_BIT =                      13 //col:19547
VMX_SEGMENT_ACCESS_RIGHTS_LONG_MODE_FLAG =                     0x2000 //col:19548
VMX_SEGMENT_ACCESS_RIGHTS_LONG_MODE_MASK =                     0x01 //col:19549
VMX_SEGMENT_ACCESS_RIGHTS_LONG_MODE(_) =                       (((_) >> 13) & 0x01) //col:19550
VMX_SEGMENT_ACCESS_RIGHTS_DEFAULT_BIG_BIT =                    14 //col:19556
VMX_SEGMENT_ACCESS_RIGHTS_DEFAULT_BIG_FLAG =                   0x4000 //col:19557
VMX_SEGMENT_ACCESS_RIGHTS_DEFAULT_BIG_MASK =                   0x01 //col:19558
VMX_SEGMENT_ACCESS_RIGHTS_DEFAULT_BIG(_) =                     (((_) >> 14) & 0x01) //col:19559
VMX_SEGMENT_ACCESS_RIGHTS_GRANULARITY_BIT =                    15 //col:19565
VMX_SEGMENT_ACCESS_RIGHTS_GRANULARITY_FLAG =                   0x8000 //col:19566
VMX_SEGMENT_ACCESS_RIGHTS_GRANULARITY_MASK =                   0x01 //col:19567
VMX_SEGMENT_ACCESS_RIGHTS_GRANULARITY(_) =                     (((_) >> 15) & 0x01) //col:19568
VMX_SEGMENT_ACCESS_RIGHTS_UNUSABLE_BIT =                       16 //col:19574
VMX_SEGMENT_ACCESS_RIGHTS_UNUSABLE_FLAG =                      0x10000 //col:19575
VMX_SEGMENT_ACCESS_RIGHTS_UNUSABLE_MASK =                      0x01 //col:19576
VMX_SEGMENT_ACCESS_RIGHTS_UNUSABLE(_) =                        (((_) >> 16) & 0x01) //col:19577
VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_STI_BIT =               0 //col:19602
VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_STI_FLAG =              0x01 //col:19603
VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_STI_MASK =              0x01 //col:19604
VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_STI(_) =                (((_) >> 0) & 0x01) //col:19605
VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_MOV_SS_BIT =            1 //col:19615
VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_MOV_SS_FLAG =           0x02 //col:19616
VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_MOV_SS_MASK =           0x01 //col:19617
VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_MOV_SS(_) =             (((_) >> 1) & 0x01) //col:19618
VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_SMI_BIT =               2 //col:19627
VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_SMI_FLAG =              0x04 //col:19628
VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_SMI_MASK =              0x01 //col:19629
VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_SMI(_) =                (((_) >> 2) & 0x01) //col:19630
VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_NMI_BIT =               3 //col:19644
VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_NMI_FLAG =              0x08 //col:19645
VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_NMI_MASK =              0x01 //col:19646
VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_NMI(_) =                (((_) >> 3) & 0x01) //col:19647
VMX_INTERRUPTIBILITY_STATE_ENCLAVE_INTERRUPTION_BIT =          4 //col:19653
VMX_INTERRUPTIBILITY_STATE_ENCLAVE_INTERRUPTION_FLAG =         0x10 //col:19654
VMX_INTERRUPTIBILITY_STATE_ENCLAVE_INTERRUPTION_MASK =         0x01 //col:19655
VMX_INTERRUPTIBILITY_STATE_ENCLAVE_INTERRUPTION(_) =           (((_) >> 4) & 0x01) //col:19656
VMX_PENDING_DEBUG_EXCEPTIONS_B0_BIT =                          0 //col:19701
VMX_PENDING_DEBUG_EXCEPTIONS_B0_FLAG =                         0x01 //col:19702
VMX_PENDING_DEBUG_EXCEPTIONS_B0_MASK =                         0x01 //col:19703
VMX_PENDING_DEBUG_EXCEPTIONS_B0(_) =                           (((_) >> 0) & 0x01) //col:19704
VMX_PENDING_DEBUG_EXCEPTIONS_B1_BIT =                          1 //col:19711
VMX_PENDING_DEBUG_EXCEPTIONS_B1_FLAG =                         0x02 //col:19712
VMX_PENDING_DEBUG_EXCEPTIONS_B1_MASK =                         0x01 //col:19713
VMX_PENDING_DEBUG_EXCEPTIONS_B1(_) =                           (((_) >> 1) & 0x01) //col:19714
VMX_PENDING_DEBUG_EXCEPTIONS_B2_BIT =                          2 //col:19721
VMX_PENDING_DEBUG_EXCEPTIONS_B2_FLAG =                         0x04 //col:19722
VMX_PENDING_DEBUG_EXCEPTIONS_B2_MASK =                         0x01 //col:19723
VMX_PENDING_DEBUG_EXCEPTIONS_B2(_) =                           (((_) >> 2) & 0x01) //col:19724
VMX_PENDING_DEBUG_EXCEPTIONS_B3_BIT =                          3 //col:19731
VMX_PENDING_DEBUG_EXCEPTIONS_B3_FLAG =                         0x08 //col:19732
VMX_PENDING_DEBUG_EXCEPTIONS_B3_MASK =                         0x01 //col:19733
VMX_PENDING_DEBUG_EXCEPTIONS_B3(_) =                           (((_) >> 3) & 0x01) //col:19734
VMX_PENDING_DEBUG_EXCEPTIONS_ENABLED_BREAKPOINT_BIT =          12 //col:19741
VMX_PENDING_DEBUG_EXCEPTIONS_ENABLED_BREAKPOINT_FLAG =         0x1000 //col:19742
VMX_PENDING_DEBUG_EXCEPTIONS_ENABLED_BREAKPOINT_MASK =         0x01 //col:19743
VMX_PENDING_DEBUG_EXCEPTIONS_ENABLED_BREAKPOINT(_) =           (((_) >> 12) & 0x01) //col:19744
VMX_PENDING_DEBUG_EXCEPTIONS_BS_BIT =                          14 //col:19751
VMX_PENDING_DEBUG_EXCEPTIONS_BS_FLAG =                         0x4000 //col:19752
VMX_PENDING_DEBUG_EXCEPTIONS_BS_MASK =                         0x01 //col:19753
VMX_PENDING_DEBUG_EXCEPTIONS_BS(_) =                           (((_) >> 14) & 0x01) //col:19754
VMX_PENDING_DEBUG_EXCEPTIONS_RTM_BIT =                         16 //col:19762
VMX_PENDING_DEBUG_EXCEPTIONS_RTM_FLAG =                        0x10000 //col:19763
VMX_PENDING_DEBUG_EXCEPTIONS_RTM_MASK =                        0x01 //col:19764
VMX_PENDING_DEBUG_EXCEPTIONS_RTM(_) =                          (((_) >> 16) & 0x01) //col:19765
VMX_VMEXIT_REASON_BASIC_EXIT_REASON_BIT =                      0 //col:19792
VMX_VMEXIT_REASON_BASIC_EXIT_REASON_FLAG =                     0xFFFF //col:19793
VMX_VMEXIT_REASON_BASIC_EXIT_REASON_MASK =                     0xFFFF //col:19794
VMX_VMEXIT_REASON_BASIC_EXIT_REASON(_) =                       (((_) >> 0) & 0xFFFF) //col:19795
VMX_VMEXIT_REASON_ALWAYS0_BIT =                                16 //col:19801
VMX_VMEXIT_REASON_ALWAYS0_FLAG =                               0x10000 //col:19802
VMX_VMEXIT_REASON_ALWAYS0_MASK =                               0x01 //col:19803
VMX_VMEXIT_REASON_ALWAYS0(_) =                                 (((_) >> 16) & 0x01) //col:19804
VMX_VMEXIT_REASON_RESERVED1_BIT =                              17 //col:19806
VMX_VMEXIT_REASON_RESERVED1_FLAG =                             0x7FE0000 //col:19807
VMX_VMEXIT_REASON_RESERVED1_MASK =                             0x3FF //col:19808
VMX_VMEXIT_REASON_RESERVED1(_) =                               (((_) >> 17) & 0x3FF) //col:19809
VMX_VMEXIT_REASON_ENCLAVE_MODE_BIT =                           27 //col:19815
VMX_VMEXIT_REASON_ENCLAVE_MODE_FLAG =                          0x8000000 //col:19816
VMX_VMEXIT_REASON_ENCLAVE_MODE_MASK =                          0x01 //col:19817
VMX_VMEXIT_REASON_ENCLAVE_MODE(_) =                            (((_) >> 27) & 0x01) //col:19818
VMX_VMEXIT_REASON_PENDING_MTF_VM_EXIT_BIT =                    28 //col:19824
VMX_VMEXIT_REASON_PENDING_MTF_VM_EXIT_FLAG =                   0x10000000 //col:19825
VMX_VMEXIT_REASON_PENDING_MTF_VM_EXIT_MASK =                   0x01 //col:19826
VMX_VMEXIT_REASON_PENDING_MTF_VM_EXIT(_) =                     (((_) >> 28) & 0x01) //col:19827
VMX_VMEXIT_REASON_VM_EXIT_FROM_VMX_ROOT_BIT =                  29 //col:19833
VMX_VMEXIT_REASON_VM_EXIT_FROM_VMX_ROOT_FLAG =                 0x20000000 //col:19834
VMX_VMEXIT_REASON_VM_EXIT_FROM_VMX_ROOT_MASK =                 0x01 //col:19835
VMX_VMEXIT_REASON_VM_EXIT_FROM_VMX_ROOT(_) =                   (((_) >> 29) & 0x01) //col:19836
VMX_VMEXIT_REASON_RESERVED2_BIT =                              30 //col:19838
VMX_VMEXIT_REASON_RESERVED2_FLAG =                             0x40000000 //col:19839
VMX_VMEXIT_REASON_RESERVED2_MASK =                             0x01 //col:19840
VMX_VMEXIT_REASON_RESERVED2(_) =                               (((_) >> 30) & 0x01) //col:19841
VMX_VMEXIT_REASON_VM_ENTRY_FAILURE_BIT =                       31 //col:19849
VMX_VMEXIT_REASON_VM_ENTRY_FAILURE_FLAG =                      0x80000000 //col:19850
VMX_VMEXIT_REASON_VM_ENTRY_FAILURE_MASK =                      0x01 //col:19851
VMX_VMEXIT_REASON_VM_ENTRY_FAILURE(_) =                        (((_) >> 31) & 0x01) //col:19852
IO_BITMAP_A_MIN =                                              0x00000000 //col:19860
IO_BITMAP_A_MAX =                                              0x00007FFF //col:19861
IO_BITMAP_B_MIN =                                              0x00008000 //col:19862
IO_BITMAP_B_MAX =                                              0x0000FFFF //col:19863
MSR_ID_LOW_MIN =                                               0x00000000 //col:19870
MSR_ID_LOW_MAX =                                               0x00001FFF //col:19871
MSR_ID_HIGH_MIN =                                              0xC0000000 //col:19872
MSR_ID_HIGH_MAX =                                              0xC0001FFF //col:19873
EPT_POINTER_MEMORY_TYPE_BIT =                                  0 //col:19914
EPT_POINTER_MEMORY_TYPE_FLAG =                                 0x07 //col:19915
EPT_POINTER_MEMORY_TYPE_MASK =                                 0x07 //col:19916
EPT_POINTER_MEMORY_TYPE(_) =                                   (((_) >> 0) & 0x07) //col:19917
EPT_POINTER_PAGE_WALK_LENGTH_BIT =                             3 //col:19925
EPT_POINTER_PAGE_WALK_LENGTH_FLAG =                            0x38 //col:19926
EPT_POINTER_PAGE_WALK_LENGTH_MASK =                            0x07 //col:19927
EPT_POINTER_PAGE_WALK_LENGTH(_) =                              (((_) >> 3) & 0x07) //col:19928
EPT_PAGE_WALK_LENGTH_4 =                                       0x00000003 //col:19929
EPT_POINTER_ENABLE_ACCESS_AND_DIRTY_FLAGS_BIT =                6 //col:19937
EPT_POINTER_ENABLE_ACCESS_AND_DIRTY_FLAGS_FLAG =               0x40 //col:19938
EPT_POINTER_ENABLE_ACCESS_AND_DIRTY_FLAGS_MASK =               0x01 //col:19939
EPT_POINTER_ENABLE_ACCESS_AND_DIRTY_FLAGS(_) =                 (((_) >> 6) & 0x01) //col:19940
EPT_POINTER_ENABLE_SUPERVISOR_SHADOW_STACK_PAGES_BIT =         7 //col:19948
EPT_POINTER_ENABLE_SUPERVISOR_SHADOW_STACK_PAGES_FLAG =        0x80 //col:19949
EPT_POINTER_ENABLE_SUPERVISOR_SHADOW_STACK_PAGES_MASK =        0x01 //col:19950
EPT_POINTER_ENABLE_SUPERVISOR_SHADOW_STACK_PAGES(_) =          (((_) >> 7) & 0x01) //col:19951
EPT_POINTER_PAGE_FRAME_NUMBER_BIT =                            12 //col:19958
EPT_POINTER_PAGE_FRAME_NUMBER_FLAG =                           0xFFFFFFFFF000 //col:19959
EPT_POINTER_PAGE_FRAME_NUMBER_MASK =                           0xFFFFFFFFF //col:19960
EPT_POINTER_PAGE_FRAME_NUMBER(_) =                             (((_) >> 12) & 0xFFFFFFFFF) //col:19961
EPT_PML4E_READ_ACCESS_BIT =                                    0 //col:19991
EPT_PML4E_READ_ACCESS_FLAG =                                   0x01 //col:19992
EPT_PML4E_READ_ACCESS_MASK =                                   0x01 //col:19993
EPT_PML4E_READ_ACCESS(_) =                                     (((_) >> 0) & 0x01) //col:19994
EPT_PML4E_WRITE_ACCESS_BIT =                                   1 //col:20000
EPT_PML4E_WRITE_ACCESS_FLAG =                                  0x02 //col:20001
EPT_PML4E_WRITE_ACCESS_MASK =                                  0x01 //col:20002
EPT_PML4E_WRITE_ACCESS(_) =                                    (((_) >> 1) & 0x01) //col:20003
EPT_PML4E_EXECUTE_ACCESS_BIT =                                 2 //col:20012
EPT_PML4E_EXECUTE_ACCESS_FLAG =                                0x04 //col:20013
EPT_PML4E_EXECUTE_ACCESS_MASK =                                0x01 //col:20014
EPT_PML4E_EXECUTE_ACCESS(_) =                                  (((_) >> 2) & 0x01) //col:20015
EPT_PML4E_ACCESSED_BIT =                                       8 //col:20025
EPT_PML4E_ACCESSED_FLAG =                                      0x100 //col:20026
EPT_PML4E_ACCESSED_MASK =                                      0x01 //col:20027
EPT_PML4E_ACCESSED(_) =                                        (((_) >> 8) & 0x01) //col:20028
EPT_PML4E_USER_MODE_EXECUTE_BIT =                              10 //col:20037
EPT_PML4E_USER_MODE_EXECUTE_FLAG =                             0x400 //col:20038
EPT_PML4E_USER_MODE_EXECUTE_MASK =                             0x01 //col:20039
EPT_PML4E_USER_MODE_EXECUTE(_) =                               (((_) >> 10) & 0x01) //col:20040
EPT_PML4E_PAGE_FRAME_NUMBER_BIT =                              12 //col:20047
EPT_PML4E_PAGE_FRAME_NUMBER_FLAG =                             0xFFFFFFFFF000 //col:20048
EPT_PML4E_PAGE_FRAME_NUMBER_MASK =                             0xFFFFFFFFF //col:20049
EPT_PML4E_PAGE_FRAME_NUMBER(_) =                               (((_) >> 12) & 0xFFFFFFFFF) //col:20050
EPT_PDPTE_1GB_READ_ACCESS_BIT =                                0 //col:20068
EPT_PDPTE_1GB_READ_ACCESS_FLAG =                               0x01 //col:20069
EPT_PDPTE_1GB_READ_ACCESS_MASK =                               0x01 //col:20070
EPT_PDPTE_1GB_READ_ACCESS(_) =                                 (((_) >> 0) & 0x01) //col:20071
EPT_PDPTE_1GB_WRITE_ACCESS_BIT =                               1 //col:20077
EPT_PDPTE_1GB_WRITE_ACCESS_FLAG =                              0x02 //col:20078
EPT_PDPTE_1GB_WRITE_ACCESS_MASK =                              0x01 //col:20079
EPT_PDPTE_1GB_WRITE_ACCESS(_) =                                (((_) >> 1) & 0x01) //col:20080
EPT_PDPTE_1GB_EXECUTE_ACCESS_BIT =                             2 //col:20089
EPT_PDPTE_1GB_EXECUTE_ACCESS_FLAG =                            0x04 //col:20090
EPT_PDPTE_1GB_EXECUTE_ACCESS_MASK =                            0x01 //col:20091
EPT_PDPTE_1GB_EXECUTE_ACCESS(_) =                              (((_) >> 2) & 0x01) //col:20092
EPT_PDPTE_1GB_MEMORY_TYPE_BIT =                                3 //col:20100
EPT_PDPTE_1GB_MEMORY_TYPE_FLAG =                               0x38 //col:20101
EPT_PDPTE_1GB_MEMORY_TYPE_MASK =                               0x07 //col:20102
EPT_PDPTE_1GB_MEMORY_TYPE(_) =                                 (((_) >> 3) & 0x07) //col:20103
EPT_PDPTE_1GB_IGNORE_PAT_BIT =                                 6 //col:20111
EPT_PDPTE_1GB_IGNORE_PAT_FLAG =                                0x40 //col:20112
EPT_PDPTE_1GB_IGNORE_PAT_MASK =                                0x01 //col:20113
EPT_PDPTE_1GB_IGNORE_PAT(_) =                                  (((_) >> 6) & 0x01) //col:20114
EPT_PDPTE_1GB_LARGE_PAGE_BIT =                                 7 //col:20120
EPT_PDPTE_1GB_LARGE_PAGE_FLAG =                                0x80 //col:20121
EPT_PDPTE_1GB_LARGE_PAGE_MASK =                                0x01 //col:20122
EPT_PDPTE_1GB_LARGE_PAGE(_) =                                  (((_) >> 7) & 0x01) //col:20123
EPT_PDPTE_1GB_ACCESSED_BIT =                                   8 //col:20132
EPT_PDPTE_1GB_ACCESSED_FLAG =                                  0x100 //col:20133
EPT_PDPTE_1GB_ACCESSED_MASK =                                  0x01 //col:20134
EPT_PDPTE_1GB_ACCESSED(_) =                                    (((_) >> 8) & 0x01) //col:20135
EPT_PDPTE_1GB_DIRTY_BIT =                                      9 //col:20144
EPT_PDPTE_1GB_DIRTY_FLAG =                                     0x200 //col:20145
EPT_PDPTE_1GB_DIRTY_MASK =                                     0x01 //col:20146
EPT_PDPTE_1GB_DIRTY(_) =                                       (((_) >> 9) & 0x01) //col:20147
EPT_PDPTE_1GB_USER_MODE_EXECUTE_BIT =                          10 //col:20155
EPT_PDPTE_1GB_USER_MODE_EXECUTE_FLAG =                         0x400 //col:20156
EPT_PDPTE_1GB_USER_MODE_EXECUTE_MASK =                         0x01 //col:20157
EPT_PDPTE_1GB_USER_MODE_EXECUTE(_) =                           (((_) >> 10) & 0x01) //col:20158
EPT_PDPTE_1GB_PAGE_FRAME_NUMBER_BIT =                          30 //col:20165
EPT_PDPTE_1GB_PAGE_FRAME_NUMBER_FLAG =                         0xFFFFC0000000 //col:20166
EPT_PDPTE_1GB_PAGE_FRAME_NUMBER_MASK =                         0x3FFFF //col:20167
EPT_PDPTE_1GB_PAGE_FRAME_NUMBER(_) =                           (((_) >> 30) & 0x3FFFF) //col:20168
EPT_PDPTE_1GB_VERIFY_GUEST_PAGING_BIT =                        57 //col:20179
EPT_PDPTE_1GB_VERIFY_GUEST_PAGING_FLAG =                       0x200000000000000 //col:20180
EPT_PDPTE_1GB_VERIFY_GUEST_PAGING_MASK =                       0x01 //col:20181
EPT_PDPTE_1GB_VERIFY_GUEST_PAGING(_) =                         (((_) >> 57) & 0x01) //col:20182
EPT_PDPTE_1GB_PAGING_WRITE_ACCESS_BIT =                        58 //col:20191
EPT_PDPTE_1GB_PAGING_WRITE_ACCESS_FLAG =                       0x400000000000000 //col:20192
EPT_PDPTE_1GB_PAGING_WRITE_ACCESS_MASK =                       0x01 //col:20193
EPT_PDPTE_1GB_PAGING_WRITE_ACCESS(_) =                         (((_) >> 58) & 0x01) //col:20194
EPT_PDPTE_1GB_SUPERVISOR_SHADOW_STACK_BIT =                    60 //col:20204
EPT_PDPTE_1GB_SUPERVISOR_SHADOW_STACK_FLAG =                   0x1000000000000000 //col:20205
EPT_PDPTE_1GB_SUPERVISOR_SHADOW_STACK_MASK =                   0x01 //col:20206
EPT_PDPTE_1GB_SUPERVISOR_SHADOW_STACK(_) =                     (((_) >> 60) & 0x01) //col:20207
EPT_PDPTE_1GB_SUPPRESS_VE_BIT =                                63 //col:20218
EPT_PDPTE_1GB_SUPPRESS_VE_FLAG =                               0x8000000000000000 //col:20219
EPT_PDPTE_1GB_SUPPRESS_VE_MASK =                               0x01 //col:20220
EPT_PDPTE_1GB_SUPPRESS_VE(_) =                                 (((_) >> 63) & 0x01) //col:20221
EPT_PDPTE_READ_ACCESS_BIT =                                    0 //col:20238
EPT_PDPTE_READ_ACCESS_FLAG =                                   0x01 //col:20239
EPT_PDPTE_READ_ACCESS_MASK =                                   0x01 //col:20240
EPT_PDPTE_READ_ACCESS(_) =                                     (((_) >> 0) & 0x01) //col:20241
EPT_PDPTE_WRITE_ACCESS_BIT =                                   1 //col:20247
EPT_PDPTE_WRITE_ACCESS_FLAG =                                  0x02 //col:20248
EPT_PDPTE_WRITE_ACCESS_MASK =                                  0x01 //col:20249
EPT_PDPTE_WRITE_ACCESS(_) =                                    (((_) >> 1) & 0x01) //col:20250
EPT_PDPTE_EXECUTE_ACCESS_BIT =                                 2 //col:20259
EPT_PDPTE_EXECUTE_ACCESS_FLAG =                                0x04 //col:20260
EPT_PDPTE_EXECUTE_ACCESS_MASK =                                0x01 //col:20261
EPT_PDPTE_EXECUTE_ACCESS(_) =                                  (((_) >> 2) & 0x01) //col:20262
EPT_PDPTE_ACCESSED_BIT =                                       8 //col:20272
EPT_PDPTE_ACCESSED_FLAG =                                      0x100 //col:20273
EPT_PDPTE_ACCESSED_MASK =                                      0x01 //col:20274
EPT_PDPTE_ACCESSED(_) =                                        (((_) >> 8) & 0x01) //col:20275
EPT_PDPTE_USER_MODE_EXECUTE_BIT =                              10 //col:20284
EPT_PDPTE_USER_MODE_EXECUTE_FLAG =                             0x400 //col:20285
EPT_PDPTE_USER_MODE_EXECUTE_MASK =                             0x01 //col:20286
EPT_PDPTE_USER_MODE_EXECUTE(_) =                               (((_) >> 10) & 0x01) //col:20287
EPT_PDPTE_PAGE_FRAME_NUMBER_BIT =                              12 //col:20294
EPT_PDPTE_PAGE_FRAME_NUMBER_FLAG =                             0xFFFFFFFFF000 //col:20295
EPT_PDPTE_PAGE_FRAME_NUMBER_MASK =                             0xFFFFFFFFF //col:20296
EPT_PDPTE_PAGE_FRAME_NUMBER(_) =                               (((_) >> 12) & 0xFFFFFFFFF) //col:20297
EPT_PDE_2MB_READ_ACCESS_BIT =                                  0 //col:20315
EPT_PDE_2MB_READ_ACCESS_FLAG =                                 0x01 //col:20316
EPT_PDE_2MB_READ_ACCESS_MASK =                                 0x01 //col:20317
EPT_PDE_2MB_READ_ACCESS(_) =                                   (((_) >> 0) & 0x01) //col:20318
EPT_PDE_2MB_WRITE_ACCESS_BIT =                                 1 //col:20324
EPT_PDE_2MB_WRITE_ACCESS_FLAG =                                0x02 //col:20325
EPT_PDE_2MB_WRITE_ACCESS_MASK =                                0x01 //col:20326
EPT_PDE_2MB_WRITE_ACCESS(_) =                                  (((_) >> 1) & 0x01) //col:20327
EPT_PDE_2MB_EXECUTE_ACCESS_BIT =                               2 //col:20336
EPT_PDE_2MB_EXECUTE_ACCESS_FLAG =                              0x04 //col:20337
EPT_PDE_2MB_EXECUTE_ACCESS_MASK =                              0x01 //col:20338
EPT_PDE_2MB_EXECUTE_ACCESS(_) =                                (((_) >> 2) & 0x01) //col:20339
EPT_PDE_2MB_MEMORY_TYPE_BIT =                                  3 //col:20347
EPT_PDE_2MB_MEMORY_TYPE_FLAG =                                 0x38 //col:20348
EPT_PDE_2MB_MEMORY_TYPE_MASK =                                 0x07 //col:20349
EPT_PDE_2MB_MEMORY_TYPE(_) =                                   (((_) >> 3) & 0x07) //col:20350
EPT_PDE_2MB_IGNORE_PAT_BIT =                                   6 //col:20358
EPT_PDE_2MB_IGNORE_PAT_FLAG =                                  0x40 //col:20359
EPT_PDE_2MB_IGNORE_PAT_MASK =                                  0x01 //col:20360
EPT_PDE_2MB_IGNORE_PAT(_) =                                    (((_) >> 6) & 0x01) //col:20361
EPT_PDE_2MB_LARGE_PAGE_BIT =                                   7 //col:20367
EPT_PDE_2MB_LARGE_PAGE_FLAG =                                  0x80 //col:20368
EPT_PDE_2MB_LARGE_PAGE_MASK =                                  0x01 //col:20369
EPT_PDE_2MB_LARGE_PAGE(_) =                                    (((_) >> 7) & 0x01) //col:20370
EPT_PDE_2MB_ACCESSED_BIT =                                     8 //col:20379
EPT_PDE_2MB_ACCESSED_FLAG =                                    0x100 //col:20380
EPT_PDE_2MB_ACCESSED_MASK =                                    0x01 //col:20381
EPT_PDE_2MB_ACCESSED(_) =                                      (((_) >> 8) & 0x01) //col:20382
EPT_PDE_2MB_DIRTY_BIT =                                        9 //col:20391
EPT_PDE_2MB_DIRTY_FLAG =                                       0x200 //col:20392
EPT_PDE_2MB_DIRTY_MASK =                                       0x01 //col:20393
EPT_PDE_2MB_DIRTY(_) =                                         (((_) >> 9) & 0x01) //col:20394
EPT_PDE_2MB_USER_MODE_EXECUTE_BIT =                            10 //col:20402
EPT_PDE_2MB_USER_MODE_EXECUTE_FLAG =                           0x400 //col:20403
EPT_PDE_2MB_USER_MODE_EXECUTE_MASK =                           0x01 //col:20404
EPT_PDE_2MB_USER_MODE_EXECUTE(_) =                             (((_) >> 10) & 0x01) //col:20405
EPT_PDE_2MB_PAGE_FRAME_NUMBER_BIT =                            21 //col:20412
EPT_PDE_2MB_PAGE_FRAME_NUMBER_FLAG =                           0xFFFFFFE00000 //col:20413
EPT_PDE_2MB_PAGE_FRAME_NUMBER_MASK =                           0x7FFFFFF //col:20414
EPT_PDE_2MB_PAGE_FRAME_NUMBER(_) =                             (((_) >> 21) & 0x7FFFFFF) //col:20415
EPT_PDE_2MB_VERIFY_GUEST_PAGING_BIT =                          57 //col:20426
EPT_PDE_2MB_VERIFY_GUEST_PAGING_FLAG =                         0x200000000000000 //col:20427
EPT_PDE_2MB_VERIFY_GUEST_PAGING_MASK =                         0x01 //col:20428
EPT_PDE_2MB_VERIFY_GUEST_PAGING(_) =                           (((_) >> 57) & 0x01) //col:20429
EPT_PDE_2MB_PAGING_WRITE_ACCESS_BIT =                          58 //col:20438
EPT_PDE_2MB_PAGING_WRITE_ACCESS_FLAG =                         0x400000000000000 //col:20439
EPT_PDE_2MB_PAGING_WRITE_ACCESS_MASK =                         0x01 //col:20440
EPT_PDE_2MB_PAGING_WRITE_ACCESS(_) =                           (((_) >> 58) & 0x01) //col:20441
EPT_PDE_2MB_SUPERVISOR_SHADOW_STACK_BIT =                      60 //col:20451
EPT_PDE_2MB_SUPERVISOR_SHADOW_STACK_FLAG =                     0x1000000000000000 //col:20452
EPT_PDE_2MB_SUPERVISOR_SHADOW_STACK_MASK =                     0x01 //col:20453
EPT_PDE_2MB_SUPERVISOR_SHADOW_STACK(_) =                       (((_) >> 60) & 0x01) //col:20454
EPT_PDE_2MB_SUPPRESS_VE_BIT =                                  63 //col:20465
EPT_PDE_2MB_SUPPRESS_VE_FLAG =                                 0x8000000000000000 //col:20466
EPT_PDE_2MB_SUPPRESS_VE_MASK =                                 0x01 //col:20467
EPT_PDE_2MB_SUPPRESS_VE(_) =                                   (((_) >> 63) & 0x01) //col:20468
EPT_PDE_READ_ACCESS_BIT =                                      0 //col:20485
EPT_PDE_READ_ACCESS_FLAG =                                     0x01 //col:20486
EPT_PDE_READ_ACCESS_MASK =                                     0x01 //col:20487
EPT_PDE_READ_ACCESS(_) =                                       (((_) >> 0) & 0x01) //col:20488
EPT_PDE_WRITE_ACCESS_BIT =                                     1 //col:20494
EPT_PDE_WRITE_ACCESS_FLAG =                                    0x02 //col:20495
EPT_PDE_WRITE_ACCESS_MASK =                                    0x01 //col:20496
EPT_PDE_WRITE_ACCESS(_) =                                      (((_) >> 1) & 0x01) //col:20497
EPT_PDE_EXECUTE_ACCESS_BIT =                                   2 //col:20506
EPT_PDE_EXECUTE_ACCESS_FLAG =                                  0x04 //col:20507
EPT_PDE_EXECUTE_ACCESS_MASK =                                  0x01 //col:20508
EPT_PDE_EXECUTE_ACCESS(_) =                                    (((_) >> 2) & 0x01) //col:20509
EPT_PDE_ACCESSED_BIT =                                         8 //col:20519
EPT_PDE_ACCESSED_FLAG =                                        0x100 //col:20520
EPT_PDE_ACCESSED_MASK =                                        0x01 //col:20521
EPT_PDE_ACCESSED(_) =                                          (((_) >> 8) & 0x01) //col:20522
EPT_PDE_USER_MODE_EXECUTE_BIT =                                10 //col:20531
EPT_PDE_USER_MODE_EXECUTE_FLAG =                               0x400 //col:20532
EPT_PDE_USER_MODE_EXECUTE_MASK =                               0x01 //col:20533
EPT_PDE_USER_MODE_EXECUTE(_) =                                 (((_) >> 10) & 0x01) //col:20534
EPT_PDE_PAGE_FRAME_NUMBER_BIT =                                12 //col:20541
EPT_PDE_PAGE_FRAME_NUMBER_FLAG =                               0xFFFFFFFFF000 //col:20542
EPT_PDE_PAGE_FRAME_NUMBER_MASK =                               0xFFFFFFFFF //col:20543
EPT_PDE_PAGE_FRAME_NUMBER(_) =                                 (((_) >> 12) & 0xFFFFFFFFF) //col:20544
EPT_PTE_READ_ACCESS_BIT =                                      0 //col:20562
EPT_PTE_READ_ACCESS_FLAG =                                     0x01 //col:20563
EPT_PTE_READ_ACCESS_MASK =                                     0x01 //col:20564
EPT_PTE_READ_ACCESS(_) =                                       (((_) >> 0) & 0x01) //col:20565
EPT_PTE_WRITE_ACCESS_BIT =                                     1 //col:20571
EPT_PTE_WRITE_ACCESS_FLAG =                                    0x02 //col:20572
EPT_PTE_WRITE_ACCESS_MASK =                                    0x01 //col:20573
EPT_PTE_WRITE_ACCESS(_) =                                      (((_) >> 1) & 0x01) //col:20574
EPT_PTE_EXECUTE_ACCESS_BIT =                                   2 //col:20583
EPT_PTE_EXECUTE_ACCESS_FLAG =                                  0x04 //col:20584
EPT_PTE_EXECUTE_ACCESS_MASK =                                  0x01 //col:20585
EPT_PTE_EXECUTE_ACCESS(_) =                                    (((_) >> 2) & 0x01) //col:20586
EPT_PTE_MEMORY_TYPE_BIT =                                      3 //col:20594
EPT_PTE_MEMORY_TYPE_FLAG =                                     0x38 //col:20595
EPT_PTE_MEMORY_TYPE_MASK =                                     0x07 //col:20596
EPT_PTE_MEMORY_TYPE(_) =                                       (((_) >> 3) & 0x07) //col:20597
EPT_PTE_IGNORE_PAT_BIT =                                       6 //col:20605
EPT_PTE_IGNORE_PAT_FLAG =                                      0x40 //col:20606
EPT_PTE_IGNORE_PAT_MASK =                                      0x01 //col:20607
EPT_PTE_IGNORE_PAT(_) =                                        (((_) >> 6) & 0x01) //col:20608
EPT_PTE_ACCESSED_BIT =                                         8 //col:20618
EPT_PTE_ACCESSED_FLAG =                                        0x100 //col:20619
EPT_PTE_ACCESSED_MASK =                                        0x01 //col:20620
EPT_PTE_ACCESSED(_) =                                          (((_) >> 8) & 0x01) //col:20621
EPT_PTE_DIRTY_BIT =                                            9 //col:20630
EPT_PTE_DIRTY_FLAG =                                           0x200 //col:20631
EPT_PTE_DIRTY_MASK =                                           0x01 //col:20632
EPT_PTE_DIRTY(_) =                                             (((_) >> 9) & 0x01) //col:20633
EPT_PTE_USER_MODE_EXECUTE_BIT =                                10 //col:20641
EPT_PTE_USER_MODE_EXECUTE_FLAG =                               0x400 //col:20642
EPT_PTE_USER_MODE_EXECUTE_MASK =                               0x01 //col:20643
EPT_PTE_USER_MODE_EXECUTE(_) =                                 (((_) >> 10) & 0x01) //col:20644
EPT_PTE_PAGE_FRAME_NUMBER_BIT =                                12 //col:20651
EPT_PTE_PAGE_FRAME_NUMBER_FLAG =                               0xFFFFFFFFF000 //col:20652
EPT_PTE_PAGE_FRAME_NUMBER_MASK =                               0xFFFFFFFFF //col:20653
EPT_PTE_PAGE_FRAME_NUMBER(_) =                                 (((_) >> 12) & 0xFFFFFFFFF) //col:20654
EPT_PTE_VERIFY_GUEST_PAGING_BIT =                              57 //col:20665
EPT_PTE_VERIFY_GUEST_PAGING_FLAG =                             0x200000000000000 //col:20666
EPT_PTE_VERIFY_GUEST_PAGING_MASK =                             0x01 //col:20667
EPT_PTE_VERIFY_GUEST_PAGING(_) =                               (((_) >> 57) & 0x01) //col:20668
EPT_PTE_PAGING_WRITE_ACCESS_BIT =                              58 //col:20677
EPT_PTE_PAGING_WRITE_ACCESS_FLAG =                             0x400000000000000 //col:20678
EPT_PTE_PAGING_WRITE_ACCESS_MASK =                             0x01 //col:20679
EPT_PTE_PAGING_WRITE_ACCESS(_) =                               (((_) >> 58) & 0x01) //col:20680
EPT_PTE_SUPERVISOR_SHADOW_STACK_BIT =                          60 //col:20690
EPT_PTE_SUPERVISOR_SHADOW_STACK_FLAG =                         0x1000000000000000 //col:20691
EPT_PTE_SUPERVISOR_SHADOW_STACK_MASK =                         0x01 //col:20692
EPT_PTE_SUPERVISOR_SHADOW_STACK(_) =                           (((_) >> 60) & 0x01) //col:20693
EPT_PTE_SUB_PAGE_WRITE_PERMISSIONS_BIT =                       61 //col:20704
EPT_PTE_SUB_PAGE_WRITE_PERMISSIONS_FLAG =                      0x2000000000000000 //col:20705
EPT_PTE_SUB_PAGE_WRITE_PERMISSIONS_MASK =                      0x01 //col:20706
EPT_PTE_SUB_PAGE_WRITE_PERMISSIONS(_) =                        (((_) >> 61) & 0x01) //col:20707
EPT_PTE_SUPPRESS_VE_BIT =                                      63 //col:20718
EPT_PTE_SUPPRESS_VE_FLAG =                                     0x8000000000000000 //col:20719
EPT_PTE_SUPPRESS_VE_MASK =                                     0x01 //col:20720
EPT_PTE_SUPPRESS_VE(_) =                                       (((_) >> 63) & 0x01) //col:20721
EPT_ENTRY_READ_ACCESS_BIT =                                    0 //col:20735
EPT_ENTRY_READ_ACCESS_FLAG =                                   0x01 //col:20736
EPT_ENTRY_READ_ACCESS_MASK =                                   0x01 //col:20737
EPT_ENTRY_READ_ACCESS(_) =                                     (((_) >> 0) & 0x01) //col:20738
EPT_ENTRY_WRITE_ACCESS_BIT =                                   1 //col:20740
EPT_ENTRY_WRITE_ACCESS_FLAG =                                  0x02 //col:20741
EPT_ENTRY_WRITE_ACCESS_MASK =                                  0x01 //col:20742
EPT_ENTRY_WRITE_ACCESS(_) =                                    (((_) >> 1) & 0x01) //col:20743
EPT_ENTRY_EXECUTE_ACCESS_BIT =                                 2 //col:20745
EPT_ENTRY_EXECUTE_ACCESS_FLAG =                                0x04 //col:20746
EPT_ENTRY_EXECUTE_ACCESS_MASK =                                0x01 //col:20747
EPT_ENTRY_EXECUTE_ACCESS(_) =                                  (((_) >> 2) & 0x01) //col:20748
EPT_ENTRY_MEMORY_TYPE_BIT =                                    3 //col:20750
EPT_ENTRY_MEMORY_TYPE_FLAG =                                   0x38 //col:20751
EPT_ENTRY_MEMORY_TYPE_MASK =                                   0x07 //col:20752
EPT_ENTRY_MEMORY_TYPE(_) =                                     (((_) >> 3) & 0x07) //col:20753
EPT_ENTRY_IGNORE_PAT_BIT =                                     6 //col:20755
EPT_ENTRY_IGNORE_PAT_FLAG =                                    0x40 //col:20756
EPT_ENTRY_IGNORE_PAT_MASK =                                    0x01 //col:20757
EPT_ENTRY_IGNORE_PAT(_) =                                      (((_) >> 6) & 0x01) //col:20758
EPT_ENTRY_LARGE_PAGE_BIT =                                     7 //col:20760
EPT_ENTRY_LARGE_PAGE_FLAG =                                    0x80 //col:20761
EPT_ENTRY_LARGE_PAGE_MASK =                                    0x01 //col:20762
EPT_ENTRY_LARGE_PAGE(_) =                                      (((_) >> 7) & 0x01) //col:20763
EPT_ENTRY_ACCESSED_BIT =                                       8 //col:20765
EPT_ENTRY_ACCESSED_FLAG =                                      0x100 //col:20766
EPT_ENTRY_ACCESSED_MASK =                                      0x01 //col:20767
EPT_ENTRY_ACCESSED(_) =                                        (((_) >> 8) & 0x01) //col:20768
EPT_ENTRY_DIRTY_BIT =                                          9 //col:20770
EPT_ENTRY_DIRTY_FLAG =                                         0x200 //col:20771
EPT_ENTRY_DIRTY_MASK =                                         0x01 //col:20772
EPT_ENTRY_DIRTY(_) =                                           (((_) >> 9) & 0x01) //col:20773
EPT_ENTRY_USER_MODE_EXECUTE_BIT =                              10 //col:20775
EPT_ENTRY_USER_MODE_EXECUTE_FLAG =                             0x400 //col:20776
EPT_ENTRY_USER_MODE_EXECUTE_MASK =                             0x01 //col:20777
EPT_ENTRY_USER_MODE_EXECUTE(_) =                               (((_) >> 10) & 0x01) //col:20778
EPT_ENTRY_PAGE_FRAME_NUMBER_BIT =                              12 //col:20781
EPT_ENTRY_PAGE_FRAME_NUMBER_FLAG =                             0xFFFFFFFFF000 //col:20782
EPT_ENTRY_PAGE_FRAME_NUMBER_MASK =                             0xFFFFFFFFF //col:20783
EPT_ENTRY_PAGE_FRAME_NUMBER(_) =                               (((_) >> 12) & 0xFFFFFFFFF) //col:20784
EPT_ENTRY_SUPPRESS_VE_BIT =                                    63 //col:20787
EPT_ENTRY_SUPPRESS_VE_FLAG =                                   0x8000000000000000 //col:20788
EPT_ENTRY_SUPPRESS_VE_MASK =                                   0x01 //col:20789
EPT_ENTRY_SUPPRESS_VE(_) =                                     (((_) >> 63) & 0x01) //col:20790
EPT_LEVEL_PML4E =                                              0x00000003 //col:20803
EPT_LEVEL_PDPTE =                                              0x00000002 //col:20804
EPT_LEVEL_PDE =                                                0x00000001 //col:20805
EPT_LEVEL_PTE =                                                0x00000000 //col:20806
EPT_PML4E_ENTRY_COUNT =                                        0x00000200 //col:20818
EPT_PDPTE_ENTRY_COUNT =                                        0x00000200 //col:20819
EPT_PDE_ENTRY_COUNT =                                          0x00000200 //col:20820
EPT_PTE_ENTRY_COUNT =                                          0x00000200 //col:20821
HLAT_POINTER_PAGE_LEVEL_WRITE_THROUGH_BIT =                    3 //col:20929
HLAT_POINTER_PAGE_LEVEL_WRITE_THROUGH_FLAG =                   0x08 //col:20930
HLAT_POINTER_PAGE_LEVEL_WRITE_THROUGH_MASK =                   0x01 //col:20931
HLAT_POINTER_PAGE_LEVEL_WRITE_THROUGH(_) =                     (((_) >> 3) & 0x01) //col:20932
HLAT_POINTER_PAGE_LEVEL_CACHE_DISABLE_BIT =                    4 //col:20939
HLAT_POINTER_PAGE_LEVEL_CACHE_DISABLE_FLAG =                   0x10 //col:20940
HLAT_POINTER_PAGE_LEVEL_CACHE_DISABLE_MASK =                   0x01 //col:20941
HLAT_POINTER_PAGE_LEVEL_CACHE_DISABLE(_) =                     (((_) >> 4) & 0x01) //col:20942
HLAT_POINTER_PAGE_FRAME_NUMBER_BIT =                           12 //col:20949
HLAT_POINTER_PAGE_FRAME_NUMBER_FLAG =                          0xFFFFFFFFF000 //col:20950
HLAT_POINTER_PAGE_FRAME_NUMBER_MASK =                          0xFFFFFFFFF //col:20951
HLAT_POINTER_PAGE_FRAME_NUMBER(_) =                            (((_) >> 12) & 0xFFFFFFFFF) //col:20952
VMCS_COMPONENT_ENCODING_ACCESS_TYPE_BIT =                      0 //col:21095
VMCS_COMPONENT_ENCODING_ACCESS_TYPE_FLAG =                     0x01 //col:21096
VMCS_COMPONENT_ENCODING_ACCESS_TYPE_MASK =                     0x01 //col:21097
VMCS_COMPONENT_ENCODING_ACCESS_TYPE(_) =                       (((_) >> 0) & 0x01) //col:21098
VMCS_COMPONENT_ENCODING_INDEX_BIT =                            1 //col:21104
VMCS_COMPONENT_ENCODING_INDEX_FLAG =                           0x3FE //col:21105
VMCS_COMPONENT_ENCODING_INDEX_MASK =                           0x1FF //col:21106
VMCS_COMPONENT_ENCODING_INDEX(_) =                             (((_) >> 1) & 0x1FF) //col:21107
VMCS_COMPONENT_ENCODING_TYPE_BIT =                             10 //col:21117
VMCS_COMPONENT_ENCODING_TYPE_FLAG =                            0xC00 //col:21118
VMCS_COMPONENT_ENCODING_TYPE_MASK =                            0x03 //col:21119
VMCS_COMPONENT_ENCODING_TYPE(_) =                              (((_) >> 10) & 0x03) //col:21120
VMCS_COMPONENT_ENCODING_MUST_BE_ZERO_BIT =                     12 //col:21126
VMCS_COMPONENT_ENCODING_MUST_BE_ZERO_FLAG =                    0x1000 //col:21127
VMCS_COMPONENT_ENCODING_MUST_BE_ZERO_MASK =                    0x01 //col:21128
VMCS_COMPONENT_ENCODING_MUST_BE_ZERO(_) =                      (((_) >> 12) & 0x01) //col:21129
VMCS_COMPONENT_ENCODING_WIDTH_BIT =                            13 //col:21139
VMCS_COMPONENT_ENCODING_WIDTH_FLAG =                           0x6000 //col:21140
VMCS_COMPONENT_ENCODING_WIDTH_MASK =                           0x03 //col:21141
VMCS_COMPONENT_ENCODING_WIDTH(_) =                             (((_) >> 13) & 0x03) //col:21142
VMCS_CTRL_VIRTUAL_PROCESSOR_IDENTIFIER =                       0x00000000 //col:21170
VMCS_CTRL_POSTED_INTERRUPT_NOTIFICATION_VECTOR =               0x00000002 //col:21178
VMCS_CTRL_EPTP_INDEX =                                         0x00000004 //col:21186
VMCS_CTRL_HLAT_PREFIX_SIZE =                                   0x00000006 //col:21193
VMCS_GUEST_ES_SELECTOR =                                       0x00000800 //col:21208
VMCS_GUEST_CS_SELECTOR =                                       0x00000802 //col:21213
VMCS_GUEST_SS_SELECTOR =                                       0x00000804 //col:21218
VMCS_GUEST_DS_SELECTOR =                                       0x00000806 //col:21223
VMCS_GUEST_FS_SELECTOR =                                       0x00000808 //col:21228
VMCS_GUEST_GS_SELECTOR =                                       0x0000080A //col:21233
VMCS_GUEST_LDTR_SELECTOR =                                     0x0000080C //col:21238
VMCS_GUEST_TR_SELECTOR =                                       0x0000080E //col:21243
VMCS_GUEST_INTERRUPT_STATUS =                                  0x00000810 //col:21251
VMCS_GUEST_PML_INDEX =                                         0x00000812 //col:21258
VMCS_HOST_ES_SELECTOR =                                        0x00000C00 //col:21273
VMCS_HOST_CS_SELECTOR =                                        0x00000C02 //col:21278
VMCS_HOST_SS_SELECTOR =                                        0x00000C04 //col:21283
VMCS_HOST_DS_SELECTOR =                                        0x00000C06 //col:21288
VMCS_HOST_FS_SELECTOR =                                        0x00000C08 //col:21293
VMCS_HOST_GS_SELECTOR =                                        0x00000C0A //col:21298
VMCS_HOST_TR_SELECTOR =                                        0x00000C0C //col:21303
VMCS_CTRL_IO_BITMAP_A_ADDRESS =                                0x00002000 //col:21331
VMCS_CTRL_IO_BITMAP_B_ADDRESS =                                0x00002002 //col:21336
VMCS_CTRL_MSR_BITMAP_ADDRESS =                                 0x00002004 //col:21341
VMCS_CTRL_VMEXIT_MSR_STORE_ADDRESS =                           0x00002006 //col:21346
VMCS_CTRL_VMEXIT_MSR_LOAD_ADDRESS =                            0x00002008 //col:21351
VMCS_CTRL_VMENTRY_MSR_LOAD_ADDRESS =                           0x0000200A //col:21356
VMCS_CTRL_EXECUTIVE_VMCS_POINTER =                             0x0000200C //col:21361
VMCS_CTRL_PML_ADDRESS =                                        0x0000200E //col:21366
VMCS_CTRL_TSC_OFFSET =                                         0x00002010 //col:21371
VMCS_CTRL_VIRTUAL_APIC_ADDRESS =                               0x00002012 //col:21376
VMCS_CTRL_APIC_ACCESS_ADDRESS =                                0x00002014 //col:21381
VMCS_CTRL_POSTED_INTERRUPT_DESCRIPTOR_ADDRESS =                0x00002016 //col:21386
VMCS_CTRL_VMFUNC_CONTROLS =                                    0x00002018 //col:21391
VMCS_CTRL_EPT_POINTER =                                        0x0000201A //col:21396
VMCS_CTRL_EOI_EXIT_BITMAP_0 =                                  0x0000201C //col:21401
VMCS_CTRL_EOI_EXIT_BITMAP_1 =                                  0x0000201E //col:21406
VMCS_CTRL_EOI_EXIT_BITMAP_2 =                                  0x00002020 //col:21411
VMCS_CTRL_EOI_EXIT_BITMAP_3 =                                  0x00002022 //col:21416
VMCS_CTRL_EPT_POINTER_LIST_ADDRESS =                           0x00002024 //col:21421
VMCS_CTRL_VMREAD_BITMAP_ADDRESS =                              0x00002026 //col:21426
VMCS_CTRL_VMWRITE_BITMAP_ADDRESS =                             0x00002028 //col:21431
VMCS_CTRL_VIRTUALIZATION_EXCEPTION_INFORMATION_ADDRESS =       0x0000202A //col:21436
VMCS_CTRL_XSS_EXITING_BITMAP =                                 0x0000202C //col:21441
VMCS_CTRL_ENCLS_EXITING_BITMAP =                               0x0000202E //col:21446
VMCS_CTRL_SUB_PAGE_PERMISSION_TABLE_POINTER =                  0x00002030 //col:21451
VMCS_CTRL_TSC_MULTIPLIER =                                     0x00002032 //col:21456
VMCS_CTRL_TERTIARY_PROCESSOR_BASED_VM_EXECUTION_CONTROLS =     0x00002034 //col:21461
VMCS_CTRL_ENCLV_EXITING_BITMAP =                               0x00002036 //col:21466
VMCS_CTRL_HLAT_POINTER =                                       0x00002040 //col:21471
VMCS_CTRL_SECONDARY_VMEXIT_CONTROLS =                          0x00002044 //col:21476
VMCS_GUEST_PHYSICAL_ADDRESS =                                  0x00002400 //col:21491
VMCS_GUEST_VMCS_LINK_POINTER =                                 0x00002800 //col:21506
VMCS_GUEST_DEBUGCTL =                                          0x00002802 //col:21511
VMCS_GUEST_PAT =                                               0x00002804 //col:21516
VMCS_GUEST_EFER =                                              0x00002806 //col:21521
VMCS_GUEST_PERF_GLOBAL_CTRL =                                  0x00002808 //col:21526
VMCS_GUEST_PDPTE0 =                                            0x0000280A //col:21531
VMCS_GUEST_PDPTE1 =                                            0x0000280C //col:21536
VMCS_GUEST_PDPTE2 =                                            0x0000280E //col:21541
VMCS_GUEST_PDPTE3 =                                            0x00002810 //col:21546
VMCS_GUEST_BNDCFGS =                                           0x00002812 //col:21551
VMCS_GUEST_RTIT_CTL =                                          0x00002814 //col:21556
VMCS_GUEST_LBR_CTL =                                           0x00002816 //col:21561
VMCS_GUEST_PKRS =                                              0x00002818 //col:21566
VMCS_HOST_PAT =                                                0x00002C00 //col:21581
VMCS_HOST_EFER =                                               0x00002C02 //col:21586
VMCS_HOST_PERF_GLOBAL_CTRL =                                   0x00002C04 //col:21591
VMCS_HOST_PKRS =                                               0x00002C06 //col:21596
VMCS_CTRL_PIN_BASED_VM_EXECUTION_CONTROLS =                    0x00004000 //col:21624
VMCS_CTRL_PROCESSOR_BASED_VM_EXECUTION_CONTROLS =              0x00004002 //col:21629
VMCS_CTRL_EXCEPTION_BITMAP =                                   0x00004004 //col:21634
VMCS_CTRL_PAGEFAULT_ERROR_CODE_MASK =                          0x00004006 //col:21639
VMCS_CTRL_PAGEFAULT_ERROR_CODE_MATCH =                         0x00004008 //col:21644
VMCS_CTRL_CR3_TARGET_COUNT =                                   0x0000400A //col:21649
VMCS_CTRL_PRIMARY_VMEXIT_CONTROLS =                            0x0000400C //col:21654
VMCS_CTRL_VMEXIT_MSR_STORE_COUNT =                             0x0000400E //col:21659
VMCS_CTRL_VMEXIT_MSR_LOAD_COUNT =                              0x00004010 //col:21664
VMCS_CTRL_VMENTRY_CONTROLS =                                   0x00004012 //col:21669
VMCS_CTRL_VMENTRY_MSR_LOAD_COUNT =                             0x00004014 //col:21674
VMCS_CTRL_VMENTRY_INTERRUPTION_INFORMATION_FIELD =             0x00004016 //col:21679
VMCS_CTRL_VMENTRY_EXCEPTION_ERROR_CODE =                       0x00004018 //col:21684
VMCS_CTRL_VMENTRY_INSTRUCTION_LENGTH =                         0x0000401A //col:21689
VMCS_CTRL_TPR_THRESHOLD =                                      0x0000401C //col:21694
VMCS_CTRL_SECONDARY_PROCESSOR_BASED_VM_EXECUTION_CONTROLS =    0x0000401E //col:21699
VMCS_CTRL_PLE_GAP =                                            0x00004020 //col:21704
VMCS_CTRL_PLE_WINDOW =                                         0x00004022 //col:21709
VMCS_VM_INSTRUCTION_ERROR =                                    0x00004400 //col:21724
VMCS_EXIT_REASON =                                             0x00004402 //col:21729
VMCS_VMEXIT_INTERRUPTION_INFORMATION =                         0x00004404 //col:21734
VMCS_VMEXIT_INTERRUPTION_ERROR_CODE =                          0x00004406 //col:21739
VMCS_IDT_VECTORING_INFORMATION =                               0x00004408 //col:21744
VMCS_IDT_VECTORING_ERROR_CODE =                                0x0000440A //col:21749
VMCS_VMEXIT_INSTRUCTION_LENGTH =                               0x0000440C //col:21754
VMCS_VMEXIT_INSTRUCTION_INFO =                                 0x0000440E //col:21759
VMCS_GUEST_ES_LIMIT =                                          0x00004800 //col:21774
VMCS_GUEST_CS_LIMIT =                                          0x00004802 //col:21779
VMCS_GUEST_SS_LIMIT =                                          0x00004804 //col:21784
VMCS_GUEST_DS_LIMIT =                                          0x00004806 //col:21789
VMCS_GUEST_FS_LIMIT =                                          0x00004808 //col:21794
VMCS_GUEST_GS_LIMIT =                                          0x0000480A //col:21799
VMCS_GUEST_LDTR_LIMIT =                                        0x0000480C //col:21804
VMCS_GUEST_TR_LIMIT =                                          0x0000480E //col:21809
VMCS_GUEST_GDTR_LIMIT =                                        0x00004810 //col:21814
VMCS_GUEST_IDTR_LIMIT =                                        0x00004812 //col:21819
VMCS_GUEST_ES_ACCESS_RIGHTS =                                  0x00004814 //col:21824
VMCS_GUEST_CS_ACCESS_RIGHTS =                                  0x00004816 //col:21829
VMCS_GUEST_SS_ACCESS_RIGHTS =                                  0x00004818 //col:21834
VMCS_GUEST_DS_ACCESS_RIGHTS =                                  0x0000481A //col:21839
VMCS_GUEST_FS_ACCESS_RIGHTS =                                  0x0000481C //col:21844
VMCS_GUEST_GS_ACCESS_RIGHTS =                                  0x0000481E //col:21849
VMCS_GUEST_LDTR_ACCESS_RIGHTS =                                0x00004820 //col:21854
VMCS_GUEST_TR_ACCESS_RIGHTS =                                  0x00004822 //col:21859
VMCS_GUEST_INTERRUPTIBILITY_STATE =                            0x00004824 //col:21864
VMCS_GUEST_ACTIVITY_STATE =                                    0x00004826 //col:21869
VMCS_GUEST_SMBASE =                                            0x00004828 //col:21874
VMCS_GUEST_SYSENTER_CS =                                       0x0000482A //col:21879
VMCS_GUEST_VMX_PREEMPTION_TIMER_VALUE =                        0x0000482E //col:21884
VMCS_HOST_SYSENTER_CS =                                        0x00004C00 //col:21899
VMCS_CTRL_CR0_GUEST_HOST_MASK =                                0x00006000 //col:21927
VMCS_CTRL_CR4_GUEST_HOST_MASK =                                0x00006002 //col:21932
VMCS_CTRL_CR0_READ_SHADOW =                                    0x00006004 //col:21937
VMCS_CTRL_CR4_READ_SHADOW =                                    0x00006006 //col:21942
VMCS_CTRL_CR3_TARGET_VALUE_0 =                                 0x00006008 //col:21947
VMCS_CTRL_CR3_TARGET_VALUE_1 =                                 0x0000600A //col:21952
VMCS_CTRL_CR3_TARGET_VALUE_2 =                                 0x0000600C //col:21957
VMCS_CTRL_CR3_TARGET_VALUE_3 =                                 0x0000600E //col:21962
VMCS_EXIT_QUALIFICATION =                                      0x00006400 //col:21977
VMCS_IO_RCX =                                                  0x00006402 //col:21982
VMCS_IO_RSI =                                                  0x00006404 //col:21987
VMCS_IO_RDI =                                                  0x00006406 //col:21992
VMCS_IO_RIP =                                                  0x00006408 //col:21997
VMCS_EXIT_GUEST_LINEAR_ADDRESS =                               0x0000640A //col:22002
VMCS_GUEST_CR0 =                                               0x00006800 //col:22017
VMCS_GUEST_CR3 =                                               0x00006802 //col:22022
VMCS_GUEST_CR4 =                                               0x00006804 //col:22027
VMCS_GUEST_ES_BASE =                                           0x00006806 //col:22032
VMCS_GUEST_CS_BASE =                                           0x00006808 //col:22037
VMCS_GUEST_SS_BASE =                                           0x0000680A //col:22042
VMCS_GUEST_DS_BASE =                                           0x0000680C //col:22047
VMCS_GUEST_FS_BASE =                                           0x0000680E //col:22052
VMCS_GUEST_GS_BASE =                                           0x00006810 //col:22057
VMCS_GUEST_LDTR_BASE =                                         0x00006812 //col:22062
VMCS_GUEST_TR_BASE =                                           0x00006814 //col:22067
VMCS_GUEST_GDTR_BASE =                                         0x00006816 //col:22072
VMCS_GUEST_IDTR_BASE =                                         0x00006818 //col:22077
VMCS_GUEST_DR7 =                                               0x0000681A //col:22082
VMCS_GUEST_RSP =                                               0x0000681C //col:22087
VMCS_GUEST_RIP =                                               0x0000681E //col:22092
VMCS_GUEST_RFLAGS =                                            0x00006820 //col:22097
VMCS_GUEST_PENDING_DEBUG_EXCEPTIONS =                          0x00006822 //col:22102
VMCS_GUEST_SYSENTER_ESP =                                      0x00006824 //col:22107
VMCS_GUEST_SYSENTER_EIP =                                      0x00006826 //col:22112
VMCS_GUEST_S_CET =                                             0x00006C28 //col:22117
VMCS_GUEST_SSP =                                               0x00006C2A //col:22122
VMCS_GUEST_INTERRUPT_SSP_TABLE_ADDR =                          0x00006C2C //col:22127
VMCS_HOST_CR0 =                                                0x00006C00 //col:22142
VMCS_HOST_CR3 =                                                0x00006C02 //col:22147
VMCS_HOST_CR4 =                                                0x00006C04 //col:22152
VMCS_HOST_FS_BASE =                                            0x00006C06 //col:22157
VMCS_HOST_GS_BASE =                                            0x00006C08 //col:22162
VMCS_HOST_TR_BASE =                                            0x00006C0A //col:22167
VMCS_HOST_GDTR_BASE =                                          0x00006C0C //col:22172
VMCS_HOST_IDTR_BASE =                                          0x00006C0E //col:22177
VMCS_HOST_SYSENTER_ESP =                                       0x00006C10 //col:22182
VMCS_HOST_SYSENTER_EIP =                                       0x00006C12 //col:22187
VMCS_HOST_RSP =                                                0x00006C14 //col:22192
VMCS_HOST_RIP =                                                0x00006C16 //col:22197
VMCS_HOST_S_CET =                                              0x00006C18 //col:22202
VMCS_HOST_SSP =                                                0x00006C1A //col:22207
VMCS_HOST_INTERRUPT_SSP_TABLE_ADDR =                           0x00006C1C //col:22212
VMENTRY_INTERRUPT_INFORMATION_VECTOR_BIT =                     0 //col:22282
VMENTRY_INTERRUPT_INFORMATION_VECTOR_FLAG =                    0xFF //col:22283
VMENTRY_INTERRUPT_INFORMATION_VECTOR_MASK =                    0xFF //col:22284
VMENTRY_INTERRUPT_INFORMATION_VECTOR(_) =                      (((_) >> 0) & 0xFF) //col:22285
VMENTRY_INTERRUPT_INFORMATION_INTERRUPTION_TYPE_BIT =          8 //col:22293
VMENTRY_INTERRUPT_INFORMATION_INTERRUPTION_TYPE_FLAG =         0x700 //col:22294
VMENTRY_INTERRUPT_INFORMATION_INTERRUPTION_TYPE_MASK =         0x07 //col:22295
VMENTRY_INTERRUPT_INFORMATION_INTERRUPTION_TYPE(_) =           (((_) >> 8) & 0x07) //col:22296
VMENTRY_INTERRUPT_INFORMATION_DELIVER_ERROR_CODE_BIT =         11 //col:22304
VMENTRY_INTERRUPT_INFORMATION_DELIVER_ERROR_CODE_FLAG =        0x800 //col:22305
VMENTRY_INTERRUPT_INFORMATION_DELIVER_ERROR_CODE_MASK =        0x01 //col:22306
VMENTRY_INTERRUPT_INFORMATION_DELIVER_ERROR_CODE(_) =          (((_) >> 11) & 0x01) //col:22307
VMENTRY_INTERRUPT_INFORMATION_VALID_BIT =                      31 //col:22317
VMENTRY_INTERRUPT_INFORMATION_VALID_FLAG =                     0x80000000 //col:22318
VMENTRY_INTERRUPT_INFORMATION_VALID_MASK =                     0x01 //col:22319
VMENTRY_INTERRUPT_INFORMATION_VALID(_) =                       (((_) >> 31) & 0x01) //col:22320
VMEXIT_INTERRUPT_INFORMATION_VECTOR_BIT =                      0 //col:22340
VMEXIT_INTERRUPT_INFORMATION_VECTOR_FLAG =                     0xFF //col:22341
VMEXIT_INTERRUPT_INFORMATION_VECTOR_MASK =                     0xFF //col:22342
VMEXIT_INTERRUPT_INFORMATION_VECTOR(_) =                       (((_) >> 0) & 0xFF) //col:22343
VMEXIT_INTERRUPT_INFORMATION_INTERRUPTION_TYPE_BIT =           8 //col:22349
VMEXIT_INTERRUPT_INFORMATION_INTERRUPTION_TYPE_FLAG =          0x700 //col:22350
VMEXIT_INTERRUPT_INFORMATION_INTERRUPTION_TYPE_MASK =          0x07 //col:22351
VMEXIT_INTERRUPT_INFORMATION_INTERRUPTION_TYPE(_) =            (((_) >> 8) & 0x07) //col:22352
VMEXIT_INTERRUPT_INFORMATION_ERROR_CODE_VALID_BIT =            11 //col:22358
VMEXIT_INTERRUPT_INFORMATION_ERROR_CODE_VALID_FLAG =           0x800 //col:22359
VMEXIT_INTERRUPT_INFORMATION_ERROR_CODE_VALID_MASK =           0x01 //col:22360
VMEXIT_INTERRUPT_INFORMATION_ERROR_CODE_VALID(_) =             (((_) >> 11) & 0x01) //col:22361
VMEXIT_INTERRUPT_INFORMATION_NMI_UNBLOCKING_BIT =              12 //col:22367
VMEXIT_INTERRUPT_INFORMATION_NMI_UNBLOCKING_FLAG =             0x1000 //col:22368
VMEXIT_INTERRUPT_INFORMATION_NMI_UNBLOCKING_MASK =             0x01 //col:22369
VMEXIT_INTERRUPT_INFORMATION_NMI_UNBLOCKING(_) =               (((_) >> 12) & 0x01) //col:22370
VMEXIT_INTERRUPT_INFORMATION_VALID_BIT =                       31 //col:22377
VMEXIT_INTERRUPT_INFORMATION_VALID_FLAG =                      0x80000000 //col:22378
VMEXIT_INTERRUPT_INFORMATION_VALID_MASK =                      0x01 //col:22379
VMEXIT_INTERRUPT_INFORMATION_VALID(_) =                        (((_) >> 31) & 0x01) //col:22380
APIC_BASE_ADDRESS =                                            0xFEE00000 //col:22413
APIC_ID =                                                      0x00000020 //col:22418
APIC_VERSION =                                                 0x00000030 //col:22423
APIC_TASK_PRIORITY =                                           0x00000080 //col:22428
APIC_ARBITRATION_PRIORITY =                                    0x00000090 //col:22433
APIC_PROCESSOR_PRIORITY =                                      0x000000A0 //col:22438
APIC_EOI =                                                     0x000000B0 //col:22443
APIC_REMOTE_READ =                                             0x000000C0 //col:22448
APIC_LOGICAL_DESTINATION =                                     0x000000D0 //col:22453
APIC_DESTINATION_FORMAT =                                      0x000000E0 //col:22460
APIC_SPURIOUS_INTERRUPT_VECTOR =                               0x000000F0 //col:22467
APIC_IN_SERVICE_BITS_31_0 =                                    0x00000100 //col:22472
APIC_IN_SERVICE_BITS_63_32 =                                   0x00000110 //col:22477
APIC_IN_SERVICE_BITS_95_64 =                                   0x00000120 //col:22482
APIC_IN_SERVICE_BITS_127_96 =                                  0x00000130 //col:22487
APIC_IN_SERVICE_BITS_159_128 =                                 0x00000140 //col:22492
APIC_IN_SERVICE_BITS_191_160 =                                 0x00000150 //col:22497
APIC_IN_SERVICE_BITS_223_192 =                                 0x00000160 //col:22502
APIC_IN_SERVICE_BITS_255_224 =                                 0x00000170 //col:22507
APIC_TRIGGER_MODE_BITS_31_0 =                                  0x00000180 //col:22512
APIC_TRIGGER_MODE_BITS_63_32 =                                 0x00000190 //col:22517
APIC_TRIGGER_MODE_BITS_95_64 =                                 0x000001A0 //col:22522
APIC_TRIGGER_MODE_BITS_127_96 =                                0x000001B0 //col:22527
APIC_TRIGGER_MODE_BITS_159_128 =                               0x000001C0 //col:22532
APIC_TRIGGER_MODE_BITS_191_160 =                               0x000001D0 //col:22537
APIC_TRIGGER_MODE_BITS_223_192 =                               0x000001E0 //col:22542
APIC_TRIGGER_MODE_BITS_255_224 =                               0x000001F0 //col:22547
APIC_INTERRUPT_REQUEST_BITS_31_0 =                             0x00000200 //col:22552
APIC_INTERRUPT_REQUEST_BITS_63_32 =                            0x00000210 //col:22557
APIC_INTERRUPT_REQUEST_BITS_95_64 =                            0x00000220 //col:22562
APIC_INTERRUPT_REQUEST_BITS_127_96 =                           0x00000230 //col:22567
APIC_INTERRUPT_REQUEST_BITS_159_128 =                          0x00000240 //col:22572
APIC_INTERRUPT_REQUEST_BITS_191_160 =                          0x00000250 //col:22577
APIC_INTERRUPT_REQUEST_BITS_223_192 =                          0x00000260 //col:22582
APIC_INTERRUPT_REQUEST_BITS_255_224 =                          0x00000270 //col:22587
APIC_ERROR_STATUS =                                            0x00000280 //col:22592
APIC_LVT_CORRECTED_MACHINE_CHECK_INTERRUPT =                   0x000002F0 //col:22597
APIC_INTERRUPT_COMMAND_BITS_0_31 =                             0x00000300 //col:22602
APIC_INTERRUPT_COMMAND_BITS_32_63 =                            0x00000310 //col:22607
APIC_LVT_TIMER =                                               0x00000320 //col:22612
APIC_LVT_THERMAL_SENSOR =                                      0x00000330 //col:22617
APIC_LVT_PERFORMANCE_MONITORING_COUNTERS =                     0x00000340 //col:22622
APIC_LVT_LINT0 =                                               0x00000350 //col:22627
APIC_LVT_LINT1 =                                               0x00000360 //col:22632
APIC_LVT_ERROR =                                               0x00000370 //col:22637
APIC_INITIAL_COUNT =                                           0x00000380 //col:22642
APIC_CURRENT_COUNT =                                           0x00000390 //col:22647
APIC_DIVIDE_CONFIGURATION =                                    0x000003E0 //col:22652
EFLAGS_CARRY_FLAG_BIT =                                        0 //col:22677
EFLAGS_CARRY_FLAG_FLAG =                                       0x01 //col:22678
EFLAGS_CARRY_FLAG_MASK =                                       0x01 //col:22679
EFLAGS_CARRY_FLAG(_) =                                         (((_) >> 0) & 0x01) //col:22680
EFLAGS_READ_AS_1_BIT =                                         1 //col:22686
EFLAGS_READ_AS_1_FLAG =                                        0x02 //col:22687
EFLAGS_READ_AS_1_MASK =                                        0x01 //col:22688
EFLAGS_READ_AS_1(_) =                                          (((_) >> 1) & 0x01) //col:22689
EFLAGS_PARITY_FLAG_BIT =                                       2 //col:22697
EFLAGS_PARITY_FLAG_FLAG =                                      0x04 //col:22698
EFLAGS_PARITY_FLAG_MASK =                                      0x01 //col:22699
EFLAGS_PARITY_FLAG(_) =                                        (((_) >> 2) & 0x01) //col:22700
EFLAGS_AUXILIARY_CARRY_FLAG_BIT =                              4 //col:22710
EFLAGS_AUXILIARY_CARRY_FLAG_FLAG =                             0x10 //col:22711
EFLAGS_AUXILIARY_CARRY_FLAG_MASK =                             0x01 //col:22712
EFLAGS_AUXILIARY_CARRY_FLAG(_) =                               (((_) >> 4) & 0x01) //col:22713
EFLAGS_ZERO_FLAG_BIT =                                         6 //col:22722
EFLAGS_ZERO_FLAG_FLAG =                                        0x40 //col:22723
EFLAGS_ZERO_FLAG_MASK =                                        0x01 //col:22724
EFLAGS_ZERO_FLAG(_) =                                          (((_) >> 6) & 0x01) //col:22725
EFLAGS_SIGN_FLAG_BIT =                                         7 //col:22734
EFLAGS_SIGN_FLAG_FLAG =                                        0x80 //col:22735
EFLAGS_SIGN_FLAG_MASK =                                        0x01 //col:22736
EFLAGS_SIGN_FLAG(_) =                                          (((_) >> 7) & 0x01) //col:22737
EFLAGS_TRAP_FLAG_BIT =                                         8 //col:22745
EFLAGS_TRAP_FLAG_FLAG =                                        0x100 //col:22746
EFLAGS_TRAP_FLAG_MASK =                                        0x01 //col:22747
EFLAGS_TRAP_FLAG(_) =                                          (((_) >> 8) & 0x01) //col:22748
EFLAGS_INTERRUPT_ENABLE_FLAG_BIT =                             9 //col:22757
EFLAGS_INTERRUPT_ENABLE_FLAG_FLAG =                            0x200 //col:22758
EFLAGS_INTERRUPT_ENABLE_FLAG_MASK =                            0x01 //col:22759
EFLAGS_INTERRUPT_ENABLE_FLAG(_) =                              (((_) >> 9) & 0x01) //col:22760
EFLAGS_DIRECTION_FLAG_BIT =                                    10 //col:22770
EFLAGS_DIRECTION_FLAG_FLAG =                                   0x400 //col:22771
EFLAGS_DIRECTION_FLAG_MASK =                                   0x01 //col:22772
EFLAGS_DIRECTION_FLAG(_) =                                     (((_) >> 10) & 0x01) //col:22773
EFLAGS_OVERFLOW_FLAG_BIT =                                     11 //col:22783
EFLAGS_OVERFLOW_FLAG_FLAG =                                    0x800 //col:22784
EFLAGS_OVERFLOW_FLAG_MASK =                                    0x01 //col:22785
EFLAGS_OVERFLOW_FLAG(_) =                                      (((_) >> 11) & 0x01) //col:22786
EFLAGS_IO_PRIVILEGE_LEVEL_BIT =                                12 //col:22796
EFLAGS_IO_PRIVILEGE_LEVEL_FLAG =                               0x3000 //col:22797
EFLAGS_IO_PRIVILEGE_LEVEL_MASK =                               0x03 //col:22798
EFLAGS_IO_PRIVILEGE_LEVEL(_) =                                 (((_) >> 12) & 0x03) //col:22799
EFLAGS_NESTED_TASK_FLAG_BIT =                                  14 //col:22808
EFLAGS_NESTED_TASK_FLAG_FLAG =                                 0x4000 //col:22809
EFLAGS_NESTED_TASK_FLAG_MASK =                                 0x01 //col:22810
EFLAGS_NESTED_TASK_FLAG(_) =                                   (((_) >> 14) & 0x01) //col:22811
EFLAGS_RESUME_FLAG_BIT =                                       16 //col:22820
EFLAGS_RESUME_FLAG_FLAG =                                      0x10000 //col:22821
EFLAGS_RESUME_FLAG_MASK =                                      0x01 //col:22822
EFLAGS_RESUME_FLAG(_) =                                        (((_) >> 16) & 0x01) //col:22823
EFLAGS_VIRTUAL_8086_MODE_FLAG_BIT =                            17 //col:22831
EFLAGS_VIRTUAL_8086_MODE_FLAG_FLAG =                           0x20000 //col:22832
EFLAGS_VIRTUAL_8086_MODE_FLAG_MASK =                           0x01 //col:22833
EFLAGS_VIRTUAL_8086_MODE_FLAG(_) =                             (((_) >> 17) & 0x01) //col:22834
EFLAGS_ALIGNMENT_CHECK_FLAG_BIT =                              18 //col:22846
EFLAGS_ALIGNMENT_CHECK_FLAG_FLAG =                             0x40000 //col:22847
EFLAGS_ALIGNMENT_CHECK_FLAG_MASK =                             0x01 //col:22848
EFLAGS_ALIGNMENT_CHECK_FLAG(_) =                               (((_) >> 18) & 0x01) //col:22849
EFLAGS_VIRTUAL_INTERRUPT_FLAG_BIT =                            19 //col:22858
EFLAGS_VIRTUAL_INTERRUPT_FLAG_FLAG =                           0x80000 //col:22859
EFLAGS_VIRTUAL_INTERRUPT_FLAG_MASK =                           0x01 //col:22860
EFLAGS_VIRTUAL_INTERRUPT_FLAG(_) =                             (((_) >> 19) & 0x01) //col:22861
EFLAGS_VIRTUAL_INTERRUPT_PENDING_FLAG_BIT =                    20 //col:22870
EFLAGS_VIRTUAL_INTERRUPT_PENDING_FLAG_FLAG =                   0x100000 //col:22871
EFLAGS_VIRTUAL_INTERRUPT_PENDING_FLAG_MASK =                   0x01 //col:22872
EFLAGS_VIRTUAL_INTERRUPT_PENDING_FLAG(_) =                     (((_) >> 20) & 0x01) //col:22873
EFLAGS_IDENTIFICATION_FLAG_BIT =                               21 //col:22881
EFLAGS_IDENTIFICATION_FLAG_FLAG =                              0x200000 //col:22882
EFLAGS_IDENTIFICATION_FLAG_MASK =                              0x01 //col:22883
EFLAGS_IDENTIFICATION_FLAG(_) =                                (((_) >> 21) & 0x01) //col:22884
RFLAGS_CARRY_FLAG_BIT =                                        0 //col:22908
RFLAGS_CARRY_FLAG_FLAG =                                       0x01 //col:22909
RFLAGS_CARRY_FLAG_MASK =                                       0x01 //col:22910
RFLAGS_CARRY_FLAG(_) =                                         (((_) >> 0) & 0x01) //col:22911
RFLAGS_READ_AS_1_BIT =                                         1 //col:22917
RFLAGS_READ_AS_1_FLAG =                                        0x02 //col:22918
RFLAGS_READ_AS_1_MASK =                                        0x01 //col:22919
RFLAGS_READ_AS_1(_) =                                          (((_) >> 1) & 0x01) //col:22920
RFLAGS_PARITY_FLAG_BIT =                                       2 //col:22928
RFLAGS_PARITY_FLAG_FLAG =                                      0x04 //col:22929
RFLAGS_PARITY_FLAG_MASK =                                      0x01 //col:22930
RFLAGS_PARITY_FLAG(_) =                                        (((_) >> 2) & 0x01) //col:22931
RFLAGS_AUXILIARY_CARRY_FLAG_BIT =                              4 //col:22940
RFLAGS_AUXILIARY_CARRY_FLAG_FLAG =                             0x10 //col:22941
RFLAGS_AUXILIARY_CARRY_FLAG_MASK =                             0x01 //col:22942
RFLAGS_AUXILIARY_CARRY_FLAG(_) =                               (((_) >> 4) & 0x01) //col:22943
RFLAGS_ZERO_FLAG_BIT =                                         6 //col:22952
RFLAGS_ZERO_FLAG_FLAG =                                        0x40 //col:22953
RFLAGS_ZERO_FLAG_MASK =                                        0x01 //col:22954
RFLAGS_ZERO_FLAG(_) =                                          (((_) >> 6) & 0x01) //col:22955
RFLAGS_SIGN_FLAG_BIT =                                         7 //col:22963
RFLAGS_SIGN_FLAG_FLAG =                                        0x80 //col:22964
RFLAGS_SIGN_FLAG_MASK =                                        0x01 //col:22965
RFLAGS_SIGN_FLAG(_) =                                          (((_) >> 7) & 0x01) //col:22966
RFLAGS_TRAP_FLAG_BIT =                                         8 //col:22974
RFLAGS_TRAP_FLAG_FLAG =                                        0x100 //col:22975
RFLAGS_TRAP_FLAG_MASK =                                        0x01 //col:22976
RFLAGS_TRAP_FLAG(_) =                                          (((_) >> 8) & 0x01) //col:22977
RFLAGS_INTERRUPT_ENABLE_FLAG_BIT =                             9 //col:22985
RFLAGS_INTERRUPT_ENABLE_FLAG_FLAG =                            0x200 //col:22986
RFLAGS_INTERRUPT_ENABLE_FLAG_MASK =                            0x01 //col:22987
RFLAGS_INTERRUPT_ENABLE_FLAG(_) =                              (((_) >> 9) & 0x01) //col:22988
RFLAGS_DIRECTION_FLAG_BIT =                                    10 //col:22996
RFLAGS_DIRECTION_FLAG_FLAG =                                   0x400 //col:22997
RFLAGS_DIRECTION_FLAG_MASK =                                   0x01 //col:22998
RFLAGS_DIRECTION_FLAG(_) =                                     (((_) >> 10) & 0x01) //col:22999
RFLAGS_OVERFLOW_FLAG_BIT =                                     11 //col:23007
RFLAGS_OVERFLOW_FLAG_FLAG =                                    0x800 //col:23008
RFLAGS_OVERFLOW_FLAG_MASK =                                    0x01 //col:23009
RFLAGS_OVERFLOW_FLAG(_) =                                      (((_) >> 11) & 0x01) //col:23010
RFLAGS_IO_PRIVILEGE_LEVEL_BIT =                                12 //col:23018
RFLAGS_IO_PRIVILEGE_LEVEL_FLAG =                               0x3000 //col:23019
RFLAGS_IO_PRIVILEGE_LEVEL_MASK =                               0x03 //col:23020
RFLAGS_IO_PRIVILEGE_LEVEL(_) =                                 (((_) >> 12) & 0x03) //col:23021
RFLAGS_NESTED_TASK_FLAG_BIT =                                  14 //col:23029
RFLAGS_NESTED_TASK_FLAG_FLAG =                                 0x4000 //col:23030
RFLAGS_NESTED_TASK_FLAG_MASK =                                 0x01 //col:23031
RFLAGS_NESTED_TASK_FLAG(_) =                                   (((_) >> 14) & 0x01) //col:23032
RFLAGS_RESUME_FLAG_BIT =                                       16 //col:23041
RFLAGS_RESUME_FLAG_FLAG =                                      0x10000 //col:23042
RFLAGS_RESUME_FLAG_MASK =                                      0x01 //col:23043
RFLAGS_RESUME_FLAG(_) =                                        (((_) >> 16) & 0x01) //col:23044
RFLAGS_VIRTUAL_8086_MODE_FLAG_BIT =                            17 //col:23052
RFLAGS_VIRTUAL_8086_MODE_FLAG_FLAG =                           0x20000 //col:23053
RFLAGS_VIRTUAL_8086_MODE_FLAG_MASK =                           0x01 //col:23054
RFLAGS_VIRTUAL_8086_MODE_FLAG(_) =                             (((_) >> 17) & 0x01) //col:23055
RFLAGS_ALIGNMENT_CHECK_FLAG_BIT =                              18 //col:23065
RFLAGS_ALIGNMENT_CHECK_FLAG_FLAG =                             0x40000 //col:23066
RFLAGS_ALIGNMENT_CHECK_FLAG_MASK =                             0x01 //col:23067
RFLAGS_ALIGNMENT_CHECK_FLAG(_) =                               (((_) >> 18) & 0x01) //col:23068
RFLAGS_VIRTUAL_INTERRUPT_FLAG_BIT =                            19 //col:23076
RFLAGS_VIRTUAL_INTERRUPT_FLAG_FLAG =                           0x80000 //col:23077
RFLAGS_VIRTUAL_INTERRUPT_FLAG_MASK =                           0x01 //col:23078
RFLAGS_VIRTUAL_INTERRUPT_FLAG(_) =                             (((_) >> 19) & 0x01) //col:23079
RFLAGS_VIRTUAL_INTERRUPT_PENDING_FLAG_BIT =                    20 //col:23087
RFLAGS_VIRTUAL_INTERRUPT_PENDING_FLAG_FLAG =                   0x100000 //col:23088
RFLAGS_VIRTUAL_INTERRUPT_PENDING_FLAG_MASK =                   0x01 //col:23089
RFLAGS_VIRTUAL_INTERRUPT_PENDING_FLAG(_) =                     (((_) >> 20) & 0x01) //col:23090
RFLAGS_IDENTIFICATION_FLAG_BIT =                               21 //col:23098
RFLAGS_IDENTIFICATION_FLAG_FLAG =                              0x200000 //col:23099
RFLAGS_IDENTIFICATION_FLAG_MASK =                              0x01 //col:23100
RFLAGS_IDENTIFICATION_FLAG(_) =                                (((_) >> 21) & 0x01) //col:23101
CONTROL_PROTECTION_EXCEPTION_CPEC_BIT =                        0 //col:23131
CONTROL_PROTECTION_EXCEPTION_CPEC_FLAG =                       0x7FFF //col:23132
CONTROL_PROTECTION_EXCEPTION_CPEC_MASK =                       0x7FFF //col:23133
CONTROL_PROTECTION_EXCEPTION_CPEC(_) =                         (((_) >> 0) & 0x7FFF) //col:23134
CONTROL_PROTECTION_EXCEPTION_ENCL_BIT =                        15 //col:23140
CONTROL_PROTECTION_EXCEPTION_ENCL_FLAG =                       0x8000 //col:23141
CONTROL_PROTECTION_EXCEPTION_ENCL_MASK =                       0x01 //col:23142
CONTROL_PROTECTION_EXCEPTION_ENCL(_) =                         (((_) >> 15) & 0x01) //col:23143
EXCEPTION_ERROR_CODE_EXTERNAL_EVENT_BIT =                      0 //col:23328
EXCEPTION_ERROR_CODE_EXTERNAL_EVENT_FLAG =                     0x01 //col:23329
EXCEPTION_ERROR_CODE_EXTERNAL_EVENT_MASK =                     0x01 //col:23330
EXCEPTION_ERROR_CODE_EXTERNAL_EVENT(_) =                       (((_) >> 0) & 0x01) //col:23331
EXCEPTION_ERROR_CODE_DESCRIPTOR_LOCATION_BIT =                 1 //col:23338
EXCEPTION_ERROR_CODE_DESCRIPTOR_LOCATION_FLAG =                0x02 //col:23339
EXCEPTION_ERROR_CODE_DESCRIPTOR_LOCATION_MASK =                0x01 //col:23340
EXCEPTION_ERROR_CODE_DESCRIPTOR_LOCATION(_) =                  (((_) >> 1) & 0x01) //col:23341
EXCEPTION_ERROR_CODE_GDT_LDT_BIT =                             2 //col:23349
EXCEPTION_ERROR_CODE_GDT_LDT_FLAG =                            0x04 //col:23350
EXCEPTION_ERROR_CODE_GDT_LDT_MASK =                            0x01 //col:23351
EXCEPTION_ERROR_CODE_GDT_LDT(_) =                              (((_) >> 2) & 0x01) //col:23352
EXCEPTION_ERROR_CODE_INDEX_BIT =                               3 //col:23363
EXCEPTION_ERROR_CODE_INDEX_FLAG =                              0xFFF8 //col:23364
EXCEPTION_ERROR_CODE_INDEX_MASK =                              0x1FFF //col:23365
EXCEPTION_ERROR_CODE_INDEX(_) =                                (((_) >> 3) & 0x1FFF) //col:23366
PAGE_FAULT_EXCEPTION_PRESENT_BIT =                             0 //col:23387
PAGE_FAULT_EXCEPTION_PRESENT_FLAG =                            0x01 //col:23388
PAGE_FAULT_EXCEPTION_PRESENT_MASK =                            0x01 //col:23389
PAGE_FAULT_EXCEPTION_PRESENT(_) =                              (((_) >> 0) & 0x01) //col:23390
PAGE_FAULT_EXCEPTION_WRITE_BIT =                               1 //col:23397
PAGE_FAULT_EXCEPTION_WRITE_FLAG =                              0x02 //col:23398
PAGE_FAULT_EXCEPTION_WRITE_MASK =                              0x01 //col:23399
PAGE_FAULT_EXCEPTION_WRITE(_) =                                (((_) >> 1) & 0x01) //col:23400
PAGE_FAULT_EXCEPTION_USER_MODE_ACCESS_BIT =                    2 //col:23409
PAGE_FAULT_EXCEPTION_USER_MODE_ACCESS_FLAG =                   0x04 //col:23410
PAGE_FAULT_EXCEPTION_USER_MODE_ACCESS_MASK =                   0x01 //col:23411
PAGE_FAULT_EXCEPTION_USER_MODE_ACCESS(_) =                     (((_) >> 2) & 0x01) //col:23412
PAGE_FAULT_EXCEPTION_RESERVED_BIT_VIOLATION_BIT =              3 //col:23423
PAGE_FAULT_EXCEPTION_RESERVED_BIT_VIOLATION_FLAG =             0x08 //col:23424
PAGE_FAULT_EXCEPTION_RESERVED_BIT_VIOLATION_MASK =             0x01 //col:23425
PAGE_FAULT_EXCEPTION_RESERVED_BIT_VIOLATION(_) =               (((_) >> 3) & 0x01) //col:23426
PAGE_FAULT_EXCEPTION_EXECUTE_BIT =                             4 //col:23435
PAGE_FAULT_EXCEPTION_EXECUTE_FLAG =                            0x10 //col:23436
PAGE_FAULT_EXCEPTION_EXECUTE_MASK =                            0x01 //col:23437
PAGE_FAULT_EXCEPTION_EXECUTE(_) =                              (((_) >> 4) & 0x01) //col:23438
PAGE_FAULT_EXCEPTION_PROTECTION_KEY_VIOLATION_BIT =            5 //col:23449
PAGE_FAULT_EXCEPTION_PROTECTION_KEY_VIOLATION_FLAG =           0x20 //col:23450
PAGE_FAULT_EXCEPTION_PROTECTION_KEY_VIOLATION_MASK =           0x01 //col:23451
PAGE_FAULT_EXCEPTION_PROTECTION_KEY_VIOLATION(_) =             (((_) >> 5) & 0x01) //col:23452
PAGE_FAULT_EXCEPTION_SHADOW_STACK_BIT =                        6 //col:23462
PAGE_FAULT_EXCEPTION_SHADOW_STACK_FLAG =                       0x40 //col:23463
PAGE_FAULT_EXCEPTION_SHADOW_STACK_MASK =                       0x01 //col:23464
PAGE_FAULT_EXCEPTION_SHADOW_STACK(_) =                         (((_) >> 6) & 0x01) //col:23465
PAGE_FAULT_EXCEPTION_HLAT_BIT =                                7 //col:23477
PAGE_FAULT_EXCEPTION_HLAT_FLAG =                               0x80 //col:23478
PAGE_FAULT_EXCEPTION_HLAT_MASK =                               0x01 //col:23479
PAGE_FAULT_EXCEPTION_HLAT(_) =                                 (((_) >> 7) & 0x01) //col:23480
PAGE_FAULT_EXCEPTION_SGX_BIT =                                 15 //col:23489
PAGE_FAULT_EXCEPTION_SGX_FLAG =                                0x8000 //col:23490
PAGE_FAULT_EXCEPTION_SGX_MASK =                                0x01 //col:23491
PAGE_FAULT_EXCEPTION_SGX(_) =                                  (((_) >> 15) & 0x01) //col:23492
MEMORY_TYPE_UNCACHEABLE =                                      0x00000000 //col:23523
MEMORY_TYPE_WRITE_COMBINING =                                  0x00000001 //col:23540
MEMORY_TYPE_WRITE_THROUGH =                                    0x00000004 //col:23552
MEMORY_TYPE_WRITE_PROTECTED =                                  0x00000005 //col:23561
MEMORY_TYPE_WRITE_BACK =                                       0x00000006 //col:23577
MEMORY_TYPE_UNCACHEABLE_MINUS =                                0x00000007 //col:23586
MEMORY_TYPE_INVALID =                                          0x000000FF //col:23587
VTD_Lower64_PRESENT_BIT =                                      0 //col:23615
VTD_Lower64_PRESENT_FLAG =                                     0x01 //col:23616
VTD_Lower64_PRESENT_MASK =                                     0x01 //col:23617
VTD_Lower64_PRESENT(_) =                                       (((_) >> 0) & 0x01) //col:23618
VTD_Lower64_CONTEXT_TABLE_POINTER_BIT =                        12 //col:23626
VTD_Lower64_CONTEXT_TABLE_POINTER_FLAG =                       0xFFFFFFFFFFFFF000 //col:23627
VTD_Lower64_CONTEXT_TABLE_POINTER_MASK =                       0xFFFFFFFFFFFFF //col:23628
VTD_Lower64_CONTEXT_TABLE_POINTER(_) =                         (((_) >> 12) & 0xFFFFFFFFFFFFF) //col:23629
VTD_Upper64_RESERVED_BIT =                                     0 //col:23643
VTD_Upper64_RESERVED_FLAG =                                    0xFFFFFFFFFFFFFFFF //col:23644
VTD_Upper64_RESERVED_MASK =                                    0xFFFFFFFFFFFFFFFF //col:23645
VTD_Upper64_RESERVED(_) =                                      (((_) >> 0) & 0xFFFFFFFFFFFFFFFF) //col:23646
VTD_Lower64_PRESENT_BIT =                                      0 //col:23673
VTD_Lower64_PRESENT_FLAG =                                     0x01 //col:23674
VTD_Lower64_PRESENT_MASK =                                     0x01 //col:23675
VTD_Lower64_PRESENT(_) =                                       (((_) >> 0) & 0x01) //col:23676
VTD_Lower64_FAULT_PROCESSING_DISABLE_BIT =                     1 //col:23685
VTD_Lower64_FAULT_PROCESSING_DISABLE_FLAG =                    0x02 //col:23686
VTD_Lower64_FAULT_PROCESSING_DISABLE_MASK =                    0x01 //col:23687
VTD_Lower64_FAULT_PROCESSING_DISABLE(_) =                      (((_) >> 1) & 0x01) //col:23688
VTD_Lower64_TRANSLATION_TYPE_BIT =                             2 //col:23703
VTD_Lower64_TRANSLATION_TYPE_FLAG =                            0x0C //col:23704
VTD_Lower64_TRANSLATION_TYPE_MASK =                            0x03 //col:23705
VTD_Lower64_TRANSLATION_TYPE(_) =                              (((_) >> 2) & 0x03) //col:23706
VTD_Lower64_SECOND_LEVEL_PAGE_TRANSLATION_POINTER_BIT =        12 //col:23716
VTD_Lower64_SECOND_LEVEL_PAGE_TRANSLATION_POINTER_FLAG =       0xFFFFFFFFFFFFF000 //col:23717
VTD_Lower64_SECOND_LEVEL_PAGE_TRANSLATION_POINTER_MASK =       0xFFFFFFFFFFFFF //col:23718
VTD_Lower64_SECOND_LEVEL_PAGE_TRANSLATION_POINTER(_) =         (((_) >> 12) & 0xFFFFFFFFFFFFF) //col:23719
VTD_Upper64_ADDRESS_WIDTH_BIT =                                0 //col:23745
VTD_Upper64_ADDRESS_WIDTH_FLAG =                               0x07 //col:23746
VTD_Upper64_ADDRESS_WIDTH_MASK =                               0x07 //col:23747
VTD_Upper64_ADDRESS_WIDTH(_) =                                 (((_) >> 0) & 0x07) //col:23748
VTD_Upper64_IGNORED_BIT =                                      3 //col:23754
VTD_Upper64_IGNORED_FLAG =                                     0x78 //col:23755
VTD_Upper64_IGNORED_MASK =                                     0x0F //col:23756
VTD_Upper64_IGNORED(_) =                                       (((_) >> 3) & 0x0F) //col:23757
VTD_Upper64_DOMAIN_IDENTIFIER_BIT =                            8 //col:23773
VTD_Upper64_DOMAIN_IDENTIFIER_FLAG =                           0x3FF00 //col:23774
VTD_Upper64_DOMAIN_IDENTIFIER_MASK =                           0x3FF //col:23775
VTD_Upper64_DOMAIN_IDENTIFIER(_) =                             (((_) >> 8) & 0x3FF) //col:23776
VTD_ROOT_ENTRY_COUNT =                                         0x00000100 //col:23792
VTD_CONTEXT_ENTRY_COUNT =                                      0x00000100 //col:23793
VTD_VERSION =                                                  0x00000000 //col:23805
VTD_VERSION_MINOR_BIT =                                        0 //col:23816
VTD_VERSION_MINOR_FLAG =                                       0x0F //col:23817
VTD_VERSION_MINOR_MASK =                                       0x0F //col:23818
VTD_VERSION_MINOR(_) =                                         (((_) >> 0) & 0x0F) //col:23819
VTD_VERSION_MAJOR_BIT =                                        4 //col:23827
VTD_VERSION_MAJOR_FLAG =                                       0xF0 //col:23828
VTD_VERSION_MAJOR_MASK =                                       0x0F //col:23829
VTD_VERSION_MAJOR(_) =                                         (((_) >> 4) & 0x0F) //col:23830
VTD_CAPABILITY =                                               0x00000008 //col:23844
VTD_CAPABILITY_NUMBER_OF_DOMAINS_SUPPORTED_BIT =               0 //col:23863
VTD_CAPABILITY_NUMBER_OF_DOMAINS_SUPPORTED_FLAG =              0x07 //col:23864
VTD_CAPABILITY_NUMBER_OF_DOMAINS_SUPPORTED_MASK =              0x07 //col:23865
VTD_CAPABILITY_NUMBER_OF_DOMAINS_SUPPORTED(_) =                (((_) >> 0) & 0x07) //col:23866
VTD_CAPABILITY_ADVANCED_FAULT_LOGGING_BIT =                    3 //col:23876
VTD_CAPABILITY_ADVANCED_FAULT_LOGGING_FLAG =                   0x08 //col:23877
VTD_CAPABILITY_ADVANCED_FAULT_LOGGING_MASK =                   0x01 //col:23878
VTD_CAPABILITY_ADVANCED_FAULT_LOGGING(_) =                     (((_) >> 3) & 0x01) //col:23879
VTD_CAPABILITY_REQUIRED_WRITE_BUFFER_FLUSHING_BIT =            4 //col:23891
VTD_CAPABILITY_REQUIRED_WRITE_BUFFER_FLUSHING_FLAG =           0x10 //col:23892
VTD_CAPABILITY_REQUIRED_WRITE_BUFFER_FLUSHING_MASK =           0x01 //col:23893
VTD_CAPABILITY_REQUIRED_WRITE_BUFFER_FLUSHING(_) =             (((_) >> 4) & 0x01) //col:23894
VTD_CAPABILITY_PROTECTED_LOW_MEMORY_REGION_BIT =               5 //col:23904
VTD_CAPABILITY_PROTECTED_LOW_MEMORY_REGION_FLAG =              0x20 //col:23905
VTD_CAPABILITY_PROTECTED_LOW_MEMORY_REGION_MASK =              0x01 //col:23906
VTD_CAPABILITY_PROTECTED_LOW_MEMORY_REGION(_) =                (((_) >> 5) & 0x01) //col:23907
VTD_CAPABILITY_PROTECTED_HIGH_MEMORY_REGION_BIT =              6 //col:23917
VTD_CAPABILITY_PROTECTED_HIGH_MEMORY_REGION_FLAG =             0x40 //col:23918
VTD_CAPABILITY_PROTECTED_HIGH_MEMORY_REGION_MASK =             0x01 //col:23919
VTD_CAPABILITY_PROTECTED_HIGH_MEMORY_REGION(_) =               (((_) >> 6) & 0x01) //col:23920
VTD_CAPABILITY_CACHING_MODE_BIT =                              7 //col:23934
VTD_CAPABILITY_CACHING_MODE_FLAG =                             0x80 //col:23935
VTD_CAPABILITY_CACHING_MODE_MASK =                             0x01 //col:23936
VTD_CAPABILITY_CACHING_MODE(_) =                               (((_) >> 7) & 0x01) //col:23937
VTD_CAPABILITY_SUPPORTED_ADJUSTED_GUEST_ADDRESS_WIDTHS_BIT =   8 //col:23956
VTD_CAPABILITY_SUPPORTED_ADJUSTED_GUEST_ADDRESS_WIDTHS_FLAG =  0x1F00 //col:23957
VTD_CAPABILITY_SUPPORTED_ADJUSTED_GUEST_ADDRESS_WIDTHS_MASK =  0x1F //col:23958
VTD_CAPABILITY_SUPPORTED_ADJUSTED_GUEST_ADDRESS_WIDTHS(_) =    (((_) >> 8) & 0x1F) //col:23959
VTD_CAPABILITY_MAXIMUM_GUEST_ADDRESS_WIDTH_BIT =               16 //col:23977
VTD_CAPABILITY_MAXIMUM_GUEST_ADDRESS_WIDTH_FLAG =              0x3F0000 //col:23978
VTD_CAPABILITY_MAXIMUM_GUEST_ADDRESS_WIDTH_MASK =              0x3F //col:23979
VTD_CAPABILITY_MAXIMUM_GUEST_ADDRESS_WIDTH(_) =                (((_) >> 16) & 0x3F) //col:23980
VTD_CAPABILITY_ZERO_LENGTH_READ_BIT =                          22 //col:23992
VTD_CAPABILITY_ZERO_LENGTH_READ_FLAG =                         0x400000 //col:23993
VTD_CAPABILITY_ZERO_LENGTH_READ_MASK =                         0x01 //col:23994
VTD_CAPABILITY_ZERO_LENGTH_READ(_) =                           (((_) >> 22) & 0x01) //col:23995
VTD_CAPABILITY_DEPRECATED_BIT =                                23 //col:24003
VTD_CAPABILITY_DEPRECATED_FLAG =                               0x800000 //col:24004
VTD_CAPABILITY_DEPRECATED_MASK =                               0x01 //col:24005
VTD_CAPABILITY_DEPRECATED(_) =                                 (((_) >> 23) & 0x01) //col:24006
VTD_CAPABILITY_FAULT_RECORDING_REGISTER_OFFSET_BIT =           24 //col:24016
VTD_CAPABILITY_FAULT_RECORDING_REGISTER_OFFSET_FLAG =          0x3FF000000 //col:24017
VTD_CAPABILITY_FAULT_RECORDING_REGISTER_OFFSET_MASK =          0x3FF //col:24018
VTD_CAPABILITY_FAULT_RECORDING_REGISTER_OFFSET(_) =            (((_) >> 24) & 0x3FF) //col:24019
VTD_CAPABILITY_SECOND_LEVEL_LARGE_PAGE_SUPPORT_BIT =           34 //col:24035
VTD_CAPABILITY_SECOND_LEVEL_LARGE_PAGE_SUPPORT_FLAG =          0x3C00000000 //col:24036
VTD_CAPABILITY_SECOND_LEVEL_LARGE_PAGE_SUPPORT_MASK =          0x0F //col:24037
VTD_CAPABILITY_SECOND_LEVEL_LARGE_PAGE_SUPPORT(_) =            (((_) >> 34) & 0x0F) //col:24038
VTD_CAPABILITY_PAGE_SELECTIVE_INVALIDATION_BIT =               39 //col:24054
VTD_CAPABILITY_PAGE_SELECTIVE_INVALIDATION_FLAG =              0x8000000000 //col:24055
VTD_CAPABILITY_PAGE_SELECTIVE_INVALIDATION_MASK =              0x01 //col:24056
VTD_CAPABILITY_PAGE_SELECTIVE_INVALIDATION(_) =                (((_) >> 39) & 0x01) //col:24057
VTD_CAPABILITY_NUMBER_OF_FAULT_RECORDING_REGISTERS_BIT =       40 //col:24068
VTD_CAPABILITY_NUMBER_OF_FAULT_RECORDING_REGISTERS_FLAG =      0xFF0000000000 //col:24069
VTD_CAPABILITY_NUMBER_OF_FAULT_RECORDING_REGISTERS_MASK =      0xFF //col:24070
VTD_CAPABILITY_NUMBER_OF_FAULT_RECORDING_REGISTERS(_) =        (((_) >> 40) & 0xFF) //col:24071
VTD_CAPABILITY_MAXIMUM_ADDRESS_MASK_VALUE_BIT =                48 //col:24084
VTD_CAPABILITY_MAXIMUM_ADDRESS_MASK_VALUE_FLAG =               0x3F000000000000 //col:24085
VTD_CAPABILITY_MAXIMUM_ADDRESS_MASK_VALUE_MASK =               0x3F //col:24086
VTD_CAPABILITY_MAXIMUM_ADDRESS_MASK_VALUE(_) =                 (((_) >> 48) & 0x3F) //col:24087
VTD_CAPABILITY_WRITE_DRAINING_BIT =                            54 //col:24100
VTD_CAPABILITY_WRITE_DRAINING_FLAG =                           0x40000000000000 //col:24101
VTD_CAPABILITY_WRITE_DRAINING_MASK =                           0x01 //col:24102
VTD_CAPABILITY_WRITE_DRAINING(_) =                             (((_) >> 54) & 0x01) //col:24103
VTD_CAPABILITY_READ_DRAINING_BIT =                             55 //col:24116
VTD_CAPABILITY_READ_DRAINING_FLAG =                            0x80000000000000 //col:24117
VTD_CAPABILITY_READ_DRAINING_MASK =                            0x01 //col:24118
VTD_CAPABILITY_READ_DRAINING(_) =                              (((_) >> 55) & 0x01) //col:24119
VTD_CAPABILITY_FIRST_LEVEL_1GBYTE_PAGE_SUPPORT_BIT =           56 //col:24128
VTD_CAPABILITY_FIRST_LEVEL_1GBYTE_PAGE_SUPPORT_FLAG =          0x100000000000000 //col:24129
VTD_CAPABILITY_FIRST_LEVEL_1GBYTE_PAGE_SUPPORT_MASK =          0x01 //col:24130
VTD_CAPABILITY_FIRST_LEVEL_1GBYTE_PAGE_SUPPORT(_) =            (((_) >> 56) & 0x01) //col:24131
VTD_CAPABILITY_POSTED_INTERRUPTS_SUPPORT_BIT =                 59 //col:24144
VTD_CAPABILITY_POSTED_INTERRUPTS_SUPPORT_FLAG =                0x800000000000000 //col:24145
VTD_CAPABILITY_POSTED_INTERRUPTS_SUPPORT_MASK =                0x01 //col:24146
VTD_CAPABILITY_POSTED_INTERRUPTS_SUPPORT(_) =                  (((_) >> 59) & 0x01) //col:24147
VTD_CAPABILITY_FIRST_LEVEL_5LEVEL_PAGING_SUPPORT_BIT =         60 //col:24158
VTD_CAPABILITY_FIRST_LEVEL_5LEVEL_PAGING_SUPPORT_FLAG =        0x1000000000000000 //col:24159
VTD_CAPABILITY_FIRST_LEVEL_5LEVEL_PAGING_SUPPORT_MASK =        0x01 //col:24160
VTD_CAPABILITY_FIRST_LEVEL_5LEVEL_PAGING_SUPPORT(_) =          (((_) >> 60) & 0x01) //col:24161
VTD_CAPABILITY_ENHANCED_SET_INTERRUPT_REMAP_TABLE_POINTER_SUPPORT_BIT = 62 //col:24172
VTD_CAPABILITY_ENHANCED_SET_INTERRUPT_REMAP_TABLE_POINTER_SUPPORT_FLAG = 0x4000000000000000 //col:24173
VTD_CAPABILITY_ENHANCED_SET_INTERRUPT_REMAP_TABLE_POINTER_SUPPORT_MASK = 0x01 //col:24174
VTD_CAPABILITY_ENHANCED_SET_INTERRUPT_REMAP_TABLE_POINTER_SUPPORT(_) = (((_) >> 62) & 0x01) //col:24175
VTD_CAPABILITY_ENHANCED_SET_ROOT_TABLE_POINTER_SUPPORT_BIT =   63 //col:24185
VTD_CAPABILITY_ENHANCED_SET_ROOT_TABLE_POINTER_SUPPORT_FLAG =  0x8000000000000000 //col:24186
VTD_CAPABILITY_ENHANCED_SET_ROOT_TABLE_POINTER_SUPPORT_MASK =  0x01 //col:24187
VTD_CAPABILITY_ENHANCED_SET_ROOT_TABLE_POINTER_SUPPORT(_) =    (((_) >> 63) & 0x01) //col:24188
VTD_EXTENDED_CAPABILITY =                                      0x00000010 //col:24201
VTD_EXTENDED_CAPABILITY_PAGE_WALK_COHERENCY_BIT =              0 //col:24218
VTD_EXTENDED_CAPABILITY_PAGE_WALK_COHERENCY_FLAG =             0x01 //col:24219
VTD_EXTENDED_CAPABILITY_PAGE_WALK_COHERENCY_MASK =             0x01 //col:24220
VTD_EXTENDED_CAPABILITY_PAGE_WALK_COHERENCY(_) =               (((_) >> 0) & 0x01) //col:24221
VTD_EXTENDED_CAPABILITY_QUEUED_INVALIDATION_SUPPORT_BIT =      1 //col:24231
VTD_EXTENDED_CAPABILITY_QUEUED_INVALIDATION_SUPPORT_FLAG =     0x02 //col:24232
VTD_EXTENDED_CAPABILITY_QUEUED_INVALIDATION_SUPPORT_MASK =     0x01 //col:24233
VTD_EXTENDED_CAPABILITY_QUEUED_INVALIDATION_SUPPORT(_) =       (((_) >> 1) & 0x01) //col:24234
VTD_EXTENDED_CAPABILITY_DEVICE_TLB_SUPPORT_BIT =               2 //col:24245
VTD_EXTENDED_CAPABILITY_DEVICE_TLB_SUPPORT_FLAG =              0x04 //col:24246
VTD_EXTENDED_CAPABILITY_DEVICE_TLB_SUPPORT_MASK =              0x01 //col:24247
VTD_EXTENDED_CAPABILITY_DEVICE_TLB_SUPPORT(_) =                (((_) >> 2) & 0x01) //col:24248
VTD_EXTENDED_CAPABILITY_INTERRUPT_REMAPPING_SUPPORT_BIT =      3 //col:24259
VTD_EXTENDED_CAPABILITY_INTERRUPT_REMAPPING_SUPPORT_FLAG =     0x08 //col:24260
VTD_EXTENDED_CAPABILITY_INTERRUPT_REMAPPING_SUPPORT_MASK =     0x01 //col:24261
VTD_EXTENDED_CAPABILITY_INTERRUPT_REMAPPING_SUPPORT(_) =       (((_) >> 3) & 0x01) //col:24262
VTD_EXTENDED_CAPABILITY_EXTENDED_INTERRUPT_MODE_BIT =          4 //col:24273
VTD_EXTENDED_CAPABILITY_EXTENDED_INTERRUPT_MODE_FLAG =         0x10 //col:24274
VTD_EXTENDED_CAPABILITY_EXTENDED_INTERRUPT_MODE_MASK =         0x01 //col:24275
VTD_EXTENDED_CAPABILITY_EXTENDED_INTERRUPT_MODE(_) =           (((_) >> 4) & 0x01) //col:24276
VTD_EXTENDED_CAPABILITY_DEPRECATED1_BIT =                      5 //col:24284
VTD_EXTENDED_CAPABILITY_DEPRECATED1_FLAG =                     0x20 //col:24285
VTD_EXTENDED_CAPABILITY_DEPRECATED1_MASK =                     0x01 //col:24286
VTD_EXTENDED_CAPABILITY_DEPRECATED1(_) =                       (((_) >> 5) & 0x01) //col:24287
VTD_EXTENDED_CAPABILITY_PASS_THROUGH_BIT =                     6 //col:24297
VTD_EXTENDED_CAPABILITY_PASS_THROUGH_FLAG =                    0x40 //col:24298
VTD_EXTENDED_CAPABILITY_PASS_THROUGH_MASK =                    0x01 //col:24299
VTD_EXTENDED_CAPABILITY_PASS_THROUGH(_) =                      (((_) >> 6) & 0x01) //col:24300
VTD_EXTENDED_CAPABILITY_SNOOP_CONTROL_BIT =                    7 //col:24312
VTD_EXTENDED_CAPABILITY_SNOOP_CONTROL_FLAG =                   0x80 //col:24313
VTD_EXTENDED_CAPABILITY_SNOOP_CONTROL_MASK =                   0x01 //col:24314
VTD_EXTENDED_CAPABILITY_SNOOP_CONTROL(_) =                     (((_) >> 7) & 0x01) //col:24315
VTD_EXTENDED_CAPABILITY_IOTLB_REGISTER_OFFSET_BIT =            8 //col:24326
VTD_EXTENDED_CAPABILITY_IOTLB_REGISTER_OFFSET_FLAG =           0x3FF00 //col:24327
VTD_EXTENDED_CAPABILITY_IOTLB_REGISTER_OFFSET_MASK =           0x3FF //col:24328
VTD_EXTENDED_CAPABILITY_IOTLB_REGISTER_OFFSET(_) =             (((_) >> 8) & 0x3FF) //col:24329
VTD_EXTENDED_CAPABILITY_MAXIMUM_HANDLE_MASK_VALUE_BIT =        20 //col:24340
VTD_EXTENDED_CAPABILITY_MAXIMUM_HANDLE_MASK_VALUE_FLAG =       0xF00000 //col:24341
VTD_EXTENDED_CAPABILITY_MAXIMUM_HANDLE_MASK_VALUE_MASK =       0x0F //col:24342
VTD_EXTENDED_CAPABILITY_MAXIMUM_HANDLE_MASK_VALUE(_) =         (((_) >> 20) & 0x0F) //col:24343
VTD_EXTENDED_CAPABILITY_DEPRECATED2_BIT =                      24 //col:24353
VTD_EXTENDED_CAPABILITY_DEPRECATED2_FLAG =                     0x1000000 //col:24354
VTD_EXTENDED_CAPABILITY_DEPRECATED2_MASK =                     0x01 //col:24355
VTD_EXTENDED_CAPABILITY_DEPRECATED2(_) =                       (((_) >> 24) & 0x01) //col:24356
VTD_EXTENDED_CAPABILITY_MEMORY_TYPE_SUPPORT_BIT =              25 //col:24370
VTD_EXTENDED_CAPABILITY_MEMORY_TYPE_SUPPORT_FLAG =             0x2000000 //col:24371
VTD_EXTENDED_CAPABILITY_MEMORY_TYPE_SUPPORT_MASK =             0x01 //col:24372
VTD_EXTENDED_CAPABILITY_MEMORY_TYPE_SUPPORT(_) =               (((_) >> 25) & 0x01) //col:24373
VTD_EXTENDED_CAPABILITY_NESTED_TRANSLATION_SUPPORT_BIT =       26 //col:24385
VTD_EXTENDED_CAPABILITY_NESTED_TRANSLATION_SUPPORT_FLAG =      0x4000000 //col:24386
VTD_EXTENDED_CAPABILITY_NESTED_TRANSLATION_SUPPORT_MASK =      0x01 //col:24387
VTD_EXTENDED_CAPABILITY_NESTED_TRANSLATION_SUPPORT(_) =        (((_) >> 26) & 0x01) //col:24388
VTD_EXTENDED_CAPABILITY_DEPRECATED3_BIT =                      28 //col:24397
VTD_EXTENDED_CAPABILITY_DEPRECATED3_FLAG =                     0x10000000 //col:24398
VTD_EXTENDED_CAPABILITY_DEPRECATED3_MASK =                     0x01 //col:24399
VTD_EXTENDED_CAPABILITY_DEPRECATED3(_) =                       (((_) >> 28) & 0x01) //col:24400
VTD_EXTENDED_CAPABILITY_PAGE_REQUEST_SUPPORT_BIT =             29 //col:24412
VTD_EXTENDED_CAPABILITY_PAGE_REQUEST_SUPPORT_FLAG =            0x20000000 //col:24413
VTD_EXTENDED_CAPABILITY_PAGE_REQUEST_SUPPORT_MASK =            0x01 //col:24414
VTD_EXTENDED_CAPABILITY_PAGE_REQUEST_SUPPORT(_) =              (((_) >> 29) & 0x01) //col:24415
VTD_EXTENDED_CAPABILITY_EXECUTE_REQUEST_SUPPORT_BIT =          30 //col:24427
VTD_EXTENDED_CAPABILITY_EXECUTE_REQUEST_SUPPORT_FLAG =         0x40000000 //col:24428
VTD_EXTENDED_CAPABILITY_EXECUTE_REQUEST_SUPPORT_MASK =         0x01 //col:24429
VTD_EXTENDED_CAPABILITY_EXECUTE_REQUEST_SUPPORT(_) =           (((_) >> 30) & 0x01) //col:24430
VTD_EXTENDED_CAPABILITY_NO_WRITE_FLAG_SUPPORT_BIT =            33 //col:24442
VTD_EXTENDED_CAPABILITY_NO_WRITE_FLAG_SUPPORT_FLAG =           0x200000000 //col:24443
VTD_EXTENDED_CAPABILITY_NO_WRITE_FLAG_SUPPORT_MASK =           0x01 //col:24444
VTD_EXTENDED_CAPABILITY_NO_WRITE_FLAG_SUPPORT(_) =             (((_) >> 33) & 0x01) //col:24445
VTD_EXTENDED_CAPABILITY_EXTENDED_ACCESSED_FLAG_SUPPORT_BIT =   34 //col:24457
VTD_EXTENDED_CAPABILITY_EXTENDED_ACCESSED_FLAG_SUPPORT_FLAG =  0x400000000 //col:24458
VTD_EXTENDED_CAPABILITY_EXTENDED_ACCESSED_FLAG_SUPPORT_MASK =  0x01 //col:24459
VTD_EXTENDED_CAPABILITY_EXTENDED_ACCESSED_FLAG_SUPPORT(_) =    (((_) >> 34) & 0x01) //col:24460
VTD_EXTENDED_CAPABILITY_PASID_SIZE_SUPPORTED_BIT =             35 //col:24472
VTD_EXTENDED_CAPABILITY_PASID_SIZE_SUPPORTED_FLAG =            0xF800000000 //col:24473
VTD_EXTENDED_CAPABILITY_PASID_SIZE_SUPPORTED_MASK =            0x1F //col:24474
VTD_EXTENDED_CAPABILITY_PASID_SIZE_SUPPORTED(_) =              (((_) >> 35) & 0x1F) //col:24475
VTD_EXTENDED_CAPABILITY_PROCESS_ADDRESS_SPACE_ID_SUPPORT_BIT = 40 //col:24487
VTD_EXTENDED_CAPABILITY_PROCESS_ADDRESS_SPACE_ID_SUPPORT_FLAG = 0x10000000000 //col:24488
VTD_EXTENDED_CAPABILITY_PROCESS_ADDRESS_SPACE_ID_SUPPORT_MASK = 0x01 //col:24489
VTD_EXTENDED_CAPABILITY_PROCESS_ADDRESS_SPACE_ID_SUPPORT(_) =  (((_) >> 40) & 0x01) //col:24490
VTD_EXTENDED_CAPABILITY_DEVICE_TLB_INVALIDATION_THROTTLE_BIT = 41 //col:24501
VTD_EXTENDED_CAPABILITY_DEVICE_TLB_INVALIDATION_THROTTLE_FLAG = 0x20000000000 //col:24502
VTD_EXTENDED_CAPABILITY_DEVICE_TLB_INVALIDATION_THROTTLE_MASK = 0x01 //col:24503
VTD_EXTENDED_CAPABILITY_DEVICE_TLB_INVALIDATION_THROTTLE(_) =  (((_) >> 41) & 0x01) //col:24504
VTD_EXTENDED_CAPABILITY_PAGE_REQUEST_DRAIN_SUPPORT_BIT =       42 //col:24515
VTD_EXTENDED_CAPABILITY_PAGE_REQUEST_DRAIN_SUPPORT_FLAG =      0x40000000000 //col:24516
VTD_EXTENDED_CAPABILITY_PAGE_REQUEST_DRAIN_SUPPORT_MASK =      0x01 //col:24517
VTD_EXTENDED_CAPABILITY_PAGE_REQUEST_DRAIN_SUPPORT(_) =        (((_) >> 42) & 0x01) //col:24518
VTD_EXTENDED_CAPABILITY_SCALABLE_MODE_TRANSLATION_SUPPORT_BIT = 43 //col:24531
VTD_EXTENDED_CAPABILITY_SCALABLE_MODE_TRANSLATION_SUPPORT_FLAG = 0x80000000000 //col:24532
VTD_EXTENDED_CAPABILITY_SCALABLE_MODE_TRANSLATION_SUPPORT_MASK = 0x01 //col:24533
VTD_EXTENDED_CAPABILITY_SCALABLE_MODE_TRANSLATION_SUPPORT(_) = (((_) >> 43) & 0x01) //col:24534
VTD_EXTENDED_CAPABILITY_VIRTUAL_COMMAND_SUPPORT_BIT =          44 //col:24547
VTD_EXTENDED_CAPABILITY_VIRTUAL_COMMAND_SUPPORT_FLAG =         0x100000000000 //col:24548
VTD_EXTENDED_CAPABILITY_VIRTUAL_COMMAND_SUPPORT_MASK =         0x01 //col:24549
VTD_EXTENDED_CAPABILITY_VIRTUAL_COMMAND_SUPPORT(_) =           (((_) >> 44) & 0x01) //col:24550
VTD_EXTENDED_CAPABILITY_SECOND_LEVEL_ACCESSED_DIRTY_SUPPORT_BIT = 45 //col:24562
VTD_EXTENDED_CAPABILITY_SECOND_LEVEL_ACCESSED_DIRTY_SUPPORT_FLAG = 0x200000000000 //col:24563
VTD_EXTENDED_CAPABILITY_SECOND_LEVEL_ACCESSED_DIRTY_SUPPORT_MASK = 0x01 //col:24564
VTD_EXTENDED_CAPABILITY_SECOND_LEVEL_ACCESSED_DIRTY_SUPPORT(_) = (((_) >> 45) & 0x01) //col:24565
VTD_EXTENDED_CAPABILITY_SECOND_LEVEL_TRANSLATION_SUPPORT_BIT = 46 //col:24576
VTD_EXTENDED_CAPABILITY_SECOND_LEVEL_TRANSLATION_SUPPORT_FLAG = 0x400000000000 //col:24577
VTD_EXTENDED_CAPABILITY_SECOND_LEVEL_TRANSLATION_SUPPORT_MASK = 0x01 //col:24578
VTD_EXTENDED_CAPABILITY_SECOND_LEVEL_TRANSLATION_SUPPORT(_) =  (((_) >> 46) & 0x01) //col:24579
VTD_EXTENDED_CAPABILITY_FIRST_LEVEL_TRANSLATION_SUPPORT_BIT =  47 //col:24591
VTD_EXTENDED_CAPABILITY_FIRST_LEVEL_TRANSLATION_SUPPORT_FLAG = 0x800000000000 //col:24592
VTD_EXTENDED_CAPABILITY_FIRST_LEVEL_TRANSLATION_SUPPORT_MASK = 0x01 //col:24593
VTD_EXTENDED_CAPABILITY_FIRST_LEVEL_TRANSLATION_SUPPORT(_) =   (((_) >> 47) & 0x01) //col:24594
VTD_EXTENDED_CAPABILITY_SCALABLE_MODE_PAGE_WALK_COHERENCY_BIT = 48 //col:24607
VTD_EXTENDED_CAPABILITY_SCALABLE_MODE_PAGE_WALK_COHERENCY_FLAG = 0x1000000000000 //col:24608
VTD_EXTENDED_CAPABILITY_SCALABLE_MODE_PAGE_WALK_COHERENCY_MASK = 0x01 //col:24609
VTD_EXTENDED_CAPABILITY_SCALABLE_MODE_PAGE_WALK_COHERENCY(_) = (((_) >> 48) & 0x01) //col:24610
VTD_EXTENDED_CAPABILITY_RID_PASID_SUPPORT_BIT =                49 //col:24621
VTD_EXTENDED_CAPABILITY_RID_PASID_SUPPORT_FLAG =               0x2000000000000 //col:24622
VTD_EXTENDED_CAPABILITY_RID_PASID_SUPPORT_MASK =               0x01 //col:24623
VTD_EXTENDED_CAPABILITY_RID_PASID_SUPPORT(_) =                 (((_) >> 49) & 0x01) //col:24624
VTD_EXTENDED_CAPABILITY_ABORT_DMA_MODE_SUPPORT_BIT =           52 //col:24635
VTD_EXTENDED_CAPABILITY_ABORT_DMA_MODE_SUPPORT_FLAG =          0x10000000000000 //col:24636
VTD_EXTENDED_CAPABILITY_ABORT_DMA_MODE_SUPPORT_MASK =          0x01 //col:24637
VTD_EXTENDED_CAPABILITY_ABORT_DMA_MODE_SUPPORT(_) =            (((_) >> 52) & 0x01) //col:24638
VTD_EXTENDED_CAPABILITY_RID_PRIV_SUPPORT_BIT =                 53 //col:24650
VTD_EXTENDED_CAPABILITY_RID_PRIV_SUPPORT_FLAG =                0x20000000000000 //col:24651
VTD_EXTENDED_CAPABILITY_RID_PRIV_SUPPORT_MASK =                0x01 //col:24652
VTD_EXTENDED_CAPABILITY_RID_PRIV_SUPPORT(_) =                  (((_) >> 53) & 0x01) //col:24653
VTD_GLOBAL_COMMAND =                                           0x00000018 //col:24674
VTD_GLOBAL_COMMAND_COMPATIBILITY_FORMAT_INTERRUPT_BIT =        23 //col:24694
VTD_GLOBAL_COMMAND_COMPATIBILITY_FORMAT_INTERRUPT_FLAG =       0x800000 //col:24695
VTD_GLOBAL_COMMAND_COMPATIBILITY_FORMAT_INTERRUPT_MASK =       0x01 //col:24696
VTD_GLOBAL_COMMAND_COMPATIBILITY_FORMAT_INTERRUPT(_) =         (((_) >> 23) & 0x01) //col:24697
VTD_GLOBAL_COMMAND_SET_INTERRUPT_REMAP_TABLE_POINTER_BIT =     24 //col:24712
VTD_GLOBAL_COMMAND_SET_INTERRUPT_REMAP_TABLE_POINTER_FLAG =    0x1000000 //col:24713
VTD_GLOBAL_COMMAND_SET_INTERRUPT_REMAP_TABLE_POINTER_MASK =    0x01 //col:24714
VTD_GLOBAL_COMMAND_SET_INTERRUPT_REMAP_TABLE_POINTER(_) =      (((_) >> 24) & 0x01) //col:24715
VTD_GLOBAL_COMMAND_INTERRUPT_REMAPPING_ENABLE_BIT =            25 //col:24736
VTD_GLOBAL_COMMAND_INTERRUPT_REMAPPING_ENABLE_FLAG =           0x2000000 //col:24737
VTD_GLOBAL_COMMAND_INTERRUPT_REMAPPING_ENABLE_MASK =           0x01 //col:24738
VTD_GLOBAL_COMMAND_INTERRUPT_REMAPPING_ENABLE(_) =             (((_) >> 25) & 0x01) //col:24739
VTD_GLOBAL_COMMAND_QUEUED_INVALIDATION_ENABLE_BIT =            26 //col:24752
VTD_GLOBAL_COMMAND_QUEUED_INVALIDATION_ENABLE_FLAG =           0x4000000 //col:24753
VTD_GLOBAL_COMMAND_QUEUED_INVALIDATION_ENABLE_MASK =           0x01 //col:24754
VTD_GLOBAL_COMMAND_QUEUED_INVALIDATION_ENABLE(_) =             (((_) >> 26) & 0x01) //col:24755
VTD_GLOBAL_COMMAND_WRITE_BUFFER_FLUSH_BIT =                    27 //col:24767
VTD_GLOBAL_COMMAND_WRITE_BUFFER_FLUSH_FLAG =                   0x8000000 //col:24768
VTD_GLOBAL_COMMAND_WRITE_BUFFER_FLUSH_MASK =                   0x01 //col:24769
VTD_GLOBAL_COMMAND_WRITE_BUFFER_FLUSH(_) =                     (((_) >> 27) & 0x01) //col:24770
VTD_GLOBAL_COMMAND_ENABLE_ADVANCED_FAULT_LOGGING_BIT =         28 //col:24785
VTD_GLOBAL_COMMAND_ENABLE_ADVANCED_FAULT_LOGGING_FLAG =        0x10000000 //col:24786
VTD_GLOBAL_COMMAND_ENABLE_ADVANCED_FAULT_LOGGING_MASK =        0x01 //col:24787
VTD_GLOBAL_COMMAND_ENABLE_ADVANCED_FAULT_LOGGING(_) =          (((_) >> 28) & 0x01) //col:24788
VTD_GLOBAL_COMMAND_SET_FAULT_LOG_BIT =                         29 //col:24802
VTD_GLOBAL_COMMAND_SET_FAULT_LOG_FLAG =                        0x20000000 //col:24803
VTD_GLOBAL_COMMAND_SET_FAULT_LOG_MASK =                        0x01 //col:24804
VTD_GLOBAL_COMMAND_SET_FAULT_LOG(_) =                          (((_) >> 29) & 0x01) //col:24805
VTD_GLOBAL_COMMAND_SET_ROOT_TABLE_POINTER_BIT =                30 //col:24819
VTD_GLOBAL_COMMAND_SET_ROOT_TABLE_POINTER_FLAG =               0x40000000 //col:24820
VTD_GLOBAL_COMMAND_SET_ROOT_TABLE_POINTER_MASK =               0x01 //col:24821
VTD_GLOBAL_COMMAND_SET_ROOT_TABLE_POINTER(_) =                 (((_) >> 30) & 0x01) //col:24822
VTD_GLOBAL_COMMAND_TRANSLATION_ENABLE_BIT =                    31 //col:24842
VTD_GLOBAL_COMMAND_TRANSLATION_ENABLE_FLAG =                   0x80000000 //col:24843
VTD_GLOBAL_COMMAND_TRANSLATION_ENABLE_MASK =                   0x01 //col:24844
VTD_GLOBAL_COMMAND_TRANSLATION_ENABLE(_) =                     (((_) >> 31) & 0x01) //col:24845
VTD_GLOBAL_STATUS =                                            0x0000001C //col:24858
VTD_GLOBAL_STATUS_COMPATIBILITY_FORMAT_INTERRUPT_STATUS_BIT =  23 //col:24875
VTD_GLOBAL_STATUS_COMPATIBILITY_FORMAT_INTERRUPT_STATUS_FLAG = 0x800000 //col:24876
VTD_GLOBAL_STATUS_COMPATIBILITY_FORMAT_INTERRUPT_STATUS_MASK = 0x01 //col:24877
VTD_GLOBAL_STATUS_COMPATIBILITY_FORMAT_INTERRUPT_STATUS(_) =   (((_) >> 23) & 0x01) //col:24878
VTD_GLOBAL_STATUS_INTERRUPT_REMAPPING_TABLE_POINTER_STATUS_BIT = 24 //col:24889
VTD_GLOBAL_STATUS_INTERRUPT_REMAPPING_TABLE_POINTER_STATUS_FLAG = 0x1000000 //col:24890
VTD_GLOBAL_STATUS_INTERRUPT_REMAPPING_TABLE_POINTER_STATUS_MASK = 0x01 //col:24891
VTD_GLOBAL_STATUS_INTERRUPT_REMAPPING_TABLE_POINTER_STATUS(_) = (((_) >> 24) & 0x01) //col:24892
VTD_GLOBAL_STATUS_INTERRUPT_REMAPPING_ENABLE_STATUS_BIT =      25 //col:24902
VTD_GLOBAL_STATUS_INTERRUPT_REMAPPING_ENABLE_STATUS_FLAG =     0x2000000 //col:24903
VTD_GLOBAL_STATUS_INTERRUPT_REMAPPING_ENABLE_STATUS_MASK =     0x01 //col:24904
VTD_GLOBAL_STATUS_INTERRUPT_REMAPPING_ENABLE_STATUS(_) =       (((_) >> 25) & 0x01) //col:24905
VTD_GLOBAL_STATUS_QUEUED_INVALIDATION_ENABLE_STATUS_BIT =      26 //col:24915
VTD_GLOBAL_STATUS_QUEUED_INVALIDATION_ENABLE_STATUS_FLAG =     0x4000000 //col:24916
VTD_GLOBAL_STATUS_QUEUED_INVALIDATION_ENABLE_STATUS_MASK =     0x01 //col:24917
VTD_GLOBAL_STATUS_QUEUED_INVALIDATION_ENABLE_STATUS(_) =       (((_) >> 26) & 0x01) //col:24918
VTD_GLOBAL_STATUS_WRITE_BUFFER_FLUSH_STATUS_BIT =              27 //col:24929
VTD_GLOBAL_STATUS_WRITE_BUFFER_FLUSH_STATUS_FLAG =             0x8000000 //col:24930
VTD_GLOBAL_STATUS_WRITE_BUFFER_FLUSH_STATUS_MASK =             0x01 //col:24931
VTD_GLOBAL_STATUS_WRITE_BUFFER_FLUSH_STATUS(_) =               (((_) >> 27) & 0x01) //col:24932
VTD_GLOBAL_STATUS_ADVANCED_FAULT_LOGGING_STATUS_BIT =          28 //col:24943
VTD_GLOBAL_STATUS_ADVANCED_FAULT_LOGGING_STATUS_FLAG =         0x10000000 //col:24944
VTD_GLOBAL_STATUS_ADVANCED_FAULT_LOGGING_STATUS_MASK =         0x01 //col:24945
VTD_GLOBAL_STATUS_ADVANCED_FAULT_LOGGING_STATUS(_) =           (((_) >> 28) & 0x01) //col:24946
VTD_GLOBAL_STATUS_FAULT_LOG_STATUS_BIT =                       29 //col:24957
VTD_GLOBAL_STATUS_FAULT_LOG_STATUS_FLAG =                      0x20000000 //col:24958
VTD_GLOBAL_STATUS_FAULT_LOG_STATUS_MASK =                      0x01 //col:24959
VTD_GLOBAL_STATUS_FAULT_LOG_STATUS(_) =                        (((_) >> 29) & 0x01) //col:24960
VTD_GLOBAL_STATUS_ROOT_TABLE_POINTER_STATUS_BIT =              30 //col:24971
VTD_GLOBAL_STATUS_ROOT_TABLE_POINTER_STATUS_FLAG =             0x40000000 //col:24972
VTD_GLOBAL_STATUS_ROOT_TABLE_POINTER_STATUS_MASK =             0x01 //col:24973
VTD_GLOBAL_STATUS_ROOT_TABLE_POINTER_STATUS(_) =               (((_) >> 30) & 0x01) //col:24974
VTD_GLOBAL_STATUS_TRANSLATION_ENABLE_STATUS_BIT =              31 //col:24984
VTD_GLOBAL_STATUS_TRANSLATION_ENABLE_STATUS_FLAG =             0x80000000 //col:24985
VTD_GLOBAL_STATUS_TRANSLATION_ENABLE_STATUS_MASK =             0x01 //col:24986
VTD_GLOBAL_STATUS_TRANSLATION_ENABLE_STATUS(_) =               (((_) >> 31) & 0x01) //col:24987
VTD_ROOT_TABLE_ADDRESS =                                       0x00000020 //col:25002
VTD_ROOT_TABLE_ADDRESS_TRANSLATION_TABLE_MODE_BIT =            10 //col:25023
VTD_ROOT_TABLE_ADDRESS_TRANSLATION_TABLE_MODE_FLAG =           0xC00 //col:25024
VTD_ROOT_TABLE_ADDRESS_TRANSLATION_TABLE_MODE_MASK =           0x03 //col:25025
VTD_ROOT_TABLE_ADDRESS_TRANSLATION_TABLE_MODE(_) =             (((_) >> 10) & 0x03) //col:25026
VTD_ROOT_TABLE_ADDRESS_ROOT_TABLE_ADDRESS_BIT =                12 //col:25036
VTD_ROOT_TABLE_ADDRESS_ROOT_TABLE_ADDRESS_FLAG =               0xFFFFFFFFFFFFF000 //col:25037
VTD_ROOT_TABLE_ADDRESS_ROOT_TABLE_ADDRESS_MASK =               0xFFFFFFFFFFFFF //col:25038
VTD_ROOT_TABLE_ADDRESS_ROOT_TABLE_ADDRESS(_) =                 (((_) >> 12) & 0xFFFFFFFFFFFFF) //col:25039
VTD_CONTEXT_COMMAND =                                          0x00000028 //col:25053
VTD_CONTEXT_COMMAND_DOMAIN_ID_BIT =                            0 //col:25068
VTD_CONTEXT_COMMAND_DOMAIN_ID_FLAG =                           0xFFFF //col:25069
VTD_CONTEXT_COMMAND_DOMAIN_ID_MASK =                           0xFFFF //col:25070
VTD_CONTEXT_COMMAND_DOMAIN_ID(_) =                             (((_) >> 0) & 0xFFFF) //col:25071
VTD_CONTEXT_COMMAND_SOURCE_ID_BIT =                            16 //col:25082
VTD_CONTEXT_COMMAND_SOURCE_ID_FLAG =                           0xFFFF0000 //col:25083
VTD_CONTEXT_COMMAND_SOURCE_ID_MASK =                           0xFFFF //col:25084
VTD_CONTEXT_COMMAND_SOURCE_ID(_) =                             (((_) >> 16) & 0xFFFF) //col:25085
VTD_CONTEXT_COMMAND_FUNCTION_MASK_BIT =                        32 //col:25103
VTD_CONTEXT_COMMAND_FUNCTION_MASK_FLAG =                       0x300000000 //col:25104
VTD_CONTEXT_COMMAND_FUNCTION_MASK_MASK =                       0x03 //col:25105
VTD_CONTEXT_COMMAND_FUNCTION_MASK(_) =                         (((_) >> 32) & 0x03) //col:25106
VTD_CONTEXT_COMMAND_CONTEXT_ACTUAL_INVALIDATION_GRANULARITY_BIT = 59 //col:25129
VTD_CONTEXT_COMMAND_CONTEXT_ACTUAL_INVALIDATION_GRANULARITY_FLAG = 0x1800000000000000 //col:25130
VTD_CONTEXT_COMMAND_CONTEXT_ACTUAL_INVALIDATION_GRANULARITY_MASK = 0x03 //col:25131
VTD_CONTEXT_COMMAND_CONTEXT_ACTUAL_INVALIDATION_GRANULARITY(_) = (((_) >> 59) & 0x03) //col:25132
VTD_CONTEXT_COMMAND_CONTEXT_INVALIDATION_REQUEST_GRANULARITY_BIT = 61 //col:25148
VTD_CONTEXT_COMMAND_CONTEXT_INVALIDATION_REQUEST_GRANULARITY_FLAG = 0x6000000000000000 //col:25149
VTD_CONTEXT_COMMAND_CONTEXT_INVALIDATION_REQUEST_GRANULARITY_MASK = 0x03 //col:25150
VTD_CONTEXT_COMMAND_CONTEXT_INVALIDATION_REQUEST_GRANULARITY(_) = (((_) >> 61) & 0x03) //col:25151
VTD_CONTEXT_COMMAND_INVALIDATE_CONTEXT_CACHE_BIT =             63 //col:25172
VTD_CONTEXT_COMMAND_INVALIDATE_CONTEXT_CACHE_FLAG =            0x8000000000000000 //col:25173
VTD_CONTEXT_COMMAND_INVALIDATE_CONTEXT_CACHE_MASK =            0x01 //col:25174
VTD_CONTEXT_COMMAND_INVALIDATE_CONTEXT_CACHE(_) =              (((_) >> 63) & 0x01) //col:25175
VTD_INVALIDATE_ADDRESS =                                       0x00000000 //col:25190
VTD_INVALIDATE_ADDRESS_ADDRESS_MASK_BIT =                      0 //col:25207
VTD_INVALIDATE_ADDRESS_ADDRESS_MASK_FLAG =                     0x3F //col:25208
VTD_INVALIDATE_ADDRESS_ADDRESS_MASK_MASK =                     0x3F //col:25209
VTD_INVALIDATE_ADDRESS_ADDRESS_MASK(_) =                       (((_) >> 0) & 0x3F) //col:25210
VTD_INVALIDATE_ADDRESS_INVALIDATION_HINT_BIT =                 6 //col:25227
VTD_INVALIDATE_ADDRESS_INVALIDATION_HINT_FLAG =                0x40 //col:25228
VTD_INVALIDATE_ADDRESS_INVALIDATION_HINT_MASK =                0x01 //col:25229
VTD_INVALIDATE_ADDRESS_INVALIDATION_HINT(_) =                  (((_) >> 6) & 0x01) //col:25230
VTD_INVALIDATE_ADDRESS_PAGE_ADDRESS_BIT =                      12 //col:25243
VTD_INVALIDATE_ADDRESS_PAGE_ADDRESS_FLAG =                     0xFFFFFFFFFFFFF000 //col:25244
VTD_INVALIDATE_ADDRESS_PAGE_ADDRESS_MASK =                     0xFFFFFFFFFFFFF //col:25245
VTD_INVALIDATE_ADDRESS_PAGE_ADDRESS(_) =                       (((_) >> 12) & 0xFFFFFFFFFFFFF) //col:25246
VTD_IOTLB_INVALIDATE =                                         0x00000008 //col:25260
VTD_IOTLB_INVALIDATE_DOMAIN_ID_BIT =                           32 //col:25277
VTD_IOTLB_INVALIDATE_DOMAIN_ID_FLAG =                          0xFFFF00000000 //col:25278
VTD_IOTLB_INVALIDATE_DOMAIN_ID_MASK =                          0xFFFF //col:25279
VTD_IOTLB_INVALIDATE_DOMAIN_ID(_) =                            (((_) >> 32) & 0xFFFF) //col:25280
VTD_IOTLB_INVALIDATE_DRAIN_WRITES_BIT =                        48 //col:25291
VTD_IOTLB_INVALIDATE_DRAIN_WRITES_FLAG =                       0x1000000000000 //col:25292
VTD_IOTLB_INVALIDATE_DRAIN_WRITES_MASK =                       0x01 //col:25293
VTD_IOTLB_INVALIDATE_DRAIN_WRITES(_) =                         (((_) >> 48) & 0x01) //col:25294
VTD_IOTLB_INVALIDATE_DRAIN_READS_BIT =                         49 //col:25305
VTD_IOTLB_INVALIDATE_DRAIN_READS_FLAG =                        0x2000000000000 //col:25306
VTD_IOTLB_INVALIDATE_DRAIN_READS_MASK =                        0x01 //col:25307
VTD_IOTLB_INVALIDATE_DRAIN_READS(_) =                          (((_) >> 49) & 0x01) //col:25308
VTD_IOTLB_INVALIDATE_IOTLB_ACTUAL_INVALIDATION_GRANULARITY_BIT = 57 //col:25333
VTD_IOTLB_INVALIDATE_IOTLB_ACTUAL_INVALIDATION_GRANULARITY_FLAG = 0x600000000000000 //col:25334
VTD_IOTLB_INVALIDATE_IOTLB_ACTUAL_INVALIDATION_GRANULARITY_MASK = 0x03 //col:25335
VTD_IOTLB_INVALIDATE_IOTLB_ACTUAL_INVALIDATION_GRANULARITY(_) = (((_) >> 57) & 0x03) //col:25336
VTD_IOTLB_INVALIDATE_IOTLB_INVALIDATION_REQUEST_GRANULARITY_BIT = 60 //col:25354
VTD_IOTLB_INVALIDATE_IOTLB_INVALIDATION_REQUEST_GRANULARITY_FLAG = 0x3000000000000000 //col:25355
VTD_IOTLB_INVALIDATE_IOTLB_INVALIDATION_REQUEST_GRANULARITY_MASK = 0x03 //col:25356
VTD_IOTLB_INVALIDATE_IOTLB_INVALIDATION_REQUEST_GRANULARITY(_) = (((_) >> 60) & 0x03) //col:25357
VTD_IOTLB_INVALIDATE_INVALIDATE_IOTLB_BIT =                    63 //col:25378
VTD_IOTLB_INVALIDATE_INVALIDATE_IOTLB_FLAG =                   0x8000000000000000 //col:25379
VTD_IOTLB_INVALIDATE_INVALIDATE_IOTLB_MASK =                   0x01 //col:25380
VTD_IOTLB_INVALIDATE_INVALIDATE_IOTLB(_) =                     (((_) >> 63) & 0x01) //col:25381
XCR0_X87_BIT =                                                 0 //col:25399
XCR0_X87_FLAG =                                                0x01 //col:25400
XCR0_X87_MASK =                                                0x01 //col:25401
XCR0_X87(_) =                                                  (((_) >> 0) & 0x01) //col:25402
XCR0_SSE_BIT =                                                 1 //col:25409
XCR0_SSE_FLAG =                                                0x02 //col:25410
XCR0_SSE_MASK =                                                0x01 //col:25411
XCR0_SSE(_) =                                                  (((_) >> 1) & 0x01) //col:25412
XCR0_AVX_BIT =                                                 2 //col:25419
XCR0_AVX_FLAG =                                                0x04 //col:25420
XCR0_AVX_MASK =                                                0x01 //col:25421
XCR0_AVX(_) =                                                  (((_) >> 2) & 0x01) //col:25422
XCR0_BNDREG_BIT =                                              3 //col:25429
XCR0_BNDREG_FLAG =                                             0x08 //col:25430
XCR0_BNDREG_MASK =                                             0x01 //col:25431
XCR0_BNDREG(_) =                                               (((_) >> 3) & 0x01) //col:25432
XCR0_BNDCSR_BIT =                                              4 //col:25439
XCR0_BNDCSR_FLAG =                                             0x10 //col:25440
XCR0_BNDCSR_MASK =                                             0x01 //col:25441
XCR0_BNDCSR(_) =                                               (((_) >> 4) & 0x01) //col:25442
XCR0_OPMASK_BIT =                                              5 //col:25449
XCR0_OPMASK_FLAG =                                             0x20 //col:25450
XCR0_OPMASK_MASK =                                             0x01 //col:25451
XCR0_OPMASK(_) =                                               (((_) >> 5) & 0x01) //col:25452
XCR0_ZMM_HI256_BIT =                                           6 //col:25459
XCR0_ZMM_HI256_FLAG =                                          0x40 //col:25460
XCR0_ZMM_HI256_MASK =                                          0x01 //col:25461
XCR0_ZMM_HI256(_) =                                            (((_) >> 6) & 0x01) //col:25462
XCR0_ZMM_HI16_BIT =                                            7 //col:25469
XCR0_ZMM_HI16_FLAG =                                           0x80 //col:25470
XCR0_ZMM_HI16_MASK =                                           0x01 //col:25471
XCR0_ZMM_HI16(_) =                                             (((_) >> 7) & 0x01) //col:25472
XCR0_PKRU_BIT =                                                9 //col:25479
XCR0_PKRU_FLAG =                                               0x200 //col:25480
XCR0_PKRU_MASK =                                               0x01 //col:25481
XCR0_PKRU(_) =                                                 (((_) >> 9) & 0x01) //col:25482
)

type typedef enum uint32
const(
typedef enum  = 1  //col:16410
  /**  = 2  //col:16412
   * If the INVPCID type is 0 the logical processor invalidates mappings-except global translations-associated with the PCID  = 3  //col:16413
   * specified in the INVPCID descriptor and that would be used to translate the linear address specified in the INVPCID  = 4  //col:16414
   * descriptor.2 (The instruction may also invalidate global translations as well as mappings associated with other PCIDs  = 5  //col:16415
   * and for other linear addresses.)  = 6  //col:16416
   */  = 7  //col:16417
  InvpcidIndividualAddress                                       =  0x00000000  //col:16418
  /**  = 9  //col:16420
   * If the INVPCID type is 1 the logical processor invalidates all mappings-except global translations-associated with the  = 10  //col:16421
   * PCID specified in the INVPCID descriptor. (The instruction may also invalidate global translations as well as mappings  = 11  //col:16422
   * associated with other PCIDs.)  = 12  //col:16423
   */  = 13  //col:16424
  InvpcidSingleContext                                           =  0x00000001  //col:16425
  /**  = 15  //col:16427
   * If the INVPCID type is 2 the logical processor invalidates mappings-including global translations-associated with all  = 16  //col:16428
   * PCIDs.  = 17  //col:16429
   */  = 18  //col:16430
  InvpcidAllContextWithGlobals                                   =  0x00000002  //col:16431
  /**  = 20  //col:16433
   * If the INVPCID type is 3 the logical processor invalidates mappings-except global translations- associated with all  = 21  //col:16434
   * PCIDs. (The instruction may also invalidate global translations.)  = 22  //col:16435
   */  = 23  //col:16436
  InvpcidAllContext                                              =  0x00000003  //col:16437
)


type typedef enum uint32
const(
typedef enum  = 1  //col:19663
  /**  = 2  //col:19665
   * The logical processor is executing instructions normally.  = 3  //col:19666
   */  = 4  //col:19667
  VmxActive                                                      =  0x00000000  //col:19668
  /**  = 6  //col:19670
   * The logical processor is inactive because it executed the HLT instruction.  = 7  //col:19671
   */  = 8  //col:19672
  VmxHlt                                                         =  0x00000001  //col:19673
  /**  = 10  //col:19675
   * The logical processor is inactive because it incurred a triple fault1 or some other serious error.  = 11  //col:19676
   */  = 12  //col:19677
  VmxShutdown                                                    =  0x00000002  //col:19678
  /**  = 14  //col:19680
   * The logical processor is inactive because it is waiting for a startup-IPI (SIPI).  = 15  //col:19681
   */  = 16  //col:19682
  VmxWaitForSipi                                                 =  0x00000003  //col:19683
)


type typedef enum uint32
const(
typedef enum  = 1  //col:20830
  /**  = 2  //col:20832
   * If the INVEPT type is 1 the logical processor invalidates all guest-physical mappings and combined mappings associated  = 3  //col:20833
   * with the EP4TA specified in the INVEPT descriptor. Combined mappings for that EP4TA are invalidated for all VPIDs and  = 4  //col:20834
   * all PCIDs. (The instruction may invalidate mappings associated with other EP4TAs.)  = 5  //col:20835
   */  = 6  //col:20836
  InveptSingleContext                                            =  0x00000001  //col:20837
  /**  = 8  //col:20839
   * If the INVEPT type is 2 the logical processor invalidates guest-physical mappings and combined mappings associated with  = 9  //col:20840
   * all EP4TAs (and for combined mappings for all VPIDs and PCIDs).  = 10  //col:20841
   */  = 11  //col:20842
  InveptAllContext                                               =  0x00000002  //col:20843
)


type typedef enum uint32
const(
typedef enum  = 1  //col:20846
  /**  = 2  //col:20848
   * If the INVVPID type is 0 the logical processor invalidates linear mappings and combined mappings associated with the  = 3  //col:20849
   * VPID specified in the INVVPID descriptor and that would be used to translate the linear address specified in of the  = 4  //col:20850
   * INVVPID descriptor. Linear mappings and combined mappings for that VPID and linear address are invalidated for all PCIDs  = 5  //col:20851
   * and for combined mappings all EP4TAs. (The instruction may also invalidate mappings associated with other VPIDs and  = 6  //col:20852
   * for other linear addresses).  = 7  //col:20853
   */  = 8  //col:20854
  InvvpidIndividualAddress                                       =  0x00000000  //col:20855
  /**  = 10  //col:20857
   * If the INVVPID type is 1 the logical processor invalidates all linear mappings and combined mappings associated with  = 11  //col:20858
   * the VPID specified in the INVVPID descriptor. Linear mappings and combined mappings for that VPID are invalidated for  = 12  //col:20859
   * all PCIDs and for combined mappings all EP4TAs. (The instruction may also invalidate mappings associated with other  = 13  //col:20860
   * VPIDs).  = 14  //col:20861
   */  = 15  //col:20862
  InvvpidSingleContext                                           =  0x00000001  //col:20863
  /**  = 17  //col:20865
   * If the INVVPID type is 2 the logical processor invalidates linear mappings and combined mappings associated with all  = 18  //col:20866
   * VPIDs except VPID 0000H and with all PCIDs. (The instruction may also invalidate linear mappings with VPID 0000H.)  = 19  //col:20867
   * Combined mappings are invalidated for all EP4TAs.  = 20  //col:20868
   */  = 21  //col:20869
  InvvpidAllContext                                              =  0x00000002  //col:20870
  /**  = 23  //col:20872
   * If the INVVPID type is 3 the logical processor invalidates linear mappings and combined mappings associated with the  = 24  //col:20873
   * VPID specified in the INVVPID descriptor. Linear mappings and combined mappings for that VPID are invalidated for all  = 25  //col:20874
   * PCIDs and for combined mappings all EP4TAs. The logical processor is not required to invalidate information that was  = 26  //col:20875
   * used for global translations (although it may do so). (The instruction may also invalidate mappings associated with  = 27  //col:20876
   * other VPIDs).  = 28  //col:20877
   *  = 29  //col:20878
   * @see Vol3C[4.10(Caching Translation Information)]  = 30  //col:20879
   */  = 31  //col:20880
  InvvpidSingleContextRetainingGlobals                           =  0x00000003  //col:20881
)


type typedef enum uint32
const(
typedef enum  = 1  //col:22228
  /**  = 2  //col:22230
   * External interrupt.  = 3  //col:22231
   */  = 4  //col:22232
  ExternalInterrupt                                              =  0x00000000  //col:22233
  /**  = 6  //col:22235
   * Non-maskable interrupt (NMI).  = 7  //col:22236
   */  = 8  //col:22237
  NonMaskableInterrupt                                           =  0x00000002  //col:22238
  /**  = 10  //col:22240
   * Hardware exception (e.g. \#PF).  = 11  //col:22241
   */  = 12  //col:22242
  HardwareException                                              =  0x00000003  //col:22243
  /**  = 14  //col:22245
   * Software interrupt (INT n).  = 15  //col:22246
   */  = 16  //col:22247
  SoftwareInterrupt                                              =  0x00000004  //col:22248
  /**  = 18  //col:22250
   * Privileged software exception (INT1).  = 19  //col:22251
   */  = 20  //col:22252
  PrivilegedSoftwareException                                    =  0x00000005  //col:22253
  /**  = 22  //col:22255
   * Software exception (INT3 or INTO).  = 23  //col:22256
   */  = 24  //col:22257
  SoftwareException                                              =  0x00000006  //col:22258
  /**  = 26  //col:22260
   * Other event. This type is used for injection of events that are not delivered through the IDT.  = 27  //col:22261
   */  = 28  //col:22262
  OtherEvent                                                     =  0x00000007  //col:22263
)


type typedef enum uint32
const(
typedef enum  = 1  //col:23158
  /**  = 2  //col:23160
   * #DE - Divide Error.  = 3  //col:23161
   * Source: DIV and IDIV instructions.  = 4  //col:23162
   * Error Code: No.  = 5  //col:23163
   */  = 6  //col:23164
  DivideError                                                    =  0x00000000  //col:23165
  /**  = 8  //col:23167
   * #DB - Debug.  = 9  //col:23168
   * Source: Any code or data reference.  = 10  //col:23169
   * Error Code: No.  = 11  //col:23170
   */  = 12  //col:23171
  Debug                                                          =  0x00000001  //col:23172
  /**  = 14  //col:23174
   * Nonmaskable Interrupt.  = 15  //col:23175
   * Source: Generated externally by asserting the processor's NMI pin or  = 16  //col:23176
   *         through an NMI request set by the I/O APIC to the local APIC.  = 17  //col:23177
   * Error Code: No.  = 18  //col:23178
   */  = 19  //col:23179
  Nmi                                                            =  0x00000002  //col:23180
  /**  = 21  //col:23182
   * #BP - Breakpoint.  = 22  //col:23183
   * Source: INT3 instruction.  = 23  //col:23184
   * Error Code: No.  = 24  //col:23185
   */  = 25  //col:23186
  Breakpoint                                                     =  0x00000003  //col:23187
  /**  = 27  //col:23189
   * #OF - Overflow.  = 28  //col:23190
   * Source: INTO instruction.  = 29  //col:23191
   * Error Code: No.  = 30  //col:23192
   */  = 31  //col:23193
  Overflow                                                       =  0x00000004  //col:23194
  /**  = 33  //col:23196
   * #BR - BOUND Range Exceeded.  = 34  //col:23197
   * Source: BOUND instruction.  = 35  //col:23198
   * Error Code: No.  = 36  //col:23199
   */  = 37  //col:23200
  BoundRangeExceeded                                             =  0x00000005  //col:23201
  /**  = 39  //col:23203
   * #UD - Invalid Opcode (Undefined Opcode).  = 40  //col:23204
   * Source: UD instruction or reserved opcode.  = 41  //col:23205
   * Error Code: No.  = 42  //col:23206
   */  = 43  //col:23207
  InvalidOpcode                                                  =  0x00000006  //col:23208
  /**  = 45  //col:23210
   * #NM - Device Not Available (No Math Coprocessor).  = 46  //col:23211
   * Source: Floating-point or WAIT/FWAIT instruction.  = 47  //col:23212
   * Error Code: No.  = 48  //col:23213
   */  = 49  //col:23214
  DeviceNotAvailable                                             =  0x00000007  //col:23215
  /**  = 51  //col:23217
   * #DF - Double Fault.  = 52  //col:23218
   * Source: Any instruction that can generate an exception an NMI or an INTR.  = 53  //col:23219
   * Error Code: Yes (zero).  = 54  //col:23220
   */  = 55  //col:23221
  DoubleFault                                                    =  0x00000008  //col:23222
  /**  = 57  //col:23224
   * #\## - Coprocessor Segment Overrun (reserved).  = 58  //col:23225
   * Source: Floating-point instruction.  = 59  //col:23226
   * Error Code: No.  = 60  //col:23227
   *  = 61  //col:23228
   * @note Processors after the Intel386 processor do not generate this exception.  = 62  //col:23229
   */  = 63  //col:23230
  CoprocessorSegmentOverrun                                      =  0x00000009  //col:23231
  /**  = 65  //col:23233
   * #TS - Invalid TSS.  = 66  //col:23234
   * Source: Task switch or TSS access.  = 67  //col:23235
   * Error Code: Yes.  = 68  //col:23236
   */  = 69  //col:23237
  InvalidTss                                                     =  0x0000000A  //col:23238
  /**  = 71  //col:23240
   * #NP - Segment Not Present.  = 72  //col:23241
   * Source: Loading segment registers or accessing system segments.  = 73  //col:23242
   * Error Code: Yes.  = 74  //col:23243
   */  = 75  //col:23244
  SegmentNotPresent                                              =  0x0000000B  //col:23245
  /**  = 77  //col:23247
   * #SS - Stack Segment Fault.  = 78  //col:23248
   * Source: Stack operations and SS register loads.  = 79  //col:23249
   * Error Code: Yes.  = 80  //col:23250
   */  = 81  //col:23251
  StackSegmentFault                                              =  0x0000000C  //col:23252
  /**  = 83  //col:23254
   * #GP - General Protection.  = 84  //col:23255
   * Source: Any memory reference and other protection checks.  = 85  //col:23256
   * Error Code: Yes.  = 86  //col:23257
   */  = 87  //col:23258
  GeneralProtection                                              =  0x0000000D  //col:23259
  /**  = 89  //col:23261
   * #PF - Page Fault.  = 90  //col:23262
   * Source: Any memory reference.  = 91  //col:23263
   * Error Code: Yes.  = 92  //col:23264
   */  = 93  //col:23265
  PageFault                                                      =  0x0000000E  //col:23266
  /**  = 95  //col:23268
   * #MF - Floating-Point Error (Math Fault).  = 96  //col:23269
   * Source: Floating-point or WAIT/FWAIT instruction.  = 97  //col:23270
   * Error Code: No.  = 98  //col:23271
   */  = 99  //col:23272
  X87FloatingPointError                                          =  0x00000010  //col:23273
  /**  = 101  //col:23275
   * #AC - Alignment Check.  = 102  //col:23276
   * Source: Any data reference in memory.  = 103  //col:23277
   * Error Code: Yes.  = 104  //col:23278
   */  = 105  //col:23279
  AlignmentCheck                                                 =  0x00000011  //col:23280
  /**  = 107  //col:23282
   * #MC - Machine Check.  = 108  //col:23283
   * Source: Model dependent machine check errors.  = 109  //col:23284
   * Error Code: No.  = 110  //col:23285
   */  = 111  //col:23286
  MachineCheck                                                   =  0x00000012  //col:23287
  /**  = 113  //col:23289
   * #XM - SIMD Floating-Point Numeric Error.  = 114  //col:23290
   * Source: SSE/SSE2/SSE3 floating-point instructions.  = 115  //col:23291
   * Error Code: No.  = 116  //col:23292
   */  = 117  //col:23293
  SimdFloatingPointError                                         =  0x00000013  //col:23294
  /**  = 119  //col:23296
   * #VE - Virtualization Exception.  = 120  //col:23297
   * Source: EPT violations.  = 121  //col:23298
   * Error Code: No.  = 122  //col:23299
   */  = 123  //col:23300
  VirtualizationException                                        =  0x00000014  //col:23301
  /**  = 125  //col:23303
   * #CP - Control Protection Exception.  = 126  //col:23304
   * Source: Control flow transfer attempt violated the control flow enforcement technology constraints.  = 127  //col:23305
   * Error Code: Yes.  = 128  //col:23306
   */  = 129  //col:23307
  ControlProtection                                              =  0x00000015  //col:23308
)



type  struct{
TypedefStruct typedef struct
* *
*MaximumInputValueForBasicCpuidInformation * Maximum Input Value for Basic CPUID Information.
MaxCpuidInputValue UINT32
* *
*Genu * "Genu"
EbxValueGenu UINT32
* *
*Ntel * "ntel"
EcxValueNtel UINT32
* *
*IneI * "ineI"
EdxValueInei UINT32
}


type  struct{
TypedefStruct typedef struct
Union union
Struct struct
SteppingId UINT32
#defineCpuidVersionInformationSteppingIdBit0 #define CPUID_VERSION_INFORMATION_STEPPING_ID_BIT                    0
#defineCpuidVersionInformationSteppingIdFlag0x0F #define CPUID_VERSION_INFORMATION_STEPPING_ID_FLAG                   0x0F
#defineCpuidVersionInformationSteppingIdMask0x0F #define CPUID_VERSION_INFORMATION_STEPPING_ID_MASK                   0x0F
#defineCpuidVersionInformationSteppingId()((()>>0)&0x0F) #define CPUID_VERSION_INFORMATION_STEPPING_ID(_)                     (((_) >> 0) & 0x0F)
Model UINT32
#defineCpuidVersionInformationModelBit4 #define CPUID_VERSION_INFORMATION_MODEL_BIT                          4
#defineCpuidVersionInformationModelFlag0xF0 #define CPUID_VERSION_INFORMATION_MODEL_FLAG                         0xF0
#defineCpuidVersionInformationModelMask0x0F #define CPUID_VERSION_INFORMATION_MODEL_MASK                         0x0F
#defineCpuidVersionInformationModel()((()>>4)&0x0F) #define CPUID_VERSION_INFORMATION_MODEL(_)                           (((_) >> 4) & 0x0F)
FamilyId UINT32
#defineCpuidVersionInformationFamilyIdBit8 #define CPUID_VERSION_INFORMATION_FAMILY_ID_BIT                      8
#defineCpuidVersionInformationFamilyIdFlag0xF00 #define CPUID_VERSION_INFORMATION_FAMILY_ID_FLAG                     0xF00
#defineCpuidVersionInformationFamilyIdMask0x0F #define CPUID_VERSION_INFORMATION_FAMILY_ID_MASK                     0x0F
#defineCpuidVersionInformationFamilyId()((()>>8)&0x0F) #define CPUID_VERSION_INFORMATION_FAMILY_ID(_)                       (((_) >> 8) & 0x0F)
*[Bits13:12]-0-OriginalOemProcessor * [Bits 13:12] - 0 - Original OEM Processor
*-1-IntelOverDrive(R)Processor * - 1 - Intel OverDrive(R) Processor
*-2-DualProcessor(NotApplicableToIntel486Processors) * - 2 - Dual processor (not applicable to Intel486 processors)
*-3-IntelReserved * - 3 - Intel reserved
ProcessorType UINT32
#defineCpuidVersionInformationProcessorTypeBit12 #define CPUID_VERSION_INFORMATION_PROCESSOR_TYPE_BIT                 12
#defineCpuidVersionInformationProcessorTypeFlag0x3000 #define CPUID_VERSION_INFORMATION_PROCESSOR_TYPE_FLAG                0x3000
#defineCpuidVersionInformationProcessorTypeMask0x03 #define CPUID_VERSION_INFORMATION_PROCESSOR_TYPE_MASK                0x03
#defineCpuidVersionInformationProcessorType()((()>>12)&0x03) #define CPUID_VERSION_INFORMATION_PROCESSOR_TYPE(_)                  (((_) >> 12) & 0x03)
Reserved1 UINT32
*[Bits19:16]TheExtendedModelIdNeedsToBeExaminedOnlyWhenTheFamilyIdIs06HOr0Fh * [Bits 19:16] The Extended Model ID needs to be examined only when the Family ID is 06H or 0FH.
ExtendedModelId UINT32
#defineCpuidVersionInformationExtendedModelIdBit16 #define CPUID_VERSION_INFORMATION_EXTENDED_MODEL_ID_BIT              16
#defineCpuidVersionInformationExtendedModelIdFlag0xF0000 #define CPUID_VERSION_INFORMATION_EXTENDED_MODEL_ID_FLAG             0xF0000
#defineCpuidVersionInformationExtendedModelIdMask0x0F #define CPUID_VERSION_INFORMATION_EXTENDED_MODEL_ID_MASK             0x0F
#defineCpuidVersionInformationExtendedModelId()((()>>16)&0x0F) #define CPUID_VERSION_INFORMATION_EXTENDED_MODEL_ID(_)               (((_) >> 16) & 0x0F)
*[Bits27:20]TheExtendedFamilyIdNeedsToBeExaminedOnlyWhenTheFamilyIdIs0Fh * [Bits 27:20] The Extended Family ID needs to be examined only when the Family ID is 0FH.
ExtendedFamilyId UINT32
#defineCpuidVersionInformationExtendedFamilyIdBit20 #define CPUID_VERSION_INFORMATION_EXTENDED_FAMILY_ID_BIT             20
#defineCpuidVersionInformationExtendedFamilyIdFlag0xFf00000 #define CPUID_VERSION_INFORMATION_EXTENDED_FAMILY_ID_FLAG            0xFF00000
#defineCpuidVersionInformationExtendedFamilyIdMask0xFf #define CPUID_VERSION_INFORMATION_EXTENDED_FAMILY_ID_MASK            0xFF
#defineCpuidVersionInformationExtendedFamilyId()((()>>20)&0xFf) #define CPUID_VERSION_INFORMATION_EXTENDED_FAMILY_ID(_)              (((_) >> 20) & 0xFF)
Reserved2 UINT32
}


type  struct{
TypedefStruct typedef struct
Union union
Struct struct
*[Bits4:0]-0=Null-NoMoreCaches * [Bits 4:0] - 0 = Null - No more caches.
*-1=DataCache * - 1 = Data Cache.
*-2=InstructionCache * - 2 = Instruction Cache.
*-3=UnifiedCache * - 3 = Unified Cache.
*-4-31=Reserved * - 4-31 = Reserved.
CacheTypeField UINT32
#defineCpuidEaxCacheTypeFieldBit0 #define CPUID_EAX_CACHE_TYPE_FIELD_BIT                               0
#defineCpuidEaxCacheTypeFieldFlag0x1F #define CPUID_EAX_CACHE_TYPE_FIELD_FLAG                              0x1F
#defineCpuidEaxCacheTypeFieldMask0x1F #define CPUID_EAX_CACHE_TYPE_FIELD_MASK                              0x1F
#defineCpuidEaxCacheTypeField()((()>>0)&0x1F) #define CPUID_EAX_CACHE_TYPE_FIELD(_)                                (((_) >> 0) & 0x1F)
*[Bits7:5]CacheLevel(StartsAt1) * [Bits 7:5] Cache Level (starts at 1).
CacheLevel UINT32
#defineCpuidEaxCacheLevelBit5 #define CPUID_EAX_CACHE_LEVEL_BIT                                    5
#defineCpuidEaxCacheLevelFlag0xE0 #define CPUID_EAX_CACHE_LEVEL_FLAG                                   0xE0
#defineCpuidEaxCacheLevelMask0x07 #define CPUID_EAX_CACHE_LEVEL_MASK                                   0x07
#defineCpuidEaxCacheLevel()((()>>5)&0x07) #define CPUID_EAX_CACHE_LEVEL(_)                                     (((_) >> 5) & 0x07)
*[Bit8]SelfInitializingCacheLevel(DoesNotNeedSwInitialization) * [Bit 8] Self Initializing cache level (does not need SW initialization).
SelfInitializingCacheLevel UINT32
#defineCpuidEaxSelfInitializingCacheLevelBit8 #define CPUID_EAX_SELF_INITIALIZING_CACHE_LEVEL_BIT                  8
#defineCpuidEaxSelfInitializingCacheLevelFlag0x100 #define CPUID_EAX_SELF_INITIALIZING_CACHE_LEVEL_FLAG                 0x100
#defineCpuidEaxSelfInitializingCacheLevelMask0x01 #define CPUID_EAX_SELF_INITIALIZING_CACHE_LEVEL_MASK                 0x01
#defineCpuidEaxSelfInitializingCacheLevel()((()>>8)&0x01) #define CPUID_EAX_SELF_INITIALIZING_CACHE_LEVEL(_)                   (((_) >> 8) & 0x01)
*[Bit9]FullyAssociativeCache * [Bit 9] Fully Associative cache.
FullyAssociativeCache UINT32
#defineCpuidEaxFullyAssociativeCacheBit9 #define CPUID_EAX_FULLY_ASSOCIATIVE_CACHE_BIT                        9
#defineCpuidEaxFullyAssociativeCacheFlag0x200 #define CPUID_EAX_FULLY_ASSOCIATIVE_CACHE_FLAG                       0x200
#defineCpuidEaxFullyAssociativeCacheMask0x01 #define CPUID_EAX_FULLY_ASSOCIATIVE_CACHE_MASK                       0x01
#defineCpuidEaxFullyAssociativeCache()((()>>9)&0x01) #define CPUID_EAX_FULLY_ASSOCIATIVE_CACHE(_)                         (((_) >> 9) & 0x01)
Reserved1 UINT32
*[Bits25:14]MaximumNumberOfAddressableIDsForLogicalProcessorsSharingThisCache * [Bits 25:14] Maximum number of addressable IDs for logical processors sharing this cache.
* *
*TheNearestPower-Of-2IntegerThatIsNotSmallerThan(1+Eax[25:14])IsTheNumberOfUniqueInitialApicIDs *       The nearest power-of-2 integer that is not smaller than (1 + EAX[25:14]) is the number of unique initial APIC IDs
*ReservedForAddressingDifferentLogicalProcessorsSharingThisCache *       reserved for addressing different logical processors sharing this cache.
MaxAddressableIdsForLogicalProcessorsSharingThisCache UINT32
#defineCpuidEaxMaxAddressableIdsForLogicalProcessorsSharingThisCacheBit14 #define CPUID_EAX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS_SHARING_THIS_CACHE_BIT 14
#defineCpuidEaxMaxAddressableIdsForLogicalProcessorsSharingThisCacheFlag0x3Ffc000 #define CPUID_EAX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS_SHARING_THIS_CACHE_FLAG 0x3FFC000
#defineCpuidEaxMaxAddressableIdsForLogicalProcessorsSharingThisCacheMask0xFff #define CPUID_EAX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS_SHARING_THIS_CACHE_MASK 0xFFF
#defineCpuidEaxMaxAddressableIdsForLogicalProcessorsSharingThisCache()((()>>14)&0xFff) #define CPUID_EAX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS_SHARING_THIS_CACHE(_) (((_) >> 14) & 0xFFF)
*[Bits31:26]MaximumNumberOfAddressableIDsForProcessorCoresInThePhysicalPackage * [Bits 31:26] Maximum number of addressable IDs for processor cores in the physical package.
* *
*TheNearestPower-Of-2IntegerThatIsNotSmallerThan(1+Eax[31:26])IsTheNumberOfUniqueCoreIDsReservedFor *       The nearest power-of-2 integer that is not smaller than (1 + EAX[31:26]) is the number of unique Core_IDs reserved for
*AddressingDifferentProcessorCoresInAPhysicalPackageCoreIdIsASubsetOfBitsOfTheInitialApicId *       addressing different processor cores in a physical package. Core ID is a subset of bits of the initial APIC ID.
*TheReturnedValueIsConstantForValidInitialValuesInEcxValidEcxValuesStartFrom0 *       The returned value is constant for valid initial values in ECX. Valid ECX values start from 0.
MaxAddressableIdsForProcessorCoresInPhysicalPackage UINT32
#defineCpuidEaxMaxAddressableIdsForProcessorCoresInPhysicalPackageBit26 #define CPUID_EAX_MAX_ADDRESSABLE_IDS_FOR_PROCESSOR_CORES_IN_PHYSICAL_PACKAGE_BIT 26
#defineCpuidEaxMaxAddressableIdsForProcessorCoresInPhysicalPackageFlag0xFc000000 #define CPUID_EAX_MAX_ADDRESSABLE_IDS_FOR_PROCESSOR_CORES_IN_PHYSICAL_PACKAGE_FLAG 0xFC000000
#defineCpuidEaxMaxAddressableIdsForProcessorCoresInPhysicalPackageMask0x3F #define CPUID_EAX_MAX_ADDRESSABLE_IDS_FOR_PROCESSOR_CORES_IN_PHYSICAL_PACKAGE_MASK 0x3F
#defineCpuidEaxMaxAddressableIdsForProcessorCoresInPhysicalPackage()((()>>26)&0x3F) #define CPUID_EAX_MAX_ADDRESSABLE_IDS_FOR_PROCESSOR_CORES_IN_PHYSICAL_PACKAGE(_) (((_) >> 26) & 0x3F)
}


type  struct{
TypedefStruct typedef struct
Union union
Struct struct
*[Bits15:0]SmallestMonitor-LineSizeInBytes(DefaultIsProcessor'SMonitorGranularity) * [Bits 15:0] Smallest monitor-line size in bytes (default is processor's monitor granularity).
SmallestMonitorLineSize UINT32
#defineCpuidEaxSmallestMonitorLineSizeBit0 #define CPUID_EAX_SMALLEST_MONITOR_LINE_SIZE_BIT                     0
#defineCpuidEaxSmallestMonitorLineSizeFlag0xFfff #define CPUID_EAX_SMALLEST_MONITOR_LINE_SIZE_FLAG                    0xFFFF
#defineCpuidEaxSmallestMonitorLineSizeMask0xFfff #define CPUID_EAX_SMALLEST_MONITOR_LINE_SIZE_MASK                    0xFFFF
#defineCpuidEaxSmallestMonitorLineSize()((()>>0)&0xFfff) #define CPUID_EAX_SMALLEST_MONITOR_LINE_SIZE(_)                      (((_) >> 0) & 0xFFFF)
Reserved1 UINT32
}


type  struct{
TypedefStruct typedef struct
Union union
Struct struct
*[Bit0]DigitalTemperatureSensorIsSupportedIfSet * [Bit 0] Digital temperature sensor is supported if set.
TemperatureSensorSupported UINT32
#defineCpuidEaxTemperatureSensorSupportedBit0 #define CPUID_EAX_TEMPERATURE_SENSOR_SUPPORTED_BIT                   0
#defineCpuidEaxTemperatureSensorSupportedFlag0x01 #define CPUID_EAX_TEMPERATURE_SENSOR_SUPPORTED_FLAG                  0x01
#defineCpuidEaxTemperatureSensorSupportedMask0x01 #define CPUID_EAX_TEMPERATURE_SENSOR_SUPPORTED_MASK                  0x01
#defineCpuidEaxTemperatureSensorSupported()((()>>0)&0x01) #define CPUID_EAX_TEMPERATURE_SENSOR_SUPPORTED(_)                    (((_) >> 0) & 0x01)
*[Bit1]IntelTurboBoostTechnologyAvailable(SeeDescriptionOfIa32MiscEnable[38]) * [Bit 1] Intel Turbo Boost Technology available (see description of IA32_MISC_ENABLE[38]).
IntelTurboBoostTechnologyAvailable UINT32
#defineCpuidEaxIntelTurboBoostTechnologyAvailableBit1 #define CPUID_EAX_INTEL_TURBO_BOOST_TECHNOLOGY_AVAILABLE_BIT         1
#defineCpuidEaxIntelTurboBoostTechnologyAvailableFlag0x02 #define CPUID_EAX_INTEL_TURBO_BOOST_TECHNOLOGY_AVAILABLE_FLAG        0x02
#defineCpuidEaxIntelTurboBoostTechnologyAvailableMask0x01 #define CPUID_EAX_INTEL_TURBO_BOOST_TECHNOLOGY_AVAILABLE_MASK        0x01
#defineCpuidEaxIntelTurboBoostTechnologyAvailable()((()>>1)&0x01) #define CPUID_EAX_INTEL_TURBO_BOOST_TECHNOLOGY_AVAILABLE(_)          (((_) >> 1) & 0x01)
*[Bit2]AratApic-Timer-Always-RunningFeatureIsSupportedIfSet * [Bit 2] ARAT. APIC-Timer-always-running feature is supported if set.
ApicTimerAlwaysRunning UINT32
#defineCpuidEaxApicTimerAlwaysRunningBit2 #define CPUID_EAX_APIC_TIMER_ALWAYS_RUNNING_BIT                      2
#defineCpuidEaxApicTimerAlwaysRunningFlag0x04 #define CPUID_EAX_APIC_TIMER_ALWAYS_RUNNING_FLAG                     0x04
#defineCpuidEaxApicTimerAlwaysRunningMask0x01 #define CPUID_EAX_APIC_TIMER_ALWAYS_RUNNING_MASK                     0x01
#defineCpuidEaxApicTimerAlwaysRunning()((()>>2)&0x01) #define CPUID_EAX_APIC_TIMER_ALWAYS_RUNNING(_)                       (((_) >> 2) & 0x01)
Reserved1 UINT32
*[Bit4]PlnPowerLimitNotificationControlsAreSupportedIfSet * [Bit 4] PLN. Power limit notification controls are supported if set.
PowerLimitNotification UINT32
#defineCpuidEaxPowerLimitNotificationBit4 #define CPUID_EAX_POWER_LIMIT_NOTIFICATION_BIT                       4
#defineCpuidEaxPowerLimitNotificationFlag0x10 #define CPUID_EAX_POWER_LIMIT_NOTIFICATION_FLAG                      0x10
#defineCpuidEaxPowerLimitNotificationMask0x01 #define CPUID_EAX_POWER_LIMIT_NOTIFICATION_MASK                      0x01
#defineCpuidEaxPowerLimitNotification()((()>>4)&0x01) #define CPUID_EAX_POWER_LIMIT_NOTIFICATION(_)                        (((_) >> 4) & 0x01)
*[Bit5]EcmdClockModulationDutyCycleExtensionIsSupportedIfSet * [Bit 5] ECMD. Clock modulation duty cycle extension is supported if set.
ClockModulationDuty UINT32
#defineCpuidEaxClockModulationDutyBit5 #define CPUID_EAX_CLOCK_MODULATION_DUTY_BIT                          5
#defineCpuidEaxClockModulationDutyFlag0x20 #define CPUID_EAX_CLOCK_MODULATION_DUTY_FLAG                         0x20
#defineCpuidEaxClockModulationDutyMask0x01 #define CPUID_EAX_CLOCK_MODULATION_DUTY_MASK                         0x01
#defineCpuidEaxClockModulationDuty()((()>>5)&0x01) #define CPUID_EAX_CLOCK_MODULATION_DUTY(_)                           (((_) >> 5) & 0x01)
*[Bit6]PtmPackageThermalManagementIsSupportedIfSet * [Bit 6] PTM. Package thermal management is supported if set.
PackageThermalManagement UINT32
#defineCpuidEaxPackageThermalManagementBit6 #define CPUID_EAX_PACKAGE_THERMAL_MANAGEMENT_BIT                     6
#defineCpuidEaxPackageThermalManagementFlag0x40 #define CPUID_EAX_PACKAGE_THERMAL_MANAGEMENT_FLAG                    0x40
#defineCpuidEaxPackageThermalManagementMask0x01 #define CPUID_EAX_PACKAGE_THERMAL_MANAGEMENT_MASK                    0x01
#defineCpuidEaxPackageThermalManagement()((()>>6)&0x01) #define CPUID_EAX_PACKAGE_THERMAL_MANAGEMENT(_)                      (((_) >> 6) & 0x01)
*[Bit7]HwpHwpBaseRegisters(Ia32PmEnable[Bit0],Ia32HwpCapabilities,Ia32HwpRequest,Ia32HwpStatus)Are * [Bit 7] HWP. HWP base registers (IA32_PM_ENABLE[bit 0], IA32_HWP_CAPABILITIES, IA32_HWP_REQUEST, IA32_HWP_STATUS) are
*SupportedIfSet * supported if set.
HwpBaseRegisters UINT32
#defineCpuidEaxHwpBaseRegistersBit7 #define CPUID_EAX_HWP_BASE_REGISTERS_BIT                             7
#defineCpuidEaxHwpBaseRegistersFlag0x80 #define CPUID_EAX_HWP_BASE_REGISTERS_FLAG                            0x80
#defineCpuidEaxHwpBaseRegistersMask0x01 #define CPUID_EAX_HWP_BASE_REGISTERS_MASK                            0x01
#defineCpuidEaxHwpBaseRegisters()((()>>7)&0x01) #define CPUID_EAX_HWP_BASE_REGISTERS(_)                              (((_) >> 7) & 0x01)
*[Bit8]HwpNotificationIa32HwpInterruptMsrIsSupportedIfSet * [Bit 8] HWP_Notification. IA32_HWP_INTERRUPT MSR is supported if set.
HwpNotification UINT32
#defineCpuidEaxHwpNotificationBit8 #define CPUID_EAX_HWP_NOTIFICATION_BIT                               8
#defineCpuidEaxHwpNotificationFlag0x100 #define CPUID_EAX_HWP_NOTIFICATION_FLAG                              0x100
#defineCpuidEaxHwpNotificationMask0x01 #define CPUID_EAX_HWP_NOTIFICATION_MASK                              0x01
#defineCpuidEaxHwpNotification()((()>>8)&0x01) #define CPUID_EAX_HWP_NOTIFICATION(_)                                (((_) >> 8) & 0x01)
*[Bit9]HwpActivityWindowIa32HwpRequest[Bits41:32]IsSupportedIfSet * [Bit 9] HWP_Activity_Window. IA32_HWP_REQUEST[bits 41:32] is supported if set.
HwpActivityWindow UINT32
#defineCpuidEaxHwpActivityWindowBit9 #define CPUID_EAX_HWP_ACTIVITY_WINDOW_BIT                            9
#defineCpuidEaxHwpActivityWindowFlag0x200 #define CPUID_EAX_HWP_ACTIVITY_WINDOW_FLAG                           0x200
#defineCpuidEaxHwpActivityWindowMask0x01 #define CPUID_EAX_HWP_ACTIVITY_WINDOW_MASK                           0x01
#defineCpuidEaxHwpActivityWindow()((()>>9)&0x01) #define CPUID_EAX_HWP_ACTIVITY_WINDOW(_)                             (((_) >> 9) & 0x01)
*[Bit10]HwpEnergyPerformancePreferenceIa32HwpRequest[Bits31:24]IsSupportedIfSet * [Bit 10] HWP_Energy_Performance_Preference. IA32_HWP_REQUEST[bits 31:24] is supported if set.
HwpEnergyPerformancePreference UINT32
#defineCpuidEaxHwpEnergyPerformancePreferenceBit10 #define CPUID_EAX_HWP_ENERGY_PERFORMANCE_PREFERENCE_BIT              10
#defineCpuidEaxHwpEnergyPerformancePreferenceFlag0x400 #define CPUID_EAX_HWP_ENERGY_PERFORMANCE_PREFERENCE_FLAG             0x400
#defineCpuidEaxHwpEnergyPerformancePreferenceMask0x01 #define CPUID_EAX_HWP_ENERGY_PERFORMANCE_PREFERENCE_MASK             0x01
#defineCpuidEaxHwpEnergyPerformancePreference()((()>>10)&0x01) #define CPUID_EAX_HWP_ENERGY_PERFORMANCE_PREFERENCE(_)               (((_) >> 10) & 0x01)
*[Bit11]HwpPackageLevelRequestIa32HwpRequestPkgMsrIsSupportedIfSet * [Bit 11] HWP_Package_Level_Request. IA32_HWP_REQUEST_PKG MSR is supported if set.
HwpPackageLevelRequest UINT32
#defineCpuidEaxHwpPackageLevelRequestBit11 #define CPUID_EAX_HWP_PACKAGE_LEVEL_REQUEST_BIT                      11
#defineCpuidEaxHwpPackageLevelRequestFlag0x800 #define CPUID_EAX_HWP_PACKAGE_LEVEL_REQUEST_FLAG                     0x800
#defineCpuidEaxHwpPackageLevelRequestMask0x01 #define CPUID_EAX_HWP_PACKAGE_LEVEL_REQUEST_MASK                     0x01
#defineCpuidEaxHwpPackageLevelRequest()((()>>11)&0x01) #define CPUID_EAX_HWP_PACKAGE_LEVEL_REQUEST(_)                       (((_) >> 11) & 0x01)
Reserved2 UINT32
*[Bit13]HdcHdcBaseRegistersIa32PkgHdcCtl,Ia32PmCtl1,Ia32ThreadStallMsRsAreSupportedIfSet * [Bit 13] HDC. HDC base registers IA32_PKG_HDC_CTL, IA32_PM_CTL1, IA32_THREAD_STALL MSRs are supported if set.
Hdc UINT32
#defineCpuidEaxHdcBit13 #define CPUID_EAX_HDC_BIT                                            13
#defineCpuidEaxHdcFlag0x2000 #define CPUID_EAX_HDC_FLAG                                           0x2000
#defineCpuidEaxHdcMask0x01 #define CPUID_EAX_HDC_MASK                                           0x01
#defineCpuidEaxHdc()((()>>13)&0x01) #define CPUID_EAX_HDC(_)                                             (((_) >> 13) & 0x01)
*[Bit14]Intel(R)TurboBoostMaxTechnology30Available * [Bit 14] Intel(R) Turbo Boost Max Technology 3.0 available.
IntelTurboBoostMaxTechnology3Available UINT32
#defineCpuidEaxIntelTurboBoostMaxTechnology3AvailableBit14 #define CPUID_EAX_INTEL_TURBO_BOOST_MAX_TECHNOLOGY_3_AVAILABLE_BIT   14
#defineCpuidEaxIntelTurboBoostMaxTechnology3AvailableFlag0x4000 #define CPUID_EAX_INTEL_TURBO_BOOST_MAX_TECHNOLOGY_3_AVAILABLE_FLAG  0x4000
#defineCpuidEaxIntelTurboBoostMaxTechnology3AvailableMask0x01 #define CPUID_EAX_INTEL_TURBO_BOOST_MAX_TECHNOLOGY_3_AVAILABLE_MASK  0x01
#defineCpuidEaxIntelTurboBoostMaxTechnology3Available()((()>>14)&0x01) #define CPUID_EAX_INTEL_TURBO_BOOST_MAX_TECHNOLOGY_3_AVAILABLE(_)    (((_) >> 14) & 0x01)
*[Bit15]HwpCapabilitiesHighestPerformanceChangeIsSupportedIfSet * [Bit 15] HWP Capabilities. Highest Performance change is supported if set.
HwpCapabilities UINT32
#defineCpuidEaxHwpCapabilitiesBit15 #define CPUID_EAX_HWP_CAPABILITIES_BIT                               15
#defineCpuidEaxHwpCapabilitiesFlag0x8000 #define CPUID_EAX_HWP_CAPABILITIES_FLAG                              0x8000
#defineCpuidEaxHwpCapabilitiesMask0x01 #define CPUID_EAX_HWP_CAPABILITIES_MASK                              0x01
#defineCpuidEaxHwpCapabilities()((()>>15)&0x01) #define CPUID_EAX_HWP_CAPABILITIES(_)                                (((_) >> 15) & 0x01)
*[Bit16]HwpPeciOverrideIsSupportedIfSet * [Bit 16] HWP PECI override is supported if set.
HwpPeciOverride UINT32
#defineCpuidEaxHwpPeciOverrideBit16 #define CPUID_EAX_HWP_PECI_OVERRIDE_BIT                              16
#defineCpuidEaxHwpPeciOverrideFlag0x10000 #define CPUID_EAX_HWP_PECI_OVERRIDE_FLAG                             0x10000
#defineCpuidEaxHwpPeciOverrideMask0x01 #define CPUID_EAX_HWP_PECI_OVERRIDE_MASK                             0x01
#defineCpuidEaxHwpPeciOverride()((()>>16)&0x01) #define CPUID_EAX_HWP_PECI_OVERRIDE(_)                               (((_) >> 16) & 0x01)
*[Bit17]FlexibleHwpIsSupportedIfSet * [Bit 17] Flexible HWP is supported if set.
FlexibleHwp UINT32
#defineCpuidEaxFlexibleHwpBit17 #define CPUID_EAX_FLEXIBLE_HWP_BIT                                   17
#defineCpuidEaxFlexibleHwpFlag0x20000 #define CPUID_EAX_FLEXIBLE_HWP_FLAG                                  0x20000
#defineCpuidEaxFlexibleHwpMask0x01 #define CPUID_EAX_FLEXIBLE_HWP_MASK                                  0x01
#defineCpuidEaxFlexibleHwp()((()>>17)&0x01) #define CPUID_EAX_FLEXIBLE_HWP(_)                                    (((_) >> 17) & 0x01)
*[Bit18]FastAccessModeForTheIa32HwpRequestMsrIsSupportedIfSet * [Bit 18] Fast access mode for the IA32_HWP_REQUEST MSR is supported if set.
FastAccessModeForHwpRequestMsr UINT32
#defineCpuidEaxFastAccessModeForHwpRequestMsrBit18 #define CPUID_EAX_FAST_ACCESS_MODE_FOR_HWP_REQUEST_MSR_BIT           18
#defineCpuidEaxFastAccessModeForHwpRequestMsrFlag0x40000 #define CPUID_EAX_FAST_ACCESS_MODE_FOR_HWP_REQUEST_MSR_FLAG          0x40000
#defineCpuidEaxFastAccessModeForHwpRequestMsrMask0x01 #define CPUID_EAX_FAST_ACCESS_MODE_FOR_HWP_REQUEST_MSR_MASK          0x01
#defineCpuidEaxFastAccessModeForHwpRequestMsr()((()>>18)&0x01) #define CPUID_EAX_FAST_ACCESS_MODE_FOR_HWP_REQUEST_MSR(_)            (((_) >> 18) & 0x01)
Reserved3 UINT32
*[Bit20]IgnoringIdleLogicalProcessorHwpRequestIsSupportedIfSet * [Bit 20] Ignoring Idle Logical Processor HWP request is supported if set.
IgnoringIdleLogicalProcessorHwpRequest UINT32
#defineCpuidEaxIgnoringIdleLogicalProcessorHwpRequestBit20 #define CPUID_EAX_IGNORING_IDLE_LOGICAL_PROCESSOR_HWP_REQUEST_BIT    20
#defineCpuidEaxIgnoringIdleLogicalProcessorHwpRequestFlag0x100000 #define CPUID_EAX_IGNORING_IDLE_LOGICAL_PROCESSOR_HWP_REQUEST_FLAG   0x100000
#defineCpuidEaxIgnoringIdleLogicalProcessorHwpRequestMask0x01 #define CPUID_EAX_IGNORING_IDLE_LOGICAL_PROCESSOR_HWP_REQUEST_MASK   0x01
#defineCpuidEaxIgnoringIdleLogicalProcessorHwpRequest()((()>>20)&0x01) #define CPUID_EAX_IGNORING_IDLE_LOGICAL_PROCESSOR_HWP_REQUEST(_)     (((_) >> 20) & 0x01)
Reserved4 UINT32
*[Bit23]IntelThreadDirectorSupportedIfSetIa32HwFeedbackCharAndIa32HwFeedbackThreadConfigMsRsAre * [Bit 23] Intel Thread Director supported if set. IA32_HW_FEEDBACK_CHAR and IA32_HW_FEEDBACK_THREAD_CONFIG MSRs are
*SupportedIfSet * supported if set.
IntelThreadDirector UINT32
#defineCpuidEaxIntelThreadDirectorBit23 #define CPUID_EAX_INTEL_THREAD_DIRECTOR_BIT                          23
#defineCpuidEaxIntelThreadDirectorFlag0x800000 #define CPUID_EAX_INTEL_THREAD_DIRECTOR_FLAG                         0x800000
#defineCpuidEaxIntelThreadDirectorMask0x01 #define CPUID_EAX_INTEL_THREAD_DIRECTOR_MASK                         0x01
#defineCpuidEaxIntelThreadDirector()((()>>23)&0x01) #define CPUID_EAX_INTEL_THREAD_DIRECTOR(_)                           (((_) >> 23) & 0x01)
Reserved5 UINT32
}


type  struct{
TypedefStruct typedef struct
Union union
Struct struct
*[Bits31:0]ReportsTheMaximumInputValueForSupportedLeaf7Sub-Leaves * [Bits 31:0] Reports the maximum input value for supported leaf 7 sub-leaves.
NumberOfSubLeaves UINT32
#defineCpuidEaxNumberOfSubLeavesBit0 #define CPUID_EAX_NUMBER_OF_SUB_LEAVES_BIT                           0
#defineCpuidEaxNumberOfSubLeavesFlag0xFfffffff #define CPUID_EAX_NUMBER_OF_SUB_LEAVES_FLAG                          0xFFFFFFFF
#defineCpuidEaxNumberOfSubLeavesMask0xFfffffff #define CPUID_EAX_NUMBER_OF_SUB_LEAVES_MASK                          0xFFFFFFFF
#defineCpuidEaxNumberOfSubLeaves()((()>>0)&0xFfffffff) #define CPUID_EAX_NUMBER_OF_SUB_LEAVES(_)                            (((_) >> 0) & 0xFFFFFFFF)
}


type  struct{
TypedefStruct typedef struct
Union union
Struct struct
*[Bits31:0]ValueOfBits[31:0]OfIa32PlatformDcaCapMsr(Address1F8H) * [Bits 31:0] Value of bits [31:0] of IA32_PLATFORM_DCA_CAP MSR (address 1F8H).
Ia32PlatformDcaCap UINT32
#defineCpuidEaxIa32PlatformDcaCapBit0 #define CPUID_EAX_IA32_PLATFORM_DCA_CAP_BIT                          0
#defineCpuidEaxIa32PlatformDcaCapFlag0xFfffffff #define CPUID_EAX_IA32_PLATFORM_DCA_CAP_FLAG                         0xFFFFFFFF
#defineCpuidEaxIa32PlatformDcaCapMask0xFfffffff #define CPUID_EAX_IA32_PLATFORM_DCA_CAP_MASK                         0xFFFFFFFF
#defineCpuidEaxIa32PlatformDcaCap()((()>>0)&0xFfffffff) #define CPUID_EAX_IA32_PLATFORM_DCA_CAP(_)                           (((_) >> 0) & 0xFFFFFFFF)
}


type  struct{
TypedefStruct typedef struct
Union union
Struct struct
*[Bits7:0]VersionIdOfArchitecturalPerformanceMonitoring * [Bits 7:0] Version ID of architectural performance monitoring.
VersionIdOfArchitecturalPerformanceMonitoring UINT32
#defineCpuidEaxVersionIdOfArchitecturalPerformanceMonitoringBit0 #define CPUID_EAX_VERSION_ID_OF_ARCHITECTURAL_PERFORMANCE_MONITORING_BIT 0
#defineCpuidEaxVersionIdOfArchitecturalPerformanceMonitoringFlag0xFf #define CPUID_EAX_VERSION_ID_OF_ARCHITECTURAL_PERFORMANCE_MONITORING_FLAG 0xFF
#defineCpuidEaxVersionIdOfArchitecturalPerformanceMonitoringMask0xFf #define CPUID_EAX_VERSION_ID_OF_ARCHITECTURAL_PERFORMANCE_MONITORING_MASK 0xFF
#defineCpuidEaxVersionIdOfArchitecturalPerformanceMonitoring()((()>>0)&0xFf) #define CPUID_EAX_VERSION_ID_OF_ARCHITECTURAL_PERFORMANCE_MONITORING(_) (((_) >> 0) & 0xFF)
*[Bits15:8]NumberOfGeneral-PurposePerformanceMonitoringCounterPerLogicalProcessor * [Bits 15:8] Number of general-purpose performance monitoring counter per logical processor.
NumberOfPerformanceMonitoringCounterPerLogicalProcessor: UINT32
#defineCpuidEaxNumberOfPerformanceMonitoringCounterPerLogicalProcessorBit8 #define CPUID_EAX_NUMBER_OF_PERFORMANCE_MONITORING_COUNTER_PER_LOGICAL_PROCESSOR_BIT 8
#defineCpuidEaxNumberOfPerformanceMonitoringCounterPerLogicalProcessorFlag0xFf00 #define CPUID_EAX_NUMBER_OF_PERFORMANCE_MONITORING_COUNTER_PER_LOGICAL_PROCESSOR_FLAG 0xFF00
#defineCpuidEaxNumberOfPerformanceMonitoringCounterPerLogicalProcessorMask0xFf #define CPUID_EAX_NUMBER_OF_PERFORMANCE_MONITORING_COUNTER_PER_LOGICAL_PROCESSOR_MASK 0xFF
#defineCpuidEaxNumberOfPerformanceMonitoringCounterPerLogicalProcessor()((()>>8)&0xFf) #define CPUID_EAX_NUMBER_OF_PERFORMANCE_MONITORING_COUNTER_PER_LOGICAL_PROCESSOR(_) (((_) >> 8) & 0xFF)
*[Bits23:16]BitWidthOfGeneral-Purpose,PerformanceMonitoringCounter * [Bits 23:16] Bit width of general-purpose, performance monitoring counter.
BitWidthOfPerformanceMonitoringCounter UINT32
#defineCpuidEaxBitWidthOfPerformanceMonitoringCounterBit16 #define CPUID_EAX_BIT_WIDTH_OF_PERFORMANCE_MONITORING_COUNTER_BIT    16
#defineCpuidEaxBitWidthOfPerformanceMonitoringCounterFlag0xFf0000 #define CPUID_EAX_BIT_WIDTH_OF_PERFORMANCE_MONITORING_COUNTER_FLAG   0xFF0000
#defineCpuidEaxBitWidthOfPerformanceMonitoringCounterMask0xFf #define CPUID_EAX_BIT_WIDTH_OF_PERFORMANCE_MONITORING_COUNTER_MASK   0xFF
#defineCpuidEaxBitWidthOfPerformanceMonitoringCounter()((()>>16)&0xFf) #define CPUID_EAX_BIT_WIDTH_OF_PERFORMANCE_MONITORING_COUNTER(_)     (((_) >> 16) & 0xFF)
*[Bits31:24]LengthOfEbxBitVectorToEnumerateArchitecturalPerformanceMonitoringEvents * [Bits 31:24] Length of EBX bit vector to enumerate architectural performance monitoring events.
EbxBitVectorLength UINT32
#defineCpuidEaxEbxBitVectorLengthBit24 #define CPUID_EAX_EBX_BIT_VECTOR_LENGTH_BIT                          24
#defineCpuidEaxEbxBitVectorLengthFlag0xFf000000 #define CPUID_EAX_EBX_BIT_VECTOR_LENGTH_FLAG                         0xFF000000
#defineCpuidEaxEbxBitVectorLengthMask0xFf #define CPUID_EAX_EBX_BIT_VECTOR_LENGTH_MASK                         0xFF
#defineCpuidEaxEbxBitVectorLength()((()>>24)&0xFf) #define CPUID_EAX_EBX_BIT_VECTOR_LENGTH(_)                           (((_) >> 24) & 0xFF)
}


type  struct{
TypedefStruct typedef struct
Union union
Struct struct
*[Bits4:0]NumberOfBitsToShiftRightOnX2ApicIdToGetAUniqueTopologyIdOfTheNextLevelTypeAllLogical * [Bits 4:0] Number of bits to shift right on x2APIC ID to get a unique topology ID of the next level type. All logical
*ProcessorsWithTheSameNextLevelIdShareCurrentLevel * processors with the same next level ID share current level.
* *
X2ApicIdToUniqueTopologyIdShift UINT32
#defineCpuidEaxX2ApicIdToUniqueTopologyIdShiftBit0 #define CPUID_EAX_X2APIC_ID_TO_UNIQUE_TOPOLOGY_ID_SHIFT_BIT          0
#defineCpuidEaxX2ApicIdToUniqueTopologyIdShiftFlag0x1F #define CPUID_EAX_X2APIC_ID_TO_UNIQUE_TOPOLOGY_ID_SHIFT_FLAG         0x1F
#defineCpuidEaxX2ApicIdToUniqueTopologyIdShiftMask0x1F #define CPUID_EAX_X2APIC_ID_TO_UNIQUE_TOPOLOGY_ID_SHIFT_MASK         0x1F
#defineCpuidEaxX2ApicIdToUniqueTopologyIdShift()((()>>0)&0x1F) #define CPUID_EAX_X2APIC_ID_TO_UNIQUE_TOPOLOGY_ID_SHIFT(_)           (((_) >> 0) & 0x1F)
Reserved1 UINT32
}


type  struct{
TypedefStruct typedef struct
Union union
Struct struct
*[Bit0]X87State * [Bit 0] x87 state.
X87State UINT32
#defineCpuidEaxX87StateBit0 #define CPUID_EAX_X87_STATE_BIT                                      0
#defineCpuidEaxX87StateFlag0x01 #define CPUID_EAX_X87_STATE_FLAG                                     0x01
#defineCpuidEaxX87StateMask0x01 #define CPUID_EAX_X87_STATE_MASK                                     0x01
#defineCpuidEaxX87State()((()>>0)&0x01) #define CPUID_EAX_X87_STATE(_)                                       (((_) >> 0) & 0x01)
*[Bit1]SseState * [Bit 1] SSE state.
SseState UINT32
#defineCpuidEaxSseStateBit1 #define CPUID_EAX_SSE_STATE_BIT                                      1
#defineCpuidEaxSseStateFlag0x02 #define CPUID_EAX_SSE_STATE_FLAG                                     0x02
#defineCpuidEaxSseStateMask0x01 #define CPUID_EAX_SSE_STATE_MASK                                     0x01
#defineCpuidEaxSseState()((()>>1)&0x01) #define CPUID_EAX_SSE_STATE(_)                                       (((_) >> 1) & 0x01)
*[Bit2]AvxState * [Bit 2] AVX state.
AvxState UINT32
#defineCpuidEaxAvxStateBit2 #define CPUID_EAX_AVX_STATE_BIT                                      2
#defineCpuidEaxAvxStateFlag0x04 #define CPUID_EAX_AVX_STATE_FLAG                                     0x04
#defineCpuidEaxAvxStateMask0x01 #define CPUID_EAX_AVX_STATE_MASK                                     0x01
#defineCpuidEaxAvxState()((()>>2)&0x01) #define CPUID_EAX_AVX_STATE(_)                                       (((_) >> 2) & 0x01)
*[Bits4:3]MpxState * [Bits 4:3] MPX state.
MpxState UINT32
#defineCpuidEaxMpxStateBit3 #define CPUID_EAX_MPX_STATE_BIT                                      3
#defineCpuidEaxMpxStateFlag0x18 #define CPUID_EAX_MPX_STATE_FLAG                                     0x18
#defineCpuidEaxMpxStateMask0x03 #define CPUID_EAX_MPX_STATE_MASK                                     0x03
#defineCpuidEaxMpxState()((()>>3)&0x03) #define CPUID_EAX_MPX_STATE(_)                                       (((_) >> 3) & 0x03)
*[Bits7:5]Avx-512State * [Bits 7:5] AVX-512 state.
Avx512State UINT32
#defineCpuidEaxAvx512StateBit5 #define CPUID_EAX_AVX_512_STATE_BIT                                  5
#defineCpuidEaxAvx512StateFlag0xE0 #define CPUID_EAX_AVX_512_STATE_FLAG                                 0xE0
#defineCpuidEaxAvx512StateMask0x07 #define CPUID_EAX_AVX_512_STATE_MASK                                 0x07
#defineCpuidEaxAvx512State()((()>>5)&0x07) #define CPUID_EAX_AVX_512_STATE(_)                                   (((_) >> 5) & 0x07)
*[Bit8]UsedForIa32Xss * [Bit 8] Used for IA32_XSS.
UsedForIa32Xss1 UINT32
#defineCpuidEaxUsedForIa32Xss1Bit8 #define CPUID_EAX_USED_FOR_IA32_XSS_1_BIT                            8
#defineCpuidEaxUsedForIa32Xss1Flag0x100 #define CPUID_EAX_USED_FOR_IA32_XSS_1_FLAG                           0x100
#defineCpuidEaxUsedForIa32Xss1Mask0x01 #define CPUID_EAX_USED_FOR_IA32_XSS_1_MASK                           0x01
#defineCpuidEaxUsedForIa32Xss1()((()>>8)&0x01) #define CPUID_EAX_USED_FOR_IA32_XSS_1(_)                             (((_) >> 8) & 0x01)
*[Bit9]PkruState * [Bit 9] PKRU state.
PkruState UINT32
#defineCpuidEaxPkruStateBit9 #define CPUID_EAX_PKRU_STATE_BIT                                     9
#defineCpuidEaxPkruStateFlag0x200 #define CPUID_EAX_PKRU_STATE_FLAG                                    0x200
#defineCpuidEaxPkruStateMask0x01 #define CPUID_EAX_PKRU_STATE_MASK                                    0x01
#defineCpuidEaxPkruState()((()>>9)&0x01) #define CPUID_EAX_PKRU_STATE(_)                                      (((_) >> 9) & 0x01)
Reserved1 UINT32
*[Bit13]UsedForIa32Xss * [Bit 13] Used for IA32_XSS.
UsedForIa32Xss2 UINT32
#defineCpuidEaxUsedForIa32Xss2Bit13 #define CPUID_EAX_USED_FOR_IA32_XSS_2_BIT                            13
#defineCpuidEaxUsedForIa32Xss2Flag0x2000 #define CPUID_EAX_USED_FOR_IA32_XSS_2_FLAG                           0x2000
#defineCpuidEaxUsedForIa32Xss2Mask0x01 #define CPUID_EAX_USED_FOR_IA32_XSS_2_MASK                           0x01
#defineCpuidEaxUsedForIa32Xss2()((()>>13)&0x01) #define CPUID_EAX_USED_FOR_IA32_XSS_2(_)                             (((_) >> 13) & 0x01)
Reserved2 UINT32
}


type  struct{
TypedefStruct typedef struct
Union union
Struct struct
Reserved1 UINT32
*[Bit1]SupportsXsavecAndTheCompactedFormOfXrstorIfSet * [Bit 1] Supports XSAVEC and the compacted form of XRSTOR if set.
SupportsXsavecAndCompactedXrstor UINT32
#defineCpuidEaxSupportsXsavecAndCompactedXrstorBit1 #define CPUID_EAX_SUPPORTS_XSAVEC_AND_COMPACTED_XRSTOR_BIT           1
#defineCpuidEaxSupportsXsavecAndCompactedXrstorFlag0x02 #define CPUID_EAX_SUPPORTS_XSAVEC_AND_COMPACTED_XRSTOR_FLAG          0x02
#defineCpuidEaxSupportsXsavecAndCompactedXrstorMask0x01 #define CPUID_EAX_SUPPORTS_XSAVEC_AND_COMPACTED_XRSTOR_MASK          0x01
#defineCpuidEaxSupportsXsavecAndCompactedXrstor()((()>>1)&0x01) #define CPUID_EAX_SUPPORTS_XSAVEC_AND_COMPACTED_XRSTOR(_)            (((_) >> 1) & 0x01)
*[Bit2]SupportsXgetbvWithEcx=1IfSet * [Bit 2] Supports XGETBV with ECX = 1 if set.
SupportsXgetbvWithEcx1 UINT32
#defineCpuidEaxSupportsXgetbvWithEcx1Bit2 #define CPUID_EAX_SUPPORTS_XGETBV_WITH_ECX_1_BIT                     2
#defineCpuidEaxSupportsXgetbvWithEcx1Flag0x04 #define CPUID_EAX_SUPPORTS_XGETBV_WITH_ECX_1_FLAG                    0x04
#defineCpuidEaxSupportsXgetbvWithEcx1Mask0x01 #define CPUID_EAX_SUPPORTS_XGETBV_WITH_ECX_1_MASK                    0x01
#defineCpuidEaxSupportsXgetbvWithEcx1()((()>>2)&0x01) #define CPUID_EAX_SUPPORTS_XGETBV_WITH_ECX_1(_)                      (((_) >> 2) & 0x01)
*[Bit3]SupportsXsavesXrstorsAndIa32XssIfSet * [Bit 3] Supports XSAVES/XRSTORS and IA32_XSS if set.
SupportsXsaveXrstorAndIa32Xss UINT32
#defineCpuidEaxSupportsXsaveXrstorAndIa32XssBit3 #define CPUID_EAX_SUPPORTS_XSAVE_XRSTOR_AND_IA32_XSS_BIT             3
#defineCpuidEaxSupportsXsaveXrstorAndIa32XssFlag0x08 #define CPUID_EAX_SUPPORTS_XSAVE_XRSTOR_AND_IA32_XSS_FLAG            0x08
#defineCpuidEaxSupportsXsaveXrstorAndIa32XssMask0x01 #define CPUID_EAX_SUPPORTS_XSAVE_XRSTOR_AND_IA32_XSS_MASK            0x01
#defineCpuidEaxSupportsXsaveXrstorAndIa32Xss()((()>>3)&0x01) #define CPUID_EAX_SUPPORTS_XSAVE_XRSTOR_AND_IA32_XSS(_)              (((_) >> 3) & 0x01)
Reserved2 UINT32
}


type  struct{
TypedefStruct typedef struct
Union union
Struct struct
*[Bits31:0]TheSizeInBytes(FromTheOffsetSpecifiedInEbx)OfTheSaveAreaForAnExtendedStateFeature * [Bits 31:0] The size in bytes (from the offset specified in EBX) of the save area for an extended state feature
*AssociatedWithAValidSub-LeafIndex,N * associated with a valid sub-leaf index, n.
Ia32PlatformDcaCap UINT32
#defineCpuidEaxIa32PlatformDcaCapBit0 #define CPUID_EAX_IA32_PLATFORM_DCA_CAP_BIT                          0
#defineCpuidEaxIa32PlatformDcaCapFlag0xFfffffff #define CPUID_EAX_IA32_PLATFORM_DCA_CAP_FLAG                         0xFFFFFFFF
#defineCpuidEaxIa32PlatformDcaCapMask0xFfffffff #define CPUID_EAX_IA32_PLATFORM_DCA_CAP_MASK                         0xFFFFFFFF
#defineCpuidEaxIa32PlatformDcaCap()((()>>0)&0xFfffffff) #define CPUID_EAX_IA32_PLATFORM_DCA_CAP(_)                           (((_) >> 0) & 0xFFFFFFFF)
}


type  struct{
TypedefStruct typedef struct
Union union
Struct struct
*[Bits31:0]EaxIsReserved * [Bits 31:0] EAX is reserved.
Reserved UINT32
#defineCpuidEaxReservedBit0 #define CPUID_EAX_RESERVED_BIT                                       0
#defineCpuidEaxReservedFlag0xFfffffff #define CPUID_EAX_RESERVED_FLAG                                      0xFFFFFFFF
#defineCpuidEaxReservedMask0xFfffffff #define CPUID_EAX_RESERVED_MASK                                      0xFFFFFFFF
#defineCpuidEaxReserved()((()>>0)&0xFfffffff) #define CPUID_EAX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
}


type  struct{
TypedefStruct typedef struct
Union union
Struct struct
*[Bits31:0]EaxIsReserved * [Bits 31:0] EAX is reserved.
Reserved UINT32
#defineCpuidEaxReservedBit0 #define CPUID_EAX_RESERVED_BIT                                       0
#defineCpuidEaxReservedFlag0xFfffffff #define CPUID_EAX_RESERVED_FLAG                                      0xFFFFFFFF
#defineCpuidEaxReservedMask0xFfffffff #define CPUID_EAX_RESERVED_MASK                                      0xFFFFFFFF
#defineCpuidEaxReserved()((()>>0)&0xFfffffff) #define CPUID_EAX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
}


type  struct{
TypedefStruct typedef struct
Union union
Struct struct
*[Bits31:0]ValueOfBits[31:0]OfIa32PlatformDcaCapMsr(Address1F8H) * [Bits 31:0] Value of bits [31:0] of IA32_PLATFORM_DCA_CAP MSR (address 1F8H).
Ia32PlatformDcaCap UINT32
#defineCpuidEaxIa32PlatformDcaCapBit0 #define CPUID_EAX_IA32_PLATFORM_DCA_CAP_BIT                          0
#defineCpuidEaxIa32PlatformDcaCapFlag0xFfffffff #define CPUID_EAX_IA32_PLATFORM_DCA_CAP_FLAG                         0xFFFFFFFF
#defineCpuidEaxIa32PlatformDcaCapMask0xFfffffff #define CPUID_EAX_IA32_PLATFORM_DCA_CAP_MASK                         0xFFFFFFFF
#defineCpuidEaxIa32PlatformDcaCap()((()>>0)&0xFfffffff) #define CPUID_EAX_IA32_PLATFORM_DCA_CAP(_)                           (((_) >> 0) & 0xFFFFFFFF)
}


type  struct{
TypedefStruct typedef struct
Union union
Struct struct
*[Bits4:0]LengthOfTheCapacityBitMaskForTheCorrespondingResIdUsingMinus-OneNotation * [Bits 4:0] Length of the capacity bit mask for the corresponding ResID using minus-one notation.
LengthOfCapacityBitMask UINT32
#defineCpuidEaxLengthOfCapacityBitMaskBit0 #define CPUID_EAX_LENGTH_OF_CAPACITY_BIT_MASK_BIT                    0
#defineCpuidEaxLengthOfCapacityBitMaskFlag0x1F #define CPUID_EAX_LENGTH_OF_CAPACITY_BIT_MASK_FLAG                   0x1F
#defineCpuidEaxLengthOfCapacityBitMaskMask0x1F #define CPUID_EAX_LENGTH_OF_CAPACITY_BIT_MASK_MASK                   0x1F
#defineCpuidEaxLengthOfCapacityBitMask()((()>>0)&0x1F) #define CPUID_EAX_LENGTH_OF_CAPACITY_BIT_MASK(_)                     (((_) >> 0) & 0x1F)
Reserved1 UINT32
}


type  struct{
TypedefStruct typedef struct
Union union
Struct struct
*[Bits4:0]LengthOfTheCapacityBitMaskForTheCorrespondingResIdUsingMinus-OneNotation * [Bits 4:0] Length of the capacity bit mask for the corresponding ResID using minus-one notation.
LengthOfCapacityBitMask UINT32
#defineCpuidEaxLengthOfCapacityBitMaskBit0 #define CPUID_EAX_LENGTH_OF_CAPACITY_BIT_MASK_BIT                    0
#defineCpuidEaxLengthOfCapacityBitMaskFlag0x1F #define CPUID_EAX_LENGTH_OF_CAPACITY_BIT_MASK_FLAG                   0x1F
#defineCpuidEaxLengthOfCapacityBitMaskMask0x1F #define CPUID_EAX_LENGTH_OF_CAPACITY_BIT_MASK_MASK                   0x1F
#defineCpuidEaxLengthOfCapacityBitMask()((()>>0)&0x1F) #define CPUID_EAX_LENGTH_OF_CAPACITY_BIT_MASK(_)                     (((_) >> 0) & 0x1F)
Reserved1 UINT32
}


type  struct{
TypedefStruct typedef struct
Union union
Struct struct
*[Bits11:0]ReportsTheMaximumMbaThrottlingValueSupportedForTheCorrespondingResIdUsingMinus-OneNotation * [Bits 11:0] Reports the maximum MBA throttling value supported for the corresponding ResID using minus-one notation.
MaxMbaThrottlingValue UINT32
#defineCpuidEaxMaxMbaThrottlingValueBit0 #define CPUID_EAX_MAX_MBA_THROTTLING_VALUE_BIT                       0
#defineCpuidEaxMaxMbaThrottlingValueFlag0xFff #define CPUID_EAX_MAX_MBA_THROTTLING_VALUE_FLAG                      0xFFF
#defineCpuidEaxMaxMbaThrottlingValueMask0xFff #define CPUID_EAX_MAX_MBA_THROTTLING_VALUE_MASK                      0xFFF
#defineCpuidEaxMaxMbaThrottlingValue()((()>>0)&0xFff) #define CPUID_EAX_MAX_MBA_THROTTLING_VALUE(_)                        (((_) >> 0) & 0xFFF)
Reserved1 UINT32
}


type  struct{
TypedefStruct typedef struct
Union union
Struct struct
*[Bit0]If1,IndicatesIntelSgxSupportsTheCollectionOfSgx1LeafFunctions * [Bit 0] If 1, Indicates Intel SGX supports the collection of SGX1 leaf functions.
Sgx1 UINT32
#defineCpuidEaxSgx1Bit0 #define CPUID_EAX_SGX1_BIT                                           0
#defineCpuidEaxSgx1Flag0x01 #define CPUID_EAX_SGX1_FLAG                                          0x01
#defineCpuidEaxSgx1Mask0x01 #define CPUID_EAX_SGX1_MASK                                          0x01
#defineCpuidEaxSgx1()((()>>0)&0x01) #define CPUID_EAX_SGX1(_)                                            (((_) >> 0) & 0x01)
*[Bit1]If1,IndicatesIntelSgxSupportsTheCollectionOfSgx2LeafFunctions * [Bit 1] If 1, Indicates Intel SGX supports the collection of SGX2 leaf functions.
Sgx2 UINT32
#defineCpuidEaxSgx2Bit1 #define CPUID_EAX_SGX2_BIT                                           1
#defineCpuidEaxSgx2Flag0x02 #define CPUID_EAX_SGX2_FLAG                                          0x02
#defineCpuidEaxSgx2Mask0x01 #define CPUID_EAX_SGX2_MASK                                          0x01
#defineCpuidEaxSgx2()((()>>1)&0x01) #define CPUID_EAX_SGX2(_)                                            (((_) >> 1) & 0x01)
Reserved1 UINT32
*[Bit5]If1,IndicatesIntelSgxSupportsEnclvInstructionLeavesEincvirtchild,Edecvirtchild,AndEsetcontext * [Bit 5] If 1, indicates Intel SGX supports ENCLV instruction leaves EINCVIRTCHILD, EDECVIRTCHILD, and ESETCONTEXT.
SgxEnclvAdvanced UINT32
#defineCpuidEaxSgxEnclvAdvancedBit5 #define CPUID_EAX_SGX_ENCLV_ADVANCED_BIT                             5
#defineCpuidEaxSgxEnclvAdvancedFlag0x20 #define CPUID_EAX_SGX_ENCLV_ADVANCED_FLAG                            0x20
#defineCpuidEaxSgxEnclvAdvancedMask0x01 #define CPUID_EAX_SGX_ENCLV_ADVANCED_MASK                            0x01
#defineCpuidEaxSgxEnclvAdvanced()((()>>5)&0x01) #define CPUID_EAX_SGX_ENCLV_ADVANCED(_)                              (((_) >> 5) & 0x01)
*[Bit6]If1,IndicatesIntelSgxSupportsEnclsInstructionLeavesEtrackc,Erdinfo,Eldbc,AndElduc * [Bit 6] If 1, indicates Intel SGX supports ENCLS instruction leaves ETRACKC, ERDINFO, ELDBC, and ELDUC.
SgxEnclsAdvanced UINT32
#defineCpuidEaxSgxEnclsAdvancedBit6 #define CPUID_EAX_SGX_ENCLS_ADVANCED_BIT                             6
#defineCpuidEaxSgxEnclsAdvancedFlag0x40 #define CPUID_EAX_SGX_ENCLS_ADVANCED_FLAG                            0x40
#defineCpuidEaxSgxEnclsAdvancedMask0x01 #define CPUID_EAX_SGX_ENCLS_ADVANCED_MASK                            0x01
#defineCpuidEaxSgxEnclsAdvanced()((()>>6)&0x01) #define CPUID_EAX_SGX_ENCLS_ADVANCED(_)                              (((_) >> 6) & 0x01)
Reserved2 UINT32
}


type  struct{
TypedefStruct typedef struct
Union union
Struct struct
*[Bits31:0]ReportsTheValidBitsOfSecsAttributes[31:0]ThatSoftwareCanSetWithEcreate * [Bits 31:0] Reports the valid bits of SECS.ATTRIBUTES[31:0] that software can set with ECREATE.
ValidSecsAttributes0 UINT32
#defineCpuidEaxValidSecsAttributes0Bit0 #define CPUID_EAX_VALID_SECS_ATTRIBUTES_0_BIT                        0
#defineCpuidEaxValidSecsAttributes0Flag0xFfffffff #define CPUID_EAX_VALID_SECS_ATTRIBUTES_0_FLAG                       0xFFFFFFFF
#defineCpuidEaxValidSecsAttributes0Mask0xFfffffff #define CPUID_EAX_VALID_SECS_ATTRIBUTES_0_MASK                       0xFFFFFFFF
#defineCpuidEaxValidSecsAttributes0()((()>>0)&0xFfffffff) #define CPUID_EAX_VALID_SECS_ATTRIBUTES_0(_)                         (((_) >> 0) & 0xFFFFFFFF)
}


type  struct{
TypedefStruct typedef struct
Union union
Struct struct
*[Bits3:0]Sub-LeafType0IndicatesThisSub-LeafIsInvalid * [Bits 3:0] Sub-leaf Type 0. Indicates this sub-leaf is invalid.
SubLeafType UINT32
#defineCpuidEaxSubLeafTypeBit0 #define CPUID_EAX_SUB_LEAF_TYPE_BIT                                  0
#defineCpuidEaxSubLeafTypeFlag0x0F #define CPUID_EAX_SUB_LEAF_TYPE_FLAG                                 0x0F
#defineCpuidEaxSubLeafTypeMask0x0F #define CPUID_EAX_SUB_LEAF_TYPE_MASK                                 0x0F
#defineCpuidEaxSubLeafType()((()>>0)&0x0F) #define CPUID_EAX_SUB_LEAF_TYPE(_)                                   (((_) >> 0) & 0x0F)
Reserved1 UINT32
}


type  struct{
TypedefStruct typedef struct
Union union
Struct struct
*[Bits3:0]Sub-LeafType1ThisSub-LeafEnumeratesAnEpcSectionEbx:EaxAndEdx:EcxProvideInformationOnThe * [Bits 3:0] Sub-leaf Type 1. This sub-leaf enumerates an EPC section. EBX:EAX and EDX:ECX provide information on the
*EnclavePageCache(Epc)Section * Enclave Page Cache (EPC) section.
SubLeafType UINT32
#defineCpuidEaxSubLeafTypeBit0 #define CPUID_EAX_SUB_LEAF_TYPE_BIT                                  0
#defineCpuidEaxSubLeafTypeFlag0x0F #define CPUID_EAX_SUB_LEAF_TYPE_FLAG                                 0x0F
#defineCpuidEaxSubLeafTypeMask0x0F #define CPUID_EAX_SUB_LEAF_TYPE_MASK                                 0x0F
#defineCpuidEaxSubLeafType()((()>>0)&0x0F) #define CPUID_EAX_SUB_LEAF_TYPE(_)                                   (((_) >> 0) & 0x0F)
Reserved1 UINT32
*[Bits31:12]Bits31:12OfThePhysicalAddressOfTheBaseOfTheEpcSection * [Bits 31:12] Bits 31:12 of the physical address of the base of the EPC section.
EpcBasePhysicalAddress1 UINT32
#defineCpuidEaxEpcBasePhysicalAddress1Bit12 #define CPUID_EAX_EPC_BASE_PHYSICAL_ADDRESS_1_BIT                    12
#defineCpuidEaxEpcBasePhysicalAddress1Flag0xFffff000 #define CPUID_EAX_EPC_BASE_PHYSICAL_ADDRESS_1_FLAG                   0xFFFFF000
#defineCpuidEaxEpcBasePhysicalAddress1Mask0xFffff #define CPUID_EAX_EPC_BASE_PHYSICAL_ADDRESS_1_MASK                   0xFFFFF
#defineCpuidEaxEpcBasePhysicalAddress1()((()>>12)&0xFffff) #define CPUID_EAX_EPC_BASE_PHYSICAL_ADDRESS_1(_)                     (((_) >> 12) & 0xFFFFF)
}


type  struct{
TypedefStruct typedef struct
Union union
Struct struct
*[Bits31:0]ReportsTheMaximumSub-LeafSupportedInLeaf14H * [Bits 31:0] Reports the maximum sub-leaf supported in leaf 14H.
MaxSubLeaf UINT32
#defineCpuidEaxMaxSubLeafBit0 #define CPUID_EAX_MAX_SUB_LEAF_BIT                                   0
#defineCpuidEaxMaxSubLeafFlag0xFfffffff #define CPUID_EAX_MAX_SUB_LEAF_FLAG                                  0xFFFFFFFF
#defineCpuidEaxMaxSubLeafMask0xFfffffff #define CPUID_EAX_MAX_SUB_LEAF_MASK                                  0xFFFFFFFF
#defineCpuidEaxMaxSubLeaf()((()>>0)&0xFfffffff) #define CPUID_EAX_MAX_SUB_LEAF(_)                                    (((_) >> 0) & 0xFFFFFFFF)
}


type  struct{
TypedefStruct typedef struct
Union union
Struct struct
*[Bits2:0]NumberOfConfigurableAddressRangesForFiltering * [Bits 2:0] Number of configurable Address Ranges for filtering.
NumberOfConfigurableAddressRangesForFiltering UINT32
#defineCpuidEaxNumberOfConfigurableAddressRangesForFilteringBit0 #define CPUID_EAX_NUMBER_OF_CONFIGURABLE_ADDRESS_RANGES_FOR_FILTERING_BIT 0
#defineCpuidEaxNumberOfConfigurableAddressRangesForFilteringFlag0x07 #define CPUID_EAX_NUMBER_OF_CONFIGURABLE_ADDRESS_RANGES_FOR_FILTERING_FLAG 0x07
#defineCpuidEaxNumberOfConfigurableAddressRangesForFilteringMask0x07 #define CPUID_EAX_NUMBER_OF_CONFIGURABLE_ADDRESS_RANGES_FOR_FILTERING_MASK 0x07
#defineCpuidEaxNumberOfConfigurableAddressRangesForFiltering()((()>>0)&0x07) #define CPUID_EAX_NUMBER_OF_CONFIGURABLE_ADDRESS_RANGES_FOR_FILTERING(_) (((_) >> 0) & 0x07)
Reserved1 UINT32
*[Bits31:16]BitmapOfSupportedMtcPeriodEncodings * [Bits 31:16] Bitmap of supported MTC period encodings.
BitmapOfSupportedMtcPeriodEncodings UINT32
#defineCpuidEaxBitmapOfSupportedMtcPeriodEncodingsBit16 #define CPUID_EAX_BITMAP_OF_SUPPORTED_MTC_PERIOD_ENCODINGS_BIT       16
#defineCpuidEaxBitmapOfSupportedMtcPeriodEncodingsFlag0xFfff0000 #define CPUID_EAX_BITMAP_OF_SUPPORTED_MTC_PERIOD_ENCODINGS_FLAG      0xFFFF0000
#defineCpuidEaxBitmapOfSupportedMtcPeriodEncodingsMask0xFfff #define CPUID_EAX_BITMAP_OF_SUPPORTED_MTC_PERIOD_ENCODINGS_MASK      0xFFFF
#defineCpuidEaxBitmapOfSupportedMtcPeriodEncodings()((()>>16)&0xFfff) #define CPUID_EAX_BITMAP_OF_SUPPORTED_MTC_PERIOD_ENCODINGS(_)        (((_) >> 16) & 0xFFFF)
}


type  struct{
TypedefStruct typedef struct
Union union
Struct struct
*[Bits31:0]AnUnsignedIntegerWhichIsTheDenominatorOfTheTscCoreCrystalClockRatio * [Bits 31:0] An unsigned integer which is the denominator of the TSC/"core crystal clock" ratio.
Denominator UINT32
#defineCpuidEaxDenominatorBit0 #define CPUID_EAX_DENOMINATOR_BIT                                    0
#defineCpuidEaxDenominatorFlag0xFfffffff #define CPUID_EAX_DENOMINATOR_FLAG                                   0xFFFFFFFF
#defineCpuidEaxDenominatorMask0xFfffffff #define CPUID_EAX_DENOMINATOR_MASK                                   0xFFFFFFFF
#defineCpuidEaxDenominator()((()>>0)&0xFfffffff) #define CPUID_EAX_DENOMINATOR(_)                                     (((_) >> 0) & 0xFFFFFFFF)
}


type  struct{
TypedefStruct typedef struct
Union union
Struct struct
*[Bits15:0]ProcessorBaseFrequency(InMHz) * [Bits 15:0] Processor Base Frequency (in MHz).
ProcesorBaseFrequencyMhz UINT32
#defineCpuidEaxProcesorBaseFrequencyMhzBit0 #define CPUID_EAX_PROCESOR_BASE_FREQUENCY_MHZ_BIT                    0
#defineCpuidEaxProcesorBaseFrequencyMhzFlag0xFfff #define CPUID_EAX_PROCESOR_BASE_FREQUENCY_MHZ_FLAG                   0xFFFF
#defineCpuidEaxProcesorBaseFrequencyMhzMask0xFfff #define CPUID_EAX_PROCESOR_BASE_FREQUENCY_MHZ_MASK                   0xFFFF
#defineCpuidEaxProcesorBaseFrequencyMhz()((()>>0)&0xFfff) #define CPUID_EAX_PROCESOR_BASE_FREQUENCY_MHZ(_)                     (((_) >> 0) & 0xFFFF)
Reserved1 UINT32
}


type  struct{
TypedefStruct typedef struct
Union union
Struct struct
*[Bits31:0]ReportsTheMaximumInputValueOfSupportedSub-LeafInLeaf17H * [Bits 31:0] Reports the maximum input value of supported sub-leaf in leaf 17H.
MaxSocIdIndex UINT32
#defineCpuidEaxMaxSocIdIndexBit0 #define CPUID_EAX_MAX_SOC_ID_INDEX_BIT                               0
#defineCpuidEaxMaxSocIdIndexFlag0xFfffffff #define CPUID_EAX_MAX_SOC_ID_INDEX_FLAG                              0xFFFFFFFF
#defineCpuidEaxMaxSocIdIndexMask0xFfffffff #define CPUID_EAX_MAX_SOC_ID_INDEX_MASK                              0xFFFFFFFF
#defineCpuidEaxMaxSocIdIndex()((()>>0)&0xFfffffff) #define CPUID_EAX_MAX_SOC_ID_INDEX(_)                                (((_) >> 0) & 0xFFFFFFFF)
}


type  struct{
TypedefStruct typedef struct
Union union
Struct struct
*[Bits31:0]SocVendorBrandStringUtf-8EncodedString * [Bits 31:0] SOC Vendor Brand String. UTF-8 encoded string.
SocVendorBrandString UINT32
#defineCpuidEaxSocVendorBrandStringBit0 #define CPUID_EAX_SOC_VENDOR_BRAND_STRING_BIT                        0
#defineCpuidEaxSocVendorBrandStringFlag0xFfffffff #define CPUID_EAX_SOC_VENDOR_BRAND_STRING_FLAG                       0xFFFFFFFF
#defineCpuidEaxSocVendorBrandStringMask0xFfffffff #define CPUID_EAX_SOC_VENDOR_BRAND_STRING_MASK                       0xFFFFFFFF
#defineCpuidEaxSocVendorBrandString()((()>>0)&0xFfffffff) #define CPUID_EAX_SOC_VENDOR_BRAND_STRING(_)                         (((_) >> 0) & 0xFFFFFFFF)
}


type  struct{
TypedefStruct typedef struct
Union union
Struct struct
*[Bits31:0]Reserved=0 * [Bits 31:0] Reserved = 0.
Reserved UINT32
#defineCpuidEaxReservedBit0 #define CPUID_EAX_RESERVED_BIT                                       0
#defineCpuidEaxReservedFlag0xFfffffff #define CPUID_EAX_RESERVED_FLAG                                      0xFFFFFFFF
#defineCpuidEaxReservedMask0xFfffffff #define CPUID_EAX_RESERVED_MASK                                      0xFFFFFFFF
#defineCpuidEaxReserved()((()>>0)&0xFfffffff) #define CPUID_EAX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
}


type  struct{
TypedefStruct typedef struct
Union union
Struct struct
*[Bits31:0]ReportsTheMaximumInputValueOfSupportedSub-LeafInLeaf18H * [Bits 31:0] Reports the maximum input value of supported sub-leaf in leaf 18H.
MaxSubLeaf UINT32
#defineCpuidEaxMaxSubLeafBit0 #define CPUID_EAX_MAX_SUB_LEAF_BIT                                   0
#defineCpuidEaxMaxSubLeafFlag0xFfffffff #define CPUID_EAX_MAX_SUB_LEAF_FLAG                                  0xFFFFFFFF
#defineCpuidEaxMaxSubLeafMask0xFfffffff #define CPUID_EAX_MAX_SUB_LEAF_MASK                                  0xFFFFFFFF
#defineCpuidEaxMaxSubLeaf()((()>>0)&0xFfffffff) #define CPUID_EAX_MAX_SUB_LEAF(_)                                    (((_) >> 0) & 0xFFFFFFFF)
}


type  struct{
TypedefStruct typedef struct
Union union
Struct struct
*[Bits31:0]EaxIsReserved * [Bits 31:0] EAX is reserved.
Reserved UINT32
#defineCpuidEaxReservedBit0 #define CPUID_EAX_RESERVED_BIT                                       0
#defineCpuidEaxReservedFlag0xFfffffff #define CPUID_EAX_RESERVED_FLAG                                      0xFFFFFFFF
#defineCpuidEaxReservedMask0xFfffffff #define CPUID_EAX_RESERVED_MASK                                      0xFFFFFFFF
#defineCpuidEaxReserved()((()>>0)&0xFfffffff) #define CPUID_EAX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
}


type  struct{
TypedefStruct typedef struct
Union union
Struct struct
*[Bits31:0]MaximumInputValueForExtendedFunctionCpuidInformation * [Bits 31:0] Maximum Input Value for Extended Function CPUID Information.
MaxExtendedFunctions UINT32
#defineCpuidEaxMaxExtendedFunctionsBit0 #define CPUID_EAX_MAX_EXTENDED_FUNCTIONS_BIT                         0
#defineCpuidEaxMaxExtendedFunctionsFlag0xFfffffff #define CPUID_EAX_MAX_EXTENDED_FUNCTIONS_FLAG                        0xFFFFFFFF
#defineCpuidEaxMaxExtendedFunctionsMask0xFfffffff #define CPUID_EAX_MAX_EXTENDED_FUNCTIONS_MASK                        0xFFFFFFFF
#defineCpuidEaxMaxExtendedFunctions()((()>>0)&0xFfffffff) #define CPUID_EAX_MAX_EXTENDED_FUNCTIONS(_)                          (((_) >> 0) & 0xFFFFFFFF)
}


type  struct{
TypedefStruct typedef struct
Union union
Struct struct
*[Bits31:0]EaxIsReserved * [Bits 31:0] EAX is reserved.
Reserved UINT32
#defineCpuidEaxReservedBit0 #define CPUID_EAX_RESERVED_BIT                                       0
#defineCpuidEaxReservedFlag0xFfffffff #define CPUID_EAX_RESERVED_FLAG                                      0xFFFFFFFF
#defineCpuidEaxReservedMask0xFfffffff #define CPUID_EAX_RESERVED_MASK                                      0xFFFFFFFF
#defineCpuidEaxReserved()((()>>0)&0xFfffffff) #define CPUID_EAX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
}


type  struct{
TypedefStruct typedef struct
Union union
Struct struct
*[Bits31:0]ProcessorBrandString * [Bits 31:0] Processor Brand String.
ProcessorBrandString1 UINT32
#defineCpuidEaxProcessorBrandString1Bit0 #define CPUID_EAX_PROCESSOR_BRAND_STRING_1_BIT                       0
#defineCpuidEaxProcessorBrandString1Flag0xFfffffff #define CPUID_EAX_PROCESSOR_BRAND_STRING_1_FLAG                      0xFFFFFFFF
#defineCpuidEaxProcessorBrandString1Mask0xFfffffff #define CPUID_EAX_PROCESSOR_BRAND_STRING_1_MASK                      0xFFFFFFFF
#defineCpuidEaxProcessorBrandString1()((()>>0)&0xFfffffff) #define CPUID_EAX_PROCESSOR_BRAND_STRING_1(_)                        (((_) >> 0) & 0xFFFFFFFF)
}


type  struct{
TypedefStruct typedef struct
Union union
Struct struct
*[Bits31:0]ProcessorBrandStringContinued * [Bits 31:0] Processor Brand String Continued.
ProcessorBrandString5 UINT32
#defineCpuidEaxProcessorBrandString5Bit0 #define CPUID_EAX_PROCESSOR_BRAND_STRING_5_BIT                       0
#defineCpuidEaxProcessorBrandString5Flag0xFfffffff #define CPUID_EAX_PROCESSOR_BRAND_STRING_5_FLAG                      0xFFFFFFFF
#defineCpuidEaxProcessorBrandString5Mask0xFfffffff #define CPUID_EAX_PROCESSOR_BRAND_STRING_5_MASK                      0xFFFFFFFF
#defineCpuidEaxProcessorBrandString5()((()>>0)&0xFfffffff) #define CPUID_EAX_PROCESSOR_BRAND_STRING_5(_)                        (((_) >> 0) & 0xFFFFFFFF)
}


type  struct{
TypedefStruct typedef struct
Union union
Struct struct
*[Bits31:0]ProcessorBrandStringContinued * [Bits 31:0] Processor Brand String Continued.
ProcessorBrandString9 UINT32
#defineCpuidEaxProcessorBrandString9Bit0 #define CPUID_EAX_PROCESSOR_BRAND_STRING_9_BIT                       0
#defineCpuidEaxProcessorBrandString9Flag0xFfffffff #define CPUID_EAX_PROCESSOR_BRAND_STRING_9_FLAG                      0xFFFFFFFF
#defineCpuidEaxProcessorBrandString9Mask0xFfffffff #define CPUID_EAX_PROCESSOR_BRAND_STRING_9_MASK                      0xFFFFFFFF
#defineCpuidEaxProcessorBrandString9()((()>>0)&0xFfffffff) #define CPUID_EAX_PROCESSOR_BRAND_STRING_9(_)                        (((_) >> 0) & 0xFFFFFFFF)
}


type  struct{
TypedefStruct typedef struct
Union union
Struct struct
*[Bits31:0]EaxIsReserved * [Bits 31:0] EAX is reserved.
Reserved UINT32
#defineCpuidEaxReservedBit0 #define CPUID_EAX_RESERVED_BIT                                       0
#defineCpuidEaxReservedFlag0xFfffffff #define CPUID_EAX_RESERVED_FLAG                                      0xFFFFFFFF
#defineCpuidEaxReservedMask0xFfffffff #define CPUID_EAX_RESERVED_MASK                                      0xFFFFFFFF
#defineCpuidEaxReserved()((()>>0)&0xFfffffff) #define CPUID_EAX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
}


type  struct{
TypedefStruct typedef struct
Union union
Struct struct
*[Bits31:0]EaxIsReserved * [Bits 31:0] EAX is reserved.
Reserved UINT32
#defineCpuidEaxReservedBit0 #define CPUID_EAX_RESERVED_BIT                                       0
#defineCpuidEaxReservedFlag0xFfffffff #define CPUID_EAX_RESERVED_FLAG                                      0xFFFFFFFF
#defineCpuidEaxReservedMask0xFfffffff #define CPUID_EAX_RESERVED_MASK                                      0xFFFFFFFF
#defineCpuidEaxReserved()((()>>0)&0xFfffffff) #define CPUID_EAX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
}


type  struct{
TypedefStruct typedef struct
Union union
Struct struct
*[Bits31:0]EaxIsReserved * [Bits 31:0] EAX is reserved.
Reserved UINT32
#defineCpuidEaxReservedBit0 #define CPUID_EAX_RESERVED_BIT                                       0
#defineCpuidEaxReservedFlag0xFfffffff #define CPUID_EAX_RESERVED_FLAG                                      0xFFFFFFFF
#defineCpuidEaxReservedMask0xFfffffff #define CPUID_EAX_RESERVED_MASK                                      0xFFFFFFFF
#defineCpuidEaxReserved()((()>>0)&0xFfffffff) #define CPUID_EAX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
}


type  struct{
TypedefStruct typedef struct
Union union
Struct struct
*[Bits7:0]NumberOfPhysicalAddressBits * [Bits 7:0] Number of Physical Address Bits.
NumberOfPhysicalAddressBits UINT32
#defineCpuidEaxNumberOfPhysicalAddressBitsBit0 #define CPUID_EAX_NUMBER_OF_PHYSICAL_ADDRESS_BITS_BIT                0
#defineCpuidEaxNumberOfPhysicalAddressBitsFlag0xFf #define CPUID_EAX_NUMBER_OF_PHYSICAL_ADDRESS_BITS_FLAG               0xFF
#defineCpuidEaxNumberOfPhysicalAddressBitsMask0xFf #define CPUID_EAX_NUMBER_OF_PHYSICAL_ADDRESS_BITS_MASK               0xFF
#defineCpuidEaxNumberOfPhysicalAddressBits()((()>>0)&0xFf) #define CPUID_EAX_NUMBER_OF_PHYSICAL_ADDRESS_BITS(_)                 (((_) >> 0) & 0xFF)
*[Bits15:8]NumberOfLinearAddressBits * [Bits 15:8] Number of Linear Address Bits.
NumberOfLinearAddressBits UINT32
#defineCpuidEaxNumberOfLinearAddressBitsBit8 #define CPUID_EAX_NUMBER_OF_LINEAR_ADDRESS_BITS_BIT                  8
#defineCpuidEaxNumberOfLinearAddressBitsFlag0xFf00 #define CPUID_EAX_NUMBER_OF_LINEAR_ADDRESS_BITS_FLAG                 0xFF00
#defineCpuidEaxNumberOfLinearAddressBitsMask0xFf #define CPUID_EAX_NUMBER_OF_LINEAR_ADDRESS_BITS_MASK                 0xFF
#defineCpuidEaxNumberOfLinearAddressBits()((()>>8)&0xFf) #define CPUID_EAX_NUMBER_OF_LINEAR_ADDRESS_BITS(_)                   (((_) >> 8) & 0xFF)
Reserved1 UINT32
}


type  struct{
TypedefStruct typedef struct
*LocalOffsetValueOfTheIa32TscForALogicalProcessorResetValueIsZeroAWriteToIa32TscWillModifyThe * Local offset value of the IA32_TSC for a logical processor. Reset value is zero. A write to IA32_TSC will modify the
*LocalOffsetInIa32TscAdjustAndTheContentOfIa32Tsc,ButDoesNotAffectTheInternalInvariantTscHardware * local offset in IA32_TSC_ADJUST and the content of IA32_TSC, but does not affect the internal invariant TSC hardware.
ThreadAdjust uint64
}


type  struct{
TypedefStruct typedef struct
* *
*DifferentProcessorsMayUseDifferentMsegRevisionIdentifiersTheseIdentifiersEnableSoftwareToAvoidUsingAn * Different processors may use different MSEG revision identifiers. These identifiers enable software to avoid using an
*MsegHeaderFormattedForOneProcessorOnAProcessorThatUsesADifferentFormatSoftwareCanDiscoverTheMseg * MSEG header formatted for one processor on a processor that uses a different format. Software can discover the MSEG
*RevisionIdentifierThatAProcessorUsesByReadingTheVmxCapabilityMsrIa32VmxMisc * revision identifier that a processor uses by reading the VMX capability MSR IA32_VMX_MISC.
* *
MsegHeaderRevision UINT32
* *
*Bits31:1OfThisFieldAreReservedAndMustBeZeroBit0OfTheFieldIsTheIa-32eModeSmmFeatureBitIt * Bits 31:1 of this field are reserved and must be zero. Bit 0 of the field is the IA-32e mode SMM feature bit. It
*IndicatesWhetherTheLogicalProcessorWillBeInIa-32eModeAfterTheStmIsActivated * indicates whether the logical processor will be in IA-32e mode after the STM is activated.
* *
MonitorFeatures UINT32
*DefineValuesForTheMonitorFeaturesFieldOfMsegHeader * Define values for the MonitorFeatures field of MSEG_HEADER.
#defineIa32StmFeaturesIa32E0x00000001 #define IA32_STM_FEATURES_IA32E                                      0x00000001
*FieldsThatDetermineHowProcessorStateIsLoadedWhenTheStmIsActivatedSmmCodeShouldEstablishTheseFieldsSo * Fields that determine how processor state is loaded when the STM is activated. SMM code should establish these fields so
*ThatActivatingOfTheStmInvokesTheStm'SInitializationCode * that activating of the STM invokes the STM's initialization code.
* *
GdtrLimit UINT32
GdtrBaseOffset UINT32
CsSelector UINT32
EipOffset UINT32
EspOffset UINT32
Cr3Offset UINT32
}


type  struct{
TypedefStruct typedef struct
* *
*IncrementsAtFixedInterval(RelativeToTscFreq)WhenTheLogicalProcessorIsInC0ClearedUponOverflow * Increments at fixed interval (relative to TSC freq.) when the logical processor is in C0. Cleared upon overflow /
*Wrap-AroundOfIa32Aperf * wrap-around of IA32_APERF.
C0Mcnt uint64
}


type  struct{
TypedefStruct typedef struct
* *
*AccumulatesCoreClockCountsAtTheCoordinatedClockFrequency,WhenTheLogicalProcessorIsInC0ClearedUpon * Accumulates core clock counts at the coordinated clock frequency, when the logical processor is in C0. Cleared upon
*OverflowWrap-AroundOfIa32Mperf * overflow / wrap-around of IA32_MPERF.
C0Acnt uint64
}


type  struct{
TypedefStruct typedef struct
* *
*StalledCyclesDueToHdcForcedIdleOnThisLogicalProcessor * Stalled cycles due to HDC forced idle on this logical processor.
* *
StallCycleCount uint64
}


type  struct{
TypedefStruct typedef struct
*Limit * Limit.
Limit UINT16
*BaseAddress * Base Address.
BaseAddress UINT32
}


type  struct{
TypedefStruct typedef struct
*Limit * Limit.
Limit UINT16
*BaseAddress * Base Address.
BaseAddress uint64
}


type  struct{
TypedefStruct typedef struct
* *
*SpecifiesTheSizeOfTheSegmentTheProcessorPutsTogetherTheTwoSegmentLimitFieldsToFormA20-BitValueThe * Specifies the size of the segment. The processor puts together the two segment limit fields to form a 20-bit value. The
*ProcessorInterpretsTheSegmentLimitInOneOfTwoWays,DependingOnTheSettingOfTheG(Granularity)Flag: * processor interprets the segment limit in one of two ways, depending on the setting of the G (granularity) flag:
*-IfTheGranularityFlagIsClear,TheSegmentSizeCanRangeFrom1ByteTo1MByte,InByteIncrements * - If the granularity flag is clear, the segment size can range from 1 byte to 1 MByte, in byte increments.
*-IfTheGranularityFlagIsSet,TheSegmentSizeCanRangeFrom4KBytesTo4GBytes,In4-KByteIncrements * - If the granularity flag is set, the segment size can range from 4 KBytes to 4 GBytes, in 4-KByte increments.
*TheProcessorUsesTheSegmentLimitInTwoDifferentWays,DependingOnWhetherTheSegmentIsAnExpand-UpOrAn * The processor uses the segment limit in two different ways, depending on whether the segment is an expand-up or an
*Expand-DownSegmentForExpand-UpSegments,TheOffsetInALogicalAddressCanRangeFrom0ToTheSegmentLimit * expand-down segment. For expand-up segments, the offset in a logical address can range from 0 to the segment limit.
*OffsetsGreaterThanTheSegmentLimitGenerateGeneral-ProtectionExceptions(\#Gp,ForAllSegmentsOtherThanSs)Or * Offsets greater than the segment limit generate general-protection exceptions (\#GP, for all segments other than SS) or
stack-fault *
*TheOffsetCanRangeFromTheSegmentLimitPlus1ToFfffffffhOrFfffh,DependingOnTheSettingOfTheBFlag * the offset can range from the segment limit plus 1 to FFFFFFFFH or FFFFH, depending on the setting of the B flag.
*OffsetsLessThanOrEqualToTheSegmentLimitGenerateGeneral-ProtectionExceptionsOrStack-FaultExceptions * Offsets less than or equal to the segment limit generate general-protection exceptions or stack-fault exceptions.
*DecreasingTheValueInTheSegmentLimitFieldForAnExpanddownSegmentAllocatesNewMemoryAtTheBottomOfThe * Decreasing the value in the segment limit field for an expanddown segment allocates new memory at the bottom of the
*Segment'SAddressSpace,RatherThanAtTheTopIa-32ArchitectureStacksAlwaysGrowDownwards,MakingThisMechanism * segment's address space, rather than at the top. IA-32 architecture stacks always grow downwards, making this mechanism
*ConvenientForExpandableStacks * convenient for expandable stacks.
* *
SegmentLimitLow UINT16
* *
*DefinesTheLocationOfByte0OfTheSegmentWithinThe4-GByteLinearAddressSpaceTheProcessorPutsTogetherThe * Defines the location of byte 0 of the segment within the 4-GByte linear address space. The processor puts together the
*ThreeBaseAddressFieldsToFormASingle32-BitValueSegmentBaseAddressesShouldBeAlignedTo16-ByteBoundaries * three base address fields to form a single 32-bit value. Segment base addresses should be aligned to 16-byte boundaries.
*Although16-ByteAlignmentIsNotRequired,ThisAlignmentAllowsProgramsToMaximizePerformanceByAligningCodeAnd * Although 16-byte alignment is not required, this alignment allows programs to maximize performance by aligning code and
*DataOn16-ByteBoundaries * data on 16-byte boundaries.
BaseAddressLow UINT16
Union union
Struct struct
[Bits *
BaseAddressMiddle UINT32
#defineSegmentBaseAddressMiddleBit0 #define SEGMENT__BASE_ADDRESS_MIDDLE_BIT                             0
#defineSegmentBaseAddressMiddleFlag0xFf #define SEGMENT__BASE_ADDRESS_MIDDLE_FLAG                            0xFF
#defineSegmentBaseAddressMiddleMask0xFf #define SEGMENT__BASE_ADDRESS_MIDDLE_MASK                            0xFF
#defineSegmentBaseAddressMiddle()((()>>0)&0xFf) #define SEGMENT__BASE_ADDRESS_MIDDLE(_)                              (((_) >> 0) & 0xFF)
* *
*[Bits11:8]IndicatesTheSegmentOrGateTypeAndSpecifiesTheKindsOfAccessThatCanBeMadeToTheSegmentAndThe * [Bits 11:8] Indicates the segment or gate type and specifies the kinds of access that can be made to the segment and the
*DirectionOfGrowthTheInterpretationOfThisFieldDependsOnWhetherTheDescriptorTypeFlagSpecifiesAn * direction of growth. The interpretation of this field depends on whether the descriptor type flag specifies an
*Application(CodeOrData)DescriptorOrASystemDescriptorTheEncodingOfTheTypeFieldIsDifferentForCode, * application (code or data) descriptor or a system descriptor. The encoding of the type field is different for code,
*Data,AndSystemDescriptors * data, and system descriptors.
* *
Type UINT32
#defineSegmentTypeBit8 #define SEGMENT__TYPE_BIT                                            8
#defineSegmentTypeFlag0xF00 #define SEGMENT__TYPE_FLAG                                           0xF00
#defineSegmentTypeMask0x0F #define SEGMENT__TYPE_MASK                                           0x0F
#defineSegmentType()((()>>8)&0x0F) #define SEGMENT__TYPE(_)                                             (((_) >> 8) & 0x0F)
* *
*[Bit12]SpecifiesWhetherTheSegmentDescriptorIsForASystemSegment(SFlagIsClear)OrACodeOrDataSegment(S * [Bit 12] Specifies whether the segment descriptor is for a system segment (S flag is clear) or a code or data segment (S
*FlagIsSet) * flag is set).
DescriptorType UINT32
#defineSegmentDescriptorTypeBit12 #define SEGMENT__DESCRIPTOR_TYPE_BIT                                 12
#defineSegmentDescriptorTypeFlag0x1000 #define SEGMENT__DESCRIPTOR_TYPE_FLAG                                0x1000
#defineSegmentDescriptorTypeMask0x01 #define SEGMENT__DESCRIPTOR_TYPE_MASK                                0x01
#defineSegmentDescriptorType()((()>>12)&0x01) #define SEGMENT__DESCRIPTOR_TYPE(_)                                  (((_) >> 12) & 0x01)
* *
*[Bits14:13]SpecifiesThePrivilegeLevelOfTheSegmentThePrivilegeLevelCanRangeFrom0To3,With0BeingThe * [Bits 14:13] Specifies the privilege level of the segment. The privilege level can range from 0 to 3, with 0 being the
*MostPrivilegedLevelTheDplIsUsedToControlAccessToTheSegmentSeeSection55,PrivilegeLevels,ForA * most privileged level. The DPL is used to control access to the segment. See Section 5.5, "Privilege Levels", for a
*DescriptionOfTheRelationshipOfTheDplToTheCplOfTheExecutingCodeSegmentAndTheRplOfASegmentSelector * description of the relationship of the DPL to the CPL of the executing code segment and the RPL of a segment selector.
DescriptorPrivilegeLevel UINT32
#defineSegmentDescriptorPrivilegeLevelBit13 #define SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL_BIT                      13
#defineSegmentDescriptorPrivilegeLevelFlag0x6000 #define SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL_FLAG                     0x6000
#defineSegmentDescriptorPrivilegeLevelMask0x03 #define SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL_MASK                     0x03
#defineSegmentDescriptorPrivilegeLevel()((()>>13)&0x03) #define SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL(_)                       (((_) >> 13) & 0x03)
* *
*[Bit15]IndicatesWhetherTheSegmentIsPresentInMemory(Set)OrNotPresent(Clear)IfThisFlagIsClear,The * [Bit 15] Indicates whether the segment is present in memory (set) or not present (clear). If this flag is clear, the
*ProcessorGeneratesASegment-Not-PresentException(\#Np)WhenASegmentSelectorThatPointsToTheSegmentDescriptor * processor generates a segment-not-present exception (\#NP) when a segment selector that points to the segment descriptor
*IsLoadedIntoASegmentRegisterMemoryManagementSoftwareCanUseThisFlagToControlWhichSegmentsAreActually * is loaded into a segment register. Memory management software can use this flag to control which segments are actually
*LoadedIntoPhysicalMemoryAtAGivenTimeItOffersAControlInAdditionToPagingForManagingVirtualMemory * loaded into physical memory at a given time. It offers a control in addition to paging for managing virtual memory.
Present UINT32
#defineSegmentPresentBit15 #define SEGMENT__PRESENT_BIT                                         15
#defineSegmentPresentFlag0x8000 #define SEGMENT__PRESENT_FLAG                                        0x8000
#defineSegmentPresentMask0x01 #define SEGMENT__PRESENT_MASK                                        0x01
#defineSegmentPresent()((()>>15)&0x01) #define SEGMENT__PRESENT(_)                                          (((_) >> 15) & 0x01)
[Bits *
SegmentLimitHigh UINT32
#defineSegmentSegmentLimitHighBit16 #define SEGMENT__SEGMENT_LIMIT_HIGH_BIT                              16
#defineSegmentSegmentLimitHighFlag0xF0000 #define SEGMENT__SEGMENT_LIMIT_HIGH_FLAG                             0xF0000
#defineSegmentSegmentLimitHighMask0x0F #define SEGMENT__SEGMENT_LIMIT_HIGH_MASK                             0x0F
#defineSegmentSegmentLimitHigh()((()>>16)&0x0F) #define SEGMENT__SEGMENT_LIMIT_HIGH(_)                               (((_) >> 16) & 0x0F)
* *
*[Bit20]Bit20OfTheSecondDoublewordOfTheSegmentDescriptorIsAvailableForUseBySystemSoftware * [Bit 20] Bit 20 of the second doubleword of the segment descriptor is available for use by system software.
System UINT32
#defineSegmentSystemBit20 #define SEGMENT__SYSTEM_BIT                                          20
#defineSegmentSystemFlag0x100000 #define SEGMENT__SYSTEM_FLAG                                         0x100000
#defineSegmentSystemMask0x01 #define SEGMENT__SYSTEM_MASK                                         0x01
#defineSegmentSystem()((()>>20)&0x01) #define SEGMENT__SYSTEM(_)                                           (((_) >> 20) & 0x01)
* *
*[Bit21]InIa-32eMode,Bit21OfTheSecondDoublewordOfTheSegmentDescriptorIndicatesWhetherACodeSegment * [Bit 21] In IA-32e mode, bit 21 of the second doubleword of the segment descriptor indicates whether a code segment
*ContainsNative64-BitCodeAValueOf1IndicatesInstructionsInThisCodeSegmentAreExecutedIn64-BitModeA * contains native 64-bit code. A value of 1 indicates instructions in this code segment are executed in 64-bit mode. A
*ValueOf0IndicatesTheInstructionsInThisCodeSegmentAreExecutedInCompatibilityModeIfL-BitIsSet,Then * value of 0 indicates the instructions in this code segment are executed in compatibility mode. If L-bit is set, then
*D-BitMustBeClearedWhenNotInIa-32eModeOrForNon-CodeSegments,Bit21IsReservedAndShouldAlwaysBeSetTo * D-bit must be cleared. When not in IA-32e mode or for non-code segments, bit 21 is reserved and should always be set to
*0 * 0.
LongMode UINT32
#defineSegmentLongModeBit21 #define SEGMENT__LONG_MODE_BIT                                       21
#defineSegmentLongModeFlag0x200000 #define SEGMENT__LONG_MODE_FLAG                                      0x200000
#defineSegmentLongModeMask0x01 #define SEGMENT__LONG_MODE_MASK                                      0x01
#defineSegmentLongMode()((()>>21)&0x01) #define SEGMENT__LONG_MODE(_)                                        (((_) >> 21) & 0x01)
* *
*[Bit22]PerformsDifferentFunctionsDependingOnWhetherTheSegmentDescriptorIsAnExecutableCodeSegment,An * [Bit 22] Performs different functions depending on whether the segment descriptor is an executable code segment, an
*Expand-DownDataSegment,OrAStackSegment(ThisFlagShouldAlwaysBeSetTo1For32-BitCodeAndDataSegmentsAnd * expand-down data segment, or a stack segment. (This flag should always be set to 1 for 32-bit code and data segments and
*To0For16-BitCodeAndDataSegments) * to 0 for 16-bit code and data segments.)
*-ExecutableCodeSegmentTheFlagIsCalledTheDFlagAndItIndicatesTheDefaultLengthForEffectiveAddressesAnd * - Executable code segment. The flag is called the D flag and it indicates the default length for effective addresses and
*OperandsReferencedByInstructionsInTheSegmentIfTheFlagIsSet,32-BitAddressesAnd32-BitOr8-BitOperands * operands referenced by instructions in the segment. If the flag is set, 32-bit addresses and 32-bit or 8-bit operands
are *
*BeUsedToSelectAnOperandSizeOtherThanTheDefault,AndThePrefix67HCanBeUsedSelectAnAddressSizeOther * be used to select an operand size other than the default, and the prefix 67H can be used select an address size other
*ThanTheDefault * than the default.
*-StackSegment(DataSegmentPointedToByTheSsRegister)TheFlagIsCalledTheB(Big)FlagAndItSpecifiesThe * - Stack segment (data segment pointed to by the SS register). The flag is called the B (big) flag and it specifies the
*SizeOfTheStackPointerUsedForImplicitStackOperations(SuchAsPushes,Pops,AndCalls)IfTheFlagIsSet,A * size of the stack pointer used for implicit stack operations (such as pushes, pops, and calls). If the flag is set, a
32-bit *
*IsUsed,WhichIsStoredInThe16-BitSpRegisterIfTheStackSegmentIsSetUpToBeAnExpand-DownDataSegment * is used, which is stored in the 16- bit SP register. If the stack segment is set up to be an expand-down data segment
*(DescribedInTheNextParagraph),TheBFlagAlsoSpecifiesTheUpperBoundOfTheStackSegment * (described in the next paragraph), the B flag also specifies the upper bound of the stack segment.
*-Expand-DownDataSegmentTheFlagIsCalledTheBFlagAndItSpecifiesTheUpperBoundOfTheSegmentIfTheFlag * - Expand-down data segment. The flag is called the B flag and it specifies the upper bound of the segment. If the flag
is *
DefaultBig UINT32
#defineSegmentDefaultBigBit22 #define SEGMENT__DEFAULT_BIG_BIT                                     22
#defineSegmentDefaultBigFlag0x400000 #define SEGMENT__DEFAULT_BIG_FLAG                                    0x400000
#defineSegmentDefaultBigMask0x01 #define SEGMENT__DEFAULT_BIG_MASK                                    0x01
#defineSegmentDefaultBig()((()>>22)&0x01) #define SEGMENT__DEFAULT_BIG(_)                                      (((_) >> 22) & 0x01)
* *
*[Bit23]DeterminesTheScalingOfTheSegmentLimitFieldWhenTheGranularityFlagIsClear,TheSegmentLimitIs * [Bit 23] Determines the scaling of the segment limit field. When the granularity flag is clear, the segment limit is
interpreted *
affect *
*LeastSignificantBitsOfAnOffsetAreNotTestedWhenCheckingTheOffsetAgainstTheSegmentLimitForExample,When * least significant bits of an offset are not tested when checking the offset against the segment limit. For example, when
*TheGranularityFlagIsSet,ALimitOf0ResultsInValidOffsetsFrom0To4095 * the granularity flag is set, a limit of 0 results in valid offsets from 0 to 4095.
Granularity UINT32
#defineSegmentGranularityBit23 #define SEGMENT__GRANULARITY_BIT                                     23
#defineSegmentGranularityFlag0x800000 #define SEGMENT__GRANULARITY_FLAG                                    0x800000
#defineSegmentGranularityMask0x01 #define SEGMENT__GRANULARITY_MASK                                    0x01
#defineSegmentGranularity()((()>>23)&0x01) #define SEGMENT__GRANULARITY(_)                                      (((_) >> 23) & 0x01)
[Bits *
BaseAddressHigh UINT32
#defineSegmentBaseAddressHighBit24 #define SEGMENT__BASE_ADDRESS_HIGH_BIT                               24
#defineSegmentBaseAddressHighFlag0xFf000000 #define SEGMENT__BASE_ADDRESS_HIGH_FLAG                              0xFF000000
#defineSegmentBaseAddressHighMask0xFf #define SEGMENT__BASE_ADDRESS_HIGH_MASK                              0xFF
#defineSegmentBaseAddressHigh()((()>>24)&0xFf) #define SEGMENT__BASE_ADDRESS_HIGH(_)                                (((_) >> 24) & 0xFF)
}


type  struct{
TypedefStruct typedef struct
* *
*SpecifiesTheSizeOfTheSegmentTheProcessorPutsTogetherTheTwoSegmentLimitFieldsToFormA20-BitValueThe * Specifies the size of the segment. The processor puts together the two segment limit fields to form a 20-bit value. The
*ProcessorInterpretsTheSegmentLimitInOneOfTwoWays,DependingOnTheSettingOfTheG(Granularity)Flag: * processor interprets the segment limit in one of two ways, depending on the setting of the G (granularity) flag:
*-IfTheGranularityFlagIsClear,TheSegmentSizeCanRangeFrom1ByteTo1MByte,InByteIncrements * - If the granularity flag is clear, the segment size can range from 1 byte to 1 MByte, in byte increments.
*-IfTheGranularityFlagIsSet,TheSegmentSizeCanRangeFrom4KBytesTo4GBytes,In4-KByteIncrements * - If the granularity flag is set, the segment size can range from 4 KBytes to 4 GBytes, in 4-KByte increments.
*TheProcessorUsesTheSegmentLimitInTwoDifferentWays,DependingOnWhetherTheSegmentIsAnExpand-UpOrAn * The processor uses the segment limit in two different ways, depending on whether the segment is an expand-up or an
*Expand-DownSegmentForExpand-UpSegments,TheOffsetInALogicalAddressCanRangeFrom0ToTheSegmentLimit * expand-down segment. For expand-up segments, the offset in a logical address can range from 0 to the segment limit.
*OffsetsGreaterThanTheSegmentLimitGenerateGeneral-ProtectionExceptions(\#Gp,ForAllSegmentsOtherThanSs)Or * Offsets greater than the segment limit generate general-protection exceptions (\#GP, for all segments other than SS) or
stack-fault *
*TheOffsetCanRangeFromTheSegmentLimitPlus1ToFfffffffhOrFfffh,DependingOnTheSettingOfTheBFlag * the offset can range from the segment limit plus 1 to FFFFFFFFH or FFFFH, depending on the setting of the B flag.
*OffsetsLessThanOrEqualToTheSegmentLimitGenerateGeneral-ProtectionExceptionsOrStack-FaultExceptions * Offsets less than or equal to the segment limit generate general-protection exceptions or stack-fault exceptions.
*DecreasingTheValueInTheSegmentLimitFieldForAnExpanddownSegmentAllocatesNewMemoryAtTheBottomOfThe * Decreasing the value in the segment limit field for an expanddown segment allocates new memory at the bottom of the
*Segment'SAddressSpace,RatherThanAtTheTopIa-32ArchitectureStacksAlwaysGrowDownwards,MakingThisMechanism * segment's address space, rather than at the top. IA-32 architecture stacks always grow downwards, making this mechanism
*ConvenientForExpandableStacks * convenient for expandable stacks.
* *
SegmentLimitLow UINT16
* *
*DefinesTheLocationOfByte0OfTheSegmentWithinThe4-GByteLinearAddressSpaceTheProcessorPutsTogetherThe * Defines the location of byte 0 of the segment within the 4-GByte linear address space. The processor puts together the
*ThreeBaseAddressFieldsToFormASingle32-BitValueSegmentBaseAddressesShouldBeAlignedTo16-ByteBoundaries * three base address fields to form a single 32-bit value. Segment base addresses should be aligned to 16-byte boundaries.
*Although16-ByteAlignmentIsNotRequired,ThisAlignmentAllowsProgramsToMaximizePerformanceByAligningCodeAnd * Although 16-byte alignment is not required, this alignment allows programs to maximize performance by aligning code and
*DataOn16-ByteBoundaries * data on 16-byte boundaries.
BaseAddressLow UINT16
Union union
Struct struct
[Bits *
BaseAddressMiddle UINT32
#defineSegmentBaseAddressMiddleBit0 #define SEGMENT__BASE_ADDRESS_MIDDLE_BIT                             0
#defineSegmentBaseAddressMiddleFlag0xFf #define SEGMENT__BASE_ADDRESS_MIDDLE_FLAG                            0xFF
#defineSegmentBaseAddressMiddleMask0xFf #define SEGMENT__BASE_ADDRESS_MIDDLE_MASK                            0xFF
#defineSegmentBaseAddressMiddle()((()>>0)&0xFf) #define SEGMENT__BASE_ADDRESS_MIDDLE(_)                              (((_) >> 0) & 0xFF)
* *
*[Bits11:8]IndicatesTheSegmentOrGateTypeAndSpecifiesTheKindsOfAccessThatCanBeMadeToTheSegmentAndThe * [Bits 11:8] Indicates the segment or gate type and specifies the kinds of access that can be made to the segment and the
*DirectionOfGrowthTheInterpretationOfThisFieldDependsOnWhetherTheDescriptorTypeFlagSpecifiesAn * direction of growth. The interpretation of this field depends on whether the descriptor type flag specifies an
*Application(CodeOrData)DescriptorOrASystemDescriptorTheEncodingOfTheTypeFieldIsDifferentForCode, * application (code or data) descriptor or a system descriptor. The encoding of the type field is different for code,
*Data,AndSystemDescriptors * data, and system descriptors.
* *
Type UINT32
#defineSegmentTypeBit8 #define SEGMENT__TYPE_BIT                                            8
#defineSegmentTypeFlag0xF00 #define SEGMENT__TYPE_FLAG                                           0xF00
#defineSegmentTypeMask0x0F #define SEGMENT__TYPE_MASK                                           0x0F
#defineSegmentType()((()>>8)&0x0F) #define SEGMENT__TYPE(_)                                             (((_) >> 8) & 0x0F)
* *
*[Bit12]SpecifiesWhetherTheSegmentDescriptorIsForASystemSegment(SFlagIsClear)OrACodeOrDataSegment(S * [Bit 12] Specifies whether the segment descriptor is for a system segment (S flag is clear) or a code or data segment (S
*FlagIsSet) * flag is set).
DescriptorType UINT32
#defineSegmentDescriptorTypeBit12 #define SEGMENT__DESCRIPTOR_TYPE_BIT                                 12
#defineSegmentDescriptorTypeFlag0x1000 #define SEGMENT__DESCRIPTOR_TYPE_FLAG                                0x1000
#defineSegmentDescriptorTypeMask0x01 #define SEGMENT__DESCRIPTOR_TYPE_MASK                                0x01
#defineSegmentDescriptorType()((()>>12)&0x01) #define SEGMENT__DESCRIPTOR_TYPE(_)                                  (((_) >> 12) & 0x01)
* *
*[Bits14:13]SpecifiesThePrivilegeLevelOfTheSegmentThePrivilegeLevelCanRangeFrom0To3,With0BeingThe * [Bits 14:13] Specifies the privilege level of the segment. The privilege level can range from 0 to 3, with 0 being the
*MostPrivilegedLevelTheDplIsUsedToControlAccessToTheSegmentSeeSection55,PrivilegeLevels,ForA * most privileged level. The DPL is used to control access to the segment. See Section 5.5, "Privilege Levels", for a
*DescriptionOfTheRelationshipOfTheDplToTheCplOfTheExecutingCodeSegmentAndTheRplOfASegmentSelector * description of the relationship of the DPL to the CPL of the executing code segment and the RPL of a segment selector.
DescriptorPrivilegeLevel UINT32
#defineSegmentDescriptorPrivilegeLevelBit13 #define SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL_BIT                      13
#defineSegmentDescriptorPrivilegeLevelFlag0x6000 #define SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL_FLAG                     0x6000
#defineSegmentDescriptorPrivilegeLevelMask0x03 #define SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL_MASK                     0x03
#defineSegmentDescriptorPrivilegeLevel()((()>>13)&0x03) #define SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL(_)                       (((_) >> 13) & 0x03)
* *
*[Bit15]IndicatesWhetherTheSegmentIsPresentInMemory(Set)OrNotPresent(Clear)IfThisFlagIsClear,The * [Bit 15] Indicates whether the segment is present in memory (set) or not present (clear). If this flag is clear, the
*ProcessorGeneratesASegment-Not-PresentException(\#Np)WhenASegmentSelectorThatPointsToTheSegmentDescriptor * processor generates a segment-not-present exception (\#NP) when a segment selector that points to the segment descriptor
*IsLoadedIntoASegmentRegisterMemoryManagementSoftwareCanUseThisFlagToControlWhichSegmentsAreActually * is loaded into a segment register. Memory management software can use this flag to control which segments are actually
*LoadedIntoPhysicalMemoryAtAGivenTimeItOffersAControlInAdditionToPagingForManagingVirtualMemory * loaded into physical memory at a given time. It offers a control in addition to paging for managing virtual memory.
Present UINT32
#defineSegmentPresentBit15 #define SEGMENT__PRESENT_BIT                                         15
#defineSegmentPresentFlag0x8000 #define SEGMENT__PRESENT_FLAG                                        0x8000
#defineSegmentPresentMask0x01 #define SEGMENT__PRESENT_MASK                                        0x01
#defineSegmentPresent()((()>>15)&0x01) #define SEGMENT__PRESENT(_)                                          (((_) >> 15) & 0x01)
[Bits *
SegmentLimitHigh UINT32
#defineSegmentSegmentLimitHighBit16 #define SEGMENT__SEGMENT_LIMIT_HIGH_BIT                              16
#defineSegmentSegmentLimitHighFlag0xF0000 #define SEGMENT__SEGMENT_LIMIT_HIGH_FLAG                             0xF0000
#defineSegmentSegmentLimitHighMask0x0F #define SEGMENT__SEGMENT_LIMIT_HIGH_MASK                             0x0F
#defineSegmentSegmentLimitHigh()((()>>16)&0x0F) #define SEGMENT__SEGMENT_LIMIT_HIGH(_)                               (((_) >> 16) & 0x0F)
* *
*[Bit20]Bit20OfTheSecondDoublewordOfTheSegmentDescriptorIsAvailableForUseBySystemSoftware * [Bit 20] Bit 20 of the second doubleword of the segment descriptor is available for use by system software.
System UINT32
#defineSegmentSystemBit20 #define SEGMENT__SYSTEM_BIT                                          20
#defineSegmentSystemFlag0x100000 #define SEGMENT__SYSTEM_FLAG                                         0x100000
#defineSegmentSystemMask0x01 #define SEGMENT__SYSTEM_MASK                                         0x01
#defineSegmentSystem()((()>>20)&0x01) #define SEGMENT__SYSTEM(_)                                           (((_) >> 20) & 0x01)
* *
*[Bit21]InIa-32eMode,Bit21OfTheSecondDoublewordOfTheSegmentDescriptorIndicatesWhetherACodeSegment * [Bit 21] In IA-32e mode, bit 21 of the second doubleword of the segment descriptor indicates whether a code segment
*ContainsNative64-BitCodeAValueOf1IndicatesInstructionsInThisCodeSegmentAreExecutedIn64-BitModeA * contains native 64-bit code. A value of 1 indicates instructions in this code segment are executed in 64-bit mode. A
*ValueOf0IndicatesTheInstructionsInThisCodeSegmentAreExecutedInCompatibilityModeIfL-BitIsSet,Then * value of 0 indicates the instructions in this code segment are executed in compatibility mode. If L-bit is set, then
*D-BitMustBeClearedWhenNotInIa-32eModeOrForNon-CodeSegments,Bit21IsReservedAndShouldAlwaysBeSetTo * D-bit must be cleared. When not in IA-32e mode or for non-code segments, bit 21 is reserved and should always be set to
*0 * 0.
LongMode UINT32
#defineSegmentLongModeBit21 #define SEGMENT__LONG_MODE_BIT                                       21
#defineSegmentLongModeFlag0x200000 #define SEGMENT__LONG_MODE_FLAG                                      0x200000
#defineSegmentLongModeMask0x01 #define SEGMENT__LONG_MODE_MASK                                      0x01
#defineSegmentLongMode()((()>>21)&0x01) #define SEGMENT__LONG_MODE(_)                                        (((_) >> 21) & 0x01)
* *
*[Bit22]PerformsDifferentFunctionsDependingOnWhetherTheSegmentDescriptorIsAnExecutableCodeSegment,An * [Bit 22] Performs different functions depending on whether the segment descriptor is an executable code segment, an
*Expand-DownDataSegment,OrAStackSegment(ThisFlagShouldAlwaysBeSetTo1For32-BitCodeAndDataSegmentsAnd * expand-down data segment, or a stack segment. (This flag should always be set to 1 for 32-bit code and data segments and
*To0For16-BitCodeAndDataSegments) * to 0 for 16-bit code and data segments.)
*-ExecutableCodeSegmentTheFlagIsCalledTheDFlagAndItIndicatesTheDefaultLengthForEffectiveAddressesAnd * - Executable code segment. The flag is called the D flag and it indicates the default length for effective addresses and
*OperandsReferencedByInstructionsInTheSegmentIfTheFlagIsSet,32-BitAddressesAnd32-BitOr8-BitOperands * operands referenced by instructions in the segment. If the flag is set, 32-bit addresses and 32-bit or 8-bit operands
are *
*BeUsedToSelectAnOperandSizeOtherThanTheDefault,AndThePrefix67HCanBeUsedSelectAnAddressSizeOther * be used to select an operand size other than the default, and the prefix 67H can be used select an address size other
*ThanTheDefault * than the default.
*-StackSegment(DataSegmentPointedToByTheSsRegister)TheFlagIsCalledTheB(Big)FlagAndItSpecifiesThe * - Stack segment (data segment pointed to by the SS register). The flag is called the B (big) flag and it specifies the
*SizeOfTheStackPointerUsedForImplicitStackOperations(SuchAsPushes,Pops,AndCalls)IfTheFlagIsSet,A * size of the stack pointer used for implicit stack operations (such as pushes, pops, and calls). If the flag is set, a
32-bit *
*IsUsed,WhichIsStoredInThe16-BitSpRegisterIfTheStackSegmentIsSetUpToBeAnExpand-DownDataSegment * is used, which is stored in the 16- bit SP register. If the stack segment is set up to be an expand-down data segment
*(DescribedInTheNextParagraph),TheBFlagAlsoSpecifiesTheUpperBoundOfTheStackSegment * (described in the next paragraph), the B flag also specifies the upper bound of the stack segment.
*-Expand-DownDataSegmentTheFlagIsCalledTheBFlagAndItSpecifiesTheUpperBoundOfTheSegmentIfTheFlag * - Expand-down data segment. The flag is called the B flag and it specifies the upper bound of the segment. If the flag
is *
DefaultBig UINT32
#defineSegmentDefaultBigBit22 #define SEGMENT__DEFAULT_BIG_BIT                                     22
#defineSegmentDefaultBigFlag0x400000 #define SEGMENT__DEFAULT_BIG_FLAG                                    0x400000
#defineSegmentDefaultBigMask0x01 #define SEGMENT__DEFAULT_BIG_MASK                                    0x01
#defineSegmentDefaultBig()((()>>22)&0x01) #define SEGMENT__DEFAULT_BIG(_)                                      (((_) >> 22) & 0x01)
* *
*[Bit23]DeterminesTheScalingOfTheSegmentLimitFieldWhenTheGranularityFlagIsClear,TheSegmentLimitIs * [Bit 23] Determines the scaling of the segment limit field. When the granularity flag is clear, the segment limit is
interpreted *
affect *
*LeastSignificantBitsOfAnOffsetAreNotTestedWhenCheckingTheOffsetAgainstTheSegmentLimitForExample,When * least significant bits of an offset are not tested when checking the offset against the segment limit. For example, when
*TheGranularityFlagIsSet,ALimitOf0ResultsInValidOffsetsFrom0To4095 * the granularity flag is set, a limit of 0 results in valid offsets from 0 to 4095.
Granularity UINT32
#defineSegmentGranularityBit23 #define SEGMENT__GRANULARITY_BIT                                     23
#defineSegmentGranularityFlag0x800000 #define SEGMENT__GRANULARITY_FLAG                                    0x800000
#defineSegmentGranularityMask0x01 #define SEGMENT__GRANULARITY_MASK                                    0x01
#defineSegmentGranularity()((()>>23)&0x01) #define SEGMENT__GRANULARITY(_)                                      (((_) >> 23) & 0x01)
[Bits *
BaseAddressHigh UINT32
#defineSegmentBaseAddressHighBit24 #define SEGMENT__BASE_ADDRESS_HIGH_BIT                               24
#defineSegmentBaseAddressHighFlag0xFf000000 #define SEGMENT__BASE_ADDRESS_HIGH_FLAG                              0xFF000000
#defineSegmentBaseAddressHighMask0xFf #define SEGMENT__BASE_ADDRESS_HIGH_MASK                              0xFF
#defineSegmentBaseAddressHigh()((()>>24)&0xFf) #define SEGMENT__BASE_ADDRESS_HIGH(_)                                (((_) >> 24) & 0xFF)
}


type  struct{
TypedefStruct typedef struct
*OffsetToProcedureEntryPoint(15:00) * Offset to procedure entry point (15:00).
OffsetLow UINT16
*SegmentSelectorForDestinationCodeSegment * Segment selector for destination code segment.
SegmentSelector UINT16
Union union
Struct struct
*[Bits2:0]IndexIntoTheTssInterruptStackTable * [Bits 2:0] Index into the TSS Interrupt Stack Table.
InterruptStackTable UINT32
#defineSegmentInterruptStackTableBit0 #define SEGMENT__INTERRUPT_STACK_TABLE_BIT                           0
#defineSegmentInterruptStackTableFlag0x07 #define SEGMENT__INTERRUPT_STACK_TABLE_FLAG                          0x07
#defineSegmentInterruptStackTableMask0x07 #define SEGMENT__INTERRUPT_STACK_TABLE_MASK                          0x07
#defineSegmentInterruptStackTable()((()>>0)&0x07) #define SEGMENT__INTERRUPT_STACK_TABLE(_)                            (((_) >> 0) & 0x07)
*[Bits7:3]ThisFieldMustBeSetToZero * [Bits 7:3] This field must be set to zero.
MustBeZero0 UINT32
#defineSegmentMustBeZero0Bit3 #define SEGMENT__MUST_BE_ZERO_0_BIT                                  3
#defineSegmentMustBeZero0Flag0xF8 #define SEGMENT__MUST_BE_ZERO_0_FLAG                                 0xF8
#defineSegmentMustBeZero0Mask0x1F #define SEGMENT__MUST_BE_ZERO_0_MASK                                 0x1F
#defineSegmentMustBeZero0()((()>>3)&0x1F) #define SEGMENT__MUST_BE_ZERO_0(_)                                   (((_) >> 3) & 0x1F)
*[Bits11:8]IndicatesTheSegmentOrGateType * [Bits 11:8] Indicates the segment or gate type.
Type UINT32
#defineSegmentTypeBit8 #define SEGMENT__TYPE_BIT                                            8
#defineSegmentTypeFlag0xF00 #define SEGMENT__TYPE_FLAG                                           0xF00
#defineSegmentTypeMask0x0F #define SEGMENT__TYPE_MASK                                           0x0F
#defineSegmentType()((()>>8)&0x0F) #define SEGMENT__TYPE(_)                                             (((_) >> 8) & 0x0F)
*[Bit12]ThisFieldMustBeSetToZero * [Bit 12] This field must be set to zero.
MustBeZero1 UINT32
#defineSegmentMustBeZero1Bit12 #define SEGMENT__MUST_BE_ZERO_1_BIT                                  12
#defineSegmentMustBeZero1Flag0x1000 #define SEGMENT__MUST_BE_ZERO_1_FLAG                                 0x1000
#defineSegmentMustBeZero1Mask0x01 #define SEGMENT__MUST_BE_ZERO_1_MASK                                 0x01
#defineSegmentMustBeZero1()((()>>12)&0x01) #define SEGMENT__MUST_BE_ZERO_1(_)                                   (((_) >> 12) & 0x01)
*[Bits14:13]SpecifiesTheSegmentPrivilegeLevel * [Bits 14:13] Specifies the segment privilege level.
DescriptorPrivilegeLevel UINT32
#defineSegmentDescriptorPrivilegeLevelBit13 #define SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL_BIT                      13
#defineSegmentDescriptorPrivilegeLevelFlag0x6000 #define SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL_FLAG                     0x6000
#defineSegmentDescriptorPrivilegeLevelMask0x03 #define SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL_MASK                     0x03
#defineSegmentDescriptorPrivilegeLevel()((()>>13)&0x03) #define SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL(_)                       (((_) >> 13) & 0x03)
*[Bit15]IndicatesWhetherTheSegmentIsPresentInMemory(Set)OrNotPresent(Clear) * [Bit 15] Indicates whether the segment is present in memory (set) or not present (clear).
Present UINT32
#defineSegmentPresentBit15 #define SEGMENT__PRESENT_BIT                                         15
#defineSegmentPresentFlag0x8000 #define SEGMENT__PRESENT_FLAG                                        0x8000
#defineSegmentPresentMask0x01 #define SEGMENT__PRESENT_MASK                                        0x01
#defineSegmentPresent()((()>>15)&0x01) #define SEGMENT__PRESENT(_)                                          (((_) >> 15) & 0x01)
*[Bits31:16]OffsetToProcedureEntryPoint(31:16) * [Bits 31:16] Offset to procedure entry point (31:16).
OffsetMiddle UINT32
#defineSegmentOffsetMiddleBit16 #define SEGMENT__OFFSET_MIDDLE_BIT                                   16
#defineSegmentOffsetMiddleFlag0xFfff0000 #define SEGMENT__OFFSET_MIDDLE_FLAG                                  0xFFFF0000
#defineSegmentOffsetMiddleMask0xFfff #define SEGMENT__OFFSET_MIDDLE_MASK                                  0xFFFF
#defineSegmentOffsetMiddle()((()>>16)&0xFfff) #define SEGMENT__OFFSET_MIDDLE(_)                                    (((_) >> 16) & 0xFFFF)
}


type  struct{
TypedefStruct typedef struct
*ReservedBitsSetTo0 * Reserved bits. Set to 0.
Reserved0 UINT32
*StackPointerForPrivilegeLevel0 * Stack pointer for privilege level 0.
Rsp0 uint64
*StackPointerForPrivilegeLevel1 * Stack pointer for privilege level 1.
Rsp1 uint64
*StackPointerForPrivilegeLevel2 * Stack pointer for privilege level 2.
Rsp2 uint64
*ReservedBitsSetTo0 * Reserved bits. Set to 0.
Reserved1 uint64
*InterruptStackTablePointer(1) * Interrupt stack table pointer (1).
Ist1 uint64
*InterruptStackTablePointer(2) * Interrupt stack table pointer (2).
Ist2 uint64
*InterruptStackTablePointer(3) * Interrupt stack table pointer (3).
Ist3 uint64
*InterruptStackTablePointer(4) * Interrupt stack table pointer (4).
Ist4 uint64
*InterruptStackTablePointer(5) * Interrupt stack table pointer (5).
Ist5 uint64
*InterruptStackTablePointer(6) * Interrupt stack table pointer (6).
Ist6 uint64
*InterruptStackTablePointer(7) * Interrupt stack table pointer (7).
Ist7 uint64
*ReservedBitsSetTo0 * Reserved bits. Set to 0.
Reserved2 uint64
*ReservedBitsSetTo0 * Reserved bits. Set to 0.
Reserved3 UINT16
*The16-BitOffsetToTheIOPermissionBitMapFromThe64-BitTssBase * The 16-bit offset to the I/O permission bit map from the 64-bit TSS base.
IoMapBase UINT16
}


type  struct{
TypedefStruct typedef struct
*The32-BitValueThatWouldHaveBeenSavedIntoTheVmcsAsAnExitReasonHadAVmExitOccurredInsteadOfThe * The 32-bit value that would have been saved into the VMCS as an exit reason had a VM exit occurred instead of the
*VirtualizationExceptionForEptViolations,ThisValueIs48(00000030H) * virtualization exception. For EPT violations, this value is 48 (00000030H).
Reason UINT32
*Ffffffffh * FFFFFFFFH
ExceptionMask UINT32
*The64-BitValueThatWouldHaveBeenSavedIntoTheVmcsAsAnExitQualificationHadAVmExitOccurredInsteadOfThe * The 64-bit value that would have been saved into the VMCS as an exit qualification had a VM exit occurred instead of the
*VirtualizationException * virtualization exception.
Exit uint64
*The64-BitValueThatWouldHaveBeenSavedIntoTheVmcsAsAGuest-LinearAddressHadAVmExitOccurredInsteadOf * The 64-bit value that would have been saved into the VMCS as a guest-linear address had a VM exit occurred instead of
*TheVirtualizationException * the virtualization exception.
GuestLinearAddress uint64
*The64-BitValueThatWouldHaveBeenSavedIntoTheVmcsAsAGuest-PhysicalAddressHadAVmExitOccurredInsteadOf * The 64-bit value that would have been saved into the VMCS as a guest-physical address had a VM exit occurred instead of
*TheVirtualizationException * the virtualization exception.
GuestPhysicalAddress uint64
*TheCurrent16-BitValueOfTheEptpIndexVm-ExecutionControl * The current 16-bit value of the EPTP index VM-execution control.
* *
CurrentEptpIndex UINT16
}


type  struct{
TypedefStruct typedef struct
#defineIoBitmapAMin0x00000000 #define IO_BITMAP_A_MIN                                              0x00000000
#defineIoBitmapAMax0x00007Fff #define IO_BITMAP_A_MAX                                              0x00007FFF
#defineIoBitmapBMin0x00008000 #define IO_BITMAP_B_MIN                                              0x00008000
#defineIoBitmapBMax0x0000Ffff #define IO_BITMAP_B_MAX                                              0x0000FFFF
IoA[4096] UINT8
IoB[4096] UINT8
}


type  struct{
TypedefStruct typedef struct
#defineMsrIdLowMin0x00000000 #define MSR_ID_LOW_MIN                                               0x00000000
#defineMsrIdLowMax0x00001Fff #define MSR_ID_LOW_MAX                                               0x00001FFF
#defineMsrIdHighMin0xC0000000 #define MSR_ID_HIGH_MIN                                              0xC0000000
#defineMsrIdHighMax0xC0001Fff #define MSR_ID_HIGH_MAX                                              0xC0001FFF
RdmsrLow[1024] UINT8
RdmsrHigh[1024] UINT8
WrmsrLow[1024] UINT8
WrmsrHigh[1024] UINT8
}


type  struct{
TypedefStruct typedef struct
EptPointer uint64
*MustBeZero * Must be zero.
Reserved uint64
}


type  struct{
TypedefStruct typedef struct
Vpid UINT16
*MustBeZero * Must be zero.
Reserved1 UINT16
*MustBeZero * Must be zero.
Reserved2 UINT32
LinearAddress uint64
}


type  struct{
TypedefStruct typedef struct
Struct struct
* *
*[Bits30:0]ProcessorsThatMaintainVmcsDataInDifferentFormats(SeeBelow)UseDifferentVmcsRevisionIdentifiers * [Bits 30:0] Processors that maintain VMCS data in different formats (see below) use different VMCS revision identifiers.
*TheseIdentifiersEnableSoftwareToAvoidUsingAVmcsRegionFormattedForOneProcessorOnAProcessorThatUsesA * These identifiers enable software to avoid using a VMCS region formatted for one processor on a processor that uses a
*DifferentFormat * different format.
*SoftwareShouldWriteTheVmcsRevisionIdentifierToTheVmcsRegionBeforeUsingThatRegionForAVmcsTheVmcs * Software should write the VMCS revision identifier to the VMCS region before using that region for a VMCS. The VMCS
revision *
*RevisionIdentifierDiffersFromThatUsedByTheProcessor * revision identifier differs from that used by the processor.
*SoftwareCanDiscoverTheVmcsRevisionIdentifierThatAProcessorUsesByReadingTheVmxCapabilityMsr * Software can discover the VMCS revision identifier that a processor uses by reading the VMX capability MSR
*Ia32VmxBasic * IA32_VMX_BASIC.
* *
RevisionId UINT32
* *
*[Bit31]SoftwareShouldClearOrSetTheShadow-VmcsIndicatorDependingOnWhetherTheVmcsIsToBeAnOrdinaryVmcs * [Bit 31] Software should clear or set the shadow-VMCS indicator depending on whether the VMCS is to be an ordinary VMCS
*OrAShadowVmcsVmptrldFailsIfTheShadow-VmcsIndicatorIsSetAndTheProcessorDoesNotSupportThe1-SettingOf * or a shadow VMCS. VMPTRLD fails if the shadow-VMCS indicator is set and the processor does not support the 1-setting of
*TheVmcsShadowingVm-ExecutionControlSoftwareCanDiscoverSupportForThisSettingByReadingTheVmxCapability * the "VMCS shadowing" VM-execution control. Software can discover support for this setting by reading the VMX capability
*MsrIa32VmxProcbasedCtls2 * MSR IA32_VMX_PROCBASED_CTLS2.
* *
ShadowVmcsIndicator UINT32
}


type  struct{
TypedefStruct typedef struct
Struct struct
* *
*[Bits30:0]BeforeExecutingVmxon,SoftwareShouldWriteTheVmcsRevisionIdentifierToTheVmxonRegion * [Bits 30:0] Before executing VMXON, software should write the VMCS revision identifier to the VMXON region.
*(Specifically,ItShouldWriteThe31-BitVmcsRevisionIdentifierToBits30:0OfTheFirst4BytesOfTheVmxon * (Specifically, it should write the 31-bit VMCS revision identifier to bits 30:0 of the first 4 bytes of the VMXON
region *
* *
RevisionId UINT32
*[Bit31]Bit31IsAlways0 * [Bit 31] Bit 31 is always 0.
MustBeZero UINT32
}


type  struct{
TypedefStruct typedef struct
Union union
Struct struct
*[Bit0]ThisFieldIndicatesWhetherTheRoot-EntryIsPresent * [Bit 0] This field indicates whether the root-entry is present.
**0:IndicatesTheRoot-EntryIsNotPresentAllOtherFieldsAreIgnoredByHardware * * 0: Indicates the root-entry is not present. All other fields are ignored by hardware.
**1:IndicatesTheRoot-EntryIsPresent * * 1: Indicates the root-entry is present.
Present uint64
#defineVtdLower64PresentBit0 #define VTD_Lower64_PRESENT_BIT                                      0
#defineVtdLower64PresentFlag0x01 #define VTD_Lower64_PRESENT_FLAG                                     0x01
#defineVtdLower64PresentMask0x01 #define VTD_Lower64_PRESENT_MASK                                     0x01
#defineVtdLower64Present()((()>>0)&0x01) #define VTD_Lower64_PRESENT(_)                                       (((_) >> 0) & 0x01)
Reserved1 uint64
*[Bits63:12]PointerToContext-TableForThisBusTheContext-TableIs4KbInSizeAndSizeAlignedHardwareTreats * [Bits 63:12] Pointer to Context-table for this bus. The Context-table is 4KB in size and size aligned. Hardware treats
*Bits63:HawAsReserved(0),WhereHawIsTheHostAddressWidthOfThePlatform * bits 63:HAW as reserved (0), where HAW is the host address width of the platform.
ContextTablePointer uint64
#defineVtdLower64ContextTablePointerBit12 #define VTD_Lower64_CONTEXT_TABLE_POINTER_BIT                        12
#defineVtdLower64ContextTablePointerFlag0xFffffffffffff000 #define VTD_Lower64_CONTEXT_TABLE_POINTER_FLAG                       0xFFFFFFFFFFFFF000
#defineVtdLower64ContextTablePointerMask0xFffffffffffff #define VTD_Lower64_CONTEXT_TABLE_POINTER_MASK                       0xFFFFFFFFFFFFF
#defineVtdLower64ContextTablePointer()((()>>12)&0xFffffffffffff) #define VTD_Lower64_CONTEXT_TABLE_POINTER(_)                         (((_) >> 12) & 0xFFFFFFFFFFFFF)
}


type  struct{
TypedefStruct typedef struct
Union union
Struct struct
*[Bit0] * [Bit 0]
**0:IndicatesTheContext-EntryIsNotPresentAllOtherFieldsExceptFaultProcessingDisable(Fpd)FieldAre * * 0: Indicates the context-entry is not present. All other fields except Fault Processing Disable (FPD) field are
*IgnoredByHardware * ignored by hardware.
**1:IndicatesTheContext-EntryIsPresent * * 1: Indicates the context-entry is present.
Present uint64
#defineVtdLower64PresentBit0 #define VTD_Lower64_PRESENT_BIT                                      0
#defineVtdLower64PresentFlag0x01 #define VTD_Lower64_PRESENT_FLAG                                     0x01
#defineVtdLower64PresentMask0x01 #define VTD_Lower64_PRESENT_MASK                                     0x01
#defineVtdLower64Present()((()>>0)&0x01) #define VTD_Lower64_PRESENT(_)                                       (((_) >> 0) & 0x01)
*[Bit1]EnablesOrDisablesRecordingReportingOfQualifiedNon-RecoverableFaults * [Bit 1] Enables or disables recording/reporting of qualified non-recoverable faults.
**0:QualifiedNon-RecoverableFaultsAreRecordedReportedForRequestsProcessedThroughThisContext-Entry * * 0: Qualified non-recoverable faults are recorded/reported for requests processed through this context-entry.
**1:QualifiedNon-RecoverableFaultsAreNotRecordedReportedForRequestsProcessedThroughThisContext-Entry * * 1: Qualified non-recoverable faults are not recorded/reported for requests processed through this context-entry.
*ThisFieldIsEvaluatedByHardwareIrrespectiveOfTheSettingOfThePresent(P)Field * This field is evaluated by hardware irrespective of the setting of the present (P) field.
FaultProcessingDisable uint64
#defineVtdLower64FaultProcessingDisableBit1 #define VTD_Lower64_FAULT_PROCESSING_DISABLE_BIT                     1
#defineVtdLower64FaultProcessingDisableFlag0x02 #define VTD_Lower64_FAULT_PROCESSING_DISABLE_FLAG                    0x02
#defineVtdLower64FaultProcessingDisableMask0x01 #define VTD_Lower64_FAULT_PROCESSING_DISABLE_MASK                    0x01
#defineVtdLower64FaultProcessingDisable()((()>>1)&0x01) #define VTD_Lower64_FAULT_PROCESSING_DISABLE(_)                      (((_) >> 1) & 0x01)
*[Bits3:2]ThisFieldIsApplicableOnlyForRequests-Without-Pasid,AsHardwareBlocksAllRequests-With-PasidIn * [Bits 3:2] This field is applicable only for requests-without-PASID, as hardware blocks all requests-with- PASID in
*LegacyModeBeforeTheyCanUseContextTable * legacy mode before they can use context table.
**00b:UntranslatedRequestsAreTranslatedUsingSecond-LevelPagingStructuresReferencedThroughSlptptrField * * 00b: Untranslated requests are translated using second-level paging structures referenced through SLPTPTR field.
*TranslatedRequestsAndTranslationRequestsAreBlocked * Translated requests and Translation Requests are blocked.
**01b:Untranslated,TranslatedAndTranslationRequestsAreSupportedThisEncodingIsTreatedAsReservedByHardware * * 01b: Untranslated, Translated and Translation Requests are supported. This encoding is treated as reserved by hardware
*ImplementationsNotSupportingDevice-TlBs(Dt=0InExtendedCapabilityRegister) * implementations not supporting Device-TLBs (DT=0 in Extended Capability Register).
**10b:UntranslatedRequestsAreProcessedAsPass-ThroughSlptptrFieldIsIgnoredByHardwareTranslatedAnd * * 10b: Untranslated requests are processed as pass-through. SLPTPTR field is ignored by hardware. Translated and
*TranslationRequestsAreBlockedThisEncodingIsTreatedByHardwareAsReservedForHardwareImplementationsNot * Translation Requests are blocked. This encoding is treated by hardware as reserved for hardware implementations not
*SupportingPassThrough(Pt=0InExtendedCapabilityRegister) * supporting Pass Through (PT=0 in Extended Capability Register).
**11b:Reserved * * 11b: Reserved.
TranslationType uint64
#defineVtdLower64TranslationTypeBit2 #define VTD_Lower64_TRANSLATION_TYPE_BIT                             2
#defineVtdLower64TranslationTypeFlag0x0C #define VTD_Lower64_TRANSLATION_TYPE_FLAG                            0x0C
#defineVtdLower64TranslationTypeMask0x03 #define VTD_Lower64_TRANSLATION_TYPE_MASK                            0x03
#defineVtdLower64TranslationType()((()>>2)&0x03) #define VTD_Lower64_TRANSLATION_TYPE(_)                              (((_) >> 2) & 0x03)
Reserved1 uint64
*[Bits63:12]WhenTheTranslation-Type(Tt)FieldIs00bOr01b,ThisFieldPointsToTheBaseOfSecondLevelPaging * [Bits 63:12] When the Translation-Type (TT) field is 00b or 01b, this field points to the base of second level paging
*Entries(DescribedInSection98) * entries (described in Section 9.8).
*HardwareTreatsBits63:HawAsReserved(0),WhereHawIsTheHostAddressWidthOfThePlatform * Hardware treats bits 63:HAW as reserved (0), where HAW is the host address width of the platform.
*ThisFieldIsIgnoredByHardwareWhenTranslation-Type(Tt)FieldIs10b(Pass-Through) * This field is ignored by hardware when Translation-Type (TT) field is 10b (pass-through).
SecondLevelPageTranslationPointer uint64
#defineVtdLower64SecondLevelPageTranslationPointerBit12 #define VTD_Lower64_SECOND_LEVEL_PAGE_TRANSLATION_POINTER_BIT        12
#defineVtdLower64SecondLevelPageTranslationPointerFlag0xFffffffffffff000 #define VTD_Lower64_SECOND_LEVEL_PAGE_TRANSLATION_POINTER_FLAG       0xFFFFFFFFFFFFF000
#defineVtdLower64SecondLevelPageTranslationPointerMask0xFffffffffffff #define VTD_Lower64_SECOND_LEVEL_PAGE_TRANSLATION_POINTER_MASK       0xFFFFFFFFFFFFF
#defineVtdLower64SecondLevelPageTranslationPointer()((()>>12)&0xFffffffffffff) #define VTD_Lower64_SECOND_LEVEL_PAGE_TRANSLATION_POINTER(_)         (((_) >> 12) & 0xFFFFFFFFFFFFF)
}



type (
Ia32 interface{
#if defined()(ok bool)//col:256
#define CR3_PAGE_LEVEL_WRITE_THROUGH()(ok bool)//col:311
     * hardware support for a virtual interrupt flag ()(ok bool)//col:669
#define CR8_TASK_PRIORITY_LEVEL()(ok bool)//col:701
 * other privilege level generates a general-protection exception ()(ok bool)//col:807
     * [Bit 0] Enables ()(ok bool)//col:998
 * - EBX <- 756e6547h ()(ok bool)//col:1052
#define CPUID_VERSION_INFORMATION_STEPPING_ID()(ok bool)//col:1896
 * describe a set of deterministic cache parameters ()(ok bool)//col:2101
       * [Bits 15:0] Smallest monitor-line size in bytes ()(ok bool)//col:2257
#define CPUID_EAX_TEMPERATURE_SENSOR_SUPPORTED()(ok bool)//col:2531
 * When CPUID executes with EAX set to 07H and the input value of ECX is invalid ()(ok bool)//col:3239
       * [Bits 31:0] Value of bits [31:0] of IA32_PLATFORM_DCA_CAP MSR ()(ok bool)//col:3318
#define CPUID_EAX_VERSION_ID_OF_ARCHITECTURAL_PERFORMANCE_MONITORING()(ok bool)//col:3504
#define CPUID_EAX_X2APIC_ID_TO_UNIQUE_TOPOLOGY_ID_SHIFT()(ok bool)//col:3619
 * When CPUID executes with EAX set to 0DH and ECX = n ()(ok bool)//col:3780
#define CPUID_EAX_SUPPORTS_XSAVEC_AND_COMPACTED_XRSTOR()(ok bool)//col:3943
 *       If ECX contains an invalid sub-leaf index, EAX/EBX/ECX/EDX return 0. Sub-leaf n ()(ok bool)//col:4040
 * resource type if the bit is set. The bit position corresponds to the sub-leaf index ()(ok bool)//col:4139
#define CPUID_EAX_RESERVED()(ok bool)//col:4235
 * corresponds to a specific resource type if the bit is set. The bit position corresponds to the sub-leaf index ()(ok bool)//col:4352
#define CPUID_EAX_LENGTH_OF_CAPACITY_BIT_MASK()(ok bool)//col:4434
#define CPUID_EAX_LENGTH_OF_CAPACITY_BIT_MASK()(ok bool)//col:4513
#define CPUID_EAX_MAX_MBA_THROTTLING_VALUE()(ok bool)//col:4595
 * When CPUID executes with EAX set to 12H and ECX = n ()(ok bool)//col:4726
#define CPUID_EAX_VALID_SECS_ATTRIBUTES_0()(ok bool)//col:4803
#define CPUID_EAX_SUB_LEAF_TYPE()(ok bool)//col:4882
       * Enclave Page Cache ()(ok bool)//col:4986
 * When CPUID executes with EAX set to 14H and ECX = n ()(ok bool)//col:5195
#define CPUID_EAX_NUMBER_OF_CONFIGURABLE_ADDRESS_RANGES_FOR_FILTERING()(ok bool)//col:5289
#define CPUID_EAX_DENOMINATOR()(ok bool)//col:5378
       * [Bits 15:0] Processor Base Frequency ()(ok bool)//col:5468
#define CPUID_EAX_MAX_SOC_ID_INDEX()(ok bool)//col:5566
#define CPUID_EAX_SOC_VENDOR_BRAND_STRING()(ok bool)//col:5645
#define CPUID_EAX_RESERVED()(ok bool)//col:5722
#define CPUID_EAX_MAX_SUB_LEAF()(ok bool)//col:5903
#define CPUID_EAX_RESERVED()(ok bool)//col:6071
#define CPUID_EAX_MAX_EXTENDED_FUNCTIONS()(ok bool)//col:6155
#define CPUID_EAX_RESERVED()(ok bool)//col:6295
#define CPUID_EAX_PROCESSOR_BRAND_STRING_1()(ok bool)//col:6382
#define CPUID_EAX_PROCESSOR_BRAND_STRING_5()(ok bool)//col:6457
#define CPUID_EAX_PROCESSOR_BRAND_STRING_9()(ok bool)//col:6532
#define CPUID_EAX_RESERVED()(ok bool)//col:6607
#define CPUID_EAX_RESERVED()(ok bool)//col:6711
#define CPUID_EAX_RESERVED()(ok bool)//col:6791
#define CPUID_EAX_NUMBER_OF_PHYSICAL_ADDRESS_BITS()(ok bool)//col:6881
 *           IA32_P5_MC_()(ok bool)//col:6981
#define IA32_APIC_BASE_BSP_FLAG()(ok bool)//col:7038
     * [Bit 0] When set, locks this MSR from being written; writes to this bit will result in GP()(ok bool)//col:7170
     * [Bit 0] IBRS: Indirect Branch Restricted Speculation ()(ok bool)//col:7239
     * [Bit 0] IBPB: Indirect Branch Prediction Barrier ()(ok bool)//col:7266
#define IA32_BIOS_UPDATE_SIGNATURE_RESERVED()(ok bool)//col:7320
 *           IA32_SGXLEPUBKEYHASH[()(ok bool)//col:7402
 *           IA32_PMC()(ok bool)//col:7490
#define IA32_MTRR_CAPABILITIES_VARIABLE_RANGE_COUNT()(ok bool)//col:7572
     * [Bit 0] RDCL_NO: The processor is not susceptible to Rogue Data Cache Load ()(ok bool)//col:7671
#define IA32_FLUSH_CMD_L1D_FLUSH()(ok bool)//col:7698
 *          Available when CPUID.ARCH_CAP()(ok bool)//col:7734
#define IA32_SYSENTER_CS_CS_SELECTOR()(ok bool)//col:7784
 * The value of this MSR is loaded into RSP ()(ok bool)//col:7914
#define IA32_MCG_STATUS_RIPV()(ok bool)//col:7972
 *           IA32_PERFEVTSEL()(ok bool)//col:8103
#define IA32_PERF_STATUS_STATE_VALUE()(ok bool)//col:8133
 * Performance Control. Software makes a request for a new Performance state ()(ok bool)//col:8173
#define IA32_CLOCK_MODULATION_EXTENDED_ON_DEMAND_CLOCK_MODULATION_DUTY_CYCLE()(ok bool)//col:8227
#define IA32_THERM_INTERRUPT_HIGH_TEMPERATURE_INTERRUPT_ENABLE()(ok bool)//col:8358
#define IA32_THERM_STATUS_THERMAL_STATUS()(ok bool)//col:8588
     * [Bit 0] When set, the fast-strings feature ()(ok bool)//col:8766
#define IA32_ENERGY_PERF_BIAS_POWER_POLICY_PREFERENCE()(ok bool)//col:8794
#define IA32_PACKAGE_THERM_STATUS_THERMAL_STATUS()(ok bool)//col:8931
#define IA32_PACKAGE_THERM_INTERRUPT_HIGH_TEMPERATURE_INTERRUPT_ENABLE()(ok bool)//col:9034
#define IA32_DEBUGCTL_LBR()(ok bool)//col:9186
#define IA32_SMRR_PHYSBASE_TYPE()(ok bool)//col:9225
#define IA32_SMRR_PHYSMASK_ENABLE_RANGE_MASK()(ok bool)//col:9263
#define IA32_DCA_0_CAP_DCA_ACTIVE()(ok bool)//col:9359
 *           IA32_MTRR_PHYSBASE()(ok bool)//col:9399
 *           IA32_MTRR_PHYSMASK()(ok bool)//col:9461
 *           IA32_MTRR_FIX()(ok bool)//col:9650
 *           IA32_MC()(ok bool)//col:9720
#define IA32_MTRR_DEF_TYPE_DEFAULT_MEMORY_TYPE()(ok bool)//col:9768
 *           IA32_FIXED_CTR()(ok bool)//col:9865
#define IA32_FIXED_CTR_CTRL_EN0_OS()(ok bool)//col:10002
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC0()(ok bool)//col:10179
     * [Bits 31:0] EN_PMC()(ok bool)//col:10219
     * [Bits 31:0] Set 1 to clear Ovf_PMC()(ok bool)//col:10336
     * [Bits 31:0] Set 1 to cause Ovf_PMC()(ok bool)//col:10443
     * [Bits 31:0] IA32_PERFEVTSEL()(ok bool)//col:10488
#define IA32_PEBS_ENABLE_ENABLE_PEBS()(ok bool)//col:10534
 *           IA32_MC()(ok bool)//col:10835
     * guest interrupt-descriptor table ()(ok bool)//col:10925
#define IA32_VMX_PROCBASED_CTLS_INTERRUPT_WINDOW_EXITING()(ok bool)//col:11225
#define IA32_VMX_EXIT_CTLS_SAVE_DEBUG_CONTROLS()(ok bool)//col:11429
#define IA32_VMX_ENTRY_CTLS_LOAD_DEBUG_CONTROLS()(ok bool)//col:11594
     * timestamp counter ()(ok bool)//col:11758
#define IA32_VMX_VMCS_ENUM_ACCESS_TYPE()(ok bool)//col:11849
#define IA32_VMX_PROCBASED_CTLS2_VIRTUALIZE_APIC_ACCESSES()(ok bool)//col:12211
     * configure EPT paging-structure entries in which bits 1:0 are clear ()(ok bool)//col:12428
 *           IA32_VMX_TRUE_()(ok bool)//col:12478
#define IA32_VMX_VMFUNC_EPTP_SWITCHING()(ok bool)//col:12511
#define IA32_VMX_PROCBASED_CTLS3_LOADIWKEY_EXITING()(ok bool)//col:12578
#define IA32_VMX_EXIT_CTLS2_RESERVED()(ok bool)//col:12601
 *           IA32_A_PMC()(ok bool)//col:12645
#define IA32_SGX_SVN_STATUS_LOCK()(ok bool)//col:12698
 *          ()(ok bool)//col:12738
 *          ()(ok bool)//col:12807
     * Note that the processor will clear this bit on \#SMI ()(ok bool)//col:13179
#define IA32_RTIT_STATUS_FILTER_ENABLED()(ok bool)//col:13319
#define IA32_RTIT_CR3_MATCH_CR3_VALUE_TO_MATCH()(ok bool)//col:13350
 *           IA32_RTIT_ADDR()(ok bool)//col:13422
 *          CPUID.()(ok bool)//col:13560
 *          CPUID.()(ok bool)//col:13681
 * ()(ok bool)//col:13770
#define IA32_HWP_CAPABILITIES_HIGHEST_PERFORMANCE()(ok bool)//col:13834
#define IA32_HWP_REQUEST_PKG_MINIMUM_PERFORMANCE()(ok bool)//col:13910
#define IA32_HWP_INTERRUPT_EN_GUARANTEED_PERFORMANCE_CHANGE()(ok bool)//col:13950
#define IA32_HWP_REQUEST_MINIMUM_PERFORMANCE()(ok bool)//col:14038
#define IA32_HWP_STATUS_GUARANTEED_PERFORMANCE_CHANGE()(ok bool)//col:14079
 *           IA32_X2APIC_ISR()(ok bool)//col:14340
     * [Bit 0] Set 1 to enable L3 CAT masks and COS to operate in Code and Data Prioritization ()(ok bool)//col:14367
     * [Bit 0] Set 1 to enable L2 CAT masks and COS to operate in Code and Data Prioritization ()(ok bool)//col:14394
#define IA32_QM_EVTSEL_EVENT_ID()(ok bool)//col:14434
#define IA32_QM_CTR_RESOURCE_MONITORED_DATA()(ok bool)//col:14480
#define IA32_PQR_ASSOC_RESOURCE_MONITORING_ID()(ok bool)//col:14521
#define IA32_BNDCFGS_ENABLE()(ok bool)//col:14564
#define IA32_XSS_TRACE_PACKET_CONFIGURATION_STATE()(ok bool)//col:14591
#define IA32_PKG_HDC_CTL_HDC_PKG_ENABLE()(ok bool)//col:14621
#define IA32_PM_CTL1_HDC_ALLOW_BLOCK()(ok bool)//col:14651
#define IA32_EFER_SYSCALL_ENABLE()(ok bool)//col:14731
#define IA32_TSC_AUX_TSC_AUXILIARY_SIGNATURE()(ok bool)//col:14809
#define PDE_4MB_32_PRESENT()(ok bool)//col:14979
#define PDE_32_PRESENT()(ok bool)//col:15092
#define PTE_32_PRESENT()(ok bool)//col:15220
#define PT_ENTRY_32_PRESENT()(ok bool)//col:15295
 *           64-Bit ()(ok bool)//col:15466
#define PDPTE_1GB_64_PRESENT()(ok bool)//col:15650
#define PDPTE_64_PRESENT()(ok bool)//col:15789
#define PDE_2MB_64_PRESENT()(ok bool)//col:15973
#define PDE_64_PRESENT()(ok bool)//col:16112
#define PTE_64_PRESENT()(ok bool)//col:16285
#define PT_ENTRY_64_PRESENT()(ok bool)//col:16385
   * descriptor.2 ()(ok bool)//col:16438
#define INVPCID_DESCRIPTOR_PCID()(ok bool)//col:16466
#pragma pack()(ok bool)//col:16490
#pragma pack()(ok bool)//col:16510
#pragma pack()(ok bool)//col:16649
   * processor interprets the segment limit in one of two ways, depending on the setting of the G ()(ok bool)//col:16859
   * processor interprets the segment limit in one of two ways, depending on the setting of the G ()(ok bool)//col:17071
   * Offset to procedure entry point ()(ok bool)//col:17166
 * When the S ()(ok bool)//col:17431
#pragma pack()(ok bool)//col:17519
#pragma pack()(ok bool)//col:18224
#define VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_BREAKPOINT_CONDITION()(ok bool)//col:18285
     * [Bits 15:0] Selector of task-state segment ()(ok bool)//col:18320
     * [Bits 3:0] Number of control register ()(ok bool)//col:18407
#define VMX_EXIT_QUALIFICATION_MOV_DR_DEBUG_REGISTER()(ok bool)//col:18456
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_SIZE_OF_ACCESS()(ok bool)//col:18534
#define VMX_EXIT_QUALIFICATION_APIC_ACCESS_PAGE_OFFSET()(ok bool)//col:18594
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_READ_ACCESS()(ok bool)//col:18790
     * 2: 64-bit ()(ok bool)//col:18849
     * 3: scale by 8 ()(ok bool)//col:18955
     * 3: scale by 8 ()(ok bool)//col:19080
     * 3: scale by 8 ()(ok bool)//col:19210
#define VMX_VMEXIT_INSTRUCTION_INFO_RDRAND_RDSEED_DESTINATION_REGISTER()(ok bool)//col:19248
     * 3: scale by 8 ()(ok bool)//col:19345
     * 3: scale by 8 ()(ok bool)//col:19471
 *        ()(ok bool)//col:19582
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_STI()(ok bool)//col:19661
   * The logical processor is inactive because it is waiting for a startup-IPI ()(ok bool)//col:19684
#define VMX_PENDING_DEBUG_EXCEPTIONS_B0()(ok bool)//col:19770
 * Exit reason ()(ok bool)//col:19856
 * The extended page-table mechanism ()(ok bool)//col:19966
 * extended-page-table pointer ()(ok bool)//col:20055
#define EPT_PDPTE_1GB_READ_ACCESS()(ok bool)//col:20225
#define EPT_PDPTE_READ_ACCESS()(ok bool)//col:20302
#define EPT_PDE_2MB_READ_ACCESS()(ok bool)//col:20472
#define EPT_PDE_READ_ACCESS()(ok bool)//col:20549
#define EPT_PTE_READ_ACCESS()(ok bool)//col:20725
#define EPT_ENTRY_READ_ACCESS()(ok bool)//col:20794
   * all PCIDs. ()(ok bool)//col:20844
   * and, for combined mappings, all EP4TAs. ()(ok bool)//col:20882
 * The hypervisor-managed linear-address translation pointer ()(ok bool)//col:20957
 * A logical processor uses virtual-machine control data structures ()(ok bool)//col:21027
     * ()(ok bool)//col:21074
 *           VMCS ()(ok bool)//col:21147
 * Virtual-processor identifier ()(ok bool)//col:22264
#define VMENTRY_INTERRUPT_INFORMATION_VECTOR()(ok bool)//col:22324
#define VMEXIT_INTERRUPT_INFORMATION_VECTOR()(ok bool)//col:22384
 *           Advanced Programmable Interrupt Controller ()(ok bool)//col:22889
#define RFLAGS_CARRY_FLAG()(ok bool)//col:23106
#define CONTROL_PROTECTION_EXCEPTION_CPEC()(ok bool)//col:23148
 *        Each exception is given a mnemonic that consists of a pound sign ()(ok bool)//col:23309
 *        error code onto the stack of the exception handler ()(ok bool)//col:23371
#define PAGE_FAULT_EXCEPTION_PRESENT()(ok bool)//col:23497
 * of system memory, it allows the type of caching ()(ok bool)//col:23652
       * * 0: Indicates the context-entry is not present. All other fields except Fault Processing Disable ()(ok bool)//col:23783
#define VTD_VERSION_MINOR()(ok bool)//col:23835
#define VTD_CAPABILITY_NUMBER_OF_DOMAINS_SUPPORTED()(ok bool)//col:24192
     * structures are coherent ()(ok bool)//col:24658
 * 3. if ()(ok bool)//col:24849
     * [Bit 23] This field indicates the status of Compatibility format interrupts on Intel()(ok bool)//col:24991
 * SRTP field in the Global Command Register ()(ok bool)//col:25043
     * to this field is within this limit. Hardware ignores ()(ok bool)//col:25179
#define VTD_INVALIDATE_ADDRESS_ADDRESS_MASK()(ok bool)//col:25250
     * to this field is within this limit. Hardware may ignore and not implement bits 47:()(ok bool)//col:25385
#define XCR0_X87()(ok bool)//col:25487
}
)

func NewIa32() { return & ia32{} }

func (i *ia32)#if defined()(ok bool){//col:256
/*#if defined(_MSC_EXTENSIONS)
#pragma warning(push)
#pragma warning(disable: 4201)
#endif
 *           Intel Manual
 *
 *          1, 2A, 2B, 2C, 2D, 3A, 3B, 3C, 3D, and 4</b> (June 2021) and <b>Intel(R) Virtualization Technology for Directed I/O</b>
 *          (April 2021)
 *           Control registers
 *
 * Control registers (CR0, CR1, CR2, CR3, and CR4) determine operating mode of the processor and the characteristics of the
 * currently executing task. These registers are 32 bits in all 32-bit modes and compatibility mode.
 * In 64-bit mode, control registers are expanded to 64 bits. The MOV CRn instructions are used to manipulate the register
 * bits. Operand-size prefixes for these instructions are ignored. The following is also true:
 * - The control registers can be read and loaded (or modified) using the move-to-or-from-control-registers forms of the
 * MOV instruction. In protected mode, the MOV instructions allow the control registers to be read or loaded (at privilege
 * level 0 only). This restriction means that application programs or operating-system procedures (running at privilege
 * levels 1, 2, or 3) are prevented from reading or loading the control registers.
 * - Bits 63:32 of CR0 and CR4 are reserved and must be written with zeros. Writing a nonzero value to any of the upper 32
 * bits results in a general-protection exception, \#GP(0).
 * - All 64 bits of CR2 are writable by software.
 * - Bits 51:40 of CR3 are reserved and must be 0.
 * - The MOV CRn instructions do not check that addresses written to CR2 and CR3 are within the linear-address or
 * physical-address limitations of the implementation.
 * - Register CR8 is available in 64-bit mode only. The control registers are summarized below, and each architecturally
 * defined control field in these control registers is described individually.
 * - CR0 - Contains system control flags that control operating mode and states of the processor.
 * - CR1 - Reserved.
 * - CR2 - Contains the page-fault linear address (the linear address that caused a page fault).
 * - CR3 - Contains the physical address of the base of the paging-structure hierarchy and two flags (PCD and PWT). Only
 * the most-significant bits (less the lower 12 bits) of the base address are specified; the lower 12 bits of the address
 * are assumed to be 0. The first paging structure must thus be aligned to a page (4-KByte) boundary. The PCD and PWT flags
 * control caching of that paging structure in the processor's internal data caches (they do not control TLB caching of
 * page-directory information). When using the physical address extension, the CR3 register contains the base address of
 * the page-directorypointer table. In IA-32e mode, the CR3 register contains the base address of the PML4 table.
 * - CR4 - Contains a group of flags that enable several architectural extensions, and indicate operating system or
 * executive support for specific processor capabilities.
 * - CR8 - Provides read and write access to the Task Priority Register (TPR). It specifies the priority threshold value
 * that operating systems use to control the priority class of external interrupts allowed to interrupt the processor. This
 * register is available only in 64-bit mode. However, interrupt filtering continues to apply in compatibility mode.
 *
typedef union
{
  struct
  {
     *
     * [Bit 0] Enables protected mode when set; enables real-address mode when clear. This flag does not enable paging
     * directly. It only enables segment-level protection. To enable paging, both the PE and PG flags must be set.
     *
    UINT64 ProtectionEnable                                        : 1;
#define CR0_PROTECTION_ENABLE_BIT                                    0
#define CR0_PROTECTION_ENABLE_FLAG                                   0x01
#define CR0_PROTECTION_ENABLE_MASK                                   0x01
#define CR0_PROTECTION_ENABLE(_)                                     (((_) >> 0) & 0x01)
     *
     * [Bit 1] Controls the interaction of the WAIT (or FWAIT) instruction with the TS flag (bit 3 of CR0). If the MP flag is
     * set, a WAIT instruction generates a device-not-available exception (\#NM) if the TS flag is also set. If the MP flag is
     * clear, the WAIT instruction ignores the setting of the TS flag.
    UINT64 MonitorCoprocessor                                      : 1;
#define CR0_MONITOR_COPROCESSOR_BIT                                  1
#define CR0_MONITOR_COPROCESSOR_FLAG                                 0x02
#define CR0_MONITOR_COPROCESSOR_MASK                                 0x01
#define CR0_MONITOR_COPROCESSOR(_)                                   (((_) >> 1) & 0x01)
     *
     * [Bit 2] Indicates that the processor does not have an internal or external x87 FPU when set; indicates an x87 FPU is
     * present when clear. This flag also affects the execution of MMX/SSE/SSE2/SSE3/SSSE3/SSE4 instructions.
     * When the EM flag is set, execution of an x87 FPU instruction generates a device-not-available exception (\#NM). This
     * flag must be set when the processor does not have an internal x87 FPU or is not connected to an external math
     * coprocessor. Setting this flag forces all floating-point instructions to be handled by software emulation.
     * Also, when the EM flag is set, execution of an MMX instruction causes an invalid-opcode exception (\#UD) to be
     * generated. Thus, if an IA-32 or Intel 64 processor incorporates MMX technology, the EM flag must be set to 0 to enable
     * execution of MMX instructions. Similarly for SSE/SSE2/SSE3/SSSE3/SSE4 extensions, when the EM flag is set, execution of
     * most SSE/SSE2/SSE3/SSSE3/SSE4 instructions causes an invalid opcode exception (\#UD) to be generated. If an IA-32 or
     * Intel 64 processor incorporates the SSE/SSE2/SSE3/SSSE3/SSE4 extensions, the EM flag must be set to 0 to enable
     * execution of these extensions. SSE/SSE2/SSE3/SSSE3/SSE4 instructions not affected by the EM flag include: PAUSE,
     * PREFETCHh, SFENCE, LFENCE, MFENCE, MOVNTI, CLFLUSH, CRC32, and POPCNT.
    UINT64 EmulateFpu                                              : 1;
#define CR0_EMULATE_FPU_BIT                                          2
#define CR0_EMULATE_FPU_FLAG                                         0x04
#define CR0_EMULATE_FPU_MASK                                         0x01
#define CR0_EMULATE_FPU(_)                                           (((_) >> 2) & 0x01)
     *
     * [Bit 3] Allows the saving of the x87 FPU/MMX/SSE/SSE2/SSE3/SSSE3/SSE4 context on a task switch to be delayed until an
     * x87 FPU/MMX/SSE/SSE2/SSE3/SSSE3/SSE4 instruction is actually executed by the new task. The processor sets this flag on
     * every task switch and tests it when executing x87 FPU/MMX/SSE/SSE2/SSE3/SSSE3/SSE4 instructions.
     * - If the TS flag is set and the EM flag (bit 2 of CR0) is clear, a device-not-available exception (\#NM) is raised prior
     * to the execution of any x87 FPU/MMX/SSE/SSE2/SSE3/SSSE3/SSE4 instruction; with the exception of PAUSE, PREFETCHh,
     * SFENCE, LFENCE, MFENCE, MOVNTI, CLFLUSH, CRC32, and POPCNT.
     * - If the TS flag is set and the MP flag (bit 1 of CR0) and EM flag are clear, an \#NM exception is not raised prior to
     * the execution of an x87 FPU WAIT/FWAIT instruction.
     * - If the EM flag is set, the setting of the TS flag has no effect on the execution of x87
     * FPU/MMX/SSE/SSE2/SSE3/SSSE3/SSE4 instructions.
     *   The processor does not automatically save the context of the x87 FPU, XMM, and MXCSR registers on a task switch.
     *   Instead, it sets the TS flag, which causes the processor to raise an \#NM exception whenever it encounters an x87
     *   FPU/MMX/SSE/SSE2/SSE3/SSSE3/SSE4 instruction in the instruction stream for the new task (with the exception of the
     *   instructions listed above).
     *   The fault handler for the \#NM exception can then be used to clear the TS flag (with the CLTS instruction) and save
     *   the context of the x87 FPU, XMM, and MXCSR registers. If the task never encounters an x87
     *   FPU/MMX/SSE/SSE2/SSE3/SSSE3/SSE4 instruction, the x87 FPU/MMX/SSE/SSE2/SSE3/SSSE3/SSE4 context is never saved.
    UINT64 TaskSwitched                                            : 1;
#define CR0_TASK_SWITCHED_BIT                                        3
#define CR0_TASK_SWITCHED_FLAG                                       0x08
#define CR0_TASK_SWITCHED_MASK                                       0x01
#define CR0_TASK_SWITCHED(_)                                         (((_) >> 3) & 0x01)
     *
     * [Bit 4] Reserved in the Pentium 4, Intel Xeon, P6 family, and Pentium processors. In the Pentium 4, Intel Xeon, and P6
     * family processors, this flag is hardcoded to 1. In the Intel386 and Intel486 processors, this flag indicates support of
     * Intel 387 DX math coprocessor instructions when set.
    UINT64 ExtensionType                                           : 1;
#define CR0_EXTENSION_TYPE_BIT                                       4
#define CR0_EXTENSION_TYPE_FLAG                                      0x10
#define CR0_EXTENSION_TYPE_MASK                                      0x01
#define CR0_EXTENSION_TYPE(_)                                        (((_) >> 4) & 0x01)
     *
     * [Bit 5] Enables the native (internal) mechanism for reporting x87 FPU errors when set; enables the PC-style x87 FPU
     * error reporting mechanism when clear. When the NE flag is clear and the IGNNE\# input is asserted, x87 FPU errors are
     * ignored. When the NE flag is clear and the IGNNE\# input is deasserted, an unmasked x87 FPU error causes the processor
     * to assert the FERR\# pin to generate an external interrupt and to stop instruction execution immediately before
     * executing the next waiting floating-point instruction or WAIT/FWAIT instruction.
     * The FERR\# pin is intended to drive an input to an external interrupt controller (the FERR\# pin emulates the ERROR\#
     * pin of the Intel 287 and Intel 387 DX math coprocessors). The NE flag, IGNNE\# pin, and FERR\# pin are used with
     * external logic to implement PC-style error reporting. Using FERR\# and IGNNE\# to handle floating-point exceptions is
     * deprecated by modern operating systems; this non-native approach also limits newer processors to operate with one
     * logical processor active.
     *
    UINT64 NumericError                                            : 1;
#define CR0_NUMERIC_ERROR_BIT                                        5
#define CR0_NUMERIC_ERROR_FLAG                                       0x20
#define CR0_NUMERIC_ERROR_MASK                                       0x01
#define CR0_NUMERIC_ERROR(_)                                         (((_) >> 5) & 0x01)
    UINT64 Reserved1                                               : 10;
     *
     * [Bit 16] When set, inhibits supervisor-level procedures from writing into readonly pages; when clear, allows
     * supervisor-level procedures to write into read-only pages (regardless of the U/S bit setting). This flag facilitates
     * implementation of the copy-onwrite method of creating a new process (forking) used by operating systems such as UNIX.
     *
    UINT64 WriteProtect                                            : 1;
#define CR0_WRITE_PROTECT_BIT                                        16
#define CR0_WRITE_PROTECT_FLAG                                       0x10000
#define CR0_WRITE_PROTECT_MASK                                       0x01
#define CR0_WRITE_PROTECT(_)                                         (((_) >> 16) & 0x01)
    UINT64 Reserved2                                               : 1;
     *
     * [Bit 18] Enables automatic alignment checking when set; disables alignment checking when clear. Alignment checking is
     * performed only when the AM flag is set, the AC flag in the EFLAGS register is set, CPL is 3, and the processor is
     * operating in either protected or virtual-8086 mode.
    UINT64 AlignmentMask                                           : 1;
#define CR0_ALIGNMENT_MASK_BIT                                       18
#define CR0_ALIGNMENT_MASK_FLAG                                      0x40000
#define CR0_ALIGNMENT_MASK_MASK                                      0x01
#define CR0_ALIGNMENT_MASK(_)                                        (((_) >> 18) & 0x01)
    UINT64 Reserved3                                               : 10;
     *
     * [Bit 29] When the NW and CD flags are clear, write-back (for Pentium 4, Intel Xeon, P6 family, and Pentium processors)
     * or write-through (for Intel486 processors) is enabled for writes that hit the cache and invalidation cycles are enabled.
    UINT64 NotWriteThrough                                         : 1;
#define CR0_NOT_WRITE_THROUGH_BIT                                    29
#define CR0_NOT_WRITE_THROUGH_FLAG                                   0x20000000
#define CR0_NOT_WRITE_THROUGH_MASK                                   0x01
#define CR0_NOT_WRITE_THROUGH(_)                                     (((_) >> 29) & 0x01)
     *
     * [Bit 30] When the CD and NW flags are clear, caching of memory locations for the whole of physical memory in the
     * processor's internal (and external) caches is enabled. When the CD flag is set, caching is restricted. To prevent the
     * processor from accessing and updating its caches, the CD flag must be set and the caches must be invalidated so that no
     * cache hits can occur.
     *
    UINT64 CacheDisable                                            : 1;
#define CR0_CACHE_DISABLE_BIT                                        30
#define CR0_CACHE_DISABLE_FLAG                                       0x40000000
#define CR0_CACHE_DISABLE_MASK                                       0x01
#define CR0_CACHE_DISABLE(_)                                         (((_) >> 30) & 0x01)
     *
     * [Bit 31] Enables paging when set; disables paging when clear. When paging is disabled, all linear addresses are treated
     * as physical addresses. The PG flag has no effect if the PE flag (bit 0 of register CR0) is not also set; setting the PG
     * flag when the PE flag is clear causes a general-protection exception (\#GP).
     * On Intel 64 processors, enabling and disabling IA-32e mode operation also requires modifying CR0.PG.
     *
    UINT64 PagingEnable                                            : 1;
#define CR0_PAGING_ENABLE_BIT                                        31
#define CR0_PAGING_ENABLE_FLAG                                       0x80000000
#define CR0_PAGING_ENABLE_MASK                                       0x01
#define CR0_PAGING_ENABLE(_)                                         (((_) >> 31) & 0x01)
    UINT64 Reserved4                                               : 32;
  };
  UINT64 AsUInt;
} CR0;*/
return true
}

func (i *ia32)#define CR3_PAGE_LEVEL_WRITE_THROUGH()(ok bool){//col:311
/*#define CR3_PAGE_LEVEL_WRITE_THROUGH(_)                              (((_) >> 3) & 0x01)
     *
     * [Bit 4] Controls the memory type used to access the first paging structure of the current paging-structure hierarchy.
     * This bit is not used if paging is disabled, with PAE paging, or with 4-level paging2 if CR4.PCIDE=1.
     *
    UINT64 PageLevelCacheDisable                                   : 1;
#define CR3_PAGE_LEVEL_CACHE_DISABLE_BIT                             4
#define CR3_PAGE_LEVEL_CACHE_DISABLE_FLAG                            0x10
#define CR3_PAGE_LEVEL_CACHE_DISABLE_MASK                            0x01
#define CR3_PAGE_LEVEL_CACHE_DISABLE(_)                              (((_) >> 4) & 0x01)
    UINT64 Reserved2                                               : 7;
     *
     * [Bits 47:12] Physical address of the 4-KByte aligned page directory (32-bit paging) or PML4 table (64-bit paging) used
     * for linear-address translation.
     *
    UINT64 AddressOfPageDirectory                                  : 36;
#define CR3_ADDRESS_OF_PAGE_DIRECTORY_BIT                            12
#define CR3_ADDRESS_OF_PAGE_DIRECTORY_FLAG                           0xFFFFFFFFF000
#define CR3_ADDRESS_OF_PAGE_DIRECTORY_MASK                           0xFFFFFFFFF
#define CR3_ADDRESS_OF_PAGE_DIRECTORY(_)                             (((_) >> 12) & 0xFFFFFFFFF)
    UINT64 Reserved3                                               : 16;
  };
  UINT64 AsUInt;
} CR3;*/
return true
}

func (i *ia32)     * hardware support for a virtual interrupt flag ()(ok bool){//col:669
/*     * hardware support for a virtual interrupt flag (VIF) to improve reliability of running 8086 programs in multitasking and
     * multiple-processor environments.
     *
    UINT64 VirtualModeExtensions                                   : 1;
#define CR4_VIRTUAL_MODE_EXTENSIONS_BIT                              0
#define CR4_VIRTUAL_MODE_EXTENSIONS_FLAG                             0x01
#define CR4_VIRTUAL_MODE_EXTENSIONS_MASK                             0x01
#define CR4_VIRTUAL_MODE_EXTENSIONS(_)                               (((_) >> 0) & 0x01)
     *
     * [Bit 1] Enables hardware support for a virtual interrupt flag (VIF) in protected mode when set; disables the VIF flag in
     * protected mode when clear.
     *
    UINT64 ProtectedModeVirtualInterrupts                          : 1;
#define CR4_PROTECTED_MODE_VIRTUAL_INTERRUPTS_BIT                    1
#define CR4_PROTECTED_MODE_VIRTUAL_INTERRUPTS_FLAG                   0x02
#define CR4_PROTECTED_MODE_VIRTUAL_INTERRUPTS_MASK                   0x01
#define CR4_PROTECTED_MODE_VIRTUAL_INTERRUPTS(_)                     (((_) >> 1) & 0x01)
     *
     * [Bit 2] Restricts the execution of the RDTSC instruction to procedures running at privilege level 0 when set; allows
     * RDTSC instruction to be executed at any privilege level when clear. This bit also applies to the RDTSCP instruction if
     * supported (if CPUID.80000001H:EDX[27] = 1).
    UINT64 TimestampDisable                                        : 1;
#define CR4_TIMESTAMP_DISABLE_BIT                                    2
#define CR4_TIMESTAMP_DISABLE_FLAG                                   0x04
#define CR4_TIMESTAMP_DISABLE_MASK                                   0x01
#define CR4_TIMESTAMP_DISABLE(_)                                     (((_) >> 2) & 0x01)
     *
     * [Bit 3] References to debug registers DR4 and DR5 cause an undefined opcode (\#UD) exception to be generated when set;
     * when clear, processor aliases references to registers DR4 and DR5 for compatibility with software written to run on
     * earlier IA-32 processors.
     *
    UINT64 DebuggingExtensions                                     : 1;
#define CR4_DEBUGGING_EXTENSIONS_BIT                                 3
#define CR4_DEBUGGING_EXTENSIONS_FLAG                                0x08
#define CR4_DEBUGGING_EXTENSIONS_MASK                                0x01
#define CR4_DEBUGGING_EXTENSIONS(_)                                  (((_) >> 3) & 0x01)
     *
     * [Bit 4] Enables 4-MByte pages with 32-bit paging when set; restricts 32-bit paging to pages of 4 KBytes when clear.
     *
    UINT64 PageSizeExtensions                                      : 1;
#define CR4_PAGE_SIZE_EXTENSIONS_BIT                                 4
#define CR4_PAGE_SIZE_EXTENSIONS_FLAG                                0x10
#define CR4_PAGE_SIZE_EXTENSIONS_MASK                                0x01
#define CR4_PAGE_SIZE_EXTENSIONS(_)                                  (((_) >> 4) & 0x01)
     *
     * [Bit 5] When set, enables paging to produce physical addresses with more than 32 bits. When clear, restricts physical
     * addresses to 32 bits. PAE must be set before entering IA-32e mode.
     *
    UINT64 PhysicalAddressExtension                                : 1;
#define CR4_PHYSICAL_ADDRESS_EXTENSION_BIT                           5
#define CR4_PHYSICAL_ADDRESS_EXTENSION_FLAG                          0x20
#define CR4_PHYSICAL_ADDRESS_EXTENSION_MASK                          0x01
#define CR4_PHYSICAL_ADDRESS_EXTENSION(_)                            (((_) >> 5) & 0x01)
     *
     * [Bit 6] Enables the machine-check exception when set; disables the machine-check exception when clear.
     *
    UINT64 MachineCheckEnable                                      : 1;
#define CR4_MACHINE_CHECK_ENABLE_BIT                                 6
#define CR4_MACHINE_CHECK_ENABLE_FLAG                                0x40
#define CR4_MACHINE_CHECK_ENABLE_MASK                                0x01
#define CR4_MACHINE_CHECK_ENABLE(_)                                  (((_) >> 6) & 0x01)
     *
     * [Bit 7] (Introduced in the P6 family processors.) Enables the global page feature when set; disables the global page
     * feature when clear. The global page feature allows frequently used or shared pages to be marked as global to all users
     * (done with the global flag, bit 8, in a page-directory or page-table entry). Global pages are not flushed from the
     * translation-lookaside buffer (TLB) on a task switch or a write to register CR3. When enabling the global page feature,
     * paging must be enabled (by setting the PG flag in control register CR0) before the PGE flag is set. Reversing this
     * sequence may affect program correctness, and processor performance will be impacted.
     *
    UINT64 PageGlobalEnable                                        : 1;
#define CR4_PAGE_GLOBAL_ENABLE_BIT                                   7
#define CR4_PAGE_GLOBAL_ENABLE_FLAG                                  0x80
#define CR4_PAGE_GLOBAL_ENABLE_MASK                                  0x01
#define CR4_PAGE_GLOBAL_ENABLE(_)                                    (((_) >> 7) & 0x01)
     *
     * [Bit 8] Enables execution of the RDPMC instruction for programs or procedures running at any protection level when set;
     * RDPMC instruction can be executed only at protection level 0 when clear.
    UINT64 PerformanceMonitoringCounterEnable                      : 1;
#define CR4_PERFORMANCE_MONITORING_COUNTER_ENABLE_BIT                8
#define CR4_PERFORMANCE_MONITORING_COUNTER_ENABLE_FLAG               0x100
#define CR4_PERFORMANCE_MONITORING_COUNTER_ENABLE_MASK               0x01
#define CR4_PERFORMANCE_MONITORING_COUNTER_ENABLE(_)                 (((_) >> 8) & 0x01)
     *
     * [Bit 9] When set, this flag:
     * -# indicates to software that the operating system supports the use of the FXSAVE and FXRSTOR instructions,
     * -# enables the FXSAVE and FXRSTOR instructions to save and restore the contents of the XMM and MXCSR registers along
     * with the contents of the x87 FPU and MMX registers, and
     * -# enables the processor to execute SSE/SSE2/SSE3/SSSE3/SSE4 instructions, with the exception of the PAUSE, PREFETCHh,
     * SFENCE, LFENCE, MFENCE, MOVNTI, CLFLUSH, CRC32, and POPCNT.
     * If this flag is clear, the FXSAVE and FXRSTOR instructions will save and restore the contents of the x87 FPU and MMX
     * registers, but they may not save and restore the contents of the XMM and MXCSR registers. Also, the processor will
     * generate an invalid opcode exception (\#UD) if it attempts to execute any SSE/SSE2/SSE3 instruction, with the exception
     * of PAUSE, PREFETCHh, SFENCE, LFENCE, MFENCE, MOVNTI, CLFLUSH, CRC32, and POPCNT. The operating system or executive must
     * explicitly set this flag.
     *
     *          operating system software with a means of enabling FXSAVE/FXRSTOR to save/restore the contents of the X87 FPU, XMM and
     *          MXCSR registers. Consequently OSFXSR bit indicates that the operating system provides context switch support for
     *          SSE/SSE2/SSE3/SSSE3/SSE4.
    UINT64 OsFxsaveFxrstorSupport                                  : 1;
#define CR4_OS_FXSAVE_FXRSTOR_SUPPORT_BIT                            9
#define CR4_OS_FXSAVE_FXRSTOR_SUPPORT_FLAG                           0x200
#define CR4_OS_FXSAVE_FXRSTOR_SUPPORT_MASK                           0x01
#define CR4_OS_FXSAVE_FXRSTOR_SUPPORT(_)                             (((_) >> 9) & 0x01)
     *
     * [Bit 10] Operating System Support for Unmasked SIMD Floating-Point Exceptions - When set, indicates that the operating
     * system supports the handling of unmasked SIMD floating-point exceptions through an exception handler that is invoked
     * when a SIMD floating-point exception (\#XM) is generated. SIMD floating-point exceptions are only generated by
     * SSE/SSE2/SSE3/SSE4.1 SIMD floating-point instructions.
     * The operating system or executive must explicitly set this flag. If this flag is not set, the processor will generate an
     * invalid opcode exception (\#UD) whenever it detects an unmasked SIMD floating-point exception.
    UINT64 OsXmmExceptionSupport                                   : 1;
#define CR4_OS_XMM_EXCEPTION_SUPPORT_BIT                             10
#define CR4_OS_XMM_EXCEPTION_SUPPORT_FLAG                            0x400
#define CR4_OS_XMM_EXCEPTION_SUPPORT_MASK                            0x01
#define CR4_OS_XMM_EXCEPTION_SUPPORT(_)                              (((_) >> 10) & 0x01)
     *
     * [Bit 11] When set, the following instructions cannot be executed if CPL > 0: SGDT, SIDT, SLDT, SMSW, and STR. An attempt
     * at such execution causes a general-protection exception (\#GP).
    UINT64 UsermodeInstructionPrevention                           : 1;
#define CR4_USERMODE_INSTRUCTION_PREVENTION_BIT                      11
#define CR4_USERMODE_INSTRUCTION_PREVENTION_FLAG                     0x800
#define CR4_USERMODE_INSTRUCTION_PREVENTION_MASK                     0x01
#define CR4_USERMODE_INSTRUCTION_PREVENTION(_)                       (((_) >> 11) & 0x01)
     *
     * [Bit 12] When set in IA-32e mode, the processor uses 5-level paging to translate 57-bit linear addresses. When clear in
     * IA-32e mode, the processor uses 4-level paging to translate 48-bit linear addresses. This bit cannot be modified in
     * IA-32e mode.
     *
    UINT64 LinearAddresses57Bit                                    : 1;
#define CR4_LINEAR_ADDRESSES_57_BIT_BIT                              12
#define CR4_LINEAR_ADDRESSES_57_BIT_FLAG                             0x1000
#define CR4_LINEAR_ADDRESSES_57_BIT_MASK                             0x01
#define CR4_LINEAR_ADDRESSES_57_BIT(_)                               (((_) >> 12) & 0x01)
     *
     * [Bit 13] Enables VMX operation when set.
     *
    UINT64 VmxEnable                                               : 1;
#define CR4_VMX_ENABLE_BIT                                           13
#define CR4_VMX_ENABLE_FLAG                                          0x2000
#define CR4_VMX_ENABLE_MASK                                          0x01
#define CR4_VMX_ENABLE(_)                                            (((_) >> 13) & 0x01)
     *
     * [Bit 14] Enables SMX operation when set.
     *
    UINT64 SmxEnable                                               : 1;
#define CR4_SMX_ENABLE_BIT                                           14
#define CR4_SMX_ENABLE_FLAG                                          0x4000
#define CR4_SMX_ENABLE_MASK                                          0x01
#define CR4_SMX_ENABLE(_)                                            (((_) >> 14) & 0x01)
    UINT64 Reserved1                                               : 1;
     *
     * [Bit 16] Enables the instructions RDFSBASE, RDGSBASE, WRFSBASE, and WRGSBASE.
    UINT64 FsgsbaseEnable                                          : 1;
#define CR4_FSGSBASE_ENABLE_BIT                                      16
#define CR4_FSGSBASE_ENABLE_FLAG                                     0x10000
#define CR4_FSGSBASE_ENABLE_MASK                                     0x01
#define CR4_FSGSBASE_ENABLE(_)                                       (((_) >> 16) & 0x01)
     *
     * [Bit 17] Enables process-context identifiers (PCIDs) when set. Can be set only in IA-32e mode (if IA32_EFER.LMA = 1).
     *
    UINT64 PcidEnable                                              : 1;
#define CR4_PCID_ENABLE_BIT                                          17
#define CR4_PCID_ENABLE_FLAG                                         0x20000
#define CR4_PCID_ENABLE_MASK                                         0x01
#define CR4_PCID_ENABLE(_)                                           (((_) >> 17) & 0x01)
     *
     * [Bit 18] When set, this flag:
     * -# indicates (via CPUID.01H:ECX.OSXSAVE[bit 27]) that the operating system supports the use of the XGETBV, XSAVE and
     * XRSTOR instructions by general software;
     * -# enables the XSAVE and XRSTOR instructions to save and restore the x87 FPU state (including MMX registers), the SSE
     * state (XMM registers and MXCSR), along with other processor extended states enabled in XCR0;
     * -# enables the processor to execute XGETBV and XSETBV instructions in order to read and write XCR0.
     *
    UINT64 OsXsave                                                 : 1;
#define CR4_OS_XSAVE_BIT                                             18
#define CR4_OS_XSAVE_FLAG                                            0x40000
#define CR4_OS_XSAVE_MASK                                            0x01
#define CR4_OS_XSAVE(_)                                              (((_) >> 18) & 0x01)
     *
     * [Bit 19] When set, the LOADIWKEY instruction is enabled; in addition, if support for the AES Key Locker instructions has
     * been activated by system firmware, CPUID.19H:EBX.AESKLE[bit 0] is enumerated as 1 and the AES Key Locker instructions
     * are enabled. When clear, CPUID.19H:EBX.AESKLE[bit 0] is enumerated as 0 and execution of any Key Locker instruction
     * causes an invalid-opcode exception (\#UD).
    UINT64 KeyLockerEnable                                         : 1;
#define CR4_KEY_LOCKER_ENABLE_BIT                                    19
#define CR4_KEY_LOCKER_ENABLE_FLAG                                   0x80000
#define CR4_KEY_LOCKER_ENABLE_MASK                                   0x01
#define CR4_KEY_LOCKER_ENABLE(_)                                     (((_) >> 19) & 0x01)
     *
     * [Bit 20] Enables supervisor-mode execution prevention (SMEP) when set.
     *
    UINT64 SmepEnable                                              : 1;
#define CR4_SMEP_ENABLE_BIT                                          20
#define CR4_SMEP_ENABLE_FLAG                                         0x100000
#define CR4_SMEP_ENABLE_MASK                                         0x01
#define CR4_SMEP_ENABLE(_)                                           (((_) >> 20) & 0x01)
     *
     * [Bit 21] Enables supervisor-mode access prevention (SMAP) when set.
     *
    UINT64 SmapEnable                                              : 1;
#define CR4_SMAP_ENABLE_BIT                                          21
#define CR4_SMAP_ENABLE_FLAG                                         0x200000
#define CR4_SMAP_ENABLE_MASK                                         0x01
#define CR4_SMAP_ENABLE(_)                                           (((_) >> 21) & 0x01)
     *
     * [Bit 22] Enables 4-level paging to associate each linear address with a protection key. The PKRU register specifies, for
     * each protection key, whether user-mode linear addresses with that protection key can be read or written. This bit also
     * enables access to the PKRU register using the RDPKRU and WRPKRU instructions.
    UINT64 ProtectionKeyEnable                                     : 1;
#define CR4_PROTECTION_KEY_ENABLE_BIT                                22
#define CR4_PROTECTION_KEY_ENABLE_FLAG                               0x400000
#define CR4_PROTECTION_KEY_ENABLE_MASK                               0x01
#define CR4_PROTECTION_KEY_ENABLE(_)                                 (((_) >> 22) & 0x01)
     *
     * [Bit 23] Enables control-flow enforcement technology when set. This flag can be set only if CR0.WP is set, and it must
     * be clear before CR0.WP can be cleared.
     *
    UINT64 ControlFlowEnforcementEnable                            : 1;
#define CR4_CONTROL_FLOW_ENFORCEMENT_ENABLE_BIT                      23
#define CR4_CONTROL_FLOW_ENFORCEMENT_ENABLE_FLAG                     0x800000
#define CR4_CONTROL_FLOW_ENFORCEMENT_ENABLE_MASK                     0x01
#define CR4_CONTROL_FLOW_ENFORCEMENT_ENABLE(_)                       (((_) >> 23) & 0x01)
     *
     * [Bit 24] 4-level paging and 5-level paging associate each supervisor-mode linear address with a protection key. When
     * set, this flag allows use of the IA32_PKRS MSR to specify, for each protection key, whether supervisor-mode linear
     * addresses with that protection key can be read or written.
    UINT64 ProtectionKeyForSupervisorModeEnable                    : 1;
#define CR4_PROTECTION_KEY_FOR_SUPERVISOR_MODE_ENABLE_BIT            24
#define CR4_PROTECTION_KEY_FOR_SUPERVISOR_MODE_ENABLE_FLAG           0x1000000
#define CR4_PROTECTION_KEY_FOR_SUPERVISOR_MODE_ENABLE_MASK           0x01
#define CR4_PROTECTION_KEY_FOR_SUPERVISOR_MODE_ENABLE(_)             (((_) >> 24) & 0x01)
    UINT64 Reserved2                                               : 39;
  };
  UINT64 AsUInt;
} CR4;*/
return true
}

func (i *ia32)#define CR8_TASK_PRIORITY_LEVEL()(ok bool){//col:701
/*#define CR8_TASK_PRIORITY_LEVEL(_)                                   (((_) >> 0) & 0x0F)
     *
     * [Bits 63:4] Reserved and must be written with zeros. Failure to do this causes a general-protection exception.
    UINT64 Reserved                                                : 60;
#define CR8_RESERVED_BIT                                             4
#define CR8_RESERVED_FLAG                                            0xFFFFFFFFFFFFFFF0
#define CR8_RESERVED_MASK                                            0xFFFFFFFFFFFFFFF
#define CR8_RESERVED(_)                                              (((_) >> 4) & 0xFFFFFFFFFFFFFFF)
  };
  UINT64 AsUInt;
} CR8;*/
return true
}

func (i *ia32) * other privilege level generates a general-protection exception ()(ok bool){//col:807
/* * other privilege level generates a general-protection exception (\#GP). The primary function of the debug registers is to
 * set up and monitor from 1 to 4 breakpoints, numbered 0 though 3. For each breakpoint, the following information can be
 * specified:
 * - The linear address where the breakpoint is to occur.
 * - The length of the breakpoint location: 1, 2, 4, or 8 bytes.
 * - The operation that must be performed at the address for a debug exception to be generated.
 * - Whether the breakpoint is enabled.
 * - Whether the breakpoint condition was present when the debug exception was generated.
 *
typedef union
{
  struct
  {
     *
     * [Bits 3:0] Indicates (when set) that its associated breakpoint condition was met when a debug exception was generated.
     * These flags are set if the condition described for each breakpoint by the LENn, and R/Wn flags in debug control register
     * DR7 is true. They may or may not be set if the breakpoint is not enabled by the Ln or the Gn flags in register DR7.
     * Therefore on a \#DB, a debug handler should check only those B0-B3 bits which correspond to an enabled breakpoint.
    UINT64 BreakpointCondition                                     : 4;
#define DR6_BREAKPOINT_CONDITION_BIT                                 0
#define DR6_BREAKPOINT_CONDITION_FLAG                                0x0F
#define DR6_BREAKPOINT_CONDITION_MASK                                0x0F
#define DR6_BREAKPOINT_CONDITION(_)                                  (((_) >> 0) & 0x0F)
    UINT64 Reserved1                                               : 9;
     *
     * [Bit 13] Indicates that the next instruction in the instruction stream accesses one of the debug registers (DR0 through
     * DR7). This flag is enabled when the GD (general detect) flag in debug control register DR7 is set.
     *
    UINT64 DebugRegisterAccessDetected                             : 1;
#define DR6_DEBUG_REGISTER_ACCESS_DETECTED_BIT                       13
#define DR6_DEBUG_REGISTER_ACCESS_DETECTED_FLAG                      0x2000
#define DR6_DEBUG_REGISTER_ACCESS_DETECTED_MASK                      0x01
#define DR6_DEBUG_REGISTER_ACCESS_DETECTED(_)                        (((_) >> 13) & 0x01)
     *
     * [Bit 14] Indicates (when set) that the debug exception was triggered by the singlestep execution mode (enabled with the
     * TF flag in the EFLAGS register). The single-step mode is the highestpriority debug exception. When the BS flag is set,
     * any of the other debug status bits also may be set.
    UINT64 SingleInstruction                                       : 1;
#define DR6_SINGLE_INSTRUCTION_BIT                                   14
#define DR6_SINGLE_INSTRUCTION_FLAG                                  0x4000
#define DR6_SINGLE_INSTRUCTION_MASK                                  0x01
#define DR6_SINGLE_INSTRUCTION(_)                                    (((_) >> 14) & 0x01)
     *
     * [Bit 15] Indicates (when set) that the debug exception was triggered by the singlestep execution mode (enabled with the
     * TF flag in the EFLAGS register). The single-step mode is the highestpriority debug exception. When the BS flag is set,
     * any of the other debug status bits also may be set.
    UINT64 TaskSwitch                                              : 1;
#define DR6_TASK_SWITCH_BIT                                          15
#define DR6_TASK_SWITCH_FLAG                                         0x8000
#define DR6_TASK_SWITCH_MASK                                         0x01
#define DR6_TASK_SWITCH(_)                                           (((_) >> 15) & 0x01)
     *
     * [Bit 16] Indicates (when clear) that a debug exception (\#DB) or breakpoint exception (\#BP) occurred inside an RTM
     * region while advanced debugging of RTM transactional regions was enabled. This bit is set for any other debug exception
     * (including all those that occur when advanced debugging of RTM transactional regions is not enabled). This bit is always
     * 1 if the processor does not support RTM.
     *
    UINT64 RestrictedTransactionalMemory                           : 1;
#define DR6_RESTRICTED_TRANSACTIONAL_MEMORY_BIT                      16
#define DR6_RESTRICTED_TRANSACTIONAL_MEMORY_FLAG                     0x10000
#define DR6_RESTRICTED_TRANSACTIONAL_MEMORY_MASK                     0x01
#define DR6_RESTRICTED_TRANSACTIONAL_MEMORY(_)                       (((_) >> 16) & 0x01)
    UINT64 Reserved2                                               : 47;
  };
  UINT64 AsUInt;
} DR6;*/
return true
}

func (i *ia32)     * [Bit 0] Enables ()(ok bool){//col:998
/*     * [Bit 0] Enables (when set) the breakpoint condition for the associated breakpoint for the current task. When a
     * breakpoint condition is detected and its associated Ln flag is set, a debug exception is generated. The processor
     * automatically clears these flags on every task switch to avoid unwanted breakpoint conditions in the new task.
    UINT64 LocalBreakpoint0                                        : 1;
#define DR7_LOCAL_BREAKPOINT_0_BIT                                   0
#define DR7_LOCAL_BREAKPOINT_0_FLAG                                  0x01
#define DR7_LOCAL_BREAKPOINT_0_MASK                                  0x01
#define DR7_LOCAL_BREAKPOINT_0(_)                                    (((_) >> 0) & 0x01)
     *
     * [Bit 1] Enables (when set) the breakpoint condition for the associated breakpoint for all tasks. When a breakpoint
     * condition is detected and its associated Gn flag is set, a debug exception is generated. The processor does not clear
     * these flags on a task switch, allowing a breakpoint to be enabled for all tasks.
    UINT64 GlobalBreakpoint0                                       : 1;
#define DR7_GLOBAL_BREAKPOINT_0_BIT                                  1
#define DR7_GLOBAL_BREAKPOINT_0_FLAG                                 0x02
#define DR7_GLOBAL_BREAKPOINT_0_MASK                                 0x01
#define DR7_GLOBAL_BREAKPOINT_0(_)                                   (((_) >> 1) & 0x01)
    UINT64 LocalBreakpoint1                                        : 1;
#define DR7_LOCAL_BREAKPOINT_1_BIT                                   2
#define DR7_LOCAL_BREAKPOINT_1_FLAG                                  0x04
#define DR7_LOCAL_BREAKPOINT_1_MASK                                  0x01
#define DR7_LOCAL_BREAKPOINT_1(_)                                    (((_) >> 2) & 0x01)
    UINT64 GlobalBreakpoint1                                       : 1;
#define DR7_GLOBAL_BREAKPOINT_1_BIT                                  3
#define DR7_GLOBAL_BREAKPOINT_1_FLAG                                 0x08
#define DR7_GLOBAL_BREAKPOINT_1_MASK                                 0x01
#define DR7_GLOBAL_BREAKPOINT_1(_)                                   (((_) >> 3) & 0x01)
    UINT64 LocalBreakpoint2                                        : 1;
#define DR7_LOCAL_BREAKPOINT_2_BIT                                   4
#define DR7_LOCAL_BREAKPOINT_2_FLAG                                  0x10
#define DR7_LOCAL_BREAKPOINT_2_MASK                                  0x01
#define DR7_LOCAL_BREAKPOINT_2(_)                                    (((_) >> 4) & 0x01)
    UINT64 GlobalBreakpoint2                                       : 1;
#define DR7_GLOBAL_BREAKPOINT_2_BIT                                  5
#define DR7_GLOBAL_BREAKPOINT_2_FLAG                                 0x20
#define DR7_GLOBAL_BREAKPOINT_2_MASK                                 0x01
#define DR7_GLOBAL_BREAKPOINT_2(_)                                   (((_) >> 5) & 0x01)
    UINT64 LocalBreakpoint3                                        : 1;
#define DR7_LOCAL_BREAKPOINT_3_BIT                                   6
#define DR7_LOCAL_BREAKPOINT_3_FLAG                                  0x40
#define DR7_LOCAL_BREAKPOINT_3_MASK                                  0x01
#define DR7_LOCAL_BREAKPOINT_3(_)                                    (((_) >> 6) & 0x01)
    UINT64 GlobalBreakpoint3                                       : 1;
#define DR7_GLOBAL_BREAKPOINT_3_BIT                                  7
#define DR7_GLOBAL_BREAKPOINT_3_FLAG                                 0x80
#define DR7_GLOBAL_BREAKPOINT_3_MASK                                 0x01
#define DR7_GLOBAL_BREAKPOINT_3(_)                                   (((_) >> 7) & 0x01)
     *
     * [Bit 8] This feature is not supported in the P6 family processors, later IA-32 processors, and Intel 64 processors. When
     * set, these flags cause the processor to detect the exact instruction that caused a data breakpoint condition. For
     * backward and forward compatibility with other Intel processors, we recommend that the LE and GE flags be set to 1 if
     * exact breakpoints are required.
    UINT64 LocalExactBreakpoint                                    : 1;
#define DR7_LOCAL_EXACT_BREAKPOINT_BIT                               8
#define DR7_LOCAL_EXACT_BREAKPOINT_FLAG                              0x100
#define DR7_LOCAL_EXACT_BREAKPOINT_MASK                              0x01
#define DR7_LOCAL_EXACT_BREAKPOINT(_)                                (((_) >> 8) & 0x01)
    UINT64 GlobalExactBreakpoint                                   : 1;
#define DR7_GLOBAL_EXACT_BREAKPOINT_BIT                              9
#define DR7_GLOBAL_EXACT_BREAKPOINT_FLAG                             0x200
#define DR7_GLOBAL_EXACT_BREAKPOINT_MASK                             0x01
#define DR7_GLOBAL_EXACT_BREAKPOINT(_)                               (((_) >> 9) & 0x01)
    UINT64 Reserved1                                               : 1;
     *
     * [Bit 11] Enables (when set) advanced debugging of RTM transactional regions. This advanced debugging is enabled only if
     * IA32_DEBUGCTL.RTM is also set.
     *
    UINT64 RestrictedTransactionalMemory                           : 1;
#define DR7_RESTRICTED_TRANSACTIONAL_MEMORY_BIT                      11
#define DR7_RESTRICTED_TRANSACTIONAL_MEMORY_FLAG                     0x800
#define DR7_RESTRICTED_TRANSACTIONAL_MEMORY_MASK                     0x01
#define DR7_RESTRICTED_TRANSACTIONAL_MEMORY(_)                       (((_) >> 11) & 0x01)
    UINT64 Reserved2                                               : 1;
     *
     * [Bit 13] Enables (when set) debug-register protection, which causes a debug exception to be generated prior to any MOV
     * instruction that accesses a debug register. When such a condition is detected, the BD flag in debug status register DR6
     * is set prior to generating the exception. This condition is provided to support in-circuit emulators.
     * When the emulator needs to access the debug registers, emulator software can set the GD flag to prevent interference
     * from the program currently executing on the processor.
     * The processor clears the GD flag upon entering to the debug exception handler, to allow the handler access to the debug
     * registers.
    UINT64 GeneralDetect                                           : 1;
#define DR7_GENERAL_DETECT_BIT                                       13
#define DR7_GENERAL_DETECT_FLAG                                      0x2000
#define DR7_GENERAL_DETECT_MASK                                      0x01
#define DR7_GENERAL_DETECT(_)                                        (((_) >> 13) & 0x01)
    UINT64 Reserved3                                               : 2;
     *
     * [Bits 17:16] Specifies the breakpoint condition for the corresponding breakpoint. The DE (debug extensions) flag in
     * control register CR4 determines how the bits in the R/Wn fields are interpreted. When the DE flag is set, the processor
     * interprets bits as follows:
     * - 00 - Break on instruction execution only.
     * - 01 - Break on data writes only.
     * - 10 - Break on I/O reads or writes.
     * - 11 - Break on data reads or writes but not instruction fetches.
     * When the DE flag is clear, the processor interprets the R/Wn bits the same as for the Intel386(TM) and Intel486(TM)
     * processors, which is as follows:
     * - 00 - Break on instruction execution only.
     * - 01 - Break on data writes only.
     * - 10 - Undefined.
     * - 11 - Break on data reads or writes but not instruction fetches.
    UINT64 ReadWrite0                                              : 2;
#define DR7_READ_WRITE_0_BIT                                         16
#define DR7_READ_WRITE_0_FLAG                                        0x30000
#define DR7_READ_WRITE_0_MASK                                        0x03
#define DR7_READ_WRITE_0(_)                                          (((_) >> 16) & 0x03)
     *
     * [Bits 19:18] Specify the size of the memory location at the address specified in the corresponding breakpoint address
     * register (DR0 through DR3). These fields are interpreted as follows:
     * - 00 - 1-byte length.
     * - 01 - 2-byte length.
     * - 10 - Undefined (or 8 byte length, see note below).
     * - 11 - 4-byte length.
     * If the corresponding RWn field in register DR7 is 00 (instruction execution), then the LENn field should also be 00. The
     * effect of using other lengths is undefined.
     *
    UINT64 Length0                                                 : 2;
#define DR7_LENGTH_0_BIT                                             18
#define DR7_LENGTH_0_FLAG                                            0xC0000
#define DR7_LENGTH_0_MASK                                            0x03
#define DR7_LENGTH_0(_)                                              (((_) >> 18) & 0x03)
    UINT64 ReadWrite1                                              : 2;
#define DR7_READ_WRITE_1_BIT                                         20
#define DR7_READ_WRITE_1_FLAG                                        0x300000
#define DR7_READ_WRITE_1_MASK                                        0x03
#define DR7_READ_WRITE_1(_)                                          (((_) >> 20) & 0x03)
    UINT64 Length1                                                 : 2;
#define DR7_LENGTH_1_BIT                                             22
#define DR7_LENGTH_1_FLAG                                            0xC00000
#define DR7_LENGTH_1_MASK                                            0x03
#define DR7_LENGTH_1(_)                                              (((_) >> 22) & 0x03)
    UINT64 ReadWrite2                                              : 2;
#define DR7_READ_WRITE_2_BIT                                         24
#define DR7_READ_WRITE_2_FLAG                                        0x3000000
#define DR7_READ_WRITE_2_MASK                                        0x03
#define DR7_READ_WRITE_2(_)                                          (((_) >> 24) & 0x03)
    UINT64 Length2                                                 : 2;
#define DR7_LENGTH_2_BIT                                             26
#define DR7_LENGTH_2_FLAG                                            0xC000000
#define DR7_LENGTH_2_MASK                                            0x03
#define DR7_LENGTH_2(_)                                              (((_) >> 26) & 0x03)
    UINT64 ReadWrite3                                              : 2;
#define DR7_READ_WRITE_3_BIT                                         28
#define DR7_READ_WRITE_3_FLAG                                        0x30000000
#define DR7_READ_WRITE_3_MASK                                        0x03
#define DR7_READ_WRITE_3(_)                                          (((_) >> 28) & 0x03)
    UINT64 Length3                                                 : 2;
#define DR7_LENGTH_3_BIT                                             30
#define DR7_LENGTH_3_FLAG                                            0xC0000000
#define DR7_LENGTH_3_MASK                                            0x03
#define DR7_LENGTH_3(_)                                              (((_) >> 30) & 0x03)
    UINT64 Reserved4                                               : 32;
  };
  UINT64 AsUInt;
} DR7;*/
return true
}

func (i *ia32) * - EBX <- 756e6547h ()(ok bool){//col:1052
/* * - EBX <- 756e6547h (* "Genu", with G in the low eight bits of BL *)
 * - EDX <- 49656e69h (* "ineI", with i in the low eight bits of DL *)
 * - ECX <- 6c65746eh (* "ntel", with n in the low eight bits of CL *)
#define CPUID_SIGNATURE                                              0x00000000
typedef struct
{
   *
   * Maximum Input Value for Basic CPUID Information.
  UINT32 MaxCpuidInputValue;
   *
   * "Genu"
  UINT32 EbxValueGenu;
   *
   * "ntel"
  UINT32 EcxValueNtel;
   *
   * "ineI"
  UINT32 EdxValueInei;
} CPUID_EAX_00;*/
return true
}

func (i *ia32)#define CPUID_VERSION_INFORMATION_STEPPING_ID()(ok bool){//col:1896
/*#define CPUID_VERSION_INFORMATION_STEPPING_ID(_)                     (((_) >> 0) & 0x0F)
      UINT32 Model                                                 : 4;
#define CPUID_VERSION_INFORMATION_MODEL_BIT                          4
#define CPUID_VERSION_INFORMATION_MODEL_FLAG                         0xF0
#define CPUID_VERSION_INFORMATION_MODEL_MASK                         0x0F
#define CPUID_VERSION_INFORMATION_MODEL(_)                           (((_) >> 4) & 0x0F)
      UINT32 FamilyId                                              : 4;
#define CPUID_VERSION_INFORMATION_FAMILY_ID_BIT                      8
#define CPUID_VERSION_INFORMATION_FAMILY_ID_FLAG                     0xF00
#define CPUID_VERSION_INFORMATION_FAMILY_ID_MASK                     0x0F
#define CPUID_VERSION_INFORMATION_FAMILY_ID(_)                       (((_) >> 8) & 0x0F)
       * [Bits 13:12] - 0 - Original OEM Processor
       * - 1 - Intel OverDrive(R) Processor
       * - 2 - Dual processor (not applicable to Intel486 processors)
       * - 3 - Intel reserved
      UINT32 ProcessorType                                         : 2;
#define CPUID_VERSION_INFORMATION_PROCESSOR_TYPE_BIT                 12
#define CPUID_VERSION_INFORMATION_PROCESSOR_TYPE_FLAG                0x3000
#define CPUID_VERSION_INFORMATION_PROCESSOR_TYPE_MASK                0x03
#define CPUID_VERSION_INFORMATION_PROCESSOR_TYPE(_)                  (((_) >> 12) & 0x03)
      UINT32 Reserved1                                             : 2;
       * [Bits 19:16] The Extended Model ID needs to be examined only when the Family ID is 06H or 0FH.
      UINT32 ExtendedModelId                                       : 4;
#define CPUID_VERSION_INFORMATION_EXTENDED_MODEL_ID_BIT              16
#define CPUID_VERSION_INFORMATION_EXTENDED_MODEL_ID_FLAG             0xF0000
#define CPUID_VERSION_INFORMATION_EXTENDED_MODEL_ID_MASK             0x0F
#define CPUID_VERSION_INFORMATION_EXTENDED_MODEL_ID(_)               (((_) >> 16) & 0x0F)
       * [Bits 27:20] The Extended Family ID needs to be examined only when the Family ID is 0FH.
      UINT32 ExtendedFamilyId                                      : 8;
#define CPUID_VERSION_INFORMATION_EXTENDED_FAMILY_ID_BIT             20
#define CPUID_VERSION_INFORMATION_EXTENDED_FAMILY_ID_FLAG            0xFF00000
#define CPUID_VERSION_INFORMATION_EXTENDED_FAMILY_ID_MASK            0xFF
#define CPUID_VERSION_INFORMATION_EXTENDED_FAMILY_ID(_)              (((_) >> 20) & 0xFF)
      UINT32 Reserved2                                             : 4;
    };
    UINT32 AsUInt;
  } CpuidVersionInformation;
  union
  {
    struct
    {
       * [Bits 7:0] This number provides an entry into a brand string table that contains brand strings for IA-32 processors.
       * More information about this field is provided later in this section.
      UINT32 BrandIndex                                            : 8;
#define CPUID_ADDITIONAL_INFORMATION_BRAND_INDEX_BIT                 0
#define CPUID_ADDITIONAL_INFORMATION_BRAND_INDEX_FLAG                0xFF
#define CPUID_ADDITIONAL_INFORMATION_BRAND_INDEX_MASK                0xFF
#define CPUID_ADDITIONAL_INFORMATION_BRAND_INDEX(_)                  (((_) >> 0) & 0xFF)
       *
       * [Bits 15:8] This number indicates the size of the cache line flushed by the CLFLUSH and CLFLUSHOPT instructions in
       * 8-byte increments. This field was introduced in the Pentium 4 processor.
      UINT32 ClflushLineSize                                       : 8;
#define CPUID_ADDITIONAL_INFORMATION_CLFLUSH_LINE_SIZE_BIT           8
#define CPUID_ADDITIONAL_INFORMATION_CLFLUSH_LINE_SIZE_FLAG          0xFF00
#define CPUID_ADDITIONAL_INFORMATION_CLFLUSH_LINE_SIZE_MASK          0xFF
#define CPUID_ADDITIONAL_INFORMATION_CLFLUSH_LINE_SIZE(_)            (((_) >> 8) & 0xFF)
       * [Bits 23:16] Maximum number of addressable IDs for logical processors in this physical package.
       *
       *          reserved for addressing different logical processors in a physical package. This field is only valid if
       *          CPUID.1.EDX.HTT[bit 28] = 1.
      UINT32 MaxAddressableIds                                     : 8;
#define CPUID_ADDITIONAL_INFORMATION_MAX_ADDRESSABLE_IDS_BIT         16
#define CPUID_ADDITIONAL_INFORMATION_MAX_ADDRESSABLE_IDS_FLAG        0xFF0000
#define CPUID_ADDITIONAL_INFORMATION_MAX_ADDRESSABLE_IDS_MASK        0xFF
#define CPUID_ADDITIONAL_INFORMATION_MAX_ADDRESSABLE_IDS(_)          (((_) >> 16) & 0xFF)
       * [Bits 31:24] This number is the 8-bit ID that is assigned to the local APIC on the processor during power up. This field
       * was introduced in the Pentium 4 processor.
      UINT32 InitialApicId                                         : 8;
#define CPUID_ADDITIONAL_INFORMATION_INITIAL_APIC_ID_BIT             24
#define CPUID_ADDITIONAL_INFORMATION_INITIAL_APIC_ID_FLAG            0xFF000000
#define CPUID_ADDITIONAL_INFORMATION_INITIAL_APIC_ID_MASK            0xFF
#define CPUID_ADDITIONAL_INFORMATION_INITIAL_APIC_ID(_)              (((_) >> 24) & 0xFF)
    };
    UINT32 AsUInt;
  } CpuidAdditionalInformation;
  union
  {
    struct
    {
       *
       * [Bit 0] A value of 1 indicates the processor supports this technology.
      UINT32 StreamingSimdExtensions3                              : 1;
#define CPUID_FEATURE_INFORMATION_ECX_STREAMING_SIMD_EXTENSIONS_3_BIT 0
#define CPUID_FEATURE_INFORMATION_ECX_STREAMING_SIMD_EXTENSIONS_3_FLAG 0x01
#define CPUID_FEATURE_INFORMATION_ECX_STREAMING_SIMD_EXTENSIONS_3_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_STREAMING_SIMD_EXTENSIONS_3(_) (((_) >> 0) & 0x01)
       *
       * [Bit 1] A value of 1 indicates the processor supports the PCLMULQDQ instruction.
      UINT32 PclmulqdqInstruction                                  : 1;
#define CPUID_FEATURE_INFORMATION_ECX_PCLMULQDQ_INSTRUCTION_BIT      1
#define CPUID_FEATURE_INFORMATION_ECX_PCLMULQDQ_INSTRUCTION_FLAG     0x02
#define CPUID_FEATURE_INFORMATION_ECX_PCLMULQDQ_INSTRUCTION_MASK     0x01
#define CPUID_FEATURE_INFORMATION_ECX_PCLMULQDQ_INSTRUCTION(_)       (((_) >> 1) & 0x01)
       *
       * [Bit 2] A value of 1 indicates the processor supports DS area using 64-bit layout.
      UINT32 DsArea64BitLayout                                     : 1;
#define CPUID_FEATURE_INFORMATION_ECX_DS_AREA_64BIT_LAYOUT_BIT       2
#define CPUID_FEATURE_INFORMATION_ECX_DS_AREA_64BIT_LAYOUT_FLAG      0x04
#define CPUID_FEATURE_INFORMATION_ECX_DS_AREA_64BIT_LAYOUT_MASK      0x01
#define CPUID_FEATURE_INFORMATION_ECX_DS_AREA_64BIT_LAYOUT(_)        (((_) >> 2) & 0x01)
       *
       * [Bit 3] A value of 1 indicates the processor supports this feature.
      UINT32 MonitorMwaitInstruction                               : 1;
#define CPUID_FEATURE_INFORMATION_ECX_MONITOR_MWAIT_INSTRUCTION_BIT  3
#define CPUID_FEATURE_INFORMATION_ECX_MONITOR_MWAIT_INSTRUCTION_FLAG 0x08
#define CPUID_FEATURE_INFORMATION_ECX_MONITOR_MWAIT_INSTRUCTION_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_MONITOR_MWAIT_INSTRUCTION(_)   (((_) >> 3) & 0x01)
       *
       * [Bit 4] A value of 1 indicates the processor supports the extensions to the Debug Store feature to allow for branch
       * message storage qualified by CPL.
      UINT32 CplQualifiedDebugStore                                : 1;
#define CPUID_FEATURE_INFORMATION_ECX_CPL_QUALIFIED_DEBUG_STORE_BIT  4
#define CPUID_FEATURE_INFORMATION_ECX_CPL_QUALIFIED_DEBUG_STORE_FLAG 0x10
#define CPUID_FEATURE_INFORMATION_ECX_CPL_QUALIFIED_DEBUG_STORE_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_CPL_QUALIFIED_DEBUG_STORE(_)   (((_) >> 4) & 0x01)
       *
       * [Bit 5] A value of 1 indicates that the processor supports this technology.
      UINT32 VirtualMachineExtensions                              : 1;
#define CPUID_FEATURE_INFORMATION_ECX_VIRTUAL_MACHINE_EXTENSIONS_BIT 5
#define CPUID_FEATURE_INFORMATION_ECX_VIRTUAL_MACHINE_EXTENSIONS_FLAG 0x20
#define CPUID_FEATURE_INFORMATION_ECX_VIRTUAL_MACHINE_EXTENSIONS_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_VIRTUAL_MACHINE_EXTENSIONS(_)  (((_) >> 5) & 0x01)
       *
       * [Bit 6] A value of 1 indicates that the processor supports this technology.
       *
      UINT32 SaferModeExtensions                                   : 1;
#define CPUID_FEATURE_INFORMATION_ECX_SAFER_MODE_EXTENSIONS_BIT      6
#define CPUID_FEATURE_INFORMATION_ECX_SAFER_MODE_EXTENSIONS_FLAG     0x40
#define CPUID_FEATURE_INFORMATION_ECX_SAFER_MODE_EXTENSIONS_MASK     0x01
#define CPUID_FEATURE_INFORMATION_ECX_SAFER_MODE_EXTENSIONS(_)       (((_) >> 6) & 0x01)
       *
       * [Bit 7] A value of 1 indicates that the processor supports this technology.
      UINT32 EnhancedIntelSpeedstepTechnology                      : 1;
#define CPUID_FEATURE_INFORMATION_ECX_ENHANCED_INTEL_SPEEDSTEP_TECHNOLOGY_BIT 7
#define CPUID_FEATURE_INFORMATION_ECX_ENHANCED_INTEL_SPEEDSTEP_TECHNOLOGY_FLAG 0x80
#define CPUID_FEATURE_INFORMATION_ECX_ENHANCED_INTEL_SPEEDSTEP_TECHNOLOGY_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_ENHANCED_INTEL_SPEEDSTEP_TECHNOLOGY(_) (((_) >> 7) & 0x01)
       *
       * [Bit 8] A value of 1 indicates whether the processor supports this technology.
      UINT32 ThermalMonitor2                                       : 1;
#define CPUID_FEATURE_INFORMATION_ECX_THERMAL_MONITOR_2_BIT          8
#define CPUID_FEATURE_INFORMATION_ECX_THERMAL_MONITOR_2_FLAG         0x100
#define CPUID_FEATURE_INFORMATION_ECX_THERMAL_MONITOR_2_MASK         0x01
#define CPUID_FEATURE_INFORMATION_ECX_THERMAL_MONITOR_2(_)           (((_) >> 8) & 0x01)
       *
       * [Bit 9] A value of 1 indicates the presence of the Supplemental Streaming SIMD Extensions 3 (SSSE3). A value of 0
       * indicates the instruction extensions are not present in the processor.
      UINT32 SupplementalStreamingSimdExtensions3                  : 1;
#define CPUID_FEATURE_INFORMATION_ECX_SUPPLEMENTAL_STREAMING_SIMD_EXTENSIONS_3_BIT 9
#define CPUID_FEATURE_INFORMATION_ECX_SUPPLEMENTAL_STREAMING_SIMD_EXTENSIONS_3_FLAG 0x200
#define CPUID_FEATURE_INFORMATION_ECX_SUPPLEMENTAL_STREAMING_SIMD_EXTENSIONS_3_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_SUPPLEMENTAL_STREAMING_SIMD_EXTENSIONS_3(_) (((_) >> 9) & 0x01)
       *
       * [Bit 10] A value of 1 indicates the L1 data cache mode can be set to either adaptive mode or shared mode. A value of 0
       * indicates this feature is not supported. See definition of the IA32_MISC_ENABLE MSR Bit 24 (L1 Data Cache Context Mode)
       * for details.
      UINT32 L1ContextId                                           : 1;
#define CPUID_FEATURE_INFORMATION_ECX_L1_CONTEXT_ID_BIT              10
#define CPUID_FEATURE_INFORMATION_ECX_L1_CONTEXT_ID_FLAG             0x400
#define CPUID_FEATURE_INFORMATION_ECX_L1_CONTEXT_ID_MASK             0x01
#define CPUID_FEATURE_INFORMATION_ECX_L1_CONTEXT_ID(_)               (((_) >> 10) & 0x01)
       *
       * [Bit 11] A value of 1 indicates the processor supports IA32_DEBUG_INTERFACE MSR for silicon debug.
      UINT32 SiliconDebug                                          : 1;
#define CPUID_FEATURE_INFORMATION_ECX_SILICON_DEBUG_BIT              11
#define CPUID_FEATURE_INFORMATION_ECX_SILICON_DEBUG_FLAG             0x800
#define CPUID_FEATURE_INFORMATION_ECX_SILICON_DEBUG_MASK             0x01
#define CPUID_FEATURE_INFORMATION_ECX_SILICON_DEBUG(_)               (((_) >> 11) & 0x01)
       *
       * [Bit 12] A value of 1 indicates the processor supports FMA (Fused Multiple Add) extensions using YMM state.
      UINT32 FmaExtensions                                         : 1;
#define CPUID_FEATURE_INFORMATION_ECX_FMA_EXTENSIONS_BIT             12
#define CPUID_FEATURE_INFORMATION_ECX_FMA_EXTENSIONS_FLAG            0x1000
#define CPUID_FEATURE_INFORMATION_ECX_FMA_EXTENSIONS_MASK            0x01
#define CPUID_FEATURE_INFORMATION_ECX_FMA_EXTENSIONS(_)              (((_) >> 12) & 0x01)
       *
       * [Bit 13] A value of 1 indicates that the feature is available.
      UINT32 Cmpxchg16BInstruction                                 : 1;
#define CPUID_FEATURE_INFORMATION_ECX_CMPXCHG16B_INSTRUCTION_BIT     13
#define CPUID_FEATURE_INFORMATION_ECX_CMPXCHG16B_INSTRUCTION_FLAG    0x2000
#define CPUID_FEATURE_INFORMATION_ECX_CMPXCHG16B_INSTRUCTION_MASK    0x01
#define CPUID_FEATURE_INFORMATION_ECX_CMPXCHG16B_INSTRUCTION(_)      (((_) >> 13) & 0x01)
       *
       * [Bit 14] A value of 1 indicates that the processor supports changing IA32_MISC_ENABLE[bit 23].
      UINT32 XtprUpdateControl                                     : 1;
#define CPUID_FEATURE_INFORMATION_ECX_XTPR_UPDATE_CONTROL_BIT        14
#define CPUID_FEATURE_INFORMATION_ECX_XTPR_UPDATE_CONTROL_FLAG       0x4000
#define CPUID_FEATURE_INFORMATION_ECX_XTPR_UPDATE_CONTROL_MASK       0x01
#define CPUID_FEATURE_INFORMATION_ECX_XTPR_UPDATE_CONTROL(_)         (((_) >> 14) & 0x01)
       *
       * [Bit 15] A value of 1 indicates the processor supports the performance and debug feature indication MSR
       * IA32_PERF_CAPABILITIES.
      UINT32 PerfmonAndDebugCapability                             : 1;
#define CPUID_FEATURE_INFORMATION_ECX_PERFMON_AND_DEBUG_CAPABILITY_BIT 15
#define CPUID_FEATURE_INFORMATION_ECX_PERFMON_AND_DEBUG_CAPABILITY_FLAG 0x8000
#define CPUID_FEATURE_INFORMATION_ECX_PERFMON_AND_DEBUG_CAPABILITY_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_PERFMON_AND_DEBUG_CAPABILITY(_) (((_) >> 15) & 0x01)
      UINT32 Reserved1                                             : 1;
       *
       * [Bit 17] A value of 1 indicates that the processor supports PCIDs and that software may set CR4.PCIDE to 1.
      UINT32 ProcessContextIdentifiers                             : 1;
#define CPUID_FEATURE_INFORMATION_ECX_PROCESS_CONTEXT_IDENTIFIERS_BIT 17
#define CPUID_FEATURE_INFORMATION_ECX_PROCESS_CONTEXT_IDENTIFIERS_FLAG 0x20000
#define CPUID_FEATURE_INFORMATION_ECX_PROCESS_CONTEXT_IDENTIFIERS_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_PROCESS_CONTEXT_IDENTIFIERS(_) (((_) >> 17) & 0x01)
       *
       * [Bit 18] A value of 1 indicates the processor supports the ability to prefetch data from a memory mapped device (Direct
       * Cache Access).
      UINT32 DirectCacheAccess                                     : 1;
#define CPUID_FEATURE_INFORMATION_ECX_DIRECT_CACHE_ACCESS_BIT        18
#define CPUID_FEATURE_INFORMATION_ECX_DIRECT_CACHE_ACCESS_FLAG       0x40000
#define CPUID_FEATURE_INFORMATION_ECX_DIRECT_CACHE_ACCESS_MASK       0x01
#define CPUID_FEATURE_INFORMATION_ECX_DIRECT_CACHE_ACCESS(_)         (((_) >> 18) & 0x01)
       *
       * [Bit 19] A value of 1 indicates that the processor supports SSE4.1.
      UINT32 Sse41Support                                          : 1;
#define CPUID_FEATURE_INFORMATION_ECX_SSE41_SUPPORT_BIT              19
#define CPUID_FEATURE_INFORMATION_ECX_SSE41_SUPPORT_FLAG             0x80000
#define CPUID_FEATURE_INFORMATION_ECX_SSE41_SUPPORT_MASK             0x01
#define CPUID_FEATURE_INFORMATION_ECX_SSE41_SUPPORT(_)               (((_) >> 19) & 0x01)
       *
       * [Bit 20] A value of 1 indicates that the processor supports SSE4.2.
      UINT32 Sse42Support                                          : 1;
#define CPUID_FEATURE_INFORMATION_ECX_SSE42_SUPPORT_BIT              20
#define CPUID_FEATURE_INFORMATION_ECX_SSE42_SUPPORT_FLAG             0x100000
#define CPUID_FEATURE_INFORMATION_ECX_SSE42_SUPPORT_MASK             0x01
#define CPUID_FEATURE_INFORMATION_ECX_SSE42_SUPPORT(_)               (((_) >> 20) & 0x01)
       *
       * [Bit 21] A value of 1 indicates that the processor supports x2APIC feature.
      UINT32 X2ApicSupport                                         : 1;
#define CPUID_FEATURE_INFORMATION_ECX_X2APIC_SUPPORT_BIT             21
#define CPUID_FEATURE_INFORMATION_ECX_X2APIC_SUPPORT_FLAG            0x200000
#define CPUID_FEATURE_INFORMATION_ECX_X2APIC_SUPPORT_MASK            0x01
#define CPUID_FEATURE_INFORMATION_ECX_X2APIC_SUPPORT(_)              (((_) >> 21) & 0x01)
       *
       * [Bit 22] A value of 1 indicates that the processor supports MOVBE instruction.
      UINT32 MovbeInstruction                                      : 1;
#define CPUID_FEATURE_INFORMATION_ECX_MOVBE_INSTRUCTION_BIT          22
#define CPUID_FEATURE_INFORMATION_ECX_MOVBE_INSTRUCTION_FLAG         0x400000
#define CPUID_FEATURE_INFORMATION_ECX_MOVBE_INSTRUCTION_MASK         0x01
#define CPUID_FEATURE_INFORMATION_ECX_MOVBE_INSTRUCTION(_)           (((_) >> 22) & 0x01)
       *
       * [Bit 23] A value of 1 indicates that the processor supports the POPCNT instruction.
      UINT32 PopcntInstruction                                     : 1;
#define CPUID_FEATURE_INFORMATION_ECX_POPCNT_INSTRUCTION_BIT         23
#define CPUID_FEATURE_INFORMATION_ECX_POPCNT_INSTRUCTION_FLAG        0x800000
#define CPUID_FEATURE_INFORMATION_ECX_POPCNT_INSTRUCTION_MASK        0x01
#define CPUID_FEATURE_INFORMATION_ECX_POPCNT_INSTRUCTION(_)          (((_) >> 23) & 0x01)
       *
       * [Bit 24] A value of 1 indicates that the processor's local APIC timer supports one-shot operation using a TSC deadline
       * value.
      UINT32 TscDeadline                                           : 1;
#define CPUID_FEATURE_INFORMATION_ECX_TSC_DEADLINE_BIT               24
#define CPUID_FEATURE_INFORMATION_ECX_TSC_DEADLINE_FLAG              0x1000000
#define CPUID_FEATURE_INFORMATION_ECX_TSC_DEADLINE_MASK              0x01
#define CPUID_FEATURE_INFORMATION_ECX_TSC_DEADLINE(_)                (((_) >> 24) & 0x01)
       *
       * [Bit 25] A value of 1 indicates that the processor supports the AESNI instruction extensions.
      UINT32 AesniInstructionExtensions                            : 1;
#define CPUID_FEATURE_INFORMATION_ECX_AESNI_INSTRUCTION_EXTENSIONS_BIT 25
#define CPUID_FEATURE_INFORMATION_ECX_AESNI_INSTRUCTION_EXTENSIONS_FLAG 0x2000000
#define CPUID_FEATURE_INFORMATION_ECX_AESNI_INSTRUCTION_EXTENSIONS_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_AESNI_INSTRUCTION_EXTENSIONS(_) (((_) >> 25) & 0x01)
       *
       * [Bit 26] A value of 1 indicates that the processor supports the XSAVE/XRSTOR processor extended states feature, the
       * XSETBV/XGETBV instructions, and XCR0.
      UINT32 XsaveXrstorInstruction                                : 1;
#define CPUID_FEATURE_INFORMATION_ECX_XSAVE_XRSTOR_INSTRUCTION_BIT   26
#define CPUID_FEATURE_INFORMATION_ECX_XSAVE_XRSTOR_INSTRUCTION_FLAG  0x4000000
#define CPUID_FEATURE_INFORMATION_ECX_XSAVE_XRSTOR_INSTRUCTION_MASK  0x01
#define CPUID_FEATURE_INFORMATION_ECX_XSAVE_XRSTOR_INSTRUCTION(_)    (((_) >> 26) & 0x01)
       *
       * [Bit 27] A value of 1 indicates that the OS has set CR4.OSXSAVE[bit 18] to enable XSETBV/XGETBV instructions to access
       * XCR0 and to support processor extended state management using XSAVE/XRSTOR.
      UINT32 OsxSave                                               : 1;
#define CPUID_FEATURE_INFORMATION_ECX_OSX_SAVE_BIT                   27
#define CPUID_FEATURE_INFORMATION_ECX_OSX_SAVE_FLAG                  0x8000000
#define CPUID_FEATURE_INFORMATION_ECX_OSX_SAVE_MASK                  0x01
#define CPUID_FEATURE_INFORMATION_ECX_OSX_SAVE(_)                    (((_) >> 27) & 0x01)
       *
       * [Bit 28] A value of 1 indicates the processor supports the AVX instruction extensions.
      UINT32 AvxSupport                                            : 1;
#define CPUID_FEATURE_INFORMATION_ECX_AVX_SUPPORT_BIT                28
#define CPUID_FEATURE_INFORMATION_ECX_AVX_SUPPORT_FLAG               0x10000000
#define CPUID_FEATURE_INFORMATION_ECX_AVX_SUPPORT_MASK               0x01
#define CPUID_FEATURE_INFORMATION_ECX_AVX_SUPPORT(_)                 (((_) >> 28) & 0x01)
       *
       * [Bit 29] A value of 1 indicates that processor supports 16-bit floating-point conversion instructions.
      UINT32 HalfPrecisionConversionInstructions                   : 1;
#define CPUID_FEATURE_INFORMATION_ECX_HALF_PRECISION_CONVERSION_INSTRUCTIONS_BIT 29
#define CPUID_FEATURE_INFORMATION_ECX_HALF_PRECISION_CONVERSION_INSTRUCTIONS_FLAG 0x20000000
#define CPUID_FEATURE_INFORMATION_ECX_HALF_PRECISION_CONVERSION_INSTRUCTIONS_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_HALF_PRECISION_CONVERSION_INSTRUCTIONS(_) (((_) >> 29) & 0x01)
       *
       * [Bit 30] A value of 1 indicates that processor supports RDRAND instruction.
      UINT32 RdrandInstruction                                     : 1;
#define CPUID_FEATURE_INFORMATION_ECX_RDRAND_INSTRUCTION_BIT         30
#define CPUID_FEATURE_INFORMATION_ECX_RDRAND_INSTRUCTION_FLAG        0x40000000
#define CPUID_FEATURE_INFORMATION_ECX_RDRAND_INSTRUCTION_MASK        0x01
#define CPUID_FEATURE_INFORMATION_ECX_RDRAND_INSTRUCTION(_)          (((_) >> 30) & 0x01)
      UINT32 Reserved2                                             : 1;
    };
    UINT32 AsUInt;
  } CpuidFeatureInformationEcx;
  union
  {
    struct
    {
       *
       * [Bit 0] The processor contains an x87 FPU.
      UINT32 FloatingPointUnitOnChip                               : 1;
#define CPUID_FEATURE_INFORMATION_EDX_FLOATING_POINT_UNIT_ON_CHIP_BIT 0
#define CPUID_FEATURE_INFORMATION_EDX_FLOATING_POINT_UNIT_ON_CHIP_FLAG 0x01
#define CPUID_FEATURE_INFORMATION_EDX_FLOATING_POINT_UNIT_ON_CHIP_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_FLOATING_POINT_UNIT_ON_CHIP(_) (((_) >> 0) & 0x01)
       *
       * [Bit 1] Virtual 8086 mode enhancements, including CR4.VME for controlling the feature, CR4.PVI for protected mode
       * virtual interrupts, software interrupt indirection, expansion of the TSS with the software indirection bitmap, and
       * EFLAGS.VIF and EFLAGS.VIP flags.
      UINT32 Virtual8086ModeEnhancements                           : 1;
#define CPUID_FEATURE_INFORMATION_EDX_VIRTUAL_8086_MODE_ENHANCEMENTS_BIT 1
#define CPUID_FEATURE_INFORMATION_EDX_VIRTUAL_8086_MODE_ENHANCEMENTS_FLAG 0x02
#define CPUID_FEATURE_INFORMATION_EDX_VIRTUAL_8086_MODE_ENHANCEMENTS_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_VIRTUAL_8086_MODE_ENHANCEMENTS(_) (((_) >> 1) & 0x01)
       *
       * [Bit 2] Support for I/O breakpoints, including CR4.DE for controlling the feature, and optional trapping of accesses to
       * DR4 and DR5.
      UINT32 DebuggingExtensions                                   : 1;
#define CPUID_FEATURE_INFORMATION_EDX_DEBUGGING_EXTENSIONS_BIT       2
#define CPUID_FEATURE_INFORMATION_EDX_DEBUGGING_EXTENSIONS_FLAG      0x04
#define CPUID_FEATURE_INFORMATION_EDX_DEBUGGING_EXTENSIONS_MASK      0x01
#define CPUID_FEATURE_INFORMATION_EDX_DEBUGGING_EXTENSIONS(_)        (((_) >> 2) & 0x01)
       *
       * [Bit 3] Large pages of size 4 MByte are supported, including CR4.PSE for controlling the feature, the defined dirty bit
       * in PDE (Page Directory Entries), optional reserved bit trapping in CR3, PDEs, and PTEs.
      UINT32 PageSizeExtension                                     : 1;
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_SIZE_EXTENSION_BIT        3
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_SIZE_EXTENSION_FLAG       0x08
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_SIZE_EXTENSION_MASK       0x01
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_SIZE_EXTENSION(_)         (((_) >> 3) & 0x01)
       *
       * [Bit 4] The RDTSC instruction is supported, including CR4.TSD for controlling privilege.
      UINT32 TimestampCounter                                      : 1;
#define CPUID_FEATURE_INFORMATION_EDX_TIMESTAMP_COUNTER_BIT          4
#define CPUID_FEATURE_INFORMATION_EDX_TIMESTAMP_COUNTER_FLAG         0x10
#define CPUID_FEATURE_INFORMATION_EDX_TIMESTAMP_COUNTER_MASK         0x01
#define CPUID_FEATURE_INFORMATION_EDX_TIMESTAMP_COUNTER(_)           (((_) >> 4) & 0x01)
       *
       * [Bit 5] The RDMSR and WRMSR instructions are supported. Some of the MSRs are implementation dependent.
      UINT32 RdmsrWrmsrInstructions                                : 1;
#define CPUID_FEATURE_INFORMATION_EDX_RDMSR_WRMSR_INSTRUCTIONS_BIT   5
#define CPUID_FEATURE_INFORMATION_EDX_RDMSR_WRMSR_INSTRUCTIONS_FLAG  0x20
#define CPUID_FEATURE_INFORMATION_EDX_RDMSR_WRMSR_INSTRUCTIONS_MASK  0x01
#define CPUID_FEATURE_INFORMATION_EDX_RDMSR_WRMSR_INSTRUCTIONS(_)    (((_) >> 5) & 0x01)
       *
       * [Bit 6] Physical addresses greater than 32 bits are supported: extended page table entry formats, an extra level in the
       * page translation tables is defined, 2-MByte pages are supported instead of 4 Mbyte pages if PAE bit is 1.
      UINT32 PhysicalAddressExtension                              : 1;
#define CPUID_FEATURE_INFORMATION_EDX_PHYSICAL_ADDRESS_EXTENSION_BIT 6
#define CPUID_FEATURE_INFORMATION_EDX_PHYSICAL_ADDRESS_EXTENSION_FLAG 0x40
#define CPUID_FEATURE_INFORMATION_EDX_PHYSICAL_ADDRESS_EXTENSION_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_PHYSICAL_ADDRESS_EXTENSION(_)  (((_) >> 6) & 0x01)
       *
       * [Bit 7] Exception 18 is defined for Machine Checks, including CR4.MCE for controlling the feature. This feature does not
       * define the model-specific implementations of machine-check error logging, reporting, and processor shutdowns. Machine
       * Check exception handlers may have to depend on processor version to do model specific processing of the exception, or
       * test for the presence of the Machine Check feature.
      UINT32 MachineCheckException                                 : 1;
#define CPUID_FEATURE_INFORMATION_EDX_MACHINE_CHECK_EXCEPTION_BIT    7
#define CPUID_FEATURE_INFORMATION_EDX_MACHINE_CHECK_EXCEPTION_FLAG   0x80
#define CPUID_FEATURE_INFORMATION_EDX_MACHINE_CHECK_EXCEPTION_MASK   0x01
#define CPUID_FEATURE_INFORMATION_EDX_MACHINE_CHECK_EXCEPTION(_)     (((_) >> 7) & 0x01)
       *
       * [Bit 8] The compare-and-exchange 8 bytes (64 bits) instruction is supported (implicitly locked and atomic).
      UINT32 Cmpxchg8B                                             : 1;
#define CPUID_FEATURE_INFORMATION_EDX_CMPXCHG8B_BIT                  8
#define CPUID_FEATURE_INFORMATION_EDX_CMPXCHG8B_FLAG                 0x100
#define CPUID_FEATURE_INFORMATION_EDX_CMPXCHG8B_MASK                 0x01
#define CPUID_FEATURE_INFORMATION_EDX_CMPXCHG8B(_)                   (((_) >> 8) & 0x01)
       *
       * [Bit 9] The processor contains an Advanced Programmable Interrupt Controller (APIC), responding to memory mapped
       * commands in the physical address range FFFE0000H to FFFE0FFFH (by default - some processors permit the APIC to be
       * relocated).
      UINT32 ApicOnChip                                            : 1;
#define CPUID_FEATURE_INFORMATION_EDX_APIC_ON_CHIP_BIT               9
#define CPUID_FEATURE_INFORMATION_EDX_APIC_ON_CHIP_FLAG              0x200
#define CPUID_FEATURE_INFORMATION_EDX_APIC_ON_CHIP_MASK              0x01
#define CPUID_FEATURE_INFORMATION_EDX_APIC_ON_CHIP(_)                (((_) >> 9) & 0x01)
      UINT32 Reserved1                                             : 1;
       *
       * [Bit 11] The SYSENTER and SYSEXIT and associated MSRs are supported.
      UINT32 SysenterSysexitInstructions                           : 1;
#define CPUID_FEATURE_INFORMATION_EDX_SYSENTER_SYSEXIT_INSTRUCTIONS_BIT 11
#define CPUID_FEATURE_INFORMATION_EDX_SYSENTER_SYSEXIT_INSTRUCTIONS_FLAG 0x800
#define CPUID_FEATURE_INFORMATION_EDX_SYSENTER_SYSEXIT_INSTRUCTIONS_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_SYSENTER_SYSEXIT_INSTRUCTIONS(_) (((_) >> 11) & 0x01)
       *
       * [Bit 12] MTRRs are supported. The MTRRcap MSR contains feature bits that describe what memory types are supported, how
       * many variable MTRRs are supported, and whether fixed MTRRs are supported.
      UINT32 MemoryTypeRangeRegisters                              : 1;
#define CPUID_FEATURE_INFORMATION_EDX_MEMORY_TYPE_RANGE_REGISTERS_BIT 12
#define CPUID_FEATURE_INFORMATION_EDX_MEMORY_TYPE_RANGE_REGISTERS_FLAG 0x1000
#define CPUID_FEATURE_INFORMATION_EDX_MEMORY_TYPE_RANGE_REGISTERS_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_MEMORY_TYPE_RANGE_REGISTERS(_) (((_) >> 12) & 0x01)
       *
       * [Bit 13] The global bit is supported in paging-structure entries that map a page, indicating TLB entries that are common
       * to different processes and need not be flushed. The CR4.PGE bit controls this feature.
      UINT32 PageGlobalBit                                         : 1;
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_GLOBAL_BIT_BIT            13
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_GLOBAL_BIT_FLAG           0x2000
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_GLOBAL_BIT_MASK           0x01
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_GLOBAL_BIT(_)             (((_) >> 13) & 0x01)
       *
       * [Bit 14] A value of 1 indicates the Machine Check Architecture of reporting machine errors is supported. The MCG_CAP MSR
       * contains feature bits describing how many banks of error reporting MSRs are supported.
      UINT32 MachineCheckArchitecture                              : 1;
#define CPUID_FEATURE_INFORMATION_EDX_MACHINE_CHECK_ARCHITECTURE_BIT 14
#define CPUID_FEATURE_INFORMATION_EDX_MACHINE_CHECK_ARCHITECTURE_FLAG 0x4000
#define CPUID_FEATURE_INFORMATION_EDX_MACHINE_CHECK_ARCHITECTURE_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_MACHINE_CHECK_ARCHITECTURE(_)  (((_) >> 14) & 0x01)
       *
       * [Bit 15] The conditional move instruction CMOV is supported. In addition, if x87 FPU is present as indicated by the
       * CPUID.FPU feature bit, then the FCOMI and FCMOV instructions are supported
      UINT32 ConditionalMoveInstructions                           : 1;
#define CPUID_FEATURE_INFORMATION_EDX_CONDITIONAL_MOVE_INSTRUCTIONS_BIT 15
#define CPUID_FEATURE_INFORMATION_EDX_CONDITIONAL_MOVE_INSTRUCTIONS_FLAG 0x8000
#define CPUID_FEATURE_INFORMATION_EDX_CONDITIONAL_MOVE_INSTRUCTIONS_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_CONDITIONAL_MOVE_INSTRUCTIONS(_) (((_) >> 15) & 0x01)
       *
       * [Bit 16] Page Attribute Table is supported. This feature augments the Memory Type Range Registers (MTRRs), allowing an
       * operating system to specify attributes of memory accessed through a linear address on a 4KB granularity.
      UINT32 PageAttributeTable                                    : 1;
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_ATTRIBUTE_TABLE_BIT       16
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_ATTRIBUTE_TABLE_FLAG      0x10000
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_ATTRIBUTE_TABLE_MASK      0x01
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_ATTRIBUTE_TABLE(_)        (((_) >> 16) & 0x01)
       *
       * [Bit 17] 4-MByte pages addressing physical memory beyond 4 GBytes are supported with 32-bit paging. This feature
       * indicates that upper bits of the physical address of a 4-MByte page are encoded in bits 20:13 of the page-directory
       * entry. Such physical addresses are limited by MAXPHYADDR and may be up to 40 bits in size.
      UINT32 PageSizeExtension36Bit                                : 1;
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_SIZE_EXTENSION_36BIT_BIT  17
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_SIZE_EXTENSION_36BIT_FLAG 0x20000
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_SIZE_EXTENSION_36BIT_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_SIZE_EXTENSION_36BIT(_)   (((_) >> 17) & 0x01)
       *
       * [Bit 18] The processor supports the 96-bit processor identification number feature and the feature is enabled.
      UINT32 ProcessorSerialNumber                                 : 1;
#define CPUID_FEATURE_INFORMATION_EDX_PROCESSOR_SERIAL_NUMBER_BIT    18
#define CPUID_FEATURE_INFORMATION_EDX_PROCESSOR_SERIAL_NUMBER_FLAG   0x40000
#define CPUID_FEATURE_INFORMATION_EDX_PROCESSOR_SERIAL_NUMBER_MASK   0x01
#define CPUID_FEATURE_INFORMATION_EDX_PROCESSOR_SERIAL_NUMBER(_)     (((_) >> 18) & 0x01)
       *
       * [Bit 19] CLFLUSH Instruction is supported.
      UINT32 Clflush                                               : 1;
#define CPUID_FEATURE_INFORMATION_EDX_CLFLUSH_BIT                    19
#define CPUID_FEATURE_INFORMATION_EDX_CLFLUSH_FLAG                   0x80000
#define CPUID_FEATURE_INFORMATION_EDX_CLFLUSH_MASK                   0x01
#define CPUID_FEATURE_INFORMATION_EDX_CLFLUSH(_)                     (((_) >> 19) & 0x01)
      UINT32 Reserved2                                             : 1;
       *
       * [Bit 21] The processor supports the ability to write debug information into a memory resident buffer. This feature is
       * used by the branch trace store (BTS) and processor event-based sampling (PEBS) facilities.
       *
      UINT32 DebugStore                                            : 1;
#define CPUID_FEATURE_INFORMATION_EDX_DEBUG_STORE_BIT                21
#define CPUID_FEATURE_INFORMATION_EDX_DEBUG_STORE_FLAG               0x200000
#define CPUID_FEATURE_INFORMATION_EDX_DEBUG_STORE_MASK               0x01
#define CPUID_FEATURE_INFORMATION_EDX_DEBUG_STORE(_)                 (((_) >> 21) & 0x01)
       *
       * [Bit 22] The processor implements internal MSRs that allow processor temperature to be monitored and processor
       * performance to be modulated in predefined duty cycles under software control.
      UINT32 ThermalControlMsrsForAcpi                             : 1;
#define CPUID_FEATURE_INFORMATION_EDX_THERMAL_CONTROL_MSRS_FOR_ACPI_BIT 22
#define CPUID_FEATURE_INFORMATION_EDX_THERMAL_CONTROL_MSRS_FOR_ACPI_FLAG 0x400000
#define CPUID_FEATURE_INFORMATION_EDX_THERMAL_CONTROL_MSRS_FOR_ACPI_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_THERMAL_CONTROL_MSRS_FOR_ACPI(_) (((_) >> 22) & 0x01)
       *
       * [Bit 23] The processor supports the Intel MMX technology.
      UINT32 MmxSupport                                            : 1;
#define CPUID_FEATURE_INFORMATION_EDX_MMX_SUPPORT_BIT                23
#define CPUID_FEATURE_INFORMATION_EDX_MMX_SUPPORT_FLAG               0x800000
#define CPUID_FEATURE_INFORMATION_EDX_MMX_SUPPORT_MASK               0x01
#define CPUID_FEATURE_INFORMATION_EDX_MMX_SUPPORT(_)                 (((_) >> 23) & 0x01)
       *
       * [Bit 24] The FXSAVE and FXRSTOR instructions are supported for fast save and restore of the floating point context.
       * Presence of this bit also indicates that CR4.OSFXSR is available for an operating system to indicate that it supports
       * the FXSAVE and FXRSTOR instructions.
      UINT32 FxsaveFxrstorInstructions                             : 1;
#define CPUID_FEATURE_INFORMATION_EDX_FXSAVE_FXRSTOR_INSTRUCTIONS_BIT 24
#define CPUID_FEATURE_INFORMATION_EDX_FXSAVE_FXRSTOR_INSTRUCTIONS_FLAG 0x1000000
#define CPUID_FEATURE_INFORMATION_EDX_FXSAVE_FXRSTOR_INSTRUCTIONS_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_FXSAVE_FXRSTOR_INSTRUCTIONS(_) (((_) >> 24) & 0x01)
       *
       * [Bit 25] The processor supports the SSE extensions.
      UINT32 SseSupport                                            : 1;
#define CPUID_FEATURE_INFORMATION_EDX_SSE_SUPPORT_BIT                25
#define CPUID_FEATURE_INFORMATION_EDX_SSE_SUPPORT_FLAG               0x2000000
#define CPUID_FEATURE_INFORMATION_EDX_SSE_SUPPORT_MASK               0x01
#define CPUID_FEATURE_INFORMATION_EDX_SSE_SUPPORT(_)                 (((_) >> 25) & 0x01)
       *
       * [Bit 26] The processor supports the SSE2 extensions.
      UINT32 Sse2Support                                           : 1;
#define CPUID_FEATURE_INFORMATION_EDX_SSE2_SUPPORT_BIT               26
#define CPUID_FEATURE_INFORMATION_EDX_SSE2_SUPPORT_FLAG              0x4000000
#define CPUID_FEATURE_INFORMATION_EDX_SSE2_SUPPORT_MASK              0x01
#define CPUID_FEATURE_INFORMATION_EDX_SSE2_SUPPORT(_)                (((_) >> 26) & 0x01)
       *
       * [Bit 27] The processor supports the management of conflicting memory types by performing a snoop of its own cache
       * structure for transactions issued to the bus.
      UINT32 SelfSnoop                                             : 1;
#define CPUID_FEATURE_INFORMATION_EDX_SELF_SNOOP_BIT                 27
#define CPUID_FEATURE_INFORMATION_EDX_SELF_SNOOP_FLAG                0x8000000
#define CPUID_FEATURE_INFORMATION_EDX_SELF_SNOOP_MASK                0x01
#define CPUID_FEATURE_INFORMATION_EDX_SELF_SNOOP(_)                  (((_) >> 27) & 0x01)
       *
       * [Bit 28] A value of 0 for HTT indicates there is only a single logical processor in the package and software should
       * assume only a single APIC ID is reserved. A value of 1 for HTT indicates the value in CPUID.1.EBX[23:16] (the Maximum
       * number of addressable IDs for logical processors in this package) is valid for the package.
      UINT32 HyperThreadingTechnology                              : 1;
#define CPUID_FEATURE_INFORMATION_EDX_HYPER_THREADING_TECHNOLOGY_BIT 28
#define CPUID_FEATURE_INFORMATION_EDX_HYPER_THREADING_TECHNOLOGY_FLAG 0x10000000
#define CPUID_FEATURE_INFORMATION_EDX_HYPER_THREADING_TECHNOLOGY_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_HYPER_THREADING_TECHNOLOGY(_)  (((_) >> 28) & 0x01)
       *
       * [Bit 29] The processor implements the thermal monitor automatic thermal control circuitry (TCC).
      UINT32 ThermalMonitor                                        : 1;
#define CPUID_FEATURE_INFORMATION_EDX_THERMAL_MONITOR_BIT            29
#define CPUID_FEATURE_INFORMATION_EDX_THERMAL_MONITOR_FLAG           0x20000000
#define CPUID_FEATURE_INFORMATION_EDX_THERMAL_MONITOR_MASK           0x01
#define CPUID_FEATURE_INFORMATION_EDX_THERMAL_MONITOR(_)             (((_) >> 29) & 0x01)
      UINT32 Reserved3                                             : 1;
       *
       * [Bit 31] The processor supports the use of the FERR\#/PBE\# pin when the processor is in the stop-clock state (STPCLK\#
       * is asserted) to signal the processor that an interrupt is pending and that the processor should return to normal
       * operation to handle the interrupt. Bit 10 (PBE enable) in the IA32_MISC_ENABLE MSR enables this capability.
      UINT32 PendingBreakEnable                                    : 1;
#define CPUID_FEATURE_INFORMATION_EDX_PENDING_BREAK_ENABLE_BIT       31
#define CPUID_FEATURE_INFORMATION_EDX_PENDING_BREAK_ENABLE_FLAG      0x80000000
#define CPUID_FEATURE_INFORMATION_EDX_PENDING_BREAK_ENABLE_MASK      0x01
#define CPUID_FEATURE_INFORMATION_EDX_PENDING_BREAK_ENABLE(_)        (((_) >> 31) & 0x01)
    };
    UINT32 AsUInt;
  } CpuidFeatureInformationEdx;
} CPUID_EAX_01;*/
return true
}

func (i *ia32) * describe a set of deterministic cache parameters ()(ok bool){//col:2101
/* * describe a set of deterministic cache parameters (for the cache level associated with the input in ECX). Valid index
 * values start from 0.
 * Software can enumerate the deterministic cache parameters for each level of the cache hierarchy starting with an index
 * value of 0, until the parameters report the value associated with the cache type field is 0. The architecturally defined
 * fields reported by deterministic cache parameters are documented in Table 3-8.
 * This Cache Size in Bytes
 * - = (Ways + 1) * (Partitions + 1) * (Line_Size + 1) * (Sets + 1)
 * - = (EBX[31:22] + 1) * (EBX[21:12] + 1) * (EBX[11:0] + 1) * (ECX + 1)
 * The CPUID leaf 04H also reports data that can be used to derive the topology of processor cores in a physical package.
 * This information is constant for all valid index values. Software can query the raw data reported by executing CPUID
 * with EAX=04H and ECX=0 and use it as part of the topology enumeration algorithm.
 *
#define CPUID_CACHE_PARAMETERS                                       0x00000004
typedef struct
{
  union
  {
    struct
    {
       * [Bits 4:0] - 0 = Null - No more caches.
       * - 1 = Data Cache.
       * - 2 = Instruction Cache.
       * - 3 = Unified Cache.
       * - 4-31 = Reserved.
      UINT32 CacheTypeField                                        : 5;
#define CPUID_EAX_CACHE_TYPE_FIELD_BIT                               0
#define CPUID_EAX_CACHE_TYPE_FIELD_FLAG                              0x1F
#define CPUID_EAX_CACHE_TYPE_FIELD_MASK                              0x1F
#define CPUID_EAX_CACHE_TYPE_FIELD(_)                                (((_) >> 0) & 0x1F)
       * [Bits 7:5] Cache Level (starts at 1).
      UINT32 CacheLevel                                            : 3;
#define CPUID_EAX_CACHE_LEVEL_BIT                                    5
#define CPUID_EAX_CACHE_LEVEL_FLAG                                   0xE0
#define CPUID_EAX_CACHE_LEVEL_MASK                                   0x07
#define CPUID_EAX_CACHE_LEVEL(_)                                     (((_) >> 5) & 0x07)
       * [Bit 8] Self Initializing cache level (does not need SW initialization).
      UINT32 SelfInitializingCacheLevel                            : 1;
#define CPUID_EAX_SELF_INITIALIZING_CACHE_LEVEL_BIT                  8
#define CPUID_EAX_SELF_INITIALIZING_CACHE_LEVEL_FLAG                 0x100
#define CPUID_EAX_SELF_INITIALIZING_CACHE_LEVEL_MASK                 0x01
#define CPUID_EAX_SELF_INITIALIZING_CACHE_LEVEL(_)                   (((_) >> 8) & 0x01)
       * [Bit 9] Fully Associative cache.
      UINT32 FullyAssociativeCache                                 : 1;
#define CPUID_EAX_FULLY_ASSOCIATIVE_CACHE_BIT                        9
#define CPUID_EAX_FULLY_ASSOCIATIVE_CACHE_FLAG                       0x200
#define CPUID_EAX_FULLY_ASSOCIATIVE_CACHE_MASK                       0x01
#define CPUID_EAX_FULLY_ASSOCIATIVE_CACHE(_)                         (((_) >> 9) & 0x01)
      UINT32 Reserved1                                             : 4;
       * [Bits 25:14] Maximum number of addressable IDs for logical processors sharing this cache.
       *
       *       The nearest power-of-2 integer that is not smaller than (1 + EAX[25:14]) is the number of unique initial APIC IDs
       *       reserved for addressing different logical processors sharing this cache.
      UINT32 MaxAddressableIdsForLogicalProcessorsSharingThisCache : 12;
#define CPUID_EAX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS_SHARING_THIS_CACHE_BIT 14
#define CPUID_EAX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS_SHARING_THIS_CACHE_FLAG 0x3FFC000
#define CPUID_EAX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS_SHARING_THIS_CACHE_MASK 0xFFF
#define CPUID_EAX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS_SHARING_THIS_CACHE(_) (((_) >> 14) & 0xFFF)
       * [Bits 31:26] Maximum number of addressable IDs for processor cores in the physical package.
       *
       *       The nearest power-of-2 integer that is not smaller than (1 + EAX[31:26]) is the number of unique Core_IDs reserved for
       *       addressing different processor cores in a physical package. Core ID is a subset of bits of the initial APIC ID.
       *       The returned value is constant for valid initial values in ECX. Valid ECX values start from 0.
      UINT32 MaxAddressableIdsForProcessorCoresInPhysicalPackage   : 6;
#define CPUID_EAX_MAX_ADDRESSABLE_IDS_FOR_PROCESSOR_CORES_IN_PHYSICAL_PACKAGE_BIT 26
#define CPUID_EAX_MAX_ADDRESSABLE_IDS_FOR_PROCESSOR_CORES_IN_PHYSICAL_PACKAGE_FLAG 0xFC000000
#define CPUID_EAX_MAX_ADDRESSABLE_IDS_FOR_PROCESSOR_CORES_IN_PHYSICAL_PACKAGE_MASK 0x3F
#define CPUID_EAX_MAX_ADDRESSABLE_IDS_FOR_PROCESSOR_CORES_IN_PHYSICAL_PACKAGE(_) (((_) >> 26) & 0x3F)
    };
    UINT32 AsUInt;
  } Eax;
  union
  {
    struct
    {
       * [Bits 11:0] System Coherency Line Size.
       *
      UINT32 SystemCoherencyLineSize                               : 12;
#define CPUID_EBX_SYSTEM_COHERENCY_LINE_SIZE_BIT                     0
#define CPUID_EBX_SYSTEM_COHERENCY_LINE_SIZE_FLAG                    0xFFF
#define CPUID_EBX_SYSTEM_COHERENCY_LINE_SIZE_MASK                    0xFFF
#define CPUID_EBX_SYSTEM_COHERENCY_LINE_SIZE(_)                      (((_) >> 0) & 0xFFF)
       * [Bits 21:12] Physical Line partitions.
       *
      UINT32 PhysicalLinePartitions                                : 10;
#define CPUID_EBX_PHYSICAL_LINE_PARTITIONS_BIT                       12
#define CPUID_EBX_PHYSICAL_LINE_PARTITIONS_FLAG                      0x3FF000
#define CPUID_EBX_PHYSICAL_LINE_PARTITIONS_MASK                      0x3FF
#define CPUID_EBX_PHYSICAL_LINE_PARTITIONS(_)                        (((_) >> 12) & 0x3FF)
       * [Bits 31:22] Ways of associativity.
       *
      UINT32 WaysOfAssociativity                                   : 10;
#define CPUID_EBX_WAYS_OF_ASSOCIATIVITY_BIT                          22
#define CPUID_EBX_WAYS_OF_ASSOCIATIVITY_FLAG                         0xFFC00000
#define CPUID_EBX_WAYS_OF_ASSOCIATIVITY_MASK                         0x3FF
#define CPUID_EBX_WAYS_OF_ASSOCIATIVITY(_)                           (((_) >> 22) & 0x3FF)
    };
    UINT32 AsUInt;
  } Ebx;
  union
  {
    struct
    {
       * [Bits 31:0] Number of Sets.
       *
      UINT32 NumberOfSets                                          : 32;
#define CPUID_ECX_NUMBER_OF_SETS_BIT                                 0
#define CPUID_ECX_NUMBER_OF_SETS_FLAG                                0xFFFFFFFF
#define CPUID_ECX_NUMBER_OF_SETS_MASK                                0xFFFFFFFF
#define CPUID_ECX_NUMBER_OF_SETS(_)                                  (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Ecx;
  union
  {
    struct
    {
       *
       * [Bit 0] - 0 = WBINVD/INVD from threads sharing this cache acts upon lower level caches for threads sharing this cache.
       * - 1 = WBINVD/INVD is not guaranteed to act upon lower level caches of non-originating threads sharing this cache.
      UINT32 WriteBackInvalidate                                   : 1;
#define CPUID_EDX_WRITE_BACK_INVALIDATE_BIT                          0
#define CPUID_EDX_WRITE_BACK_INVALIDATE_FLAG                         0x01
#define CPUID_EDX_WRITE_BACK_INVALIDATE_MASK                         0x01
#define CPUID_EDX_WRITE_BACK_INVALIDATE(_)                           (((_) >> 0) & 0x01)
       *
       * [Bit 1] - 0 = Cache is not inclusive of lower cache levels.
       * - 1 = Cache is inclusive of lower cache levels.
      UINT32 CacheInclusiveness                                    : 1;
#define CPUID_EDX_CACHE_INCLUSIVENESS_BIT                            1
#define CPUID_EDX_CACHE_INCLUSIVENESS_FLAG                           0x02
#define CPUID_EDX_CACHE_INCLUSIVENESS_MASK                           0x01
#define CPUID_EDX_CACHE_INCLUSIVENESS(_)                             (((_) >> 1) & 0x01)
       *
       * [Bit 2] - 0 = Direct mapped cache.
       * - 1 = A complex function is used to index the cache, potentially using all address bits.
      UINT32 ComplexCacheIndexing                                  : 1;
#define CPUID_EDX_COMPLEX_CACHE_INDEXING_BIT                         2
#define CPUID_EDX_COMPLEX_CACHE_INDEXING_FLAG                        0x04
#define CPUID_EDX_COMPLEX_CACHE_INDEXING_MASK                        0x01
#define CPUID_EDX_COMPLEX_CACHE_INDEXING(_)                          (((_) >> 2) & 0x01)
      UINT32 Reserved1                                             : 29;
    };
    UINT32 AsUInt;
  } Edx;
} CPUID_EAX_04;*/
return true
}

func (i *ia32)       * [Bits 15:0] Smallest monitor-line size in bytes ()(ok bool){//col:2257
/*       * [Bits 15:0] Smallest monitor-line size in bytes (default is processor's monitor granularity).
      UINT32 SmallestMonitorLineSize                               : 16;
#define CPUID_EAX_SMALLEST_MONITOR_LINE_SIZE_BIT                     0
#define CPUID_EAX_SMALLEST_MONITOR_LINE_SIZE_FLAG                    0xFFFF
#define CPUID_EAX_SMALLEST_MONITOR_LINE_SIZE_MASK                    0xFFFF
#define CPUID_EAX_SMALLEST_MONITOR_LINE_SIZE(_)                      (((_) >> 0) & 0xFFFF)
      UINT32 Reserved1                                             : 16;
    };
    UINT32 AsUInt;
  } Eax;
  union
  {
    struct
    {
       * [Bits 15:0] Largest monitor-line size in bytes (default is processor's monitor granularity).
      UINT32 LargestMonitorLineSize                                : 16;
#define CPUID_EBX_LARGEST_MONITOR_LINE_SIZE_BIT                      0
#define CPUID_EBX_LARGEST_MONITOR_LINE_SIZE_FLAG                     0xFFFF
#define CPUID_EBX_LARGEST_MONITOR_LINE_SIZE_MASK                     0xFFFF
#define CPUID_EBX_LARGEST_MONITOR_LINE_SIZE(_)                       (((_) >> 0) & 0xFFFF)
      UINT32 Reserved1                                             : 16;
    };
    UINT32 AsUInt;
  } Ebx;
  union
  {
    struct
    {
       * [Bit 0] Enumeration of Monitor-Mwait extensions (beyond EAX and EBX registers) supported.
      UINT32 EnumerationOfMonitorMwaitExtensions                   : 1;
#define CPUID_ECX_ENUMERATION_OF_MONITOR_MWAIT_EXTENSIONS_BIT        0
#define CPUID_ECX_ENUMERATION_OF_MONITOR_MWAIT_EXTENSIONS_FLAG       0x01
#define CPUID_ECX_ENUMERATION_OF_MONITOR_MWAIT_EXTENSIONS_MASK       0x01
#define CPUID_ECX_ENUMERATION_OF_MONITOR_MWAIT_EXTENSIONS(_)         (((_) >> 0) & 0x01)
       * [Bit 1] Supports treating interrupts as break-event for MWAIT, even when interrupts disabled.
      UINT32 SupportsTreatingInterruptsAsBreakEventForMwait        : 1;
#define CPUID_ECX_SUPPORTS_TREATING_INTERRUPTS_AS_BREAK_EVENT_FOR_MWAIT_BIT 1
#define CPUID_ECX_SUPPORTS_TREATING_INTERRUPTS_AS_BREAK_EVENT_FOR_MWAIT_FLAG 0x02
#define CPUID_ECX_SUPPORTS_TREATING_INTERRUPTS_AS_BREAK_EVENT_FOR_MWAIT_MASK 0x01
#define CPUID_ECX_SUPPORTS_TREATING_INTERRUPTS_AS_BREAK_EVENT_FOR_MWAIT(_) (((_) >> 1) & 0x01)
      UINT32 Reserved1                                             : 30;
    };
    UINT32 AsUInt;
  } Ecx;
  union
  {
    struct
    {
       * [Bits 3:0] Number of C0 sub C-states supported using MWAIT.
      UINT32 NumberOfC0SubCStates                                  : 4;
#define CPUID_EDX_NUMBER_OF_C0_SUB_C_STATES_BIT                      0
#define CPUID_EDX_NUMBER_OF_C0_SUB_C_STATES_FLAG                     0x0F
#define CPUID_EDX_NUMBER_OF_C0_SUB_C_STATES_MASK                     0x0F
#define CPUID_EDX_NUMBER_OF_C0_SUB_C_STATES(_)                       (((_) >> 0) & 0x0F)
       * [Bits 7:4] Number of C1 sub C-states supported using MWAIT.
      UINT32 NumberOfC1SubCStates                                  : 4;
#define CPUID_EDX_NUMBER_OF_C1_SUB_C_STATES_BIT                      4
#define CPUID_EDX_NUMBER_OF_C1_SUB_C_STATES_FLAG                     0xF0
#define CPUID_EDX_NUMBER_OF_C1_SUB_C_STATES_MASK                     0x0F
#define CPUID_EDX_NUMBER_OF_C1_SUB_C_STATES(_)                       (((_) >> 4) & 0x0F)
       * [Bits 11:8] Number of C2 sub C-states supported using MWAIT.
      UINT32 NumberOfC2SubCStates                                  : 4;
#define CPUID_EDX_NUMBER_OF_C2_SUB_C_STATES_BIT                      8
#define CPUID_EDX_NUMBER_OF_C2_SUB_C_STATES_FLAG                     0xF00
#define CPUID_EDX_NUMBER_OF_C2_SUB_C_STATES_MASK                     0x0F
#define CPUID_EDX_NUMBER_OF_C2_SUB_C_STATES(_)                       (((_) >> 8) & 0x0F)
       * [Bits 15:12] Number of C3 sub C-states supported using MWAIT.
      UINT32 NumberOfC3SubCStates                                  : 4;
#define CPUID_EDX_NUMBER_OF_C3_SUB_C_STATES_BIT                      12
#define CPUID_EDX_NUMBER_OF_C3_SUB_C_STATES_FLAG                     0xF000
#define CPUID_EDX_NUMBER_OF_C3_SUB_C_STATES_MASK                     0x0F
#define CPUID_EDX_NUMBER_OF_C3_SUB_C_STATES(_)                       (((_) >> 12) & 0x0F)
       * [Bits 19:16] Number of C4 sub C-states supported using MWAIT.
      UINT32 NumberOfC4SubCStates                                  : 4;
#define CPUID_EDX_NUMBER_OF_C4_SUB_C_STATES_BIT                      16
#define CPUID_EDX_NUMBER_OF_C4_SUB_C_STATES_FLAG                     0xF0000
#define CPUID_EDX_NUMBER_OF_C4_SUB_C_STATES_MASK                     0x0F
#define CPUID_EDX_NUMBER_OF_C4_SUB_C_STATES(_)                       (((_) >> 16) & 0x0F)
       * [Bits 23:20] Number of C5 sub C-states supported using MWAIT.
      UINT32 NumberOfC5SubCStates                                  : 4;
#define CPUID_EDX_NUMBER_OF_C5_SUB_C_STATES_BIT                      20
#define CPUID_EDX_NUMBER_OF_C5_SUB_C_STATES_FLAG                     0xF00000
#define CPUID_EDX_NUMBER_OF_C5_SUB_C_STATES_MASK                     0x0F
#define CPUID_EDX_NUMBER_OF_C5_SUB_C_STATES(_)                       (((_) >> 20) & 0x0F)
       * [Bits 27:24] Number of C6 sub C-states supported using MWAIT.
      UINT32 NumberOfC6SubCStates                                  : 4;
#define CPUID_EDX_NUMBER_OF_C6_SUB_C_STATES_BIT                      24
#define CPUID_EDX_NUMBER_OF_C6_SUB_C_STATES_FLAG                     0xF000000
#define CPUID_EDX_NUMBER_OF_C6_SUB_C_STATES_MASK                     0x0F
#define CPUID_EDX_NUMBER_OF_C6_SUB_C_STATES(_)                       (((_) >> 24) & 0x0F)
       * [Bits 31:28] Number of C7 sub C-states supported using MWAIT.
      UINT32 NumberOfC7SubCStates                                  : 4;
#define CPUID_EDX_NUMBER_OF_C7_SUB_C_STATES_BIT                      28
#define CPUID_EDX_NUMBER_OF_C7_SUB_C_STATES_FLAG                     0xF0000000
#define CPUID_EDX_NUMBER_OF_C7_SUB_C_STATES_MASK                     0x0F
#define CPUID_EDX_NUMBER_OF_C7_SUB_C_STATES(_)                       (((_) >> 28) & 0x0F)
    };
    UINT32 AsUInt;
  } Edx;
} CPUID_EAX_05;*/
return true
}

func (i *ia32)#define CPUID_EAX_TEMPERATURE_SENSOR_SUPPORTED()(ok bool){//col:2531
/*#define CPUID_EAX_TEMPERATURE_SENSOR_SUPPORTED(_)                    (((_) >> 0) & 0x01)
       * [Bit 1] Intel Turbo Boost Technology available (see description of IA32_MISC_ENABLE[38]).
      UINT32 IntelTurboBoostTechnologyAvailable                    : 1;
#define CPUID_EAX_INTEL_TURBO_BOOST_TECHNOLOGY_AVAILABLE_BIT         1
#define CPUID_EAX_INTEL_TURBO_BOOST_TECHNOLOGY_AVAILABLE_FLAG        0x02
#define CPUID_EAX_INTEL_TURBO_BOOST_TECHNOLOGY_AVAILABLE_MASK        0x01
#define CPUID_EAX_INTEL_TURBO_BOOST_TECHNOLOGY_AVAILABLE(_)          (((_) >> 1) & 0x01)
       * [Bit 2] ARAT. APIC-Timer-always-running feature is supported if set.
      UINT32 ApicTimerAlwaysRunning                                : 1;
#define CPUID_EAX_APIC_TIMER_ALWAYS_RUNNING_BIT                      2
#define CPUID_EAX_APIC_TIMER_ALWAYS_RUNNING_FLAG                     0x04
#define CPUID_EAX_APIC_TIMER_ALWAYS_RUNNING_MASK                     0x01
#define CPUID_EAX_APIC_TIMER_ALWAYS_RUNNING(_)                       (((_) >> 2) & 0x01)
      UINT32 Reserved1                                             : 1;
       * [Bit 4] PLN. Power limit notification controls are supported if set.
      UINT32 PowerLimitNotification                                : 1;
#define CPUID_EAX_POWER_LIMIT_NOTIFICATION_BIT                       4
#define CPUID_EAX_POWER_LIMIT_NOTIFICATION_FLAG                      0x10
#define CPUID_EAX_POWER_LIMIT_NOTIFICATION_MASK                      0x01
#define CPUID_EAX_POWER_LIMIT_NOTIFICATION(_)                        (((_) >> 4) & 0x01)
       * [Bit 5] ECMD. Clock modulation duty cycle extension is supported if set.
      UINT32 ClockModulationDuty                                   : 1;
#define CPUID_EAX_CLOCK_MODULATION_DUTY_BIT                          5
#define CPUID_EAX_CLOCK_MODULATION_DUTY_FLAG                         0x20
#define CPUID_EAX_CLOCK_MODULATION_DUTY_MASK                         0x01
#define CPUID_EAX_CLOCK_MODULATION_DUTY(_)                           (((_) >> 5) & 0x01)
       * [Bit 6] PTM. Package thermal management is supported if set.
      UINT32 PackageThermalManagement                              : 1;
#define CPUID_EAX_PACKAGE_THERMAL_MANAGEMENT_BIT                     6
#define CPUID_EAX_PACKAGE_THERMAL_MANAGEMENT_FLAG                    0x40
#define CPUID_EAX_PACKAGE_THERMAL_MANAGEMENT_MASK                    0x01
#define CPUID_EAX_PACKAGE_THERMAL_MANAGEMENT(_)                      (((_) >> 6) & 0x01)
       * [Bit 7] HWP. HWP base registers (IA32_PM_ENABLE[bit 0], IA32_HWP_CAPABILITIES, IA32_HWP_REQUEST, IA32_HWP_STATUS) are
       * supported if set.
      UINT32 HwpBaseRegisters                                      : 1;
#define CPUID_EAX_HWP_BASE_REGISTERS_BIT                             7
#define CPUID_EAX_HWP_BASE_REGISTERS_FLAG                            0x80
#define CPUID_EAX_HWP_BASE_REGISTERS_MASK                            0x01
#define CPUID_EAX_HWP_BASE_REGISTERS(_)                              (((_) >> 7) & 0x01)
       * [Bit 8] HWP_Notification. IA32_HWP_INTERRUPT MSR is supported if set.
      UINT32 HwpNotification                                       : 1;
#define CPUID_EAX_HWP_NOTIFICATION_BIT                               8
#define CPUID_EAX_HWP_NOTIFICATION_FLAG                              0x100
#define CPUID_EAX_HWP_NOTIFICATION_MASK                              0x01
#define CPUID_EAX_HWP_NOTIFICATION(_)                                (((_) >> 8) & 0x01)
       * [Bit 9] HWP_Activity_Window. IA32_HWP_REQUEST[bits 41:32] is supported if set.
      UINT32 HwpActivityWindow                                     : 1;
#define CPUID_EAX_HWP_ACTIVITY_WINDOW_BIT                            9
#define CPUID_EAX_HWP_ACTIVITY_WINDOW_FLAG                           0x200
#define CPUID_EAX_HWP_ACTIVITY_WINDOW_MASK                           0x01
#define CPUID_EAX_HWP_ACTIVITY_WINDOW(_)                             (((_) >> 9) & 0x01)
       * [Bit 10] HWP_Energy_Performance_Preference. IA32_HWP_REQUEST[bits 31:24] is supported if set.
      UINT32 HwpEnergyPerformancePreference                        : 1;
#define CPUID_EAX_HWP_ENERGY_PERFORMANCE_PREFERENCE_BIT              10
#define CPUID_EAX_HWP_ENERGY_PERFORMANCE_PREFERENCE_FLAG             0x400
#define CPUID_EAX_HWP_ENERGY_PERFORMANCE_PREFERENCE_MASK             0x01
#define CPUID_EAX_HWP_ENERGY_PERFORMANCE_PREFERENCE(_)               (((_) >> 10) & 0x01)
       * [Bit 11] HWP_Package_Level_Request. IA32_HWP_REQUEST_PKG MSR is supported if set.
      UINT32 HwpPackageLevelRequest                                : 1;
#define CPUID_EAX_HWP_PACKAGE_LEVEL_REQUEST_BIT                      11
#define CPUID_EAX_HWP_PACKAGE_LEVEL_REQUEST_FLAG                     0x800
#define CPUID_EAX_HWP_PACKAGE_LEVEL_REQUEST_MASK                     0x01
#define CPUID_EAX_HWP_PACKAGE_LEVEL_REQUEST(_)                       (((_) >> 11) & 0x01)
      UINT32 Reserved2                                             : 1;
       * [Bit 13] HDC. HDC base registers IA32_PKG_HDC_CTL, IA32_PM_CTL1, IA32_THREAD_STALL MSRs are supported if set.
      UINT32 Hdc                                                   : 1;
#define CPUID_EAX_HDC_BIT                                            13
#define CPUID_EAX_HDC_FLAG                                           0x2000
#define CPUID_EAX_HDC_MASK                                           0x01
#define CPUID_EAX_HDC(_)                                             (((_) >> 13) & 0x01)
       * [Bit 14] Intel(R) Turbo Boost Max Technology 3.0 available.
      UINT32 IntelTurboBoostMaxTechnology3Available                : 1;
#define CPUID_EAX_INTEL_TURBO_BOOST_MAX_TECHNOLOGY_3_AVAILABLE_BIT   14
#define CPUID_EAX_INTEL_TURBO_BOOST_MAX_TECHNOLOGY_3_AVAILABLE_FLAG  0x4000
#define CPUID_EAX_INTEL_TURBO_BOOST_MAX_TECHNOLOGY_3_AVAILABLE_MASK  0x01
#define CPUID_EAX_INTEL_TURBO_BOOST_MAX_TECHNOLOGY_3_AVAILABLE(_)    (((_) >> 14) & 0x01)
       * [Bit 15] HWP Capabilities. Highest Performance change is supported if set.
      UINT32 HwpCapabilities                                       : 1;
#define CPUID_EAX_HWP_CAPABILITIES_BIT                               15
#define CPUID_EAX_HWP_CAPABILITIES_FLAG                              0x8000
#define CPUID_EAX_HWP_CAPABILITIES_MASK                              0x01
#define CPUID_EAX_HWP_CAPABILITIES(_)                                (((_) >> 15) & 0x01)
       * [Bit 16] HWP PECI override is supported if set.
      UINT32 HwpPeciOverride                                       : 1;
#define CPUID_EAX_HWP_PECI_OVERRIDE_BIT                              16
#define CPUID_EAX_HWP_PECI_OVERRIDE_FLAG                             0x10000
#define CPUID_EAX_HWP_PECI_OVERRIDE_MASK                             0x01
#define CPUID_EAX_HWP_PECI_OVERRIDE(_)                               (((_) >> 16) & 0x01)
       * [Bit 17] Flexible HWP is supported if set.
      UINT32 FlexibleHwp                                           : 1;
#define CPUID_EAX_FLEXIBLE_HWP_BIT                                   17
#define CPUID_EAX_FLEXIBLE_HWP_FLAG                                  0x20000
#define CPUID_EAX_FLEXIBLE_HWP_MASK                                  0x01
#define CPUID_EAX_FLEXIBLE_HWP(_)                                    (((_) >> 17) & 0x01)
       * [Bit 18] Fast access mode for the IA32_HWP_REQUEST MSR is supported if set.
      UINT32 FastAccessModeForHwpRequestMsr                        : 1;
#define CPUID_EAX_FAST_ACCESS_MODE_FOR_HWP_REQUEST_MSR_BIT           18
#define CPUID_EAX_FAST_ACCESS_MODE_FOR_HWP_REQUEST_MSR_FLAG          0x40000
#define CPUID_EAX_FAST_ACCESS_MODE_FOR_HWP_REQUEST_MSR_MASK          0x01
#define CPUID_EAX_FAST_ACCESS_MODE_FOR_HWP_REQUEST_MSR(_)            (((_) >> 18) & 0x01)
      UINT32 Reserved3                                             : 1;
       * [Bit 20] Ignoring Idle Logical Processor HWP request is supported if set.
      UINT32 IgnoringIdleLogicalProcessorHwpRequest                : 1;
#define CPUID_EAX_IGNORING_IDLE_LOGICAL_PROCESSOR_HWP_REQUEST_BIT    20
#define CPUID_EAX_IGNORING_IDLE_LOGICAL_PROCESSOR_HWP_REQUEST_FLAG   0x100000
#define CPUID_EAX_IGNORING_IDLE_LOGICAL_PROCESSOR_HWP_REQUEST_MASK   0x01
#define CPUID_EAX_IGNORING_IDLE_LOGICAL_PROCESSOR_HWP_REQUEST(_)     (((_) >> 20) & 0x01)
      UINT32 Reserved4                                             : 2;
       * [Bit 23] Intel Thread Director supported if set. IA32_HW_FEEDBACK_CHAR and IA32_HW_FEEDBACK_THREAD_CONFIG MSRs are
       * supported if set.
      UINT32 IntelThreadDirector                                   : 1;
#define CPUID_EAX_INTEL_THREAD_DIRECTOR_BIT                          23
#define CPUID_EAX_INTEL_THREAD_DIRECTOR_FLAG                         0x800000
#define CPUID_EAX_INTEL_THREAD_DIRECTOR_MASK                         0x01
#define CPUID_EAX_INTEL_THREAD_DIRECTOR(_)                           (((_) >> 23) & 0x01)
      UINT32 Reserved5                                             : 8;
    };
    UINT32 AsUInt;
  } Eax;
  union
  {
    struct
    {
       * [Bits 3:0] Number of Interrupt Thresholds in Digital Thermal Sensor.
      UINT32 NumberOfInterruptThresholdsInThermalSensor            : 4;
#define CPUID_EBX_NUMBER_OF_INTERRUPT_THRESHOLDS_IN_THERMAL_SENSOR_BIT 0
#define CPUID_EBX_NUMBER_OF_INTERRUPT_THRESHOLDS_IN_THERMAL_SENSOR_FLAG 0x0F
#define CPUID_EBX_NUMBER_OF_INTERRUPT_THRESHOLDS_IN_THERMAL_SENSOR_MASK 0x0F
#define CPUID_EBX_NUMBER_OF_INTERRUPT_THRESHOLDS_IN_THERMAL_SENSOR(_) (((_) >> 0) & 0x0F)
      UINT32 Reserved1                                             : 28;
    };
    UINT32 AsUInt;
  } Ebx;
  union
  {
    struct
    {
       * [Bit 0] Hardware Coordination Feedback Capability (Presence of IA32_MPERF and IA32_APERF). The capability to provide a
       * measure of delivered processor performance (since last reset of the counters), as a percentage of the expected processor
       * performance when running at the TSC frequency.
      UINT32 HardwareCoordinationFeedbackCapability                : 1;
#define CPUID_ECX_HARDWARE_COORDINATION_FEEDBACK_CAPABILITY_BIT      0
#define CPUID_ECX_HARDWARE_COORDINATION_FEEDBACK_CAPABILITY_FLAG     0x01
#define CPUID_ECX_HARDWARE_COORDINATION_FEEDBACK_CAPABILITY_MASK     0x01
#define CPUID_ECX_HARDWARE_COORDINATION_FEEDBACK_CAPABILITY(_)       (((_) >> 0) & 0x01)
      UINT32 Reserved1                                             : 2;
       * [Bit 3] Number of Intel Thread Director classes supported by the processor. Information for that many classes is written
       * into the Intel Thread Director Table by the hardware.
      UINT32 NumberOfIntelThreadDirectorClasses                    : 1;
#define CPUID_ECX_NUMBER_OF_INTEL_THREAD_DIRECTOR_CLASSES_BIT        3
#define CPUID_ECX_NUMBER_OF_INTEL_THREAD_DIRECTOR_CLASSES_FLAG       0x08
#define CPUID_ECX_NUMBER_OF_INTEL_THREAD_DIRECTOR_CLASSES_MASK       0x01
#define CPUID_ECX_NUMBER_OF_INTEL_THREAD_DIRECTOR_CLASSES(_)         (((_) >> 3) & 0x01)
      UINT32 Reserved2                                             : 4;
       * [Bits 15:8] The processor supports performance-energy bias preference if CPUID.06H:ECX.SETBH[bit 3] is set and it also
       * implies the presence of a new architectural MSR called IA32_ENERGY_PERF_BIAS (1B0H).
      UINT32 PerformanceEnergyBiasPreference                       : 8;
#define CPUID_ECX_PERFORMANCE_ENERGY_BIAS_PREFERENCE_BIT             8
#define CPUID_ECX_PERFORMANCE_ENERGY_BIAS_PREFERENCE_FLAG            0xFF00
#define CPUID_ECX_PERFORMANCE_ENERGY_BIAS_PREFERENCE_MASK            0xFF
#define CPUID_ECX_PERFORMANCE_ENERGY_BIAS_PREFERENCE(_)              (((_) >> 8) & 0xFF)
      UINT32 Reserved3                                             : 16;
    };
    UINT32 AsUInt;
  } Ecx;
  union
  {
    struct
    {
       * [Bits 31:0] EDX is reserved.
      UINT32 Reserved                                              : 32;
#define CPUID_EDX_RESERVED_BIT                                       0
#define CPUID_EDX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Edx;
} CPUID_EAX_06;*/
return true
}

func (i *ia32) * When CPUID executes with EAX set to 07H and the input value of ECX is invalid ()(ok bool){//col:3239
/* * When CPUID executes with EAX set to 07H and the input value of ECX is invalid (see leaf 07H entry in Table 3-8), the
 * processor returns 0 in EAX/EBX/ECX/EDX. In subleaf 0, EAX returns the maximum input value of the highest leaf 7
 * sub-leaf, and EBX, ECX & EDX contain information of extended feature flags.
#define CPUID_STRUCTURED_EXTENDED_FEATURE_FLAGS                      0x00000007
typedef struct
{
  union
  {
    struct
    {
       * [Bits 31:0] Reports the maximum input value for supported leaf 7 sub-leaves.
      UINT32 NumberOfSubLeaves                                     : 32;
#define CPUID_EAX_NUMBER_OF_SUB_LEAVES_BIT                           0
#define CPUID_EAX_NUMBER_OF_SUB_LEAVES_FLAG                          0xFFFFFFFF
#define CPUID_EAX_NUMBER_OF_SUB_LEAVES_MASK                          0xFFFFFFFF
#define CPUID_EAX_NUMBER_OF_SUB_LEAVES(_)                            (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Eax;
  union
  {
    struct
    {
       * [Bit 0] Supports RDFSBASE/RDGSBASE/WRFSBASE/WRGSBASE if 1.
      UINT32 Fsgsbase                                              : 1;
#define CPUID_EBX_FSGSBASE_BIT                                       0
#define CPUID_EBX_FSGSBASE_FLAG                                      0x01
#define CPUID_EBX_FSGSBASE_MASK                                      0x01
#define CPUID_EBX_FSGSBASE(_)                                        (((_) >> 0) & 0x01)
       * [Bit 1] IA32_TSC_ADJUST MSR is supported if 1.
      UINT32 Ia32TscAdjustMsr                                      : 1;
#define CPUID_EBX_IA32_TSC_ADJUST_MSR_BIT                            1
#define CPUID_EBX_IA32_TSC_ADJUST_MSR_FLAG                           0x02
#define CPUID_EBX_IA32_TSC_ADJUST_MSR_MASK                           0x01
#define CPUID_EBX_IA32_TSC_ADJUST_MSR(_)                             (((_) >> 1) & 0x01)
       * [Bit 2] Supports Intel(R) Software Guard Extensions (Intel(R) SGX Extensions) if 1.
      UINT32 Sgx                                                   : 1;
#define CPUID_EBX_SGX_BIT                                            2
#define CPUID_EBX_SGX_FLAG                                           0x04
#define CPUID_EBX_SGX_MASK                                           0x01
#define CPUID_EBX_SGX(_)                                             (((_) >> 2) & 0x01)
       * [Bit 3] BMI1.
      UINT32 Bmi1                                                  : 1;
#define CPUID_EBX_BMI1_BIT                                           3
#define CPUID_EBX_BMI1_FLAG                                          0x08
#define CPUID_EBX_BMI1_MASK                                          0x01
#define CPUID_EBX_BMI1(_)                                            (((_) >> 3) & 0x01)
       * [Bit 4] HLE.
      UINT32 Hle                                                   : 1;
#define CPUID_EBX_HLE_BIT                                            4
#define CPUID_EBX_HLE_FLAG                                           0x10
#define CPUID_EBX_HLE_MASK                                           0x01
#define CPUID_EBX_HLE(_)                                             (((_) >> 4) & 0x01)
       * [Bit 5] AVX2.
      UINT32 Avx2                                                  : 1;
#define CPUID_EBX_AVX2_BIT                                           5
#define CPUID_EBX_AVX2_FLAG                                          0x20
#define CPUID_EBX_AVX2_MASK                                          0x01
#define CPUID_EBX_AVX2(_)                                            (((_) >> 5) & 0x01)
       * [Bit 6] x87 FPU Data Pointer updated only on x87 exceptions if 1.
      UINT32 FdpExcptnOnly                                         : 1;
#define CPUID_EBX_FDP_EXCPTN_ONLY_BIT                                6
#define CPUID_EBX_FDP_EXCPTN_ONLY_FLAG                               0x40
#define CPUID_EBX_FDP_EXCPTN_ONLY_MASK                               0x01
#define CPUID_EBX_FDP_EXCPTN_ONLY(_)                                 (((_) >> 6) & 0x01)
       * [Bit 7] Supports Supervisor-Mode Execution Prevention if 1.
      UINT32 Smep                                                  : 1;
#define CPUID_EBX_SMEP_BIT                                           7
#define CPUID_EBX_SMEP_FLAG                                          0x80
#define CPUID_EBX_SMEP_MASK                                          0x01
#define CPUID_EBX_SMEP(_)                                            (((_) >> 7) & 0x01)
       * [Bit 8] BMI2.
      UINT32 Bmi2                                                  : 1;
#define CPUID_EBX_BMI2_BIT                                           8
#define CPUID_EBX_BMI2_FLAG                                          0x100
#define CPUID_EBX_BMI2_MASK                                          0x01
#define CPUID_EBX_BMI2(_)                                            (((_) >> 8) & 0x01)
       * [Bit 9] Supports Enhanced REP MOVSB/STOSB if 1.
      UINT32 EnhancedRepMovsbStosb                                 : 1;
#define CPUID_EBX_ENHANCED_REP_MOVSB_STOSB_BIT                       9
#define CPUID_EBX_ENHANCED_REP_MOVSB_STOSB_FLAG                      0x200
#define CPUID_EBX_ENHANCED_REP_MOVSB_STOSB_MASK                      0x01
#define CPUID_EBX_ENHANCED_REP_MOVSB_STOSB(_)                        (((_) >> 9) & 0x01)
       * [Bit 10] If 1, supports INVPCID instruction for system software that manages process-context identifiers.
      UINT32 Invpcid                                               : 1;
#define CPUID_EBX_INVPCID_BIT                                        10
#define CPUID_EBX_INVPCID_FLAG                                       0x400
#define CPUID_EBX_INVPCID_MASK                                       0x01
#define CPUID_EBX_INVPCID(_)                                         (((_) >> 10) & 0x01)
       * [Bit 11] RTM.
      UINT32 Rtm                                                   : 1;
#define CPUID_EBX_RTM_BIT                                            11
#define CPUID_EBX_RTM_FLAG                                           0x800
#define CPUID_EBX_RTM_MASK                                           0x01
#define CPUID_EBX_RTM(_)                                             (((_) >> 11) & 0x01)
       * [Bit 12] Supports Intel(R) Resource Director Technology (Intel(R) RDT) Monitoring capability if 1.
      UINT32 RdtM                                                  : 1;
#define CPUID_EBX_RDT_M_BIT                                          12
#define CPUID_EBX_RDT_M_FLAG                                         0x1000
#define CPUID_EBX_RDT_M_MASK                                         0x01
#define CPUID_EBX_RDT_M(_)                                           (((_) >> 12) & 0x01)
       * [Bit 13] Deprecates FPU CS and FPU DS values if 1.
      UINT32 Deprecates                                            : 1;
#define CPUID_EBX_DEPRECATES_BIT                                     13
#define CPUID_EBX_DEPRECATES_FLAG                                    0x2000
#define CPUID_EBX_DEPRECATES_MASK                                    0x01
#define CPUID_EBX_DEPRECATES(_)                                      (((_) >> 13) & 0x01)
       * [Bit 14] Supports Intel(R) Memory Protection Extensions if 1.
      UINT32 Mpx                                                   : 1;
#define CPUID_EBX_MPX_BIT                                            14
#define CPUID_EBX_MPX_FLAG                                           0x4000
#define CPUID_EBX_MPX_MASK                                           0x01
#define CPUID_EBX_MPX(_)                                             (((_) >> 14) & 0x01)
       * [Bit 15] Supports Intel(R) Resource Director Technology (Intel(R) RDT) Allocation capability if 1.
      UINT32 Rdt                                                   : 1;
#define CPUID_EBX_RDT_BIT                                            15
#define CPUID_EBX_RDT_FLAG                                           0x8000
#define CPUID_EBX_RDT_MASK                                           0x01
#define CPUID_EBX_RDT(_)                                             (((_) >> 15) & 0x01)
       * [Bit 16] AVX512F.
      UINT32 Avx512F                                               : 1;
#define CPUID_EBX_AVX512F_BIT                                        16
#define CPUID_EBX_AVX512F_FLAG                                       0x10000
#define CPUID_EBX_AVX512F_MASK                                       0x01
#define CPUID_EBX_AVX512F(_)                                         (((_) >> 16) & 0x01)
       * [Bit 17] AVX512DQ.
      UINT32 Avx512Dq                                              : 1;
#define CPUID_EBX_AVX512DQ_BIT                                       17
#define CPUID_EBX_AVX512DQ_FLAG                                      0x20000
#define CPUID_EBX_AVX512DQ_MASK                                      0x01
#define CPUID_EBX_AVX512DQ(_)                                        (((_) >> 17) & 0x01)
       * [Bit 18] RDSEED.
      UINT32 Rdseed                                                : 1;
#define CPUID_EBX_RDSEED_BIT                                         18
#define CPUID_EBX_RDSEED_FLAG                                        0x40000
#define CPUID_EBX_RDSEED_MASK                                        0x01
#define CPUID_EBX_RDSEED(_)                                          (((_) >> 18) & 0x01)
       * [Bit 19] ADX.
      UINT32 Adx                                                   : 1;
#define CPUID_EBX_ADX_BIT                                            19
#define CPUID_EBX_ADX_FLAG                                           0x80000
#define CPUID_EBX_ADX_MASK                                           0x01
#define CPUID_EBX_ADX(_)                                             (((_) >> 19) & 0x01)
       * [Bit 20] Supports Supervisor-Mode Access Prevention (and the CLAC/STAC instructions) if 1.
      UINT32 Smap                                                  : 1;
#define CPUID_EBX_SMAP_BIT                                           20
#define CPUID_EBX_SMAP_FLAG                                          0x100000
#define CPUID_EBX_SMAP_MASK                                          0x01
#define CPUID_EBX_SMAP(_)                                            (((_) >> 20) & 0x01)
       * [Bit 21] AVX512_IFMA.
      UINT32 Avx512Ifma                                            : 1;
#define CPUID_EBX_AVX512_IFMA_BIT                                    21
#define CPUID_EBX_AVX512_IFMA_FLAG                                   0x200000
#define CPUID_EBX_AVX512_IFMA_MASK                                   0x01
#define CPUID_EBX_AVX512_IFMA(_)                                     (((_) >> 21) & 0x01)
      UINT32 Reserved1                                             : 1;
       * [Bit 23] CLFLUSHOPT.
      UINT32 Clflushopt                                            : 1;
#define CPUID_EBX_CLFLUSHOPT_BIT                                     23
#define CPUID_EBX_CLFLUSHOPT_FLAG                                    0x800000
#define CPUID_EBX_CLFLUSHOPT_MASK                                    0x01
#define CPUID_EBX_CLFLUSHOPT(_)                                      (((_) >> 23) & 0x01)
       * [Bit 24] CLWB.
      UINT32 Clwb                                                  : 1;
#define CPUID_EBX_CLWB_BIT                                           24
#define CPUID_EBX_CLWB_FLAG                                          0x1000000
#define CPUID_EBX_CLWB_MASK                                          0x01
#define CPUID_EBX_CLWB(_)                                            (((_) >> 24) & 0x01)
       * [Bit 25] Intel Processor Trace.
      UINT32 Intel                                                 : 1;
#define CPUID_EBX_INTEL_BIT                                          25
#define CPUID_EBX_INTEL_FLAG                                         0x2000000
#define CPUID_EBX_INTEL_MASK                                         0x01
#define CPUID_EBX_INTEL(_)                                           (((_) >> 25) & 0x01)
       * [Bit 26] (Intel(R) Xeon Phi(TM) only).
      UINT32 Avx512Pf                                              : 1;
#define CPUID_EBX_AVX512PF_BIT                                       26
#define CPUID_EBX_AVX512PF_FLAG                                      0x4000000
#define CPUID_EBX_AVX512PF_MASK                                      0x01
#define CPUID_EBX_AVX512PF(_)                                        (((_) >> 26) & 0x01)
       * [Bit 27] (Intel(R) Xeon Phi(TM) only).
      UINT32 Avx512Er                                              : 1;
#define CPUID_EBX_AVX512ER_BIT                                       27
#define CPUID_EBX_AVX512ER_FLAG                                      0x8000000
#define CPUID_EBX_AVX512ER_MASK                                      0x01
#define CPUID_EBX_AVX512ER(_)                                        (((_) >> 27) & 0x01)
       * [Bit 28] AVX512CD.
      UINT32 Avx512Cd                                              : 1;
#define CPUID_EBX_AVX512CD_BIT                                       28
#define CPUID_EBX_AVX512CD_FLAG                                      0x10000000
#define CPUID_EBX_AVX512CD_MASK                                      0x01
#define CPUID_EBX_AVX512CD(_)                                        (((_) >> 28) & 0x01)
       * [Bit 29] Supports Intel(R) Secure Hash Algorithm Extensions (Intel(R) SHA Extensions) if 1.
      UINT32 Sha                                                   : 1;
#define CPUID_EBX_SHA_BIT                                            29
#define CPUID_EBX_SHA_FLAG                                           0x20000000
#define CPUID_EBX_SHA_MASK                                           0x01
#define CPUID_EBX_SHA(_)                                             (((_) >> 29) & 0x01)
       * [Bit 30] AVX512BW.
      UINT32 Avx512Bw                                              : 1;
#define CPUID_EBX_AVX512BW_BIT                                       30
#define CPUID_EBX_AVX512BW_FLAG                                      0x40000000
#define CPUID_EBX_AVX512BW_MASK                                      0x01
#define CPUID_EBX_AVX512BW(_)                                        (((_) >> 30) & 0x01)
       * [Bit 31] AVX512VL.
      UINT32 Avx512Vl                                              : 1;
#define CPUID_EBX_AVX512VL_BIT                                       31
#define CPUID_EBX_AVX512VL_FLAG                                      0x80000000
#define CPUID_EBX_AVX512VL_MASK                                      0x01
#define CPUID_EBX_AVX512VL(_)                                        (((_) >> 31) & 0x01)
    };
    UINT32 AsUInt;
  } Ebx;
  union
  {
    struct
    {
       * [Bit 0] (Intel(R) Xeon Phi(TM) only).
      UINT32 Prefetchwt1                                           : 1;
#define CPUID_ECX_PREFETCHWT1_BIT                                    0
#define CPUID_ECX_PREFETCHWT1_FLAG                                   0x01
#define CPUID_ECX_PREFETCHWT1_MASK                                   0x01
#define CPUID_ECX_PREFETCHWT1(_)                                     (((_) >> 0) & 0x01)
       * [Bit 1] AVX512_VBMI.
      UINT32 Avx512Vbmi                                            : 1;
#define CPUID_ECX_AVX512_VBMI_BIT                                    1
#define CPUID_ECX_AVX512_VBMI_FLAG                                   0x02
#define CPUID_ECX_AVX512_VBMI_MASK                                   0x01
#define CPUID_ECX_AVX512_VBMI(_)                                     (((_) >> 1) & 0x01)
       * [Bit 2] Supports user-mode instruction prevention if 1.
      UINT32 Umip                                                  : 1;
#define CPUID_ECX_UMIP_BIT                                           2
#define CPUID_ECX_UMIP_FLAG                                          0x04
#define CPUID_ECX_UMIP_MASK                                          0x01
#define CPUID_ECX_UMIP(_)                                            (((_) >> 2) & 0x01)
       * [Bit 3] Supports protection keys for user-mode pages if 1.
      UINT32 Pku                                                   : 1;
#define CPUID_ECX_PKU_BIT                                            3
#define CPUID_ECX_PKU_FLAG                                           0x08
#define CPUID_ECX_PKU_MASK                                           0x01
#define CPUID_ECX_PKU(_)                                             (((_) >> 3) & 0x01)
       * [Bit 4] If 1, OS has set CR4.PKE to enable protection keys (and the RDPKRU/WRPKRU instructions).
      UINT32 Ospke                                                 : 1;
#define CPUID_ECX_OSPKE_BIT                                          4
#define CPUID_ECX_OSPKE_FLAG                                         0x10
#define CPUID_ECX_OSPKE_MASK                                         0x01
#define CPUID_ECX_OSPKE(_)                                           (((_) >> 4) & 0x01)
       * [Bit 5] WAITPKG.
      UINT32 Waitpkg                                               : 1;
#define CPUID_ECX_WAITPKG_BIT                                        5
#define CPUID_ECX_WAITPKG_FLAG                                       0x20
#define CPUID_ECX_WAITPKG_MASK                                       0x01
#define CPUID_ECX_WAITPKG(_)                                         (((_) >> 5) & 0x01)
       * [Bit 6] AVX512_VBMI2.
      UINT32 Avx512Vbmi2                                           : 1;
#define CPUID_ECX_AVX512_VBMI2_BIT                                   6
#define CPUID_ECX_AVX512_VBMI2_FLAG                                  0x40
#define CPUID_ECX_AVX512_VBMI2_MASK                                  0x01
#define CPUID_ECX_AVX512_VBMI2(_)                                    (((_) >> 6) & 0x01)
       * [Bit 7] Supports CET shadow stack features if 1. Processors that set this bit define bits 1:0 of the IA32_U_CET and
       * IA32_S_CET MSRs. Enumerates support for the following MSRs: IA32_INTERRUPT_SPP_TABLE_ADDR, IA32_PL3_SSP, IA32_PL2_SSP,
       * IA32_PL1_SSP, and IA32_PL0_SSP.
      UINT32 CetSs                                                 : 1;
#define CPUID_ECX_CET_SS_BIT                                         7
#define CPUID_ECX_CET_SS_FLAG                                        0x80
#define CPUID_ECX_CET_SS_MASK                                        0x01
#define CPUID_ECX_CET_SS(_)                                          (((_) >> 7) & 0x01)
       * [Bit 8] GFNI.
      UINT32 Gfni                                                  : 1;
#define CPUID_ECX_GFNI_BIT                                           8
#define CPUID_ECX_GFNI_FLAG                                          0x100
#define CPUID_ECX_GFNI_MASK                                          0x01
#define CPUID_ECX_GFNI(_)                                            (((_) >> 8) & 0x01)
       * [Bit 9] VAES.
      UINT32 Vaes                                                  : 1;
#define CPUID_ECX_VAES_BIT                                           9
#define CPUID_ECX_VAES_FLAG                                          0x200
#define CPUID_ECX_VAES_MASK                                          0x01
#define CPUID_ECX_VAES(_)                                            (((_) >> 9) & 0x01)
       * [Bit 10] VPCLMULQDQ.
      UINT32 Vpclmulqdq                                            : 1;
#define CPUID_ECX_VPCLMULQDQ_BIT                                     10
#define CPUID_ECX_VPCLMULQDQ_FLAG                                    0x400
#define CPUID_ECX_VPCLMULQDQ_MASK                                    0x01
#define CPUID_ECX_VPCLMULQDQ(_)                                      (((_) >> 10) & 0x01)
       * [Bit 11] AVX512_VNNI.
      UINT32 Avx512Vnni                                            : 1;
#define CPUID_ECX_AVX512_VNNI_BIT                                    11
#define CPUID_ECX_AVX512_VNNI_FLAG                                   0x800
#define CPUID_ECX_AVX512_VNNI_MASK                                   0x01
#define CPUID_ECX_AVX512_VNNI(_)                                     (((_) >> 11) & 0x01)
       * [Bit 12] AVX512_BITALG.
      UINT32 Avx512Bitalg                                          : 1;
#define CPUID_ECX_AVX512_BITALG_BIT                                  12
#define CPUID_ECX_AVX512_BITALG_FLAG                                 0x1000
#define CPUID_ECX_AVX512_BITALG_MASK                                 0x01
#define CPUID_ECX_AVX512_BITALG(_)                                   (((_) >> 12) & 0x01)
       * [Bit 13] If 1, the following MSRs are supported: IA32_TME_CAPABILITY, IA32_TME_ACTIVATE, IA32_TME_EXCLUDE_MASK, and
       * IA32_TME_EXCLUDE_BASE.
      UINT32 TmeEn                                                 : 1;
#define CPUID_ECX_TME_EN_BIT                                         13
#define CPUID_ECX_TME_EN_FLAG                                        0x2000
#define CPUID_ECX_TME_EN_MASK                                        0x01
#define CPUID_ECX_TME_EN(_)                                          (((_) >> 13) & 0x01)
       * [Bit 14] AVX512_VPOPCNTDQ.
      UINT32 Avx512Vpopcntdq                                       : 1;
#define CPUID_ECX_AVX512_VPOPCNTDQ_BIT                               14
#define CPUID_ECX_AVX512_VPOPCNTDQ_FLAG                              0x4000
#define CPUID_ECX_AVX512_VPOPCNTDQ_MASK                              0x01
#define CPUID_ECX_AVX512_VPOPCNTDQ(_)                                (((_) >> 14) & 0x01)
      UINT32 Reserved1                                             : 1;
       * [Bit 16] Supports 57-bit linear addresses and five-level paging if 1.
      UINT32 La57                                                  : 1;
#define CPUID_ECX_LA57_BIT                                           16
#define CPUID_ECX_LA57_FLAG                                          0x10000
#define CPUID_ECX_LA57_MASK                                          0x01
#define CPUID_ECX_LA57(_)                                            (((_) >> 16) & 0x01)
       * [Bits 21:17] The value of MAWAU used by the BNDLDX and BNDSTX instructions in 64-bit mode.
      UINT32 Mawau                                                 : 5;
#define CPUID_ECX_MAWAU_BIT                                          17
#define CPUID_ECX_MAWAU_FLAG                                         0x3E0000
#define CPUID_ECX_MAWAU_MASK                                         0x1F
#define CPUID_ECX_MAWAU(_)                                           (((_) >> 17) & 0x1F)
       * [Bit 22] RDPID and IA32_TSC_AUX are available if 1.
      UINT32 Rdpid                                                 : 1;
#define CPUID_ECX_RDPID_BIT                                          22
#define CPUID_ECX_RDPID_FLAG                                         0x400000
#define CPUID_ECX_RDPID_MASK                                         0x01
#define CPUID_ECX_RDPID(_)                                           (((_) >> 22) & 0x01)
       * [Bit 23] KL. Supports Key Locker if 1.
      UINT32 Kl                                                    : 1;
#define CPUID_ECX_KL_BIT                                             23
#define CPUID_ECX_KL_FLAG                                            0x800000
#define CPUID_ECX_KL_MASK                                            0x01
#define CPUID_ECX_KL(_)                                              (((_) >> 23) & 0x01)
      UINT32 Reserved2                                             : 1;
       * [Bit 25] Supports cache line demote if 1.
      UINT32 Cldemote                                              : 1;
#define CPUID_ECX_CLDEMOTE_BIT                                       25
#define CPUID_ECX_CLDEMOTE_FLAG                                      0x2000000
#define CPUID_ECX_CLDEMOTE_MASK                                      0x01
#define CPUID_ECX_CLDEMOTE(_)                                        (((_) >> 25) & 0x01)
      UINT32 Reserved3                                             : 1;
       * [Bit 27] Supports MOVDIRI if 1.
      UINT32 Movdiri                                               : 1;
#define CPUID_ECX_MOVDIRI_BIT                                        27
#define CPUID_ECX_MOVDIRI_FLAG                                       0x8000000
#define CPUID_ECX_MOVDIRI_MASK                                       0x01
#define CPUID_ECX_MOVDIRI(_)                                         (((_) >> 27) & 0x01)
       * [Bit 28] Supports MOVDIR64B if 1.
      UINT32 Movdir64B                                             : 1;
#define CPUID_ECX_MOVDIR64B_BIT                                      28
#define CPUID_ECX_MOVDIR64B_FLAG                                     0x10000000
#define CPUID_ECX_MOVDIR64B_MASK                                     0x01
#define CPUID_ECX_MOVDIR64B(_)                                       (((_) >> 28) & 0x01)
      UINT32 Reserved4                                             : 1;
       * [Bit 30] Supports SGX Launch Configuration if 1.
      UINT32 SgxLc                                                 : 1;
#define CPUID_ECX_SGX_LC_BIT                                         30
#define CPUID_ECX_SGX_LC_FLAG                                        0x40000000
#define CPUID_ECX_SGX_LC_MASK                                        0x01
#define CPUID_ECX_SGX_LC(_)                                          (((_) >> 30) & 0x01)
       * [Bit 31] Supports protection keys for supervisor-mode pages if 1.
      UINT32 Pks                                                   : 1;
#define CPUID_ECX_PKS_BIT                                            31
#define CPUID_ECX_PKS_FLAG                                           0x80000000
#define CPUID_ECX_PKS_MASK                                           0x01
#define CPUID_ECX_PKS(_)                                             (((_) >> 31) & 0x01)
    };
    UINT32 AsUInt;
  } Ecx;
  union
  {
    struct
    {
      UINT32 Reserved1                                             : 2;
       * [Bit 2] (Intel(R) Xeon Phi(TM) only.)
      UINT32 Avx5124Vnniw                                          : 1;
#define CPUID_EDX_AVX512_4VNNIW_BIT                                  2
#define CPUID_EDX_AVX512_4VNNIW_FLAG                                 0x04
#define CPUID_EDX_AVX512_4VNNIW_MASK                                 0x01
#define CPUID_EDX_AVX512_4VNNIW(_)                                   (((_) >> 2) & 0x01)
       * [Bit 3] (Intel(R) Xeon Phi(TM) only.)
      UINT32 Avx5124Fmaps                                          : 1;
#define CPUID_EDX_AVX512_4FMAPS_BIT                                  3
#define CPUID_EDX_AVX512_4FMAPS_FLAG                                 0x08
#define CPUID_EDX_AVX512_4FMAPS_MASK                                 0x01
#define CPUID_EDX_AVX512_4FMAPS(_)                                   (((_) >> 3) & 0x01)
       * [Bit 4] Fast Short REP MOV.
      UINT32 FastShortRepMov                                       : 1;
#define CPUID_EDX_FAST_SHORT_REP_MOV_BIT                             4
#define CPUID_EDX_FAST_SHORT_REP_MOV_FLAG                            0x10
#define CPUID_EDX_FAST_SHORT_REP_MOV_MASK                            0x01
#define CPUID_EDX_FAST_SHORT_REP_MOV(_)                              (((_) >> 4) & 0x01)
      UINT32 Reserved2                                             : 3;
       * [Bit 8] AVX512_VP2INTERSECT.
      UINT32 Avx512Vp2Intersect                                    : 1;
#define CPUID_EDX_AVX512_VP2INTERSECT_BIT                            8
#define CPUID_EDX_AVX512_VP2INTERSECT_FLAG                           0x100
#define CPUID_EDX_AVX512_VP2INTERSECT_MASK                           0x01
#define CPUID_EDX_AVX512_VP2INTERSECT(_)                             (((_) >> 8) & 0x01)
      UINT32 Reserved3                                             : 1;
       * [Bit 10] MD_CLEAR supported.
      UINT32 MdClear                                               : 1;
#define CPUID_EDX_MD_CLEAR_BIT                                       10
#define CPUID_EDX_MD_CLEAR_FLAG                                      0x400
#define CPUID_EDX_MD_CLEAR_MASK                                      0x01
#define CPUID_EDX_MD_CLEAR(_)                                        (((_) >> 10) & 0x01)
      UINT32 Reserved4                                             : 3;
       * [Bit 14] SERIALIZE supported.
      UINT32 Serialize                                             : 1;
#define CPUID_EDX_SERIALIZE_BIT                                      14
#define CPUID_EDX_SERIALIZE_FLAG                                     0x4000
#define CPUID_EDX_SERIALIZE_MASK                                     0x01
#define CPUID_EDX_SERIALIZE(_)                                       (((_) >> 14) & 0x01)
       * [Bit 15] If 1, the processor is identified as a hybrid part.
      UINT32 Hybrid                                                : 1;
#define CPUID_EDX_HYBRID_BIT                                         15
#define CPUID_EDX_HYBRID_FLAG                                        0x8000
#define CPUID_EDX_HYBRID_MASK                                        0x01
#define CPUID_EDX_HYBRID(_)                                          (((_) >> 15) & 0x01)
      UINT32 Reserved5                                             : 2;
       * [Bit 18] Supports PCONFIG if 1.
      UINT32 Pconfig                                               : 1;
#define CPUID_EDX_PCONFIG_BIT                                        18
#define CPUID_EDX_PCONFIG_FLAG                                       0x40000
#define CPUID_EDX_PCONFIG_MASK                                       0x01
#define CPUID_EDX_PCONFIG(_)                                         (((_) >> 18) & 0x01)
      UINT32 Reserved6                                             : 1;
       * [Bit 20] Supports CET indirect branch tracking features if 1. Processors that set this bit define bits 5:2 and bits
       * 63:10 of the IA32_U_CET and IA32_S_CET MSRs.
      UINT32 CetIbt                                                : 1;
#define CPUID_EDX_CET_IBT_BIT                                        20
#define CPUID_EDX_CET_IBT_FLAG                                       0x100000
#define CPUID_EDX_CET_IBT_MASK                                       0x01
#define CPUID_EDX_CET_IBT(_)                                         (((_) >> 20) & 0x01)
      UINT32 Reserved7                                             : 5;
       * [Bit 26] Enumerates support for indirect branch restricted speculation (IBRS) and the indirect branch predictor barrier
       * (IBPB). Processors that set this bit support the IA32_SPEC_CTRL MSR and the IA32_PRED_CMD MSR. They allow software to
       * set IA32_SPEC_CTRL[0] (IBRS) and IA32_PRED_CMD[0] (IBPB).
      UINT32 IbrsIbpb                                              : 1;
#define CPUID_EDX_IBRS_IBPB_BIT                                      26
#define CPUID_EDX_IBRS_IBPB_FLAG                                     0x4000000
#define CPUID_EDX_IBRS_IBPB_MASK                                     0x01
#define CPUID_EDX_IBRS_IBPB(_)                                       (((_) >> 26) & 0x01)
       * [Bit 27] Enumerates support for single thread indirect branch predictors (STIBP). Processors that set this bit support
       * the IA32_SPEC_CTRL MSR. They allow software to set IA32_SPEC_CTRL[1] (STIBP).
      UINT32 Stibp                                                 : 1;
#define CPUID_EDX_STIBP_BIT                                          27
#define CPUID_EDX_STIBP_FLAG                                         0x8000000
#define CPUID_EDX_STIBP_MASK                                         0x01
#define CPUID_EDX_STIBP(_)                                           (((_) >> 27) & 0x01)
       * [Bit 28] Enumerates support for L1D_FLUSH. Processors that set this bit support the IA32_FLUSH_CMD MSR. They allow
       * software to set IA32_FLUSH_CMD[0] (L1D_FLUSH).
      UINT32 L1DFlush                                              : 1;
#define CPUID_EDX_L1D_FLUSH_BIT                                      28
#define CPUID_EDX_L1D_FLUSH_FLAG                                     0x10000000
#define CPUID_EDX_L1D_FLUSH_MASK                                     0x01
#define CPUID_EDX_L1D_FLUSH(_)                                       (((_) >> 28) & 0x01)
       * [Bit 29] Enumerates support for the IA32_ARCH_CAPABILITIES MSR.
      UINT32 Ia32ArchCapabilities                                  : 1;
#define CPUID_EDX_IA32_ARCH_CAPABILITIES_BIT                         29
#define CPUID_EDX_IA32_ARCH_CAPABILITIES_FLAG                        0x20000000
#define CPUID_EDX_IA32_ARCH_CAPABILITIES_MASK                        0x01
#define CPUID_EDX_IA32_ARCH_CAPABILITIES(_)                          (((_) >> 29) & 0x01)
       * [Bit 30] Enumerates support for the IA32_CORE_CAPABILITIES MSR.
      UINT32 Ia32CoreCapabilities                                  : 1;
#define CPUID_EDX_IA32_CORE_CAPABILITIES_BIT                         30
#define CPUID_EDX_IA32_CORE_CAPABILITIES_FLAG                        0x40000000
#define CPUID_EDX_IA32_CORE_CAPABILITIES_MASK                        0x01
#define CPUID_EDX_IA32_CORE_CAPABILITIES(_)                          (((_) >> 30) & 0x01)
       * [Bit 31] Enumerates support for Speculative Store Bypass Disable (SSBD). Processors that set this bit support the
       * IA32_SPEC_CTRL MSR. They allow software to set IA32_SPEC_CTRL[2] (SSBD).
      UINT32 Ssbd                                                  : 1;
#define CPUID_EDX_SSBD_BIT                                           31
#define CPUID_EDX_SSBD_FLAG                                          0x80000000
#define CPUID_EDX_SSBD_MASK                                          0x01
#define CPUID_EDX_SSBD(_)                                            (((_) >> 31) & 0x01)
    };
    UINT32 AsUInt;
  } Edx;
} CPUID_EAX_07;*/
return true
}

func (i *ia32)       * [Bits 31:0] Value of bits [31:0] of IA32_PLATFORM_DCA_CAP MSR ()(ok bool){//col:3318
/*       * [Bits 31:0] Value of bits [31:0] of IA32_PLATFORM_DCA_CAP MSR (address 1F8H).
      UINT32 Ia32PlatformDcaCap                                    : 32;
#define CPUID_EAX_IA32_PLATFORM_DCA_CAP_BIT                          0
#define CPUID_EAX_IA32_PLATFORM_DCA_CAP_FLAG                         0xFFFFFFFF
#define CPUID_EAX_IA32_PLATFORM_DCA_CAP_MASK                         0xFFFFFFFF
#define CPUID_EAX_IA32_PLATFORM_DCA_CAP(_)                           (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Eax;
  union
  {
    struct
    {
       * [Bits 31:0] EBX is reserved.
      UINT32 Reserved                                              : 32;
#define CPUID_EBX_RESERVED_BIT                                       0
#define CPUID_EBX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Ebx;
  union
  {
    struct
    {
       * [Bits 31:0] ECX is reserved.
      UINT32 Reserved                                              : 32;
#define CPUID_ECX_RESERVED_BIT                                       0
#define CPUID_ECX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Ecx;
  union
  {
    struct
    {
       * [Bits 31:0] EDX is reserved.
      UINT32 Reserved                                              : 32;
#define CPUID_EDX_RESERVED_BIT                                       0
#define CPUID_EDX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Edx;
} CPUID_EAX_09;*/
return true
}

func (i *ia32)#define CPUID_EAX_VERSION_ID_OF_ARCHITECTURAL_PERFORMANCE_MONITORING()(ok bool){//col:3504
/*#define CPUID_EAX_VERSION_ID_OF_ARCHITECTURAL_PERFORMANCE_MONITORING(_) (((_) >> 0) & 0xFF)
       * [Bits 15:8] Number of general-purpose performance monitoring counter per logical processor.
      UINT32 NumberOfPerformanceMonitoringCounterPerLogicalProcessor: 8;
#define CPUID_EAX_NUMBER_OF_PERFORMANCE_MONITORING_COUNTER_PER_LOGICAL_PROCESSOR_BIT 8
#define CPUID_EAX_NUMBER_OF_PERFORMANCE_MONITORING_COUNTER_PER_LOGICAL_PROCESSOR_FLAG 0xFF00
#define CPUID_EAX_NUMBER_OF_PERFORMANCE_MONITORING_COUNTER_PER_LOGICAL_PROCESSOR_MASK 0xFF
#define CPUID_EAX_NUMBER_OF_PERFORMANCE_MONITORING_COUNTER_PER_LOGICAL_PROCESSOR(_) (((_) >> 8) & 0xFF)
       * [Bits 23:16] Bit width of general-purpose, performance monitoring counter.
      UINT32 BitWidthOfPerformanceMonitoringCounter                : 8;
#define CPUID_EAX_BIT_WIDTH_OF_PERFORMANCE_MONITORING_COUNTER_BIT    16
#define CPUID_EAX_BIT_WIDTH_OF_PERFORMANCE_MONITORING_COUNTER_FLAG   0xFF0000
#define CPUID_EAX_BIT_WIDTH_OF_PERFORMANCE_MONITORING_COUNTER_MASK   0xFF
#define CPUID_EAX_BIT_WIDTH_OF_PERFORMANCE_MONITORING_COUNTER(_)     (((_) >> 16) & 0xFF)
       * [Bits 31:24] Length of EBX bit vector to enumerate architectural performance monitoring events.
      UINT32 EbxBitVectorLength                                    : 8;
#define CPUID_EAX_EBX_BIT_VECTOR_LENGTH_BIT                          24
#define CPUID_EAX_EBX_BIT_VECTOR_LENGTH_FLAG                         0xFF000000
#define CPUID_EAX_EBX_BIT_VECTOR_LENGTH_MASK                         0xFF
#define CPUID_EAX_EBX_BIT_VECTOR_LENGTH(_)                           (((_) >> 24) & 0xFF)
    };
    UINT32 AsUInt;
  } Eax;
  union
  {
    struct
    {
       * [Bit 0] Core cycle event not available if 1.
      UINT32 CoreCycleEventNotAvailable                            : 1;
#define CPUID_EBX_CORE_CYCLE_EVENT_NOT_AVAILABLE_BIT                 0
#define CPUID_EBX_CORE_CYCLE_EVENT_NOT_AVAILABLE_FLAG                0x01
#define CPUID_EBX_CORE_CYCLE_EVENT_NOT_AVAILABLE_MASK                0x01
#define CPUID_EBX_CORE_CYCLE_EVENT_NOT_AVAILABLE(_)                  (((_) >> 0) & 0x01)
       * [Bit 1] Instruction retired event not available if 1.
      UINT32 InstructionRetiredEventNotAvailable                   : 1;
#define CPUID_EBX_INSTRUCTION_RETIRED_EVENT_NOT_AVAILABLE_BIT        1
#define CPUID_EBX_INSTRUCTION_RETIRED_EVENT_NOT_AVAILABLE_FLAG       0x02
#define CPUID_EBX_INSTRUCTION_RETIRED_EVENT_NOT_AVAILABLE_MASK       0x01
#define CPUID_EBX_INSTRUCTION_RETIRED_EVENT_NOT_AVAILABLE(_)         (((_) >> 1) & 0x01)
       * [Bit 2] Reference cycles event not available if 1.
      UINT32 ReferenceCyclesEventNotAvailable                      : 1;
#define CPUID_EBX_REFERENCE_CYCLES_EVENT_NOT_AVAILABLE_BIT           2
#define CPUID_EBX_REFERENCE_CYCLES_EVENT_NOT_AVAILABLE_FLAG          0x04
#define CPUID_EBX_REFERENCE_CYCLES_EVENT_NOT_AVAILABLE_MASK          0x01
#define CPUID_EBX_REFERENCE_CYCLES_EVENT_NOT_AVAILABLE(_)            (((_) >> 2) & 0x01)
       * [Bit 3] Last-level cache reference event not available if 1.
      UINT32 LastLevelCacheReferenceEventNotAvailable              : 1;
#define CPUID_EBX_LAST_LEVEL_CACHE_REFERENCE_EVENT_NOT_AVAILABLE_BIT 3
#define CPUID_EBX_LAST_LEVEL_CACHE_REFERENCE_EVENT_NOT_AVAILABLE_FLAG 0x08
#define CPUID_EBX_LAST_LEVEL_CACHE_REFERENCE_EVENT_NOT_AVAILABLE_MASK 0x01
#define CPUID_EBX_LAST_LEVEL_CACHE_REFERENCE_EVENT_NOT_AVAILABLE(_)  (((_) >> 3) & 0x01)
       * [Bit 4] Last-level cache misses event not available if 1.
      UINT32 LastLevelCacheMissesEventNotAvailable                 : 1;
#define CPUID_EBX_LAST_LEVEL_CACHE_MISSES_EVENT_NOT_AVAILABLE_BIT    4
#define CPUID_EBX_LAST_LEVEL_CACHE_MISSES_EVENT_NOT_AVAILABLE_FLAG   0x10
#define CPUID_EBX_LAST_LEVEL_CACHE_MISSES_EVENT_NOT_AVAILABLE_MASK   0x01
#define CPUID_EBX_LAST_LEVEL_CACHE_MISSES_EVENT_NOT_AVAILABLE(_)     (((_) >> 4) & 0x01)
       * [Bit 5] Branch instruction retired event not available if 1.
      UINT32 BranchInstructionRetiredEventNotAvailable             : 1;
#define CPUID_EBX_BRANCH_INSTRUCTION_RETIRED_EVENT_NOT_AVAILABLE_BIT 5
#define CPUID_EBX_BRANCH_INSTRUCTION_RETIRED_EVENT_NOT_AVAILABLE_FLAG 0x20
#define CPUID_EBX_BRANCH_INSTRUCTION_RETIRED_EVENT_NOT_AVAILABLE_MASK 0x01
#define CPUID_EBX_BRANCH_INSTRUCTION_RETIRED_EVENT_NOT_AVAILABLE(_)  (((_) >> 5) & 0x01)
       * [Bit 6] Branch mispredict retired event not available if 1.
      UINT32 BranchMispredictRetiredEventNotAvailable              : 1;
#define CPUID_EBX_BRANCH_MISPREDICT_RETIRED_EVENT_NOT_AVAILABLE_BIT  6
#define CPUID_EBX_BRANCH_MISPREDICT_RETIRED_EVENT_NOT_AVAILABLE_FLAG 0x40
#define CPUID_EBX_BRANCH_MISPREDICT_RETIRED_EVENT_NOT_AVAILABLE_MASK 0x01
#define CPUID_EBX_BRANCH_MISPREDICT_RETIRED_EVENT_NOT_AVAILABLE(_)   (((_) >> 6) & 0x01)
      UINT32 Reserved1                                             : 25;
    };
    UINT32 AsUInt;
  } Ebx;
  union
  {
    struct
    {
       * [Bits 31:0] ECX is reserved.
      UINT32 Reserved                                              : 32;
#define CPUID_ECX_RESERVED_BIT                                       0
#define CPUID_ECX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Ecx;
  union
  {
    struct
    {
       * [Bits 4:0] Number of fixed-function performance counters (if Version ID > 1).
      UINT32 NumberOfFixedFunctionPerformanceCounters              : 5;
#define CPUID_EDX_NUMBER_OF_FIXED_FUNCTION_PERFORMANCE_COUNTERS_BIT  0
#define CPUID_EDX_NUMBER_OF_FIXED_FUNCTION_PERFORMANCE_COUNTERS_FLAG 0x1F
#define CPUID_EDX_NUMBER_OF_FIXED_FUNCTION_PERFORMANCE_COUNTERS_MASK 0x1F
#define CPUID_EDX_NUMBER_OF_FIXED_FUNCTION_PERFORMANCE_COUNTERS(_)   (((_) >> 0) & 0x1F)
       * [Bits 12:5] Bit width of fixed-function performance counters (if Version ID > 1).
      UINT32 BitWidthOfFixedFunctionPerformanceCounters            : 8;
#define CPUID_EDX_BIT_WIDTH_OF_FIXED_FUNCTION_PERFORMANCE_COUNTERS_BIT 5
#define CPUID_EDX_BIT_WIDTH_OF_FIXED_FUNCTION_PERFORMANCE_COUNTERS_FLAG 0x1FE0
#define CPUID_EDX_BIT_WIDTH_OF_FIXED_FUNCTION_PERFORMANCE_COUNTERS_MASK 0xFF
#define CPUID_EDX_BIT_WIDTH_OF_FIXED_FUNCTION_PERFORMANCE_COUNTERS(_) (((_) >> 5) & 0xFF)
      UINT32 Reserved1                                             : 2;
       * [Bit 15] AnyThread deprecation.
      UINT32 AnyThreadDeprecation                                  : 1;
#define CPUID_EDX_ANY_THREAD_DEPRECATION_BIT                         15
#define CPUID_EDX_ANY_THREAD_DEPRECATION_FLAG                        0x8000
#define CPUID_EDX_ANY_THREAD_DEPRECATION_MASK                        0x01
#define CPUID_EDX_ANY_THREAD_DEPRECATION(_)                          (((_) >> 15) & 0x01)
      UINT32 Reserved2                                             : 16;
    };
    UINT32 AsUInt;
  } Edx;
} CPUID_EAX_0A;*/
return true
}

func (i *ia32)#define CPUID_EAX_X2APIC_ID_TO_UNIQUE_TOPOLOGY_ID_SHIFT()(ok bool){//col:3619
/*#define CPUID_EAX_X2APIC_ID_TO_UNIQUE_TOPOLOGY_ID_SHIFT(_)           (((_) >> 0) & 0x1F)
      UINT32 Reserved1                                             : 27;
    };
    UINT32 AsUInt;
  } Eax;
  union
  {
    struct
    {
       * [Bits 15:0] Number of logical processors at this level type. The number reflects configuration as shipped by Intel.
       *
       *       (EBX[15:0]) is only intended for display/diagnostic purposes. The actual number of logical processors available to
       *       BIOS/OS/Applications may be different from the value of EBX[15:0], depending on software and platform hardware
       *       configurations.
      UINT32 NumberOfLogicalProcessorsAtThisLevelType              : 16;
#define CPUID_EBX_NUMBER_OF_LOGICAL_PROCESSORS_AT_THIS_LEVEL_TYPE_BIT 0
#define CPUID_EBX_NUMBER_OF_LOGICAL_PROCESSORS_AT_THIS_LEVEL_TYPE_FLAG 0xFFFF
#define CPUID_EBX_NUMBER_OF_LOGICAL_PROCESSORS_AT_THIS_LEVEL_TYPE_MASK 0xFFFF
#define CPUID_EBX_NUMBER_OF_LOGICAL_PROCESSORS_AT_THIS_LEVEL_TYPE(_) (((_) >> 0) & 0xFFFF)
      UINT32 Reserved1                                             : 16;
    };
    UINT32 AsUInt;
  } Ebx;
  union
  {
    struct
    {
       * [Bits 7:0] Level number. Same value in ECX input.
      UINT32 LevelNumber                                           : 8;
#define CPUID_ECX_LEVEL_NUMBER_BIT                                   0
#define CPUID_ECX_LEVEL_NUMBER_FLAG                                  0xFF
#define CPUID_ECX_LEVEL_NUMBER_MASK                                  0xFF
#define CPUID_ECX_LEVEL_NUMBER(_)                                    (((_) >> 0) & 0xFF)
       * [Bits 15:8] Level type.
       *
       *       mean higher levels. Level type field has the following encoding:
       *       - 0: Invalid.
       *       - 1: SMT.
       *       - 2: Core.
       *       - 3-255: Reserved.
      UINT32 LevelType                                             : 8;
#define CPUID_ECX_LEVEL_TYPE_BIT                                     8
#define CPUID_ECX_LEVEL_TYPE_FLAG                                    0xFF00
#define CPUID_ECX_LEVEL_TYPE_MASK                                    0xFF
#define CPUID_ECX_LEVEL_TYPE(_)                                      (((_) >> 8) & 0xFF)
      UINT32 Reserved1                                             : 16;
    };
    UINT32 AsUInt;
  } Ecx;
  union
  {
    struct
    {
       * [Bits 31:0] x2APIC ID the current logical processor.
      UINT32 X2ApicId                                              : 32;
#define CPUID_EDX_X2APIC_ID_BIT                                      0
#define CPUID_EDX_X2APIC_ID_FLAG                                     0xFFFFFFFF
#define CPUID_EDX_X2APIC_ID_MASK                                     0xFFFFFFFF
#define CPUID_EDX_X2APIC_ID(_)                                       (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Edx;
} CPUID_EAX_0B;*/
return true
}

func (i *ia32) * When CPUID executes with EAX set to 0DH and ECX = n ()(ok bool){//col:3780
/* * When CPUID executes with EAX set to 0DH and ECX = n (n > 1, and is a valid sub-leaf index), the processor returns
 * information about the size and offset of each processor extended state save area within the XSAVE/XRSTOR area. Software
 * can use the forward-extendable technique depicted below to query the valid sub-leaves and obtain size and offset
 * information for each processor extended state save area:
 * of EDX:EAX Execute CPUID.(EAX=0DH, ECX = i) to examine size and offset for sub-leaf i; FI; </pre>
#define CPUID_EXTENDED_STATE_INFORMATION                             0x0000000D
typedef struct
{
  union
  {
    struct
    {
       * [Bit 0] x87 state.
      UINT32 X87State                                              : 1;
#define CPUID_EAX_X87_STATE_BIT                                      0
#define CPUID_EAX_X87_STATE_FLAG                                     0x01
#define CPUID_EAX_X87_STATE_MASK                                     0x01
#define CPUID_EAX_X87_STATE(_)                                       (((_) >> 0) & 0x01)
       * [Bit 1] SSE state.
      UINT32 SseState                                              : 1;
#define CPUID_EAX_SSE_STATE_BIT                                      1
#define CPUID_EAX_SSE_STATE_FLAG                                     0x02
#define CPUID_EAX_SSE_STATE_MASK                                     0x01
#define CPUID_EAX_SSE_STATE(_)                                       (((_) >> 1) & 0x01)
       * [Bit 2] AVX state.
      UINT32 AvxState                                              : 1;
#define CPUID_EAX_AVX_STATE_BIT                                      2
#define CPUID_EAX_AVX_STATE_FLAG                                     0x04
#define CPUID_EAX_AVX_STATE_MASK                                     0x01
#define CPUID_EAX_AVX_STATE(_)                                       (((_) >> 2) & 0x01)
       * [Bits 4:3] MPX state.
      UINT32 MpxState                                              : 2;
#define CPUID_EAX_MPX_STATE_BIT                                      3
#define CPUID_EAX_MPX_STATE_FLAG                                     0x18
#define CPUID_EAX_MPX_STATE_MASK                                     0x03
#define CPUID_EAX_MPX_STATE(_)                                       (((_) >> 3) & 0x03)
       * [Bits 7:5] AVX-512 state.
      UINT32 Avx512State                                           : 3;
#define CPUID_EAX_AVX_512_STATE_BIT                                  5
#define CPUID_EAX_AVX_512_STATE_FLAG                                 0xE0
#define CPUID_EAX_AVX_512_STATE_MASK                                 0x07
#define CPUID_EAX_AVX_512_STATE(_)                                   (((_) >> 5) & 0x07)
       * [Bit 8] Used for IA32_XSS.
      UINT32 UsedForIa32Xss1                                       : 1;
#define CPUID_EAX_USED_FOR_IA32_XSS_1_BIT                            8
#define CPUID_EAX_USED_FOR_IA32_XSS_1_FLAG                           0x100
#define CPUID_EAX_USED_FOR_IA32_XSS_1_MASK                           0x01
#define CPUID_EAX_USED_FOR_IA32_XSS_1(_)                             (((_) >> 8) & 0x01)
       * [Bit 9] PKRU state.
      UINT32 PkruState                                             : 1;
#define CPUID_EAX_PKRU_STATE_BIT                                     9
#define CPUID_EAX_PKRU_STATE_FLAG                                    0x200
#define CPUID_EAX_PKRU_STATE_MASK                                    0x01
#define CPUID_EAX_PKRU_STATE(_)                                      (((_) >> 9) & 0x01)
      UINT32 Reserved1                                             : 3;
       * [Bit 13] Used for IA32_XSS.
      UINT32 UsedForIa32Xss2                                       : 1;
#define CPUID_EAX_USED_FOR_IA32_XSS_2_BIT                            13
#define CPUID_EAX_USED_FOR_IA32_XSS_2_FLAG                           0x2000
#define CPUID_EAX_USED_FOR_IA32_XSS_2_MASK                           0x01
#define CPUID_EAX_USED_FOR_IA32_XSS_2(_)                             (((_) >> 13) & 0x01)
      UINT32 Reserved2                                             : 18;
    };
    UINT32 AsUInt;
  } Eax;
  union
  {
    struct
    {
       * [Bits 31:0] Maximum size (bytes, from the beginning of the XSAVE/XRSTOR save area) required by enabled features in XCR0.
       * May be different than ECX if some features at the end of the XSAVE save area are not enabled.
      UINT32 MaxSizeRequiredByEnabledFeaturesInXcr0                : 32;
#define CPUID_EBX_MAX_SIZE_REQUIRED_BY_ENABLED_FEATURES_IN_XCR0_BIT  0
#define CPUID_EBX_MAX_SIZE_REQUIRED_BY_ENABLED_FEATURES_IN_XCR0_FLAG 0xFFFFFFFF
#define CPUID_EBX_MAX_SIZE_REQUIRED_BY_ENABLED_FEATURES_IN_XCR0_MASK 0xFFFFFFFF
#define CPUID_EBX_MAX_SIZE_REQUIRED_BY_ENABLED_FEATURES_IN_XCR0(_)   (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Ebx;
  union
  {
    struct
    {
       * [Bits 31:0] Maximum size (bytes, from the beginning of the XSAVE/XRSTOR save area) of the XSAVE/XRSTOR save area
       * required by all supported features in the processor, i.e., all the valid bit fields in XCR0.
      UINT32 MaxSizeOfXsaveXrstorSaveArea                          : 32;
#define CPUID_ECX_MAX_SIZE_OF_XSAVE_XRSTOR_SAVE_AREA_BIT             0
#define CPUID_ECX_MAX_SIZE_OF_XSAVE_XRSTOR_SAVE_AREA_FLAG            0xFFFFFFFF
#define CPUID_ECX_MAX_SIZE_OF_XSAVE_XRSTOR_SAVE_AREA_MASK            0xFFFFFFFF
#define CPUID_ECX_MAX_SIZE_OF_XSAVE_XRSTOR_SAVE_AREA(_)              (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Ecx;
  union
  {
    struct
    {
       * [Bits 31:0] Reports the supported bits of the upper 32 bits of XCR0. XCR0[n+32] can be set to 1 only if EDX[n] is 1.
      UINT32 Xcr0SupportedBits                                     : 32;
#define CPUID_EDX_XCR0_SUPPORTED_BITS_BIT                            0
#define CPUID_EDX_XCR0_SUPPORTED_BITS_FLAG                           0xFFFFFFFF
#define CPUID_EDX_XCR0_SUPPORTED_BITS_MASK                           0xFFFFFFFF
#define CPUID_EDX_XCR0_SUPPORTED_BITS(_)                             (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Edx;
} CPUID_EAX_0D_ECX_00;*/
return true
}

func (i *ia32)#define CPUID_EAX_SUPPORTS_XSAVEC_AND_COMPACTED_XRSTOR()(ok bool){//col:3943
/*#define CPUID_EAX_SUPPORTS_XSAVEC_AND_COMPACTED_XRSTOR(_)            (((_) >> 1) & 0x01)
       * [Bit 2] Supports XGETBV with ECX = 1 if set.
      UINT32 SupportsXgetbvWithEcx1                                : 1;
#define CPUID_EAX_SUPPORTS_XGETBV_WITH_ECX_1_BIT                     2
#define CPUID_EAX_SUPPORTS_XGETBV_WITH_ECX_1_FLAG                    0x04
#define CPUID_EAX_SUPPORTS_XGETBV_WITH_ECX_1_MASK                    0x01
#define CPUID_EAX_SUPPORTS_XGETBV_WITH_ECX_1(_)                      (((_) >> 2) & 0x01)
       * [Bit 3] Supports XSAVES/XRSTORS and IA32_XSS if set.
      UINT32 SupportsXsaveXrstorAndIa32Xss                         : 1;
#define CPUID_EAX_SUPPORTS_XSAVE_XRSTOR_AND_IA32_XSS_BIT             3
#define CPUID_EAX_SUPPORTS_XSAVE_XRSTOR_AND_IA32_XSS_FLAG            0x08
#define CPUID_EAX_SUPPORTS_XSAVE_XRSTOR_AND_IA32_XSS_MASK            0x01
#define CPUID_EAX_SUPPORTS_XSAVE_XRSTOR_AND_IA32_XSS(_)              (((_) >> 3) & 0x01)
      UINT32 Reserved2                                             : 28;
    };
    UINT32 AsUInt;
  } Eax;
  union
  {
    struct
    {
       * [Bits 31:0] The size in bytes of the XSAVE area containing all states enabled by XCRO | IA32_XSS.
      UINT32 SizeOfXsaveAread                                      : 32;
#define CPUID_EBX_SIZE_OF_XSAVE_AREAD_BIT                            0
#define CPUID_EBX_SIZE_OF_XSAVE_AREAD_FLAG                           0xFFFFFFFF
#define CPUID_EBX_SIZE_OF_XSAVE_AREAD_MASK                           0xFFFFFFFF
#define CPUID_EBX_SIZE_OF_XSAVE_AREAD(_)                             (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Ebx;
  union
  {
    struct
    {
       * [Bits 7:0] Used for XCR0.
      UINT32 UsedForXcr01                                          : 8;
#define CPUID_ECX_USED_FOR_XCR0_1_BIT                                0
#define CPUID_ECX_USED_FOR_XCR0_1_FLAG                               0xFF
#define CPUID_ECX_USED_FOR_XCR0_1_MASK                               0xFF
#define CPUID_ECX_USED_FOR_XCR0_1(_)                                 (((_) >> 0) & 0xFF)
       * [Bit 8] PT state.
      UINT32 PtState                                               : 1;
#define CPUID_ECX_PT_STATE_BIT                                       8
#define CPUID_ECX_PT_STATE_FLAG                                      0x100
#define CPUID_ECX_PT_STATE_MASK                                      0x01
#define CPUID_ECX_PT_STATE(_)                                        (((_) >> 8) & 0x01)
       * [Bit 9] Used for XCR0.
      UINT32 UsedForXcr02                                          : 1;
#define CPUID_ECX_USED_FOR_XCR0_2_BIT                                9
#define CPUID_ECX_USED_FOR_XCR0_2_FLAG                               0x200
#define CPUID_ECX_USED_FOR_XCR0_2_MASK                               0x01
#define CPUID_ECX_USED_FOR_XCR0_2(_)                                 (((_) >> 9) & 0x01)
      UINT32 Reserved1                                             : 1;
       * [Bit 11] CET user state.
      UINT32 CetUserState                                          : 1;
#define CPUID_ECX_CET_USER_STATE_BIT                                 11
#define CPUID_ECX_CET_USER_STATE_FLAG                                0x800
#define CPUID_ECX_CET_USER_STATE_MASK                                0x01
#define CPUID_ECX_CET_USER_STATE(_)                                  (((_) >> 11) & 0x01)
       * [Bit 12] CET supervisor state.
      UINT32 CetSupervisorState                                    : 1;
#define CPUID_ECX_CET_SUPERVISOR_STATE_BIT                           12
#define CPUID_ECX_CET_SUPERVISOR_STATE_FLAG                          0x1000
#define CPUID_ECX_CET_SUPERVISOR_STATE_MASK                          0x01
#define CPUID_ECX_CET_SUPERVISOR_STATE(_)                            (((_) >> 12) & 0x01)
       * [Bit 13] HDC state.
      UINT32 HdcState                                              : 1;
#define CPUID_ECX_HDC_STATE_BIT                                      13
#define CPUID_ECX_HDC_STATE_FLAG                                     0x2000
#define CPUID_ECX_HDC_STATE_MASK                                     0x01
#define CPUID_ECX_HDC_STATE(_)                                       (((_) >> 13) & 0x01)
      UINT32 Reserved2                                             : 1;
       * [Bit 15] LBR state.
      UINT32 LbrState                                              : 1;
#define CPUID_ECX_LBR_STATE_BIT                                      15
#define CPUID_ECX_LBR_STATE_FLAG                                     0x8000
#define CPUID_ECX_LBR_STATE_MASK                                     0x01
#define CPUID_ECX_LBR_STATE(_)                                       (((_) >> 15) & 0x01)
       * [Bit 16] HWP state.
      UINT32 HwpState                                              : 1;
#define CPUID_ECX_HWP_STATE_BIT                                      16
#define CPUID_ECX_HWP_STATE_FLAG                                     0x10000
#define CPUID_ECX_HWP_STATE_MASK                                     0x01
#define CPUID_ECX_HWP_STATE(_)                                       (((_) >> 16) & 0x01)
      UINT32 Reserved3                                             : 15;
    };
    UINT32 AsUInt;
  } Ecx;
  union
  {
    struct
    {
       * [Bits 31:0] Reports the supported bits of the upper 32 bits of the IA32_XSS MSR. IA32_XSS[n+32] can be set to 1 only if
       * EDX[n] is 1
      UINT32 SupportedUpperIa32XssBits                             : 32;
#define CPUID_EDX_SUPPORTED_UPPER_IA32_XSS_BITS_BIT                  0
#define CPUID_EDX_SUPPORTED_UPPER_IA32_XSS_BITS_FLAG                 0xFFFFFFFF
#define CPUID_EDX_SUPPORTED_UPPER_IA32_XSS_BITS_MASK                 0xFFFFFFFF
#define CPUID_EDX_SUPPORTED_UPPER_IA32_XSS_BITS(_)                   (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Edx;
} CPUID_EAX_0D_ECX_01;*/
return true
}

func (i *ia32) *       If ECX contains an invalid sub-leaf index, EAX/EBX/ECX/EDX return 0. Sub-leaf n ()(ok bool){//col:4040
/* *       If ECX contains an invalid sub-leaf index, EAX/EBX/ECX/EDX return 0. Sub-leaf n (0 <= n <= 31) is invalid if sub-leaf 0
 *       returns 0 in EAX[n] and sub-leaf 1 returns 0 in ECX[n]. Sub-leaf n (32 <= n <= 63) is invalid if sub-leaf 0 returns 0 in
 *       EDX[n-32] and sub-leaf 1 returns 0 in EDX[n-32].
typedef struct
{
  union
  {
    struct
    {
       * [Bits 31:0] The size in bytes (from the offset specified in EBX) of the save area for an extended state feature
       * associated with a valid sub-leaf index, n.
      UINT32 Ia32PlatformDcaCap                                    : 32;
#define CPUID_EAX_IA32_PLATFORM_DCA_CAP_BIT                          0
#define CPUID_EAX_IA32_PLATFORM_DCA_CAP_FLAG                         0xFFFFFFFF
#define CPUID_EAX_IA32_PLATFORM_DCA_CAP_MASK                         0xFFFFFFFF
#define CPUID_EAX_IA32_PLATFORM_DCA_CAP(_)                           (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Eax;
  union
  {
    struct
    {
       * [Bits 31:0] The offset in bytes of this extended state component's save area from the beginning of the XSAVE/XRSTOR
       * area.
       * This field reports 0 if the sub-leaf index, n, does not map to a valid bit in the XCR0 register.
      UINT32 Reserved                                              : 32;
#define CPUID_EBX_RESERVED_BIT                                       0
#define CPUID_EBX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Ebx;
  union
  {
    struct
    {
       * [Bit 0] Is set if the bit n (corresponding to the sub-leaf index) is supported in the IA32_XSS MSR; it is clear if bit n
       * is instead supported in XCR0.
      UINT32 Ecx2                                                  : 1;
#define CPUID_ECX_ECX_2_BIT                                          0
#define CPUID_ECX_ECX_2_FLAG                                         0x01
#define CPUID_ECX_ECX_2_MASK                                         0x01
#define CPUID_ECX_ECX_2(_)                                           (((_) >> 0) & 0x01)
       * [Bit 1] Is set if, when the compacted format of an XSAVE area is used, this extended state component located on the next
       * 64-byte boundary following the preceding state component (otherwise, it is located immediately following the preceding
       * state component).
      UINT32 Ecx1                                                  : 1;
#define CPUID_ECX_ECX_1_BIT                                          1
#define CPUID_ECX_ECX_1_FLAG                                         0x02
#define CPUID_ECX_ECX_1_MASK                                         0x01
#define CPUID_ECX_ECX_1(_)                                           (((_) >> 1) & 0x01)
      UINT32 Reserved1                                             : 30;
    };
    UINT32 AsUInt;
  } Ecx;
  union
  {
    struct
    {
       * [Bits 31:0] This field reports 0 if the sub-leaf index, n, is invalid; otherwise it is reserved.
      UINT32 Reserved                                              : 32;
#define CPUID_EDX_RESERVED_BIT                                       0
#define CPUID_EDX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Edx;
} CPUID_EAX_0D_ECX_N;*/
return true
}

func (i *ia32) * resource type if the bit is set. The bit position corresponds to the sub-leaf index ()(ok bool){//col:4139
/* * resource type if the bit is set. The bit position corresponds to the sub-leaf index (or ResID) that software must use to
 * query QoS monitoring capability available for that type. See Table 3-8.
 * When CPUID executes with EAX set to 0FH and ECX = n (n >= 1, and is a valid ResID), the processor returns information
 * software can use to program IA32_PQR_ASSOC, IA32_QM_EVTSEL MSRs before reading QoS data from the IA32_QM_CTR MSR.
#define CPUID_INTEL_RESOURCE_DIRECTOR_TECHNOLOGY_MONITORING_INFORMATION 0x0000000F
 *
 *       position 1 of EDX.
typedef struct
{
  union
  {
    struct
    {
       * [Bits 31:0] EAX is reserved.
      UINT32 Reserved                                              : 32;
#define CPUID_EAX_RESERVED_BIT                                       0
#define CPUID_EAX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EAX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EAX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Eax;
  union
  {
    struct
    {
       * [Bits 31:0] Maximum range (zero-based) of RMID within this physical processor of all types.
      UINT32 RmidMaxRange                                          : 32;
#define CPUID_EBX_RMID_MAX_RANGE_BIT                                 0
#define CPUID_EBX_RMID_MAX_RANGE_FLAG                                0xFFFFFFFF
#define CPUID_EBX_RMID_MAX_RANGE_MASK                                0xFFFFFFFF
#define CPUID_EBX_RMID_MAX_RANGE(_)                                  (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Ebx;
  union
  {
    struct
    {
       * [Bits 31:0] ECX is reserved.
      UINT32 Reserved                                              : 32;
#define CPUID_ECX_RESERVED_BIT                                       0
#define CPUID_ECX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Ecx;
  union
  {
    struct
    {
      UINT32 Reserved1                                             : 1;
       * [Bit 1] Supports L3 Cache Intel RDT Monitoring if 1.
      UINT32 SupportsL3CacheIntelRdtMonitoring                     : 1;
#define CPUID_EDX_SUPPORTS_L3_CACHE_INTEL_RDT_MONITORING_BIT         1
#define CPUID_EDX_SUPPORTS_L3_CACHE_INTEL_RDT_MONITORING_FLAG        0x02
#define CPUID_EDX_SUPPORTS_L3_CACHE_INTEL_RDT_MONITORING_MASK        0x01
#define CPUID_EDX_SUPPORTS_L3_CACHE_INTEL_RDT_MONITORING(_)          (((_) >> 1) & 0x01)
      UINT32 Reserved2                                             : 30;
    };
    UINT32 AsUInt;
  } Edx;
} CPUID_EAX_0F_ECX_00;*/
return true
}

func (i *ia32)#define CPUID_EAX_RESERVED()(ok bool){//col:4235
/*#define CPUID_EAX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Eax;
  union
  {
    struct
    {
       * [Bits 31:0] Conversion factor from reported IA32_QM_CTR value to occupancy metric (bytes).
      UINT32 ConversionFactor                                      : 32;
#define CPUID_EBX_CONVERSION_FACTOR_BIT                              0
#define CPUID_EBX_CONVERSION_FACTOR_FLAG                             0xFFFFFFFF
#define CPUID_EBX_CONVERSION_FACTOR_MASK                             0xFFFFFFFF
#define CPUID_EBX_CONVERSION_FACTOR(_)                               (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Ebx;
  union
  {
    struct
    {
       * [Bits 31:0] Maximum range (zero-based) of RMID within this physical processor of all types.
      UINT32 RmidMaxRange                                          : 32;
#define CPUID_ECX_RMID_MAX_RANGE_BIT                                 0
#define CPUID_ECX_RMID_MAX_RANGE_FLAG                                0xFFFFFFFF
#define CPUID_ECX_RMID_MAX_RANGE_MASK                                0xFFFFFFFF
#define CPUID_ECX_RMID_MAX_RANGE(_)                                  (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Ecx;
  union
  {
    struct
    {
       * [Bit 0] Supports L3 occupancy monitoring if 1.
      UINT32 SupportsL3OccupancyMonitoring                         : 1;
#define CPUID_EDX_SUPPORTS_L3_OCCUPANCY_MONITORING_BIT               0
#define CPUID_EDX_SUPPORTS_L3_OCCUPANCY_MONITORING_FLAG              0x01
#define CPUID_EDX_SUPPORTS_L3_OCCUPANCY_MONITORING_MASK              0x01
#define CPUID_EDX_SUPPORTS_L3_OCCUPANCY_MONITORING(_)                (((_) >> 0) & 0x01)
       * [Bit 1] Supports L3 Total Bandwidth monitoring if 1.
      UINT32 SupportsL3TotalBandwidthMonitoring                    : 1;
#define CPUID_EDX_SUPPORTS_L3_TOTAL_BANDWIDTH_MONITORING_BIT         1
#define CPUID_EDX_SUPPORTS_L3_TOTAL_BANDWIDTH_MONITORING_FLAG        0x02
#define CPUID_EDX_SUPPORTS_L3_TOTAL_BANDWIDTH_MONITORING_MASK        0x01
#define CPUID_EDX_SUPPORTS_L3_TOTAL_BANDWIDTH_MONITORING(_)          (((_) >> 1) & 0x01)
       * [Bit 2] Supports L3 Local Bandwidth monitoring if 1.
      UINT32 SupportsL3LocalBandwidthMonitoring                    : 1;
#define CPUID_EDX_SUPPORTS_L3_LOCAL_BANDWIDTH_MONITORING_BIT         2
#define CPUID_EDX_SUPPORTS_L3_LOCAL_BANDWIDTH_MONITORING_FLAG        0x04
#define CPUID_EDX_SUPPORTS_L3_LOCAL_BANDWIDTH_MONITORING_MASK        0x01
#define CPUID_EDX_SUPPORTS_L3_LOCAL_BANDWIDTH_MONITORING(_)          (((_) >> 2) & 0x01)
      UINT32 Reserved1                                             : 29;
    };
    UINT32 AsUInt;
  } Edx;
} CPUID_EAX_0F_ECX_01;*/
return true
}

func (i *ia32) * corresponds to a specific resource type if the bit is set. The bit position corresponds to the sub-leaf index ()(ok bool){//col:4352
/* * corresponds to a specific resource type if the bit is set. The bit position corresponds to the sub-leaf index (or ResID)
 * that software must use to query QoS enforcement capability available for that type.
 * When CPUID executes with EAX set to 10H and ECX = n (n >= 1, and is a valid ResID), the processor returns information
 * about available classes of service and range of QoS mask MSRs that software can use to configure each class of services
 * using capability bit masks in the QoS Mask registers, IA32_resourceType_Mask_n.
#define CPUID_INTEL_RESOURCE_DIRECTOR_TECHNOLOGY_ALLOCATION_INFORMATION 0x00000010
 *
 *       (ResID) starting at bit position 1 of EBX.
typedef struct
{
  union
  {
    struct
    {
       * [Bits 31:0] Value of bits [31:0] of IA32_PLATFORM_DCA_CAP MSR (address 1F8H).
      UINT32 Ia32PlatformDcaCap                                    : 32;
#define CPUID_EAX_IA32_PLATFORM_DCA_CAP_BIT                          0
#define CPUID_EAX_IA32_PLATFORM_DCA_CAP_FLAG                         0xFFFFFFFF
#define CPUID_EAX_IA32_PLATFORM_DCA_CAP_MASK                         0xFFFFFFFF
#define CPUID_EAX_IA32_PLATFORM_DCA_CAP(_)                           (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Eax;
  union
  {
    struct
    {
      UINT32 Reserved1                                             : 1;
       * [Bit 1] Supports L3 Cache Allocation Technology if 1.
      UINT32 SupportsL3CacheAllocationTechnology                   : 1;
#define CPUID_EBX_SUPPORTS_L3_CACHE_ALLOCATION_TECHNOLOGY_BIT        1
#define CPUID_EBX_SUPPORTS_L3_CACHE_ALLOCATION_TECHNOLOGY_FLAG       0x02
#define CPUID_EBX_SUPPORTS_L3_CACHE_ALLOCATION_TECHNOLOGY_MASK       0x01
#define CPUID_EBX_SUPPORTS_L3_CACHE_ALLOCATION_TECHNOLOGY(_)         (((_) >> 1) & 0x01)
       * [Bit 2] Supports L2 Cache Allocation Technology if 1.
      UINT32 SupportsL2CacheAllocationTechnology                   : 1;
#define CPUID_EBX_SUPPORTS_L2_CACHE_ALLOCATION_TECHNOLOGY_BIT        2
#define CPUID_EBX_SUPPORTS_L2_CACHE_ALLOCATION_TECHNOLOGY_FLAG       0x04
#define CPUID_EBX_SUPPORTS_L2_CACHE_ALLOCATION_TECHNOLOGY_MASK       0x01
#define CPUID_EBX_SUPPORTS_L2_CACHE_ALLOCATION_TECHNOLOGY(_)         (((_) >> 2) & 0x01)
       * [Bit 3] Supports Memory Bandwidth Allocation if 1.
      UINT32 SupportsMemoryBandwidthAllocation                     : 1;
#define CPUID_EBX_SUPPORTS_MEMORY_BANDWIDTH_ALLOCATION_BIT           3
#define CPUID_EBX_SUPPORTS_MEMORY_BANDWIDTH_ALLOCATION_FLAG          0x08
#define CPUID_EBX_SUPPORTS_MEMORY_BANDWIDTH_ALLOCATION_MASK          0x01
#define CPUID_EBX_SUPPORTS_MEMORY_BANDWIDTH_ALLOCATION(_)            (((_) >> 3) & 0x01)
      UINT32 Reserved2                                             : 28;
    };
    UINT32 AsUInt;
  } Ebx;
  union
  {
    struct
    {
       * [Bits 31:0] ECX is reserved.
      UINT32 Reserved                                              : 32;
#define CPUID_ECX_RESERVED_BIT                                       0
#define CPUID_ECX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Ecx;
  union
  {
    struct
    {
       * [Bits 31:0] EDX is reserved.
      UINT32 Reserved                                              : 32;
#define CPUID_EDX_RESERVED_BIT                                       0
#define CPUID_EDX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Edx;
} CPUID_EAX_10_ECX_00;*/
return true
}

func (i *ia32)#define CPUID_EAX_LENGTH_OF_CAPACITY_BIT_MASK()(ok bool){//col:4434
/*#define CPUID_EAX_LENGTH_OF_CAPACITY_BIT_MASK(_)                     (((_) >> 0) & 0x1F)
      UINT32 Reserved1                                             : 27;
    };
    UINT32 AsUInt;
  } Eax;
  union
  {
    struct
    {
       * [Bits 31:0] Bit-granular map of isolation/contention of allocation units.
      UINT32 Ebx0                                                  : 32;
#define CPUID_EBX_EBX_0_BIT                                          0
#define CPUID_EBX_EBX_0_FLAG                                         0xFFFFFFFF
#define CPUID_EBX_EBX_0_MASK                                         0xFFFFFFFF
#define CPUID_EBX_EBX_0(_)                                           (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Ebx;
  union
  {
    struct
    {
      UINT32 Reserved1                                             : 2;
       * [Bit 2] Code and Data Prioritization Technology supported if 1.
      UINT32 CodeAndDataPriorizationTechnologySupported            : 1;
#define CPUID_ECX_CODE_AND_DATA_PRIORIZATION_TECHNOLOGY_SUPPORTED_BIT 2
#define CPUID_ECX_CODE_AND_DATA_PRIORIZATION_TECHNOLOGY_SUPPORTED_FLAG 0x04
#define CPUID_ECX_CODE_AND_DATA_PRIORIZATION_TECHNOLOGY_SUPPORTED_MASK 0x01
#define CPUID_ECX_CODE_AND_DATA_PRIORIZATION_TECHNOLOGY_SUPPORTED(_) (((_) >> 2) & 0x01)
      UINT32 Reserved2                                             : 29;
    };
    UINT32 AsUInt;
  } Ecx;
  union
  {
    struct
    {
       * [Bits 15:0] Highest COS number supported for this ResID.
      UINT32 HighestCosNumberSupported                             : 16;
#define CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED_BIT                   0
#define CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED_FLAG                  0xFFFF
#define CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED_MASK                  0xFFFF
#define CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED(_)                    (((_) >> 0) & 0xFFFF)
      UINT32 Reserved1                                             : 16;
    };
    UINT32 AsUInt;
  } Edx;
} CPUID_EAX_10_ECX_01;*/
return true
}

func (i *ia32)#define CPUID_EAX_LENGTH_OF_CAPACITY_BIT_MASK()(ok bool){//col:4513
/*#define CPUID_EAX_LENGTH_OF_CAPACITY_BIT_MASK(_)                     (((_) >> 0) & 0x1F)
      UINT32 Reserved1                                             : 27;
    };
    UINT32 AsUInt;
  } Eax;
  union
  {
    struct
    {
       * [Bits 31:0] Bit-granular map of isolation/contention of allocation units.
      UINT32 Ebx0                                                  : 32;
#define CPUID_EBX_EBX_0_BIT                                          0
#define CPUID_EBX_EBX_0_FLAG                                         0xFFFFFFFF
#define CPUID_EBX_EBX_0_MASK                                         0xFFFFFFFF
#define CPUID_EBX_EBX_0(_)                                           (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Ebx;
  union
  {
    struct
    {
       * [Bits 31:0] ECX is reserved.
      UINT32 Reserved                                              : 32;
#define CPUID_ECX_RESERVED_BIT                                       0
#define CPUID_ECX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Ecx;
  union
  {
    struct
    {
       * [Bits 15:0] Highest COS number supported for this ResID.
      UINT32 HighestCosNumberSupported                             : 16;
#define CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED_BIT                   0
#define CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED_FLAG                  0xFFFF
#define CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED_MASK                  0xFFFF
#define CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED(_)                    (((_) >> 0) & 0xFFFF)
      UINT32 Reserved1                                             : 16;
    };
    UINT32 AsUInt;
  } Edx;
} CPUID_EAX_10_ECX_02;*/
return true
}

func (i *ia32)#define CPUID_EAX_MAX_MBA_THROTTLING_VALUE()(ok bool){//col:4595
/*#define CPUID_EAX_MAX_MBA_THROTTLING_VALUE(_)                        (((_) >> 0) & 0xFFF)
      UINT32 Reserved1                                             : 20;
    };
    UINT32 AsUInt;
  } Eax;
  union
  {
    struct
    {
       * [Bits 31:0] EBX is reserved.
      UINT32 Reserved                                              : 32;
#define CPUID_EBX_RESERVED_BIT                                       0
#define CPUID_EBX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Ebx;
  union
  {
    struct
    {
      UINT32 Reserved1                                             : 2;
       * [Bit 2] Reports whether the response of the delay values is linear.
      UINT32 ResponseOfDelayIsLinear                               : 1;
#define CPUID_ECX_RESPONSE_OF_DELAY_IS_LINEAR_BIT                    2
#define CPUID_ECX_RESPONSE_OF_DELAY_IS_LINEAR_FLAG                   0x04
#define CPUID_ECX_RESPONSE_OF_DELAY_IS_LINEAR_MASK                   0x01
#define CPUID_ECX_RESPONSE_OF_DELAY_IS_LINEAR(_)                     (((_) >> 2) & 0x01)
      UINT32 Reserved2                                             : 29;
    };
    UINT32 AsUInt;
  } Ecx;
  union
  {
    struct
    {
       * [Bits 15:0] Highest COS number supported for this ResID.
      UINT32 HighestCosNumberSupported                             : 16;
#define CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED_BIT                   0
#define CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED_FLAG                  0xFFFF
#define CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED_MASK                  0xFFFF
#define CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED(_)                    (((_) >> 0) & 0xFFFF)
      UINT32 Reserved1                                             : 16;
    };
    UINT32 AsUInt;
  } Edx;
} CPUID_EAX_10_ECX_03;*/
return true
}

func (i *ia32) * When CPUID executes with EAX set to 12H and ECX = n ()(ok bool){//col:4726
/* * When CPUID executes with EAX set to 12H and ECX = n (n > 1), the processor returns information about Intel SGX Enclave
 * Page Cache.
#define CPUID_INTEL_SGX                                              0x00000012
 *
typedef struct
{
  union
  {
    struct
    {
       * [Bit 0] If 1, Indicates Intel SGX supports the collection of SGX1 leaf functions.
      UINT32 Sgx1                                                  : 1;
#define CPUID_EAX_SGX1_BIT                                           0
#define CPUID_EAX_SGX1_FLAG                                          0x01
#define CPUID_EAX_SGX1_MASK                                          0x01
#define CPUID_EAX_SGX1(_)                                            (((_) >> 0) & 0x01)
       * [Bit 1] If 1, Indicates Intel SGX supports the collection of SGX2 leaf functions.
      UINT32 Sgx2                                                  : 1;
#define CPUID_EAX_SGX2_BIT                                           1
#define CPUID_EAX_SGX2_FLAG                                          0x02
#define CPUID_EAX_SGX2_MASK                                          0x01
#define CPUID_EAX_SGX2(_)                                            (((_) >> 1) & 0x01)
      UINT32 Reserved1                                             : 3;
       * [Bit 5] If 1, indicates Intel SGX supports ENCLV instruction leaves EINCVIRTCHILD, EDECVIRTCHILD, and ESETCONTEXT.
      UINT32 SgxEnclvAdvanced                                      : 1;
#define CPUID_EAX_SGX_ENCLV_ADVANCED_BIT                             5
#define CPUID_EAX_SGX_ENCLV_ADVANCED_FLAG                            0x20
#define CPUID_EAX_SGX_ENCLV_ADVANCED_MASK                            0x01
#define CPUID_EAX_SGX_ENCLV_ADVANCED(_)                              (((_) >> 5) & 0x01)
       * [Bit 6] If 1, indicates Intel SGX supports ENCLS instruction leaves ETRACKC, ERDINFO, ELDBC, and ELDUC.
      UINT32 SgxEnclsAdvanced                                      : 1;
#define CPUID_EAX_SGX_ENCLS_ADVANCED_BIT                             6
#define CPUID_EAX_SGX_ENCLS_ADVANCED_FLAG                            0x40
#define CPUID_EAX_SGX_ENCLS_ADVANCED_MASK                            0x01
#define CPUID_EAX_SGX_ENCLS_ADVANCED(_)                              (((_) >> 6) & 0x01)
      UINT32 Reserved2                                             : 25;
    };
    UINT32 AsUInt;
  } Eax;
  union
  {
    struct
    {
       * [Bits 31:0] Bit vector of supported extended SGX features.
      UINT32 Miscselect                                            : 32;
#define CPUID_EBX_MISCSELECT_BIT                                     0
#define CPUID_EBX_MISCSELECT_FLAG                                    0xFFFFFFFF
#define CPUID_EBX_MISCSELECT_MASK                                    0xFFFFFFFF
#define CPUID_EBX_MISCSELECT(_)                                      (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Ebx;
  union
  {
    struct
    {
       * [Bits 31:0] ECX is reserved.
      UINT32 Reserved                                              : 32;
#define CPUID_ECX_RESERVED_BIT                                       0
#define CPUID_ECX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Ecx;
  union
  {
    struct
    {
       * [Bits 7:0] The maximum supported enclave size in non-64-bit mode is 2^(EDX[7:0]).
      UINT32 MaxEnclaveSizeNot64                                   : 8;
#define CPUID_EDX_MAX_ENCLAVE_SIZE_NOT64_BIT                         0
#define CPUID_EDX_MAX_ENCLAVE_SIZE_NOT64_FLAG                        0xFF
#define CPUID_EDX_MAX_ENCLAVE_SIZE_NOT64_MASK                        0xFF
#define CPUID_EDX_MAX_ENCLAVE_SIZE_NOT64(_)                          (((_) >> 0) & 0xFF)
       * [Bits 15:8] The maximum supported enclave size in 64-bit mode is 2^(EDX[15:8]).
      UINT32 MaxEnclaveSize64                                      : 8;
#define CPUID_EDX_MAX_ENCLAVE_SIZE_64_BIT                            8
#define CPUID_EDX_MAX_ENCLAVE_SIZE_64_FLAG                           0xFF00
#define CPUID_EDX_MAX_ENCLAVE_SIZE_64_MASK                           0xFF
#define CPUID_EDX_MAX_ENCLAVE_SIZE_64(_)                             (((_) >> 8) & 0xFF)
      UINT32 Reserved1                                             : 16;
    };
    UINT32 AsUInt;
  } Edx;
} CPUID_EAX_12_ECX_00;*/
return true
}

func (i *ia32)#define CPUID_EAX_VALID_SECS_ATTRIBUTES_0()(ok bool){//col:4803
/*#define CPUID_EAX_VALID_SECS_ATTRIBUTES_0(_)                         (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Eax;
  union
  {
    struct
    {
       * [Bits 31:0] Reports the valid bits of SECS.ATTRIBUTES[63:32] that software can set with ECREATE.
      UINT32 ValidSecsAttributes1                                  : 32;
#define CPUID_EBX_VALID_SECS_ATTRIBUTES_1_BIT                        0
#define CPUID_EBX_VALID_SECS_ATTRIBUTES_1_FLAG                       0xFFFFFFFF
#define CPUID_EBX_VALID_SECS_ATTRIBUTES_1_MASK                       0xFFFFFFFF
#define CPUID_EBX_VALID_SECS_ATTRIBUTES_1(_)                         (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Ebx;
  union
  {
    struct
    {
       * [Bits 31:0] Reports the valid bits of SECS.ATTRIBUTES[95:64] that software can set with ECREATE.
      UINT32 ValidSecsAttributes2                                  : 32;
#define CPUID_ECX_VALID_SECS_ATTRIBUTES_2_BIT                        0
#define CPUID_ECX_VALID_SECS_ATTRIBUTES_2_FLAG                       0xFFFFFFFF
#define CPUID_ECX_VALID_SECS_ATTRIBUTES_2_MASK                       0xFFFFFFFF
#define CPUID_ECX_VALID_SECS_ATTRIBUTES_2(_)                         (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Ecx;
  union
  {
    struct
    {
       * [Bits 31:0] Reports the valid bits of SECS.ATTRIBUTES[127:96] that software can set with ECREATE.
      UINT32 ValidSecsAttributes3                                  : 32;
#define CPUID_EDX_VALID_SECS_ATTRIBUTES_3_BIT                        0
#define CPUID_EDX_VALID_SECS_ATTRIBUTES_3_FLAG                       0xFFFFFFFF
#define CPUID_EDX_VALID_SECS_ATTRIBUTES_3_MASK                       0xFFFFFFFF
#define CPUID_EDX_VALID_SECS_ATTRIBUTES_3(_)                         (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Edx;
} CPUID_EAX_12_ECX_01;*/
return true
}

func (i *ia32)#define CPUID_EAX_SUB_LEAF_TYPE()(ok bool){//col:4882
/*#define CPUID_EAX_SUB_LEAF_TYPE(_)                                   (((_) >> 0) & 0x0F)
      UINT32 Reserved1                                             : 28;
    };
    UINT32 AsUInt;
  } Eax;
  union
  {
    struct
    {
       * [Bits 31:0] EBX is zero.
      UINT32 Zero                                                  : 32;
#define CPUID_EBX_ZERO_BIT                                           0
#define CPUID_EBX_ZERO_FLAG                                          0xFFFFFFFF
#define CPUID_EBX_ZERO_MASK                                          0xFFFFFFFF
#define CPUID_EBX_ZERO(_)                                            (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Ebx;
  union
  {
    struct
    {
       * [Bits 31:0] ECX is zero.
      UINT32 Zero                                                  : 32;
#define CPUID_ECX_ZERO_BIT                                           0
#define CPUID_ECX_ZERO_FLAG                                          0xFFFFFFFF
#define CPUID_ECX_ZERO_MASK                                          0xFFFFFFFF
#define CPUID_ECX_ZERO(_)                                            (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Ecx;
  union
  {
    struct
    {
       * [Bits 31:0] EDX is zero.
      UINT32 Zero                                                  : 32;
#define CPUID_EDX_ZERO_BIT                                           0
#define CPUID_EDX_ZERO_FLAG                                          0xFFFFFFFF
#define CPUID_EDX_ZERO_MASK                                          0xFFFFFFFF
#define CPUID_EDX_ZERO(_)                                            (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Edx;
} CPUID_EAX_12_ECX_02P_SLT_0;*/
return true
}

func (i *ia32)       * Enclave Page Cache ()(ok bool){//col:4986
/*       * Enclave Page Cache (EPC) section.
      UINT32 SubLeafType                                           : 4;
#define CPUID_EAX_SUB_LEAF_TYPE_BIT                                  0
#define CPUID_EAX_SUB_LEAF_TYPE_FLAG                                 0x0F
#define CPUID_EAX_SUB_LEAF_TYPE_MASK                                 0x0F
#define CPUID_EAX_SUB_LEAF_TYPE(_)                                   (((_) >> 0) & 0x0F)
      UINT32 Reserved1                                             : 8;
       * [Bits 31:12] Bits 31:12 of the physical address of the base of the EPC section.
      UINT32 EpcBasePhysicalAddress1                               : 20;
#define CPUID_EAX_EPC_BASE_PHYSICAL_ADDRESS_1_BIT                    12
#define CPUID_EAX_EPC_BASE_PHYSICAL_ADDRESS_1_FLAG                   0xFFFFF000
#define CPUID_EAX_EPC_BASE_PHYSICAL_ADDRESS_1_MASK                   0xFFFFF
#define CPUID_EAX_EPC_BASE_PHYSICAL_ADDRESS_1(_)                     (((_) >> 12) & 0xFFFFF)
    };
    UINT32 AsUInt;
  } Eax;
  union
  {
    struct
    {
       * [Bits 19:0] Bits 51:32 of the physical address of the base of the EPC section.
      UINT32 EpcBasePhysicalAddress2                               : 20;
#define CPUID_EBX_EPC_BASE_PHYSICAL_ADDRESS_2_BIT                    0
#define CPUID_EBX_EPC_BASE_PHYSICAL_ADDRESS_2_FLAG                   0xFFFFF
#define CPUID_EBX_EPC_BASE_PHYSICAL_ADDRESS_2_MASK                   0xFFFFF
#define CPUID_EBX_EPC_BASE_PHYSICAL_ADDRESS_2(_)                     (((_) >> 0) & 0xFFFFF)
      UINT32 Reserved1                                             : 12;
    };
    UINT32 AsUInt;
  } Ebx;
  union
  {
    struct
    {
       * [Bits 3:0] EPC section property encoding defined as follows:
       * - If EAX[3:0] 0000b, then all bits of the EDX:ECX pair are enumerated as 0.
       * - If EAX[3:0] 0001b, then this section has confidentiality and integrity protection.
       * All other encodings are reserved.
      UINT32 EpcSectionProperty                                    : 4;
#define CPUID_ECX_EPC_SECTION_PROPERTY_BIT                           0
#define CPUID_ECX_EPC_SECTION_PROPERTY_FLAG                          0x0F
#define CPUID_ECX_EPC_SECTION_PROPERTY_MASK                          0x0F
#define CPUID_ECX_EPC_SECTION_PROPERTY(_)                            (((_) >> 0) & 0x0F)
      UINT32 Reserved1                                             : 8;
       * [Bits 31:12] Bits 31:12 of the size of the corresponding EPC section within the Processor Reserved Memory.
      UINT32 EpcSize1                                              : 20;
#define CPUID_ECX_EPC_SIZE_1_BIT                                     12
#define CPUID_ECX_EPC_SIZE_1_FLAG                                    0xFFFFF000
#define CPUID_ECX_EPC_SIZE_1_MASK                                    0xFFFFF
#define CPUID_ECX_EPC_SIZE_1(_)                                      (((_) >> 12) & 0xFFFFF)
    };
    UINT32 AsUInt;
  } Ecx;
  union
  {
    struct
    {
       * [Bits 19:0] Bits 51:32 of the size of the corresponding EPC section within the Processor Reserved Memory.
      UINT32 EpcSize2                                              : 20;
#define CPUID_EDX_EPC_SIZE_2_BIT                                     0
#define CPUID_EDX_EPC_SIZE_2_FLAG                                    0xFFFFF
#define CPUID_EDX_EPC_SIZE_2_MASK                                    0xFFFFF
#define CPUID_EDX_EPC_SIZE_2(_)                                      (((_) >> 0) & 0xFFFFF)
      UINT32 Reserved1                                             : 12;
    };
    UINT32 AsUInt;
  } Edx;
} CPUID_EAX_12_ECX_02P_SLT_1;*/
return true
}

func (i *ia32) * When CPUID executes with EAX set to 14H and ECX = n ()(ok bool){//col:5195
/* * When CPUID executes with EAX set to 14H and ECX = n (n > 0 and less than the number of non-zero bits in CPUID.(EAX=14H,
 * ECX= 0H).EAX), the processor returns information about packet generation in Intel Processor Trace.
#define CPUID_INTEL_PROCESSOR_TRACE_INFORMATION                      0x00000014
 *
typedef struct
{
  union
  {
    struct
    {
       * [Bits 31:0] Reports the maximum sub-leaf supported in leaf 14H.
      UINT32 MaxSubLeaf                                            : 32;
#define CPUID_EAX_MAX_SUB_LEAF_BIT                                   0
#define CPUID_EAX_MAX_SUB_LEAF_FLAG                                  0xFFFFFFFF
#define CPUID_EAX_MAX_SUB_LEAF_MASK                                  0xFFFFFFFF
#define CPUID_EAX_MAX_SUB_LEAF(_)                                    (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Eax;
  union
  {
    struct
    {
       * [Bit 0] If 1, indicates that IA32_RTIT_CTL.CR3Filter can be set to 1, and that IA32_RTIT_CR3_MATCH MSR can be accessed.
      UINT32 Flag0                                                 : 1;
#define CPUID_EBX_FLAG0_BIT                                          0
#define CPUID_EBX_FLAG0_FLAG                                         0x01
#define CPUID_EBX_FLAG0_MASK                                         0x01
#define CPUID_EBX_FLAG0(_)                                           (((_) >> 0) & 0x01)
       * [Bit 1] If 1, indicates support of Configurable PSB and Cycle-Accurate Mode.
      UINT32 Flag1                                                 : 1;
#define CPUID_EBX_FLAG1_BIT                                          1
#define CPUID_EBX_FLAG1_FLAG                                         0x02
#define CPUID_EBX_FLAG1_MASK                                         0x01
#define CPUID_EBX_FLAG1(_)                                           (((_) >> 1) & 0x01)
       * [Bit 2] If 1, indicates support of IP Filtering, TraceStop filtering, and preservation of Intel PT MSRs across warm
       * reset.
      UINT32 Flag2                                                 : 1;
#define CPUID_EBX_FLAG2_BIT                                          2
#define CPUID_EBX_FLAG2_FLAG                                         0x04
#define CPUID_EBX_FLAG2_MASK                                         0x01
#define CPUID_EBX_FLAG2(_)                                           (((_) >> 2) & 0x01)
       * [Bit 3] If 1, indicates support of MTC timing packet and suppression of COFI-based packets.
      UINT32 Flag3                                                 : 1;
#define CPUID_EBX_FLAG3_BIT                                          3
#define CPUID_EBX_FLAG3_FLAG                                         0x08
#define CPUID_EBX_FLAG3_MASK                                         0x01
#define CPUID_EBX_FLAG3(_)                                           (((_) >> 3) & 0x01)
       * [Bit 4] If 1, indicates support of PTWRITE. Writes can set IA32_RTIT_CTL[12] (PTWEn) and IA32_RTIT_CTL[5] (FUPonPTW),
       * and PTWRITE can generate packets.
      UINT32 Flag4                                                 : 1;
#define CPUID_EBX_FLAG4_BIT                                          4
#define CPUID_EBX_FLAG4_FLAG                                         0x10
#define CPUID_EBX_FLAG4_MASK                                         0x01
#define CPUID_EBX_FLAG4(_)                                           (((_) >> 4) & 0x01)
       * [Bit 5] If 1, indicates support of Power Event Trace. Writes can set IA32_RTIT_CTL[4] (PwrEvtEn), enabling Power Event
       * Trace packet generation.
      UINT32 Flag5                                                 : 1;
#define CPUID_EBX_FLAG5_BIT                                          5
#define CPUID_EBX_FLAG5_FLAG                                         0x20
#define CPUID_EBX_FLAG5_MASK                                         0x01
#define CPUID_EBX_FLAG5(_)                                           (((_) >> 5) & 0x01)
       * [Bit 6] If 1, indicates support for PSB and PH preservation. Writes can set IA32_RTIT CTL[56] (InjectPsb-PmiOnEnable),
       * enabling the processor to setIA32_12TIT STATUS[7] (PendTopaPMI) and/or IA32_RTIT_STATUS[6] (PendPSB) in order to
       * preserve ToPA PMIs and/or PSBs otherwise lost due to Intel PT disable. Writes can also set PendToPAPMI and PendPSB.
      UINT32 Flag6                                                 : 1;
#define CPUID_EBX_FLAG6_BIT                                          6
#define CPUID_EBX_FLAG6_FLAG                                         0x40
#define CPUID_EBX_FLAG6_MASK                                         0x01
#define CPUID_EBX_FLAG6(_)                                           (((_) >> 6) & 0x01)
       * [Bit 7] If 1, writes can set IA32_RTIT_CTL[31] (EventEn), enabling Event Trace packet generation.
      UINT32 Flag7                                                 : 1;
#define CPUID_EBX_FLAG7_BIT                                          7
#define CPUID_EBX_FLAG7_FLAG                                         0x80
#define CPUID_EBX_FLAG7_MASK                                         0x01
#define CPUID_EBX_FLAG7(_)                                           (((_) >> 7) & 0x01)
       * [Bit 8] If 1, writes can set IA32_RTIT_CTL[55] (DisTNT), disabling TNT packet generation.
      UINT32 Flag8                                                 : 1;
#define CPUID_EBX_FLAG8_BIT                                          8
#define CPUID_EBX_FLAG8_FLAG                                         0x100
#define CPUID_EBX_FLAG8_MASK                                         0x01
#define CPUID_EBX_FLAG8(_)                                           (((_) >> 8) & 0x01)
      UINT32 Reserved1                                             : 23;
    };
    UINT32 AsUInt;
  } Ebx;
  union
  {
    struct
    {
       * [Bit 0] If 1, Tracing can be enabled with IA32_RTIT_CTL.ToPA = 1, hence utilizing the ToPA output scheme;
       * IA32_RTIT_OUTPUT_BASE and IA32_RTIT_OUTPUT_MASK_PTRS MSRs can be accessed.
      UINT32 Flag0                                                 : 1;
#define CPUID_ECX_FLAG0_BIT                                          0
#define CPUID_ECX_FLAG0_FLAG                                         0x01
#define CPUID_ECX_FLAG0_MASK                                         0x01
#define CPUID_ECX_FLAG0(_)                                           (((_) >> 0) & 0x01)
       * [Bit 1] If 1, ToPA tables can hold any number of output entries, up to the maximum allowed by the MaskOrTableOffset
       * field of IA32_RTIT_OUTPUT_MASK_PTRS.
      UINT32 Flag1                                                 : 1;
#define CPUID_ECX_FLAG1_BIT                                          1
#define CPUID_ECX_FLAG1_FLAG                                         0x02
#define CPUID_ECX_FLAG1_MASK                                         0x01
#define CPUID_ECX_FLAG1(_)                                           (((_) >> 1) & 0x01)
       * [Bit 2] If 1, indicates support of Single-Range Output scheme.
      UINT32 Flag2                                                 : 1;
#define CPUID_ECX_FLAG2_BIT                                          2
#define CPUID_ECX_FLAG2_FLAG                                         0x04
#define CPUID_ECX_FLAG2_MASK                                         0x01
#define CPUID_ECX_FLAG2(_)                                           (((_) >> 2) & 0x01)
       * [Bit 3] If 1, indicates support of output to Trace Transport subsystem.
      UINT32 Flag3                                                 : 1;
#define CPUID_ECX_FLAG3_BIT                                          3
#define CPUID_ECX_FLAG3_FLAG                                         0x08
#define CPUID_ECX_FLAG3_MASK                                         0x01
#define CPUID_ECX_FLAG3(_)                                           (((_) >> 3) & 0x01)
      UINT32 Reserved1                                             : 27;
       * [Bit 31] If 1, generated packets which contain IP payloads have LIP values, which include the CS base component.
      UINT32 Flag31                                                : 1;
#define CPUID_ECX_FLAG31_BIT                                         31
#define CPUID_ECX_FLAG31_FLAG                                        0x80000000
#define CPUID_ECX_FLAG31_MASK                                        0x01
#define CPUID_ECX_FLAG31(_)                                          (((_) >> 31) & 0x01)
    };
    UINT32 AsUInt;
  } Ecx;
  union
  {
    struct
    {
       * [Bits 31:0] EDX is reserved.
      UINT32 Reserved                                              : 32;
#define CPUID_EDX_RESERVED_BIT                                       0
#define CPUID_EDX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Edx;
} CPUID_EAX_14_ECX_00;*/
return true
}

func (i *ia32)#define CPUID_EAX_NUMBER_OF_CONFIGURABLE_ADDRESS_RANGES_FOR_FILTERING()(ok bool){//col:5289
/*#define CPUID_EAX_NUMBER_OF_CONFIGURABLE_ADDRESS_RANGES_FOR_FILTERING(_) (((_) >> 0) & 0x07)
      UINT32 Reserved1                                             : 13;
       * [Bits 31:16] Bitmap of supported MTC period encodings.
      UINT32 BitmapOfSupportedMtcPeriodEncodings                   : 16;
#define CPUID_EAX_BITMAP_OF_SUPPORTED_MTC_PERIOD_ENCODINGS_BIT       16
#define CPUID_EAX_BITMAP_OF_SUPPORTED_MTC_PERIOD_ENCODINGS_FLAG      0xFFFF0000
#define CPUID_EAX_BITMAP_OF_SUPPORTED_MTC_PERIOD_ENCODINGS_MASK      0xFFFF
#define CPUID_EAX_BITMAP_OF_SUPPORTED_MTC_PERIOD_ENCODINGS(_)        (((_) >> 16) & 0xFFFF)
    };
    UINT32 AsUInt;
  } Eax;
  union
  {
    struct
    {
       * [Bits 15:0] Bitmap of supported Cycle Threshold value encodings.
      UINT32 BitmapOfSupportedCycleThresholdValueEncodings         : 16;
#define CPUID_EBX_BITMAP_OF_SUPPORTED_CYCLE_THRESHOLD_VALUE_ENCODINGS_BIT 0
#define CPUID_EBX_BITMAP_OF_SUPPORTED_CYCLE_THRESHOLD_VALUE_ENCODINGS_FLAG 0xFFFF
#define CPUID_EBX_BITMAP_OF_SUPPORTED_CYCLE_THRESHOLD_VALUE_ENCODINGS_MASK 0xFFFF
#define CPUID_EBX_BITMAP_OF_SUPPORTED_CYCLE_THRESHOLD_VALUE_ENCODINGS(_) (((_) >> 0) & 0xFFFF)
       * [Bits 31:16] Bitmap of supported Configurable PSB frequency encodings.
      UINT32 BitmapOfSupportedConfigurablePsbFrequencyEncodings    : 16;
#define CPUID_EBX_BITMAP_OF_SUPPORTED_CONFIGURABLE_PSB_FREQUENCY_ENCODINGS_BIT 16
#define CPUID_EBX_BITMAP_OF_SUPPORTED_CONFIGURABLE_PSB_FREQUENCY_ENCODINGS_FLAG 0xFFFF0000
#define CPUID_EBX_BITMAP_OF_SUPPORTED_CONFIGURABLE_PSB_FREQUENCY_ENCODINGS_MASK 0xFFFF
#define CPUID_EBX_BITMAP_OF_SUPPORTED_CONFIGURABLE_PSB_FREQUENCY_ENCODINGS(_) (((_) >> 16) & 0xFFFF)
    };
    UINT32 AsUInt;
  } Ebx;
  union
  {
    struct
    {
       * [Bits 31:0] ECX is reserved.
      UINT32 Reserved                                              : 32;
#define CPUID_ECX_RESERVED_BIT                                       0
#define CPUID_ECX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Ecx;
  union
  {
    struct
    {
       * [Bits 31:0] EDX is reserved.
      UINT32 Reserved                                              : 32;
#define CPUID_EDX_RESERVED_BIT                                       0
#define CPUID_EDX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Edx;
} CPUID_EAX_14_ECX_01;*/
return true
}

func (i *ia32)#define CPUID_EAX_DENOMINATOR()(ok bool){//col:5378
/*#define CPUID_EAX_DENOMINATOR(_)                                     (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Eax;
  union
  {
    struct
    {
       * [Bits 31:0] An unsigned integer which is the numerator of the TSC/"core crystal clock" ratio.
      UINT32 Numerator                                             : 32;
#define CPUID_EBX_NUMERATOR_BIT                                      0
#define CPUID_EBX_NUMERATOR_FLAG                                     0xFFFFFFFF
#define CPUID_EBX_NUMERATOR_MASK                                     0xFFFFFFFF
#define CPUID_EBX_NUMERATOR(_)                                       (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Ebx;
  union
  {
    struct
    {
       * [Bits 31:0] An unsigned integer which is the nominal frequency of the core crystal clock in Hz.
      UINT32 NominalFrequency                                      : 32;
#define CPUID_ECX_NOMINAL_FREQUENCY_BIT                              0
#define CPUID_ECX_NOMINAL_FREQUENCY_FLAG                             0xFFFFFFFF
#define CPUID_ECX_NOMINAL_FREQUENCY_MASK                             0xFFFFFFFF
#define CPUID_ECX_NOMINAL_FREQUENCY(_)                               (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Ecx;
  union
  {
    struct
    {
       * [Bits 31:0] EDX is reserved.
      UINT32 Reserved                                              : 32;
#define CPUID_EDX_RESERVED_BIT                                       0
#define CPUID_EDX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Edx;
} CPUID_EAX_15;*/
return true
}

func (i *ia32)       * [Bits 15:0] Processor Base Frequency ()(ok bool){//col:5468
/*       * [Bits 15:0] Processor Base Frequency (in MHz).
      UINT32 ProcesorBaseFrequencyMhz                              : 16;
#define CPUID_EAX_PROCESOR_BASE_FREQUENCY_MHZ_BIT                    0
#define CPUID_EAX_PROCESOR_BASE_FREQUENCY_MHZ_FLAG                   0xFFFF
#define CPUID_EAX_PROCESOR_BASE_FREQUENCY_MHZ_MASK                   0xFFFF
#define CPUID_EAX_PROCESOR_BASE_FREQUENCY_MHZ(_)                     (((_) >> 0) & 0xFFFF)
      UINT32 Reserved1                                             : 16;
    };
    UINT32 AsUInt;
  } Eax;
  union
  {
    struct
    {
       * [Bits 15:0] Maximum Frequency (in MHz).
      UINT32 ProcessorMaximumFrequencyMhz                          : 16;
#define CPUID_EBX_PROCESSOR_MAXIMUM_FREQUENCY_MHZ_BIT                0
#define CPUID_EBX_PROCESSOR_MAXIMUM_FREQUENCY_MHZ_FLAG               0xFFFF
#define CPUID_EBX_PROCESSOR_MAXIMUM_FREQUENCY_MHZ_MASK               0xFFFF
#define CPUID_EBX_PROCESSOR_MAXIMUM_FREQUENCY_MHZ(_)                 (((_) >> 0) & 0xFFFF)
      UINT32 Reserved1                                             : 16;
    };
    UINT32 AsUInt;
  } Ebx;
  union
  {
    struct
    {
       * [Bits 15:0] Bus (Reference) Frequency (in MHz).
      UINT32 BusFrequencyMhz                                       : 16;
#define CPUID_ECX_BUS_FREQUENCY_MHZ_BIT                              0
#define CPUID_ECX_BUS_FREQUENCY_MHZ_FLAG                             0xFFFF
#define CPUID_ECX_BUS_FREQUENCY_MHZ_MASK                             0xFFFF
#define CPUID_ECX_BUS_FREQUENCY_MHZ(_)                               (((_) >> 0) & 0xFFFF)
      UINT32 Reserved1                                             : 16;
    };
    UINT32 AsUInt;
  } Ecx;
  union
  {
    struct
    {
       * [Bits 31:0] EDX is reserved.
      UINT32 Reserved                                              : 32;
#define CPUID_EDX_RESERVED_BIT                                       0
#define CPUID_EDX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Edx;
} CPUID_EAX_16;*/
return true
}

func (i *ia32)#define CPUID_EAX_MAX_SOC_ID_INDEX()(ok bool){//col:5566
/*#define CPUID_EAX_MAX_SOC_ID_INDEX(_)                                (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Eax;
  union
  {
    struct
    {
       * [Bits 15:0] SOC Vendor ID.
      UINT32 SocVendorId                                           : 16;
#define CPUID_EBX_SOC_VENDOR_ID_BIT                                  0
#define CPUID_EBX_SOC_VENDOR_ID_FLAG                                 0xFFFF
#define CPUID_EBX_SOC_VENDOR_ID_MASK                                 0xFFFF
#define CPUID_EBX_SOC_VENDOR_ID(_)                                   (((_) >> 0) & 0xFFFF)
       * [Bit 16] If 1, the SOC Vendor ID field is assigned via an industry standard enumeration scheme. Otherwise, the SOC
       * Vendor ID field is assigned by Intel.
      UINT32 IsVendorScheme                                        : 1;
#define CPUID_EBX_IS_VENDOR_SCHEME_BIT                               16
#define CPUID_EBX_IS_VENDOR_SCHEME_FLAG                              0x10000
#define CPUID_EBX_IS_VENDOR_SCHEME_MASK                              0x01
#define CPUID_EBX_IS_VENDOR_SCHEME(_)                                (((_) >> 16) & 0x01)
      UINT32 Reserved1                                             : 15;
    };
    UINT32 AsUInt;
  } Ebx;
  union
  {
    struct
    {
       * [Bits 31:0] A unique number an SOC vendor assigns to its SOC projects.
      UINT32 ProjectId                                             : 32;
#define CPUID_ECX_PROJECT_ID_BIT                                     0
#define CPUID_ECX_PROJECT_ID_FLAG                                    0xFFFFFFFF
#define CPUID_ECX_PROJECT_ID_MASK                                    0xFFFFFFFF
#define CPUID_ECX_PROJECT_ID(_)                                      (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Ecx;
  union
  {
    struct
    {
       * [Bits 31:0] A unique number within an SOC project that an SOC vendor assigns.
      UINT32 SteppingId                                            : 32;
#define CPUID_EDX_STEPPING_ID_BIT                                    0
#define CPUID_EDX_STEPPING_ID_FLAG                                   0xFFFFFFFF
#define CPUID_EDX_STEPPING_ID_MASK                                   0xFFFFFFFF
#define CPUID_EDX_STEPPING_ID(_)                                     (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Edx;
} CPUID_EAX_17_ECX_00;*/
return true
}

func (i *ia32)#define CPUID_EAX_SOC_VENDOR_BRAND_STRING()(ok bool){//col:5645
/*#define CPUID_EAX_SOC_VENDOR_BRAND_STRING(_)                         (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Eax;
  union
  {
    struct
    {
       * [Bits 31:0] SOC Vendor Brand String. UTF-8 encoded string.
      UINT32 SocVendorBrandString                                  : 32;
#define CPUID_EBX_SOC_VENDOR_BRAND_STRING_BIT                        0
#define CPUID_EBX_SOC_VENDOR_BRAND_STRING_FLAG                       0xFFFFFFFF
#define CPUID_EBX_SOC_VENDOR_BRAND_STRING_MASK                       0xFFFFFFFF
#define CPUID_EBX_SOC_VENDOR_BRAND_STRING(_)                         (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Ebx;
  union
  {
    struct
    {
       * [Bits 31:0] SOC Vendor Brand String. UTF-8 encoded string.
      UINT32 SocVendorBrandString                                  : 32;
#define CPUID_ECX_SOC_VENDOR_BRAND_STRING_BIT                        0
#define CPUID_ECX_SOC_VENDOR_BRAND_STRING_FLAG                       0xFFFFFFFF
#define CPUID_ECX_SOC_VENDOR_BRAND_STRING_MASK                       0xFFFFFFFF
#define CPUID_ECX_SOC_VENDOR_BRAND_STRING(_)                         (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Ecx;
  union
  {
    struct
    {
       * [Bits 31:0] SOC Vendor Brand String. UTF-8 encoded string.
      UINT32 SocVendorBrandString                                  : 32;
#define CPUID_EDX_SOC_VENDOR_BRAND_STRING_BIT                        0
#define CPUID_EDX_SOC_VENDOR_BRAND_STRING_FLAG                       0xFFFFFFFF
#define CPUID_EDX_SOC_VENDOR_BRAND_STRING_MASK                       0xFFFFFFFF
#define CPUID_EDX_SOC_VENDOR_BRAND_STRING(_)                         (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Edx;
} CPUID_EAX_17_ECX_01_03;*/
return true
}

func (i *ia32)#define CPUID_EAX_RESERVED()(ok bool){//col:5722
/*#define CPUID_EAX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Eax;
  union
  {
    struct
    {
       * [Bits 31:0] Reserved = 0.
      UINT32 Reserved                                              : 32;
#define CPUID_EBX_RESERVED_BIT                                       0
#define CPUID_EBX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Ebx;
  union
  {
    struct
    {
       * [Bits 31:0] Reserved = 0.
      UINT32 Reserved                                              : 32;
#define CPUID_ECX_RESERVED_BIT                                       0
#define CPUID_ECX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Ecx;
  union
  {
    struct
    {
       * [Bits 31:0] Reserved = 0.
      UINT32 Reserved                                              : 32;
#define CPUID_EDX_RESERVED_BIT                                       0
#define CPUID_EDX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Edx;
} CPUID_EAX_17_ECX_N;*/
return true
}

func (i *ia32)#define CPUID_EAX_MAX_SUB_LEAF()(ok bool){//col:5903
/*#define CPUID_EAX_MAX_SUB_LEAF(_)                                    (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Eax;
  union
  {
    struct
    {
       * [Bit 0] 4K page size entries supported by this structure.
      UINT32 PageEntries4KbSupported                               : 1;
#define CPUID_EBX_PAGE_ENTRIES_4KB_SUPPORTED_BIT                     0
#define CPUID_EBX_PAGE_ENTRIES_4KB_SUPPORTED_FLAG                    0x01
#define CPUID_EBX_PAGE_ENTRIES_4KB_SUPPORTED_MASK                    0x01
#define CPUID_EBX_PAGE_ENTRIES_4KB_SUPPORTED(_)                      (((_) >> 0) & 0x01)
       * [Bit 1] 2MB page size entries supported by this structure.
      UINT32 PageEntries2MbSupported                               : 1;
#define CPUID_EBX_PAGE_ENTRIES_2MB_SUPPORTED_BIT                     1
#define CPUID_EBX_PAGE_ENTRIES_2MB_SUPPORTED_FLAG                    0x02
#define CPUID_EBX_PAGE_ENTRIES_2MB_SUPPORTED_MASK                    0x01
#define CPUID_EBX_PAGE_ENTRIES_2MB_SUPPORTED(_)                      (((_) >> 1) & 0x01)
       * [Bit 2] 4MB page size entries supported by this structure.
      UINT32 PageEntries4MbSupported                               : 1;
#define CPUID_EBX_PAGE_ENTRIES_4MB_SUPPORTED_BIT                     2
#define CPUID_EBX_PAGE_ENTRIES_4MB_SUPPORTED_FLAG                    0x04
#define CPUID_EBX_PAGE_ENTRIES_4MB_SUPPORTED_MASK                    0x01
#define CPUID_EBX_PAGE_ENTRIES_4MB_SUPPORTED(_)                      (((_) >> 2) & 0x01)
       * [Bit 3] 1 GB page size entries supported by this structure.
      UINT32 PageEntries1GbSupported                               : 1;
#define CPUID_EBX_PAGE_ENTRIES_1GB_SUPPORTED_BIT                     3
#define CPUID_EBX_PAGE_ENTRIES_1GB_SUPPORTED_FLAG                    0x08
#define CPUID_EBX_PAGE_ENTRIES_1GB_SUPPORTED_MASK                    0x01
#define CPUID_EBX_PAGE_ENTRIES_1GB_SUPPORTED(_)                      (((_) >> 3) & 0x01)
      UINT32 Reserved1                                             : 4;
       * [Bits 10:8] Partitioning (0: Soft partitioning between the logical processors sharing this structure).
      UINT32 Partitioning                                          : 3;
#define CPUID_EBX_PARTITIONING_BIT                                   8
#define CPUID_EBX_PARTITIONING_FLAG                                  0x700
#define CPUID_EBX_PARTITIONING_MASK                                  0x07
#define CPUID_EBX_PARTITIONING(_)                                    (((_) >> 8) & 0x07)
      UINT32 Reserved2                                             : 5;
       * [Bits 31:16] W = Ways of associativity.
      UINT32 WaysOfAssociativity00                                 : 16;
#define CPUID_EBX_WAYS_OF_ASSOCIATIVITY_00_BIT                       16
#define CPUID_EBX_WAYS_OF_ASSOCIATIVITY_00_FLAG                      0xFFFF0000
#define CPUID_EBX_WAYS_OF_ASSOCIATIVITY_00_MASK                      0xFFFF
#define CPUID_EBX_WAYS_OF_ASSOCIATIVITY_00(_)                        (((_) >> 16) & 0xFFFF)
    };
    UINT32 AsUInt;
  } Ebx;
  union
  {
    struct
    {
       * [Bits 31:0] Number of Sets.
      UINT32 NumberOfSets                                          : 32;
#define CPUID_ECX_NUMBER_OF_SETS_BIT                                 0
#define CPUID_ECX_NUMBER_OF_SETS_FLAG                                0xFFFFFFFF
#define CPUID_ECX_NUMBER_OF_SETS_MASK                                0xFFFFFFFF
#define CPUID_ECX_NUMBER_OF_SETS(_)                                  (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Ecx;
  union
  {
    struct
    {
       * [Bits 4:0] Translation cache type field.
       * - 00000b: Null (indicates this sub-leaf is not valid).
       * - 00001b: Data TLB.
       * - 00010b: Instruction TLB.
       * - 00011b: Unified TLB.
       * All other encodings are reserved.
       *
       *       require separate entries (e.g., one loaded on data read/write and another loaded on an instruction fetch) . Please see
       *       the Intel(R) 64 and IA-32 Architectures Optimization Reference Manual for details of a particular product.
      UINT32 TranslationCacheTypeField                             : 5;
#define CPUID_EDX_TRANSLATION_CACHE_TYPE_FIELD_BIT                   0
#define CPUID_EDX_TRANSLATION_CACHE_TYPE_FIELD_FLAG                  0x1F
#define CPUID_EDX_TRANSLATION_CACHE_TYPE_FIELD_MASK                  0x1F
#define CPUID_EDX_TRANSLATION_CACHE_TYPE_FIELD(_)                    (((_) >> 0) & 0x1F)
       * [Bits 7:5] Translation cache level (starts at 1).
      UINT32 TranslationCacheLevel                                 : 3;
#define CPUID_EDX_TRANSLATION_CACHE_LEVEL_BIT                        5
#define CPUID_EDX_TRANSLATION_CACHE_LEVEL_FLAG                       0xE0
#define CPUID_EDX_TRANSLATION_CACHE_LEVEL_MASK                       0x07
#define CPUID_EDX_TRANSLATION_CACHE_LEVEL(_)                         (((_) >> 5) & 0x07)
       * [Bit 8] Fully associative structure.
      UINT32 FullyAssociativeStructure                             : 1;
#define CPUID_EDX_FULLY_ASSOCIATIVE_STRUCTURE_BIT                    8
#define CPUID_EDX_FULLY_ASSOCIATIVE_STRUCTURE_FLAG                   0x100
#define CPUID_EDX_FULLY_ASSOCIATIVE_STRUCTURE_MASK                   0x01
#define CPUID_EDX_FULLY_ASSOCIATIVE_STRUCTURE(_)                     (((_) >> 8) & 0x01)
      UINT32 Reserved1                                             : 5;
       * [Bits 25:14] Maximum number of addressable IDs for logical processors sharing this translation cache.
       *
      UINT32 MaxAddressableIdsForLogicalProcessors                 : 12;
#define CPUID_EDX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS_BIT     14
#define CPUID_EDX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS_FLAG    0x3FFC000
#define CPUID_EDX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS_MASK    0xFFF
#define CPUID_EDX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS(_)      (((_) >> 14) & 0xFFF)
      UINT32 Reserved2                                             : 6;
    };
    UINT32 AsUInt;
  } Edx;
} CPUID_EAX_18_ECX_00;*/
return true
}

func (i *ia32)#define CPUID_EAX_RESERVED()(ok bool){//col:6071
/*#define CPUID_EAX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Eax;
  union
  {
    struct
    {
       * [Bit 0] 4K page size entries supported by this structure.
      UINT32 PageEntries4KbSupported                               : 1;
#define CPUID_EBX_PAGE_ENTRIES_4KB_SUPPORTED_BIT                     0
#define CPUID_EBX_PAGE_ENTRIES_4KB_SUPPORTED_FLAG                    0x01
#define CPUID_EBX_PAGE_ENTRIES_4KB_SUPPORTED_MASK                    0x01
#define CPUID_EBX_PAGE_ENTRIES_4KB_SUPPORTED(_)                      (((_) >> 0) & 0x01)
       * [Bit 1] 2MB page size entries supported by this structure.
      UINT32 PageEntries2MbSupported                               : 1;
#define CPUID_EBX_PAGE_ENTRIES_2MB_SUPPORTED_BIT                     1
#define CPUID_EBX_PAGE_ENTRIES_2MB_SUPPORTED_FLAG                    0x02
#define CPUID_EBX_PAGE_ENTRIES_2MB_SUPPORTED_MASK                    0x01
#define CPUID_EBX_PAGE_ENTRIES_2MB_SUPPORTED(_)                      (((_) >> 1) & 0x01)
       * [Bit 2] 4MB page size entries supported by this structure.
      UINT32 PageEntries4MbSupported                               : 1;
#define CPUID_EBX_PAGE_ENTRIES_4MB_SUPPORTED_BIT                     2
#define CPUID_EBX_PAGE_ENTRIES_4MB_SUPPORTED_FLAG                    0x04
#define CPUID_EBX_PAGE_ENTRIES_4MB_SUPPORTED_MASK                    0x01
#define CPUID_EBX_PAGE_ENTRIES_4MB_SUPPORTED(_)                      (((_) >> 2) & 0x01)
       * [Bit 3] 1 GB page size entries supported by this structure.
      UINT32 PageEntries1GbSupported                               : 1;
#define CPUID_EBX_PAGE_ENTRIES_1GB_SUPPORTED_BIT                     3
#define CPUID_EBX_PAGE_ENTRIES_1GB_SUPPORTED_FLAG                    0x08
#define CPUID_EBX_PAGE_ENTRIES_1GB_SUPPORTED_MASK                    0x01
#define CPUID_EBX_PAGE_ENTRIES_1GB_SUPPORTED(_)                      (((_) >> 3) & 0x01)
      UINT32 Reserved1                                             : 4;
       * [Bits 10:8] Partitioning (0: Soft partitioning between the logical processors sharing this structure).
      UINT32 Partitioning                                          : 3;
#define CPUID_EBX_PARTITIONING_BIT                                   8
#define CPUID_EBX_PARTITIONING_FLAG                                  0x700
#define CPUID_EBX_PARTITIONING_MASK                                  0x07
#define CPUID_EBX_PARTITIONING(_)                                    (((_) >> 8) & 0x07)
      UINT32 Reserved2                                             : 5;
       * [Bits 31:16] W = Ways of associativity.
      UINT32 WaysOfAssociativity01                                 : 16;
#define CPUID_EBX_WAYS_OF_ASSOCIATIVITY_01_BIT                       16
#define CPUID_EBX_WAYS_OF_ASSOCIATIVITY_01_FLAG                      0xFFFF0000
#define CPUID_EBX_WAYS_OF_ASSOCIATIVITY_01_MASK                      0xFFFF
#define CPUID_EBX_WAYS_OF_ASSOCIATIVITY_01(_)                        (((_) >> 16) & 0xFFFF)
    };
    UINT32 AsUInt;
  } Ebx;
  union
  {
    struct
    {
       * [Bits 31:0] Number of Sets.
      UINT32 NumberOfSets                                          : 32;
#define CPUID_ECX_NUMBER_OF_SETS_BIT                                 0
#define CPUID_ECX_NUMBER_OF_SETS_FLAG                                0xFFFFFFFF
#define CPUID_ECX_NUMBER_OF_SETS_MASK                                0xFFFFFFFF
#define CPUID_ECX_NUMBER_OF_SETS(_)                                  (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Ecx;
  union
  {
    struct
    {
       * [Bits 4:0] Translation cache type field.
       * - 00000b: Null (indicates this sub-leaf is not valid).
       * - 00001b: Data TLB.
       * - 00010b: Instruction TLB.
       * - 00011b: Unified TLB.
       * All other encodings are reserved.
       *
       *       require separate entries (e.g., one loaded on data read/write and another loaded on an instruction fetch) . Please see
       *       the Intel(R) 64 and IA-32 Architectures Optimization Reference Manual for details of a particular product.
      UINT32 TranslationCacheTypeField                             : 5;
#define CPUID_EDX_TRANSLATION_CACHE_TYPE_FIELD_BIT                   0
#define CPUID_EDX_TRANSLATION_CACHE_TYPE_FIELD_FLAG                  0x1F
#define CPUID_EDX_TRANSLATION_CACHE_TYPE_FIELD_MASK                  0x1F
#define CPUID_EDX_TRANSLATION_CACHE_TYPE_FIELD(_)                    (((_) >> 0) & 0x1F)
       * [Bits 7:5] Translation cache level (starts at 1).
      UINT32 TranslationCacheLevel                                 : 3;
#define CPUID_EDX_TRANSLATION_CACHE_LEVEL_BIT                        5
#define CPUID_EDX_TRANSLATION_CACHE_LEVEL_FLAG                       0xE0
#define CPUID_EDX_TRANSLATION_CACHE_LEVEL_MASK                       0x07
#define CPUID_EDX_TRANSLATION_CACHE_LEVEL(_)                         (((_) >> 5) & 0x07)
       * [Bit 8] Fully associative structure.
      UINT32 FullyAssociativeStructure                             : 1;
#define CPUID_EDX_FULLY_ASSOCIATIVE_STRUCTURE_BIT                    8
#define CPUID_EDX_FULLY_ASSOCIATIVE_STRUCTURE_FLAG                   0x100
#define CPUID_EDX_FULLY_ASSOCIATIVE_STRUCTURE_MASK                   0x01
#define CPUID_EDX_FULLY_ASSOCIATIVE_STRUCTURE(_)                     (((_) >> 8) & 0x01)
      UINT32 Reserved1                                             : 5;
       * [Bits 25:14] Maximum number of addressable IDs for logical processors sharing this translation cache.
       *
      UINT32 MaxAddressableIdsForLogicalProcessors                 : 12;
#define CPUID_EDX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS_BIT     14
#define CPUID_EDX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS_FLAG    0x3FFC000
#define CPUID_EDX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS_MASK    0xFFF
#define CPUID_EDX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS(_)      (((_) >> 14) & 0xFFF)
      UINT32 Reserved2                                             : 6;
    };
    UINT32 AsUInt;
  } Edx;
} CPUID_EAX_18_ECX_01P;*/
return true
}

func (i *ia32)#define CPUID_EAX_MAX_EXTENDED_FUNCTIONS()(ok bool){//col:6155
/*#define CPUID_EAX_MAX_EXTENDED_FUNCTIONS(_)                          (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Eax;
  union
  {
    struct
    {
       * [Bits 31:0] EBX is reserved.
      UINT32 Reserved                                              : 32;
#define CPUID_EBX_RESERVED_BIT                                       0
#define CPUID_EBX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Ebx;
  union
  {
    struct
    {
       * [Bits 31:0] ECX is reserved.
      UINT32 Reserved                                              : 32;
#define CPUID_ECX_RESERVED_BIT                                       0
#define CPUID_ECX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Ecx;
  union
  {
    struct
    {
       * [Bits 31:0] EDX is reserved.
      UINT32 Reserved                                              : 32;
#define CPUID_EDX_RESERVED_BIT                                       0
#define CPUID_EDX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Edx;
} CPUID_EAX_80000000;*/
return true
}

func (i *ia32)#define CPUID_EAX_RESERVED()(ok bool){//col:6295
/*#define CPUID_EAX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Eax;
  union
  {
    struct
    {
       * [Bits 31:0] EBX is reserved.
      UINT32 Reserved                                              : 32;
#define CPUID_EBX_RESERVED_BIT                                       0
#define CPUID_EBX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Ebx;
  union
  {
    struct
    {
       * [Bit 0] LAHF/SAHF available in 64-bit mode.
      UINT32 LahfSahfAvailableIn64BitMode                          : 1;
#define CPUID_ECX_LAHF_SAHF_AVAILABLE_IN_64_BIT_MODE_BIT             0
#define CPUID_ECX_LAHF_SAHF_AVAILABLE_IN_64_BIT_MODE_FLAG            0x01
#define CPUID_ECX_LAHF_SAHF_AVAILABLE_IN_64_BIT_MODE_MASK            0x01
#define CPUID_ECX_LAHF_SAHF_AVAILABLE_IN_64_BIT_MODE(_)              (((_) >> 0) & 0x01)
      UINT32 Reserved1                                             : 4;
       * [Bit 5] LZCNT.
      UINT32 Lzcnt                                                 : 1;
#define CPUID_ECX_LZCNT_BIT                                          5
#define CPUID_ECX_LZCNT_FLAG                                         0x20
#define CPUID_ECX_LZCNT_MASK                                         0x01
#define CPUID_ECX_LZCNT(_)                                           (((_) >> 5) & 0x01)
      UINT32 Reserved2                                             : 2;
       * [Bit 8] PREFETCHW.
      UINT32 Prefetchw                                             : 1;
#define CPUID_ECX_PREFETCHW_BIT                                      8
#define CPUID_ECX_PREFETCHW_FLAG                                     0x100
#define CPUID_ECX_PREFETCHW_MASK                                     0x01
#define CPUID_ECX_PREFETCHW(_)                                       (((_) >> 8) & 0x01)
      UINT32 Reserved3                                             : 23;
    };
    UINT32 AsUInt;
  } Ecx;
  union
  {
    struct
    {
      UINT32 Reserved1                                             : 11;
       * [Bit 11] SYSCALL/SYSRET available in 64-bit mode.
      UINT32 SyscallSysretAvailableIn64BitMode                     : 1;
#define CPUID_EDX_SYSCALL_SYSRET_AVAILABLE_IN_64_BIT_MODE_BIT        11
#define CPUID_EDX_SYSCALL_SYSRET_AVAILABLE_IN_64_BIT_MODE_FLAG       0x800
#define CPUID_EDX_SYSCALL_SYSRET_AVAILABLE_IN_64_BIT_MODE_MASK       0x01
#define CPUID_EDX_SYSCALL_SYSRET_AVAILABLE_IN_64_BIT_MODE(_)         (((_) >> 11) & 0x01)
      UINT32 Reserved2                                             : 8;
       * [Bit 20] Execute Disable Bit available.
      UINT32 ExecuteDisableBitAvailable                            : 1;
#define CPUID_EDX_EXECUTE_DISABLE_BIT_AVAILABLE_BIT                  20
#define CPUID_EDX_EXECUTE_DISABLE_BIT_AVAILABLE_FLAG                 0x100000
#define CPUID_EDX_EXECUTE_DISABLE_BIT_AVAILABLE_MASK                 0x01
#define CPUID_EDX_EXECUTE_DISABLE_BIT_AVAILABLE(_)                   (((_) >> 20) & 0x01)
      UINT32 Reserved3                                             : 5;
       * [Bit 26] 1-GByte pages are available if 1.
      UINT32 Pages1GbAvailable                                     : 1;
#define CPUID_EDX_PAGES_1GB_AVAILABLE_BIT                            26
#define CPUID_EDX_PAGES_1GB_AVAILABLE_FLAG                           0x4000000
#define CPUID_EDX_PAGES_1GB_AVAILABLE_MASK                           0x01
#define CPUID_EDX_PAGES_1GB_AVAILABLE(_)                             (((_) >> 26) & 0x01)
       * [Bit 27] RDTSCP and IA32_TSC_AUX are available if 1.
      UINT32 RdtscpAvailable                                       : 1;
#define CPUID_EDX_RDTSCP_AVAILABLE_BIT                               27
#define CPUID_EDX_RDTSCP_AVAILABLE_FLAG                              0x8000000
#define CPUID_EDX_RDTSCP_AVAILABLE_MASK                              0x01
#define CPUID_EDX_RDTSCP_AVAILABLE(_)                                (((_) >> 27) & 0x01)
      UINT32 Reserved4                                             : 1;
       * [Bit 29] Intel(R) 64 Architecture available if 1.
      UINT32 Ia64Available                                         : 1;
#define CPUID_EDX_IA64_AVAILABLE_BIT                                 29
#define CPUID_EDX_IA64_AVAILABLE_FLAG                                0x20000000
#define CPUID_EDX_IA64_AVAILABLE_MASK                                0x01
#define CPUID_EDX_IA64_AVAILABLE(_)                                  (((_) >> 29) & 0x01)
      UINT32 Reserved5                                             : 2;
    };
    UINT32 AsUInt;
  } Edx;
} CPUID_EAX_80000001;*/
return true
}

func (i *ia32)#define CPUID_EAX_PROCESSOR_BRAND_STRING_1()(ok bool){//col:6382
/*#define CPUID_EAX_PROCESSOR_BRAND_STRING_1(_)                        (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Eax;
  union
  {
    struct
    {
       * [Bits 31:0] Processor Brand String Continued.
      UINT32 ProcessorBrandString2                                 : 32;
#define CPUID_EBX_PROCESSOR_BRAND_STRING_2_BIT                       0
#define CPUID_EBX_PROCESSOR_BRAND_STRING_2_FLAG                      0xFFFFFFFF
#define CPUID_EBX_PROCESSOR_BRAND_STRING_2_MASK                      0xFFFFFFFF
#define CPUID_EBX_PROCESSOR_BRAND_STRING_2(_)                        (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Ebx;
  union
  {
    struct
    {
       * [Bits 31:0] Processor Brand String Continued.
      UINT32 ProcessorBrandString3                                 : 32;
#define CPUID_ECX_PROCESSOR_BRAND_STRING_3_BIT                       0
#define CPUID_ECX_PROCESSOR_BRAND_STRING_3_FLAG                      0xFFFFFFFF
#define CPUID_ECX_PROCESSOR_BRAND_STRING_3_MASK                      0xFFFFFFFF
#define CPUID_ECX_PROCESSOR_BRAND_STRING_3(_)                        (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Ecx;
  union
  {
    struct
    {
       * [Bits 31:0] Processor Brand String Continued.
      UINT32 ProcessorBrandString4                                 : 32;
#define CPUID_EDX_PROCESSOR_BRAND_STRING_4_BIT                       0
#define CPUID_EDX_PROCESSOR_BRAND_STRING_4_FLAG                      0xFFFFFFFF
#define CPUID_EDX_PROCESSOR_BRAND_STRING_4_MASK                      0xFFFFFFFF
#define CPUID_EDX_PROCESSOR_BRAND_STRING_4(_)                        (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Edx;
} CPUID_EAX_80000002;*/
return true
}

func (i *ia32)#define CPUID_EAX_PROCESSOR_BRAND_STRING_5()(ok bool){//col:6457
/*#define CPUID_EAX_PROCESSOR_BRAND_STRING_5(_)                        (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Eax;
  union
  {
    struct
    {
       * [Bits 31:0] Processor Brand String Continued.
      UINT32 ProcessorBrandString6                                 : 32;
#define CPUID_EBX_PROCESSOR_BRAND_STRING_6_BIT                       0
#define CPUID_EBX_PROCESSOR_BRAND_STRING_6_FLAG                      0xFFFFFFFF
#define CPUID_EBX_PROCESSOR_BRAND_STRING_6_MASK                      0xFFFFFFFF
#define CPUID_EBX_PROCESSOR_BRAND_STRING_6(_)                        (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Ebx;
  union
  {
    struct
    {
       * [Bits 31:0] Processor Brand String Continued.
      UINT32 ProcessorBrandString7                                 : 32;
#define CPUID_ECX_PROCESSOR_BRAND_STRING_7_BIT                       0
#define CPUID_ECX_PROCESSOR_BRAND_STRING_7_FLAG                      0xFFFFFFFF
#define CPUID_ECX_PROCESSOR_BRAND_STRING_7_MASK                      0xFFFFFFFF
#define CPUID_ECX_PROCESSOR_BRAND_STRING_7(_)                        (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Ecx;
  union
  {
    struct
    {
       * [Bits 31:0] Processor Brand String Continued.
      UINT32 ProcessorBrandString8                                 : 32;
#define CPUID_EDX_PROCESSOR_BRAND_STRING_8_BIT                       0
#define CPUID_EDX_PROCESSOR_BRAND_STRING_8_FLAG                      0xFFFFFFFF
#define CPUID_EDX_PROCESSOR_BRAND_STRING_8_MASK                      0xFFFFFFFF
#define CPUID_EDX_PROCESSOR_BRAND_STRING_8(_)                        (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Edx;
} CPUID_EAX_80000003;*/
return true
}

func (i *ia32)#define CPUID_EAX_PROCESSOR_BRAND_STRING_9()(ok bool){//col:6532
/*#define CPUID_EAX_PROCESSOR_BRAND_STRING_9(_)                        (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Eax;
  union
  {
    struct
    {
       * [Bits 31:0] Processor Brand String Continued.
      UINT32 ProcessorBrandString10                                : 32;
#define CPUID_EBX_PROCESSOR_BRAND_STRING_10_BIT                      0
#define CPUID_EBX_PROCESSOR_BRAND_STRING_10_FLAG                     0xFFFFFFFF
#define CPUID_EBX_PROCESSOR_BRAND_STRING_10_MASK                     0xFFFFFFFF
#define CPUID_EBX_PROCESSOR_BRAND_STRING_10(_)                       (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Ebx;
  union
  {
    struct
    {
       * [Bits 31:0] Processor Brand String Continued.
      UINT32 ProcessorBrandString11                                : 32;
#define CPUID_ECX_PROCESSOR_BRAND_STRING_11_BIT                      0
#define CPUID_ECX_PROCESSOR_BRAND_STRING_11_FLAG                     0xFFFFFFFF
#define CPUID_ECX_PROCESSOR_BRAND_STRING_11_MASK                     0xFFFFFFFF
#define CPUID_ECX_PROCESSOR_BRAND_STRING_11(_)                       (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Ecx;
  union
  {
    struct
    {
       * [Bits 31:0] Processor Brand String Continued.
      UINT32 ProcessorBrandString12                                : 32;
#define CPUID_EDX_PROCESSOR_BRAND_STRING_12_BIT                      0
#define CPUID_EDX_PROCESSOR_BRAND_STRING_12_FLAG                     0xFFFFFFFF
#define CPUID_EDX_PROCESSOR_BRAND_STRING_12_MASK                     0xFFFFFFFF
#define CPUID_EDX_PROCESSOR_BRAND_STRING_12(_)                       (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Edx;
} CPUID_EAX_80000004;*/
return true
}

func (i *ia32)#define CPUID_EAX_RESERVED()(ok bool){//col:6607
/*#define CPUID_EAX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Eax;
  union
  {
    struct
    {
       * [Bits 31:0] EBX is reserved.
      UINT32 Reserved                                              : 32;
#define CPUID_EBX_RESERVED_BIT                                       0
#define CPUID_EBX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Ebx;
  union
  {
    struct
    {
       * [Bits 31:0] ECX is reserved.
      UINT32 Reserved                                              : 32;
#define CPUID_ECX_RESERVED_BIT                                       0
#define CPUID_ECX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Ecx;
  union
  {
    struct
    {
       * [Bits 31:0] EDX is reserved.
      UINT32 Reserved                                              : 32;
#define CPUID_EDX_RESERVED_BIT                                       0
#define CPUID_EDX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Edx;
} CPUID_EAX_80000005;*/
return true
}

func (i *ia32)#define CPUID_EAX_RESERVED()(ok bool){//col:6711
/*#define CPUID_EAX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Eax;
  union
  {
    struct
    {
       * [Bits 31:0] EBX is reserved.
      UINT32 Reserved                                              : 32;
#define CPUID_EBX_RESERVED_BIT                                       0
#define CPUID_EBX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Ebx;
  union
  {
    struct
    {
       * [Bits 7:0] Cache Line size in bytes.
      UINT32 CacheLineSizeInBytes                                  : 8;
#define CPUID_ECX_CACHE_LINE_SIZE_IN_BYTES_BIT                       0
#define CPUID_ECX_CACHE_LINE_SIZE_IN_BYTES_FLAG                      0xFF
#define CPUID_ECX_CACHE_LINE_SIZE_IN_BYTES_MASK                      0xFF
#define CPUID_ECX_CACHE_LINE_SIZE_IN_BYTES(_)                        (((_) >> 0) & 0xFF)
      UINT32 Reserved1                                             : 4;
       * [Bits 15:12] L2 Associativity field.
       * L2 associativity field encodings:
       * - 00H - Disabled.
       * - 01H - Direct mapped.
       * - 02H - 2-way.
       * - 04H - 4-way.
       * - 06H - 8-way.
       * - 08H - 16-way.
       * - 0FH - Fully associative.
      UINT32 L2AssociativityField                                  : 4;
#define CPUID_ECX_L2_ASSOCIATIVITY_FIELD_BIT                         12
#define CPUID_ECX_L2_ASSOCIATIVITY_FIELD_FLAG                        0xF000
#define CPUID_ECX_L2_ASSOCIATIVITY_FIELD_MASK                        0x0F
#define CPUID_ECX_L2_ASSOCIATIVITY_FIELD(_)                          (((_) >> 12) & 0x0F)
       * [Bits 31:16] Cache size in 1K units.
      UINT32 CacheSizeIn1KUnits                                    : 16;
#define CPUID_ECX_CACHE_SIZE_IN_1K_UNITS_BIT                         16
#define CPUID_ECX_CACHE_SIZE_IN_1K_UNITS_FLAG                        0xFFFF0000
#define CPUID_ECX_CACHE_SIZE_IN_1K_UNITS_MASK                        0xFFFF
#define CPUID_ECX_CACHE_SIZE_IN_1K_UNITS(_)                          (((_) >> 16) & 0xFFFF)
    };
    UINT32 AsUInt;
  } Ecx;
  union
  {
    struct
    {
       * [Bits 31:0] EDX is reserved.
      UINT32 Reserved                                              : 32;
#define CPUID_EDX_RESERVED_BIT                                       0
#define CPUID_EDX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Edx;
} CPUID_EAX_80000006;*/
return true
}

func (i *ia32)#define CPUID_EAX_RESERVED()(ok bool){//col:6791
/*#define CPUID_EAX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Eax;
  union
  {
    struct
    {
       * [Bits 31:0] EBX is reserved.
      UINT32 Reserved                                              : 32;
#define CPUID_EBX_RESERVED_BIT                                       0
#define CPUID_EBX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Ebx;
  union
  {
    struct
    {
       * [Bits 31:0] ECX is reserved.
      UINT32 Reserved                                              : 32;
#define CPUID_ECX_RESERVED_BIT                                       0
#define CPUID_ECX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Ecx;
  union
  {
    struct
    {
      UINT32 Reserved1                                             : 8;
       * [Bit 8] Invariant TSC available if 1.
      UINT32 InvariantTscAvailable                                 : 1;
#define CPUID_EDX_INVARIANT_TSC_AVAILABLE_BIT                        8
#define CPUID_EDX_INVARIANT_TSC_AVAILABLE_FLAG                       0x100
#define CPUID_EDX_INVARIANT_TSC_AVAILABLE_MASK                       0x01
#define CPUID_EDX_INVARIANT_TSC_AVAILABLE(_)                         (((_) >> 8) & 0x01)
      UINT32 Reserved2                                             : 23;
    };
    UINT32 AsUInt;
  } Edx;
} CPUID_EAX_80000007;*/
return true
}

func (i *ia32)#define CPUID_EAX_NUMBER_OF_PHYSICAL_ADDRESS_BITS()(ok bool){//col:6881
/*#define CPUID_EAX_NUMBER_OF_PHYSICAL_ADDRESS_BITS(_)                 (((_) >> 0) & 0xFF)
       * [Bits 15:8] Number of Linear Address Bits.
      UINT32 NumberOfLinearAddressBits                             : 8;
#define CPUID_EAX_NUMBER_OF_LINEAR_ADDRESS_BITS_BIT                  8
#define CPUID_EAX_NUMBER_OF_LINEAR_ADDRESS_BITS_FLAG                 0xFF00
#define CPUID_EAX_NUMBER_OF_LINEAR_ADDRESS_BITS_MASK                 0xFF
#define CPUID_EAX_NUMBER_OF_LINEAR_ADDRESS_BITS(_)                   (((_) >> 8) & 0xFF)
      UINT32 Reserved1                                             : 16;
    };
    UINT32 AsUInt;
  } Eax;
  union
  {
    struct
    {
       * [Bits 31:0] EBX is reserved.
      UINT32 Reserved                                              : 32;
#define CPUID_EBX_RESERVED_BIT                                       0
#define CPUID_EBX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Ebx;
  union
  {
    struct
    {
       * [Bits 31:0] ECX is reserved.
      UINT32 Reserved                                              : 32;
#define CPUID_ECX_RESERVED_BIT                                       0
#define CPUID_ECX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Ecx;
  union
  {
    struct
    {
       * [Bits 31:0] EDX is reserved.
      UINT32 Reserved                                              : 32;
#define CPUID_EDX_RESERVED_BIT                                       0
#define CPUID_EDX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
    };
    UINT32 AsUInt;
  } Edx;
} CPUID_EAX_80000008;*/
return true
}

func (i *ia32) *           IA32_P5_MC_()(ok bool){//col:6981
/* *           IA32_P5_MC_(x)
 *
 * When machine-check exceptions are enabled for the Pentium processor (MCE flag is set in control register CR4), the
 * machine-check exception handler uses the RDMSR instruction to read the error type from the P5_MC_TYPE register and the
 * machine check address from the P5_MC_ADDR register. The handler then normally reports these register values to the
 * system console before aborting execution.
 *
 * Machine-check exception address.
 *
#define IA32_P5_MC_ADDR                                              0x00000000
 * Machine-check exception type.
 *
#define IA32_P5_MC_TYPE                                              0x00000001
 * System coherence line size.
 *
#define IA32_MONITOR_FILTER_LINE_SIZE                                0x00000006
 * Value as returned by instruction RDTSC.
 *
#define IA32_TIME_STAMP_COUNTER                                      0x00000010
 * The operating system can use this MSR to determine "slot" information for the processor and the proper microcode update
 * to load.
 *
#define IA32_PLATFORM_ID                                             0x00000017
typedef union
{
  struct
  {
    UINT64 Reserved1                                               : 50;
     *
     * [Bits 52:50] Contains information concerning the intended platform for the processor.
     * 
     * 
     * 52 | 51 | 50 | _
     * --:|:--:|:---|-----------------
     * 0  | 0  | 0  | Processor Flag 0
     * 0  | 0  | 1  | Processor Flag 1
     * 0  | 1  | 0  | Processor Flag 2
     * 0  | 1  | 1  | Processor Flag 3
     * 1  | 0  | 0  | Processor Flag 4
     * 1  | 0  | 1  | Processor Flag 5
     * 1  | 1  | 0  | Processor Flag 6
     * 1  | 1  | 1  | Processor Flag 7
    UINT64 PlatformId                                              : 3;
#define IA32_PLATFORM_ID_PLATFORM_ID_BIT                             50
#define IA32_PLATFORM_ID_PLATFORM_ID_FLAG                            0x1C000000000000
#define IA32_PLATFORM_ID_PLATFORM_ID_MASK                            0x07
#define IA32_PLATFORM_ID_PLATFORM_ID(_)                              (((_) >> 50) & 0x07)
    UINT64 Reserved2                                               : 11;
  };
  UINT64 AsUInt;
} IA32_PLATFORM_ID_REGISTER;*/
return true
}

func (i *ia32)#define IA32_APIC_BASE_BSP_FLAG()(ok bool){//col:7038
/*#define IA32_APIC_BASE_BSP_FLAG(_)                                   (((_) >> 8) & 0x01)
    UINT64 Reserved2                                               : 1;
     * [Bit 10] Enable x2APIC mode.
    UINT64 EnableX2ApicMode                                        : 1;
#define IA32_APIC_BASE_ENABLE_X2APIC_MODE_BIT                        10
#define IA32_APIC_BASE_ENABLE_X2APIC_MODE_FLAG                       0x400
#define IA32_APIC_BASE_ENABLE_X2APIC_MODE_MASK                       0x01
#define IA32_APIC_BASE_ENABLE_X2APIC_MODE(_)                         (((_) >> 10) & 0x01)
     * [Bit 11] APIC Global Enable.
    UINT64 ApicGlobalEnable                                        : 1;
#define IA32_APIC_BASE_APIC_GLOBAL_ENABLE_BIT                        11
#define IA32_APIC_BASE_APIC_GLOBAL_ENABLE_FLAG                       0x800
#define IA32_APIC_BASE_APIC_GLOBAL_ENABLE_MASK                       0x01
#define IA32_APIC_BASE_APIC_GLOBAL_ENABLE(_)                         (((_) >> 11) & 0x01)
     * [Bits 47:12] APIC Base.
    UINT64 ApicBase                                                : 36;
#define IA32_APIC_BASE_APIC_BASE_BIT                                 12
#define IA32_APIC_BASE_APIC_BASE_FLAG                                0xFFFFFFFFF000
#define IA32_APIC_BASE_APIC_BASE_MASK                                0xFFFFFFFFF
#define IA32_APIC_BASE_APIC_BASE(_)                                  (((_) >> 12) & 0xFFFFFFFFF)
    UINT64 Reserved3                                               : 16;
  };
  UINT64 AsUInt;
} IA32_APIC_BASE_REGISTER;*/
return true
}

func (i *ia32)     * [Bit 0] When set, locks this MSR from being written; writes to this bit will result in GP()(ok bool){//col:7170
/*     * [Bit 0] When set, locks this MSR from being written; writes to this bit will result in GP(0).
     *
     *       after configuring support for Intel Virtualization Technology and prior to transferring control to an option ROM or the
     *       OS. Hence, once the Lock bit is set, the entire IA32_FEATURE_CONTROL contents are preserved across RESET when PWRGOOD is
     *       not deasserted.
    UINT64 LockBit                                                 : 1;
#define IA32_FEATURE_CONTROL_LOCK_BIT_BIT                            0
#define IA32_FEATURE_CONTROL_LOCK_BIT_FLAG                           0x01
#define IA32_FEATURE_CONTROL_LOCK_BIT_MASK                           0x01
#define IA32_FEATURE_CONTROL_LOCK_BIT(_)                             (((_) >> 0) & 0x01)
     *
     * [Bit 1] This bit enables a system executive to use VMX in conjunction with SMX to support Intel(R) Trusted Execution
     * Technology. BIOS must set this bit only when the CPUID function 1 returns VMX feature flag and SMX feature flag set (ECX
     * bits 5 and 6 respectively).
     *
    UINT64 EnableVmxInsideSmx                                      : 1;
#define IA32_FEATURE_CONTROL_ENABLE_VMX_INSIDE_SMX_BIT               1
#define IA32_FEATURE_CONTROL_ENABLE_VMX_INSIDE_SMX_FLAG              0x02
#define IA32_FEATURE_CONTROL_ENABLE_VMX_INSIDE_SMX_MASK              0x01
#define IA32_FEATURE_CONTROL_ENABLE_VMX_INSIDE_SMX(_)                (((_) >> 1) & 0x01)
     *
     * [Bit 2] This bit enables VMX for a system executive that does not require SMX. BIOS must set this bit only when the
     * CPUID function 1 returns the VMX feature flag set (ECX bit 5).
     *
    UINT64 EnableVmxOutsideSmx                                     : 1;
#define IA32_FEATURE_CONTROL_ENABLE_VMX_OUTSIDE_SMX_BIT              2
#define IA32_FEATURE_CONTROL_ENABLE_VMX_OUTSIDE_SMX_FLAG             0x04
#define IA32_FEATURE_CONTROL_ENABLE_VMX_OUTSIDE_SMX_MASK             0x01
#define IA32_FEATURE_CONTROL_ENABLE_VMX_OUTSIDE_SMX(_)               (((_) >> 2) & 0x01)
    UINT64 Reserved1                                               : 5;
     *
     * [Bits 14:8] When set, each bit in the field represents an enable control for a corresponding SENTER function. This field
     * is supported only if CPUID.1:ECX.[bit 6] is set.
     *
    UINT64 SenterLocalFunctionEnables                              : 7;
#define IA32_FEATURE_CONTROL_SENTER_LOCAL_FUNCTION_ENABLES_BIT       8
#define IA32_FEATURE_CONTROL_SENTER_LOCAL_FUNCTION_ENABLES_FLAG      0x7F00
#define IA32_FEATURE_CONTROL_SENTER_LOCAL_FUNCTION_ENABLES_MASK      0x7F
#define IA32_FEATURE_CONTROL_SENTER_LOCAL_FUNCTION_ENABLES(_)        (((_) >> 8) & 0x7F)
     *
     * [Bit 15] This bit must be set to enable SENTER leaf functions. This bit is supported only if CPUID.1:ECX.[bit 6] is set.
     *
    UINT64 SenterGlobalEnable                                      : 1;
#define IA32_FEATURE_CONTROL_SENTER_GLOBAL_ENABLE_BIT                15
#define IA32_FEATURE_CONTROL_SENTER_GLOBAL_ENABLE_FLAG               0x8000
#define IA32_FEATURE_CONTROL_SENTER_GLOBAL_ENABLE_MASK               0x01
#define IA32_FEATURE_CONTROL_SENTER_GLOBAL_ENABLE(_)                 (((_) >> 15) & 0x01)
    UINT64 Reserved2                                               : 1;
     *
     * [Bit 17] This bit must be set to enable runtime reconfiguration of SGX Launch Control via the IA32_SGXLEPUBKEYHASHn MSR.
     *
    UINT64 SgxLaunchControlEnable                                  : 1;
#define IA32_FEATURE_CONTROL_SGX_LAUNCH_CONTROL_ENABLE_BIT           17
#define IA32_FEATURE_CONTROL_SGX_LAUNCH_CONTROL_ENABLE_FLAG          0x20000
#define IA32_FEATURE_CONTROL_SGX_LAUNCH_CONTROL_ENABLE_MASK          0x01
#define IA32_FEATURE_CONTROL_SGX_LAUNCH_CONTROL_ENABLE(_)            (((_) >> 17) & 0x01)
     *
     * [Bit 18] This bit must be set to enable SGX leaf functions.
     *
    UINT64 SgxGlobalEnable                                         : 1;
#define IA32_FEATURE_CONTROL_SGX_GLOBAL_ENABLE_BIT                   18
#define IA32_FEATURE_CONTROL_SGX_GLOBAL_ENABLE_FLAG                  0x40000
#define IA32_FEATURE_CONTROL_SGX_GLOBAL_ENABLE_MASK                  0x01
#define IA32_FEATURE_CONTROL_SGX_GLOBAL_ENABLE(_)                    (((_) >> 18) & 0x01)
    UINT64 Reserved3                                               : 1;
     *
     * [Bit 20] When set, system software can program the MSRs associated with LMCE to configure delivery of some machine check
     * exceptions to a single logical processor.
     *
    UINT64 LmceOn                                                  : 1;
#define IA32_FEATURE_CONTROL_LMCE_ON_BIT                             20
#define IA32_FEATURE_CONTROL_LMCE_ON_FLAG                            0x100000
#define IA32_FEATURE_CONTROL_LMCE_ON_MASK                            0x01
#define IA32_FEATURE_CONTROL_LMCE_ON(_)                              (((_) >> 20) & 0x01)
    UINT64 Reserved4                                               : 43;
  };
  UINT64 AsUInt;
} IA32_FEATURE_CONTROL_REGISTER;*/
return true
}

func (i *ia32)     * [Bit 0] IBRS: Indirect Branch Restricted Speculation ()(ok bool){//col:7239
/*     * [Bit 0] IBRS: Indirect Branch Restricted Speculation (IBRS). Restricts speculation of indirect branch.
     *
    UINT64 Ibrs                                                    : 1;
#define IA32_SPEC_CTRL_IBRS_BIT                                      0
#define IA32_SPEC_CTRL_IBRS_FLAG                                     0x01
#define IA32_SPEC_CTRL_IBRS_MASK                                     0x01
#define IA32_SPEC_CTRL_IBRS(_)                                       (((_) >> 0) & 0x01)
     * [Bit 1] STIBP: Single Thread Indirect Branch Predictors (STIBP). Prevents indirect branch predictions on all logical
     * processors on the core from being controlled by any sibling logical processor in the same core.
     *
    UINT64 Stibp                                                   : 1;
#define IA32_SPEC_CTRL_STIBP_BIT                                     1
#define IA32_SPEC_CTRL_STIBP_FLAG                                    0x02
#define IA32_SPEC_CTRL_STIBP_MASK                                    0x01
#define IA32_SPEC_CTRL_STIBP(_)                                      (((_) >> 1) & 0x01)
     * [Bit 2] SSBD: Speculative Store Bypass Disable (SSBD). Delays speculative execution of a load until the addresses for
     * all older stores are known.
     *
    UINT64 Ssbd                                                    : 1;
#define IA32_SPEC_CTRL_SSBD_BIT                                      2
#define IA32_SPEC_CTRL_SSBD_FLAG                                     0x04
#define IA32_SPEC_CTRL_SSBD_MASK                                     0x01
#define IA32_SPEC_CTRL_SSBD(_)                                       (((_) >> 2) & 0x01)
    UINT64 Reserved1                                               : 61;
  };
  UINT64 AsUInt;
} IA32_SPEC_CTRL_REGISTER;*/
return true
}

func (i *ia32)     * [Bit 0] IBPB: Indirect Branch Prediction Barrier ()(ok bool){//col:7266
/*     * [Bit 0] IBPB: Indirect Branch Prediction Barrier (IBPB).
     *
    UINT64 Ibpb                                                    : 1;
#define IA32_PRED_CMD_IBPB_BIT                                       0
#define IA32_PRED_CMD_IBPB_FLAG                                      0x01
#define IA32_PRED_CMD_IBPB_MASK                                      0x01
#define IA32_PRED_CMD_IBPB(_)                                        (((_) >> 0) & 0x01)
    UINT64 Reserved1                                               : 63;
  };
  UINT64 AsUInt;
} IA32_PRED_CMD_REGISTER;*/
return true
}

func (i *ia32)#define IA32_BIOS_UPDATE_SIGNATURE_RESERVED()(ok bool){//col:7320
/*#define IA32_BIOS_UPDATE_SIGNATURE_RESERVED(_)                       (((_) >> 0) & 0xFFFFFFFF)
     *
     * [Bits 63:32] This field contains the signature of the currently loaded microcode update when read following the
     * execution of the CPUID instruction, function 1. It is required that this register field be pre-loaded with zero prior to
     * executing the CPUID, function 1. If the field remains equal to zero, then there is no microcode update loaded. Another
     * nonzero value will be the signature.
     *
    UINT64 MicrocodeUpdateSignature                                : 32;
#define IA32_BIOS_UPDATE_SIGNATURE_MICROCODE_UPDATE_SIGNATURE_BIT    32
#define IA32_BIOS_UPDATE_SIGNATURE_MICROCODE_UPDATE_SIGNATURE_FLAG   0xFFFFFFFF00000000
#define IA32_BIOS_UPDATE_SIGNATURE_MICROCODE_UPDATE_SIGNATURE_MASK   0xFFFFFFFF
#define IA32_BIOS_UPDATE_SIGNATURE_MICROCODE_UPDATE_SIGNATURE(_)     (((_) >> 32) & 0xFFFFFFFF)
  };
  UINT64 AsUInt;
} IA32_BIOS_UPDATE_SIGNATURE_REGISTER;*/
return true
}

func (i *ia32) *           IA32_SGXLEPUBKEYHASH[()(ok bool){//col:7402
/* *           IA32_SGXLEPUBKEYHASH[(64*n+63):(64*n)]
 *
 * Bits (64*n+63):(64*n) of the SHA256 digest of the SIGSTRUCT.MODULUS for SGX Launch Enclave. On reset, the default value
 * is the digest of Intel's signing key.
 *
 *          CPUID.(EAX=12H,ECX=0H): EAX[0]=1 && IA32_FEATURE_CONTROL[17] = 1 && IA32_FEATURE_CONTROL[0] = 1.
#define IA32_SGXLEPUBKEYHASH0                                        0x0000008C
#define IA32_SGXLEPUBKEYHASH1                                        0x0000008D
#define IA32_SGXLEPUBKEYHASH2                                        0x0000008E
#define IA32_SGXLEPUBKEYHASH3                                        0x0000008F
 * SMM Monitor Configuration.
 *
#define IA32_SMM_MONITOR_CTL                                         0x0000009B
typedef union
{
  struct
  {
     *
     * [Bit 0] The STM may be invoked using VMCALL only if this bit is 1. Because VMCALL is used to activate the dual-monitor
     * treatment, the dual-monitor treatment cannot be activated if the bit is 0. This bit is cleared when the logical
     * processor is reset.
     *
    UINT64 Valid                                                   : 1;
#define IA32_SMM_MONITOR_CTL_VALID_BIT                               0
#define IA32_SMM_MONITOR_CTL_VALID_FLAG                              0x01
#define IA32_SMM_MONITOR_CTL_VALID_MASK                              0x01
#define IA32_SMM_MONITOR_CTL_VALID(_)                                (((_) >> 0) & 0x01)
    UINT64 Reserved1                                               : 1;
     *
     * [Bit 2] Determines whether executions of VMXOFF unblock SMIs under the default treatment of SMIs and SMM. Executions of
     * VMXOFF unblock SMIs unless bit 2 is 1 (the value of bit 0 is irrelevant).
     *
    UINT64 SmiUnblockingByVmxoff                                   : 1;
#define IA32_SMM_MONITOR_CTL_SMI_UNBLOCKING_BY_VMXOFF_BIT            2
#define IA32_SMM_MONITOR_CTL_SMI_UNBLOCKING_BY_VMXOFF_FLAG           0x04
#define IA32_SMM_MONITOR_CTL_SMI_UNBLOCKING_BY_VMXOFF_MASK           0x01
#define IA32_SMM_MONITOR_CTL_SMI_UNBLOCKING_BY_VMXOFF(_)             (((_) >> 2) & 0x01)
    UINT64 Reserved2                                               : 9;
     *
     * [Bits 31:12] Value that, when shifted left 12 bits, is the physical address of MSEG (the MSEG base address).
     *
    UINT64 MsegBase                                                : 20;
#define IA32_SMM_MONITOR_CTL_MSEG_BASE_BIT                           12
#define IA32_SMM_MONITOR_CTL_MSEG_BASE_FLAG                          0xFFFFF000
#define IA32_SMM_MONITOR_CTL_MSEG_BASE_MASK                          0xFFFFF
#define IA32_SMM_MONITOR_CTL_MSEG_BASE(_)                            (((_) >> 12) & 0xFFFFF)
    UINT64 Reserved3                                               : 32;
  };
  UINT64 AsUInt;
} IA32_SMM_MONITOR_CTL_REGISTER;*/
return true
}

func (i *ia32) *           IA32_PMC()(ok bool){//col:7490
/* *           IA32_PMC(n)
 *
 * General Performance Counters.
 *
#define IA32_PMC0                                                    0x000000C1
#define IA32_PMC1                                                    0x000000C2
#define IA32_PMC2                                                    0x000000C3
#define IA32_PMC3                                                    0x000000C4
#define IA32_PMC4                                                    0x000000C5
#define IA32_PMC5                                                    0x000000C6
#define IA32_PMC6                                                    0x000000C7
#define IA32_PMC7                                                    0x000000C8
 * TSC Frequency Clock Counter.
 *
#define IA32_MPERF                                                   0x000000E7
typedef struct
{
   *
   * Increments at fixed interval (relative to TSC freq.) when the logical processor is in C0. Cleared upon overflow /
   * wrap-around of IA32_APERF.
  UINT64 C0Mcnt;
} IA32_MPERF_REGISTER;*/
return true
}

func (i *ia32)#define IA32_MTRR_CAPABILITIES_VARIABLE_RANGE_COUNT()(ok bool){//col:7572
/*#define IA32_MTRR_CAPABILITIES_VARIABLE_RANGE_COUNT(_)               (((_) >> 0) & 0xFF)
     *
     * [Bit 8] Fixed range MTRRs (IA32_MTRR_FIX64K_00000 through IA32_MTRR_FIX4K_0F8000) are supported when set; no fixed range
     * registers are supported when clear.
    UINT64 FixedRangeSupported                                     : 1;
#define IA32_MTRR_CAPABILITIES_FIXED_RANGE_SUPPORTED_BIT             8
#define IA32_MTRR_CAPABILITIES_FIXED_RANGE_SUPPORTED_FLAG            0x100
#define IA32_MTRR_CAPABILITIES_FIXED_RANGE_SUPPORTED_MASK            0x01
#define IA32_MTRR_CAPABILITIES_FIXED_RANGE_SUPPORTED(_)              (((_) >> 8) & 0x01)
    UINT64 Reserved1                                               : 1;
     *
     * [Bit 10] The write-combining (WC) memory type is supported when set; the WC type is not supported when clear.
    UINT64 WcSupported                                             : 1;
#define IA32_MTRR_CAPABILITIES_WC_SUPPORTED_BIT                      10
#define IA32_MTRR_CAPABILITIES_WC_SUPPORTED_FLAG                     0x400
#define IA32_MTRR_CAPABILITIES_WC_SUPPORTED_MASK                     0x01
#define IA32_MTRR_CAPABILITIES_WC_SUPPORTED(_)                       (((_) >> 10) & 0x01)
     *
     * [Bit 11] The system-management range register (SMRR) interface is supported when bit 11 is set; the SMRR interface is
     * not supported when clear.
    UINT64 SmrrSupported                                           : 1;
#define IA32_MTRR_CAPABILITIES_SMRR_SUPPORTED_BIT                    11
#define IA32_MTRR_CAPABILITIES_SMRR_SUPPORTED_FLAG                   0x800
#define IA32_MTRR_CAPABILITIES_SMRR_SUPPORTED_MASK                   0x01
#define IA32_MTRR_CAPABILITIES_SMRR_SUPPORTED(_)                     (((_) >> 11) & 0x01)
    UINT64 Reserved2                                               : 52;
  };
  UINT64 AsUInt;
} IA32_MTRR_CAPABILITIES_REGISTER;*/
return true
}

func (i *ia32)     * [Bit 0] RDCL_NO: The processor is not susceptible to Rogue Data Cache Load ()(ok bool){//col:7671
/*     * [Bit 0] RDCL_NO: The processor is not susceptible to Rogue Data Cache Load (RDCL).
    UINT64 RdclNo                                                  : 1;
#define IA32_ARCH_CAPABILITIES_RDCL_NO_BIT                           0
#define IA32_ARCH_CAPABILITIES_RDCL_NO_FLAG                          0x01
#define IA32_ARCH_CAPABILITIES_RDCL_NO_MASK                          0x01
#define IA32_ARCH_CAPABILITIES_RDCL_NO(_)                            (((_) >> 0) & 0x01)
     * [Bit 1] IBRS_ALL: The processor supports enhanced IBRS.
    UINT64 IbrsAll                                                 : 1;
#define IA32_ARCH_CAPABILITIES_IBRS_ALL_BIT                          1
#define IA32_ARCH_CAPABILITIES_IBRS_ALL_FLAG                         0x02
#define IA32_ARCH_CAPABILITIES_IBRS_ALL_MASK                         0x01
#define IA32_ARCH_CAPABILITIES_IBRS_ALL(_)                           (((_) >> 1) & 0x01)
     * [Bit 2] RSBA: The processor supports RSB Alternate. Alternative branch predictors may be used by RET instructions when
     * the RSB is empty. SW using retpoline may be affected by this behavior.
    UINT64 Rsba                                                    : 1;
#define IA32_ARCH_CAPABILITIES_RSBA_BIT                              2
#define IA32_ARCH_CAPABILITIES_RSBA_FLAG                             0x04
#define IA32_ARCH_CAPABILITIES_RSBA_MASK                             0x01
#define IA32_ARCH_CAPABILITIES_RSBA(_)                               (((_) >> 2) & 0x01)
     * [Bit 3] SKIP_L1DFL_VMENTRY: A value of 1 indicates the hypervisor need not flush the L1D on VM entry.
    UINT64 SkipL1DflVmentry                                        : 1;
#define IA32_ARCH_CAPABILITIES_SKIP_L1DFL_VMENTRY_BIT                3
#define IA32_ARCH_CAPABILITIES_SKIP_L1DFL_VMENTRY_FLAG               0x08
#define IA32_ARCH_CAPABILITIES_SKIP_L1DFL_VMENTRY_MASK               0x01
#define IA32_ARCH_CAPABILITIES_SKIP_L1DFL_VMENTRY(_)                 (((_) >> 3) & 0x01)
     * [Bit 4] SSB_NO: Processor is not susceptible to Speculative Store Bypass.
    UINT64 SsbNo                                                   : 1;
#define IA32_ARCH_CAPABILITIES_SSB_NO_BIT                            4
#define IA32_ARCH_CAPABILITIES_SSB_NO_FLAG                           0x10
#define IA32_ARCH_CAPABILITIES_SSB_NO_MASK                           0x01
#define IA32_ARCH_CAPABILITIES_SSB_NO(_)                             (((_) >> 4) & 0x01)
     * [Bit 5] MDS_NO: Processor is not susceptible to Microarchitectural Data Sampling (MDS).
    UINT64 MdsNo                                                   : 1;
#define IA32_ARCH_CAPABILITIES_MDS_NO_BIT                            5
#define IA32_ARCH_CAPABILITIES_MDS_NO_FLAG                           0x20
#define IA32_ARCH_CAPABILITIES_MDS_NO_MASK                           0x01
#define IA32_ARCH_CAPABILITIES_MDS_NO(_)                             (((_) >> 5) & 0x01)
     * [Bit 6] IF_PSCHANGE_MC_NO: The processor is not susceptible to a machine check error due to modifying the size of a code
     * page without TLB invalidation.
    UINT64 IfPschangeMcNo                                          : 1;
#define IA32_ARCH_CAPABILITIES_IF_PSCHANGE_MC_NO_BIT                 6
#define IA32_ARCH_CAPABILITIES_IF_PSCHANGE_MC_NO_FLAG                0x40
#define IA32_ARCH_CAPABILITIES_IF_PSCHANGE_MC_NO_MASK                0x01
#define IA32_ARCH_CAPABILITIES_IF_PSCHANGE_MC_NO(_)                  (((_) >> 6) & 0x01)
     * [Bit 7] TSX_CTRL: If 1, indicates presence of IA32_TSX_CTRL MSR.
    UINT64 TsxCtrl                                                 : 1;
#define IA32_ARCH_CAPABILITIES_TSX_CTRL_BIT                          7
#define IA32_ARCH_CAPABILITIES_TSX_CTRL_FLAG                         0x80
#define IA32_ARCH_CAPABILITIES_TSX_CTRL_MASK                         0x01
#define IA32_ARCH_CAPABILITIES_TSX_CTRL(_)                           (((_) >> 7) & 0x01)
     * [Bit 8] TAA_NO: If 1, processor is not affected by TAA.
    UINT64 TaaNo                                                   : 1;
#define IA32_ARCH_CAPABILITIES_TAA_NO_BIT                            8
#define IA32_ARCH_CAPABILITIES_TAA_NO_FLAG                           0x100
#define IA32_ARCH_CAPABILITIES_TAA_NO_MASK                           0x01
#define IA32_ARCH_CAPABILITIES_TAA_NO(_)                             (((_) >> 8) & 0x01)
    UINT64 Reserved1                                               : 55;
  };
  UINT64 AsUInt;
} IA32_ARCH_CAPABILITIES_REGISTER;*/
return true
}

func (i *ia32)#define IA32_FLUSH_CMD_L1D_FLUSH()(ok bool){//col:7698
/*#define IA32_FLUSH_CMD_L1D_FLUSH(_)                                  (((_) >> 0) & 0x01)
    UINT64 Reserved1                                               : 63;
  };
  UINT64 AsUInt;
} IA32_FLUSH_CMD_REGISTER;*/
return true
}

func (i *ia32) *          Available when CPUID.ARCH_CAP()(ok bool){//col:7734
/* *          Available when CPUID.ARCH_CAP(EAX=7H,ECX = 0):EDX[29] = 1 and IA32_ARCH_CAPABILITIES.bit 7 = 1.
#define IA32_TSX_CTRL                                                0x00000122
typedef union
{
  struct
  {
     * [Bit 0] RTM_DISABLE: When set to 1, XBEGIN will always abort with EAX code 0.
    UINT64 RtmDisable                                              : 1;
#define IA32_TSX_CTRL_RTM_DISABLE_BIT                                0
#define IA32_TSX_CTRL_RTM_DISABLE_FLAG                               0x01
#define IA32_TSX_CTRL_RTM_DISABLE_MASK                               0x01
#define IA32_TSX_CTRL_RTM_DISABLE(_)                                 (((_) >> 0) & 0x01)
     * [Bit 1] TSX_CPUID_CLEAR: When set to 1, CPUID.07H.EBX.RTM [bit 11] and CPUID.07H.EBX.HLE [bit 4] report 0. When set to 0
     * and the SKU supports TSX, these bits will return 1.
    UINT64 TsxCpuidClear                                           : 1;
#define IA32_TSX_CTRL_TSX_CPUID_CLEAR_BIT                            1
#define IA32_TSX_CTRL_TSX_CPUID_CLEAR_FLAG                           0x02
#define IA32_TSX_CTRL_TSX_CPUID_CLEAR_MASK                           0x01
#define IA32_TSX_CTRL_TSX_CPUID_CLEAR(_)                             (((_) >> 1) & 0x01)
    UINT64 Reserved1                                               : 62;
  };
  UINT64 AsUInt;
} IA32_TSX_CTRL_REGISTER;*/
return true
}

func (i *ia32)#define IA32_SYSENTER_CS_CS_SELECTOR()(ok bool){//col:7784
/*#define IA32_SYSENTER_CS_CS_SELECTOR(_)                              (((_) >> 0) & 0xFFFF)
     * [Bits 31:16] Not used.
     *
    UINT64 NotUsed1                                                : 16;
#define IA32_SYSENTER_CS_NOT_USED_1_BIT                              16
#define IA32_SYSENTER_CS_NOT_USED_1_FLAG                             0xFFFF0000
#define IA32_SYSENTER_CS_NOT_USED_1_MASK                             0xFFFF
#define IA32_SYSENTER_CS_NOT_USED_1(_)                               (((_) >> 16) & 0xFFFF)
     * [Bits 63:32] Not used.
     *
    UINT64 NotUsed2                                                : 32;
#define IA32_SYSENTER_CS_NOT_USED_2_BIT                              32
#define IA32_SYSENTER_CS_NOT_USED_2_FLAG                             0xFFFFFFFF00000000
#define IA32_SYSENTER_CS_NOT_USED_2_MASK                             0xFFFFFFFF
#define IA32_SYSENTER_CS_NOT_USED_2(_)                               (((_) >> 32) & 0xFFFFFFFF)
  };
  UINT64 AsUInt;
} IA32_SYSENTER_CS_REGISTER;*/
return true
}

func (i *ia32) * The value of this MSR is loaded into RSP ()(ok bool){//col:7914
/* * The value of this MSR is loaded into RSP (thus, this value contains the stack pointer for the privilege level 0 stack).
 * This value cannot represent a non-canonical address. In protected mode, only bits 31:0 are loaded.
 *
#define IA32_SYSENTER_ESP                                            0x00000175
 *
 * The value of this MSR is loaded into RIP (thus, this value references the first instruction of the selected operating
 * procedure or routine). In protected mode, only bits 31:0 are loaded.
 *
#define IA32_SYSENTER_EIP                                            0x00000176
 * Global Machine Check Capability.
 *
#define IA32_MCG_CAP                                                 0x00000179
typedef union
{
  struct
  {
     * [Bits 7:0] Number of reporting banks.
    UINT64 Count                                                   : 8;
#define IA32_MCG_CAP_COUNT_BIT                                       0
#define IA32_MCG_CAP_COUNT_FLAG                                      0xFF
#define IA32_MCG_CAP_COUNT_MASK                                      0xFF
#define IA32_MCG_CAP_COUNT(_)                                        (((_) >> 0) & 0xFF)
     * [Bit 8] IA32_MCG_CTL is present if this bit is set.
    UINT64 McgCtlP                                                 : 1;
#define IA32_MCG_CAP_MCG_CTL_P_BIT                                   8
#define IA32_MCG_CAP_MCG_CTL_P_FLAG                                  0x100
#define IA32_MCG_CAP_MCG_CTL_P_MASK                                  0x01
#define IA32_MCG_CAP_MCG_CTL_P(_)                                    (((_) >> 8) & 0x01)
     * [Bit 9] Extended machine check state registers are present if this bit is set.
    UINT64 McgExtP                                                 : 1;
#define IA32_MCG_CAP_MCG_EXT_P_BIT                                   9
#define IA32_MCG_CAP_MCG_EXT_P_FLAG                                  0x200
#define IA32_MCG_CAP_MCG_EXT_P_MASK                                  0x01
#define IA32_MCG_CAP_MCG_EXT_P(_)                                    (((_) >> 9) & 0x01)
     * [Bit 10] Support for corrected MC error event is present.
     *
    UINT64 McpCmciP                                                : 1;
#define IA32_MCG_CAP_MCP_CMCI_P_BIT                                  10
#define IA32_MCG_CAP_MCP_CMCI_P_FLAG                                 0x400
#define IA32_MCG_CAP_MCP_CMCI_P_MASK                                 0x01
#define IA32_MCG_CAP_MCP_CMCI_P(_)                                   (((_) >> 10) & 0x01)
     * [Bit 11] Threshold-based error status register are present if this bit is set.
    UINT64 McgTesP                                                 : 1;
#define IA32_MCG_CAP_MCG_TES_P_BIT                                   11
#define IA32_MCG_CAP_MCG_TES_P_FLAG                                  0x800
#define IA32_MCG_CAP_MCG_TES_P_MASK                                  0x01
#define IA32_MCG_CAP_MCG_TES_P(_)                                    (((_) >> 11) & 0x01)
    UINT64 Reserved1                                               : 4;
     * [Bits 23:16] Number of extended machine check state registers present.
    UINT64 McgExtCnt                                               : 8;
#define IA32_MCG_CAP_MCG_EXT_CNT_BIT                                 16
#define IA32_MCG_CAP_MCG_EXT_CNT_FLAG                                0xFF0000
#define IA32_MCG_CAP_MCG_EXT_CNT_MASK                                0xFF
#define IA32_MCG_CAP_MCG_EXT_CNT(_)                                  (((_) >> 16) & 0xFF)
     * [Bit 24] The processor supports software error recovery if this bit is set.
    UINT64 McgSerP                                                 : 1;
#define IA32_MCG_CAP_MCG_SER_P_BIT                                   24
#define IA32_MCG_CAP_MCG_SER_P_FLAG                                  0x1000000
#define IA32_MCG_CAP_MCG_SER_P_MASK                                  0x01
#define IA32_MCG_CAP_MCG_SER_P(_)                                    (((_) >> 24) & 0x01)
    UINT64 Reserved2                                               : 1;
     * [Bit 26] Indicates that the processor allows platform firmware to be invoked when an error is detected so that it may
     * provide additional platform specific information in an ACPI format "Generic Error Data Entry" that augments the data
     * included in machine check bank registers.
     *
    UINT64 McgElogP                                                : 1;
#define IA32_MCG_CAP_MCG_ELOG_P_BIT                                  26
#define IA32_MCG_CAP_MCG_ELOG_P_FLAG                                 0x4000000
#define IA32_MCG_CAP_MCG_ELOG_P_MASK                                 0x01
#define IA32_MCG_CAP_MCG_ELOG_P(_)                                   (((_) >> 26) & 0x01)
     * [Bit 27] Indicates that the processor supports extended state in IA32_MCG_STATUS and associated MSR necessary to
     * configure Local Machine Check Exception (LMCE).
     *
    UINT64 McgLmceP                                                : 1;
#define IA32_MCG_CAP_MCG_LMCE_P_BIT                                  27
#define IA32_MCG_CAP_MCG_LMCE_P_FLAG                                 0x8000000
#define IA32_MCG_CAP_MCG_LMCE_P_MASK                                 0x01
#define IA32_MCG_CAP_MCG_LMCE_P(_)                                   (((_) >> 27) & 0x01)
    UINT64 Reserved3                                               : 36;
  };
  UINT64 AsUInt;
} IA32_MCG_CAP_REGISTER;*/
return true
}

func (i *ia32)#define IA32_MCG_STATUS_RIPV()(ok bool){//col:7972
/*#define IA32_MCG_STATUS_RIPV(_)                                      (((_) >> 0) & 0x01)
     * [Bit 1] Error IP valid.
     *
    UINT64 Eipv                                                    : 1;
#define IA32_MCG_STATUS_EIPV_BIT                                     1
#define IA32_MCG_STATUS_EIPV_FLAG                                    0x02
#define IA32_MCG_STATUS_EIPV_MASK                                    0x01
#define IA32_MCG_STATUS_EIPV(_)                                      (((_) >> 1) & 0x01)
     * [Bit 2] Machine check in progress.
     *
    UINT64 Mcip                                                    : 1;
#define IA32_MCG_STATUS_MCIP_BIT                                     2
#define IA32_MCG_STATUS_MCIP_FLAG                                    0x04
#define IA32_MCG_STATUS_MCIP_MASK                                    0x01
#define IA32_MCG_STATUS_MCIP(_)                                      (((_) >> 2) & 0x01)
     * [Bit 3] If IA32_MCG_CAP.LMCE_P[27] = 1.
    UINT64 LmceS                                                   : 1;
#define IA32_MCG_STATUS_LMCE_S_BIT                                   3
#define IA32_MCG_STATUS_LMCE_S_FLAG                                  0x08
#define IA32_MCG_STATUS_LMCE_S_MASK                                  0x01
#define IA32_MCG_STATUS_LMCE_S(_)                                    (((_) >> 3) & 0x01)
    UINT64 Reserved1                                               : 60;
  };
  UINT64 AsUInt;
} IA32_MCG_STATUS_REGISTER;*/
return true
}

func (i *ia32) *           IA32_PERFEVTSEL()(ok bool){//col:8103
/* *           IA32_PERFEVTSEL(n)
 *
 * Performance Event Select Register n.
 *
#define IA32_PERFEVTSEL0                                             0x00000186
#define IA32_PERFEVTSEL1                                             0x00000187
#define IA32_PERFEVTSEL2                                             0x00000188
#define IA32_PERFEVTSEL3                                             0x00000189
typedef union
{
  struct
  {
     * [Bits 7:0] Selects a performance event logic unit.
    UINT64 EventSelect                                             : 8;
#define IA32_PERFEVTSEL_EVENT_SELECT_BIT                             0
#define IA32_PERFEVTSEL_EVENT_SELECT_FLAG                            0xFF
#define IA32_PERFEVTSEL_EVENT_SELECT_MASK                            0xFF
#define IA32_PERFEVTSEL_EVENT_SELECT(_)                              (((_) >> 0) & 0xFF)
     * [Bits 15:8] Qualifies the microarchitectural condition to detect on the selected event logic.
    UINT64 UMask                                                   : 8;
#define IA32_PERFEVTSEL_U_MASK_BIT                                   8
#define IA32_PERFEVTSEL_U_MASK_FLAG                                  0xFF00
#define IA32_PERFEVTSEL_U_MASK_MASK                                  0xFF
#define IA32_PERFEVTSEL_U_MASK(_)                                    (((_) >> 8) & 0xFF)
     * [Bit 16] Counts while in privilege level is not ring 0.
    UINT64 Usr                                                     : 1;
#define IA32_PERFEVTSEL_USR_BIT                                      16
#define IA32_PERFEVTSEL_USR_FLAG                                     0x10000
#define IA32_PERFEVTSEL_USR_MASK                                     0x01
#define IA32_PERFEVTSEL_USR(_)                                       (((_) >> 16) & 0x01)
     * [Bit 17] Counts while in privilege level is ring 0.
    UINT64 Os                                                      : 1;
#define IA32_PERFEVTSEL_OS_BIT                                       17
#define IA32_PERFEVTSEL_OS_FLAG                                      0x20000
#define IA32_PERFEVTSEL_OS_MASK                                      0x01
#define IA32_PERFEVTSEL_OS(_)                                        (((_) >> 17) & 0x01)
     * [Bit 18] Enables edge detection if set.
    UINT64 Edge                                                    : 1;
#define IA32_PERFEVTSEL_EDGE_BIT                                     18
#define IA32_PERFEVTSEL_EDGE_FLAG                                    0x40000
#define IA32_PERFEVTSEL_EDGE_MASK                                    0x01
#define IA32_PERFEVTSEL_EDGE(_)                                      (((_) >> 18) & 0x01)
     * [Bit 19] Enables pin control.
    UINT64 Pc                                                      : 1;
#define IA32_PERFEVTSEL_PC_BIT                                       19
#define IA32_PERFEVTSEL_PC_FLAG                                      0x80000
#define IA32_PERFEVTSEL_PC_MASK                                      0x01
#define IA32_PERFEVTSEL_PC(_)                                        (((_) >> 19) & 0x01)
     * [Bit 20] Enables interrupt on counter overflow.
    UINT64 Intr                                                    : 1;
#define IA32_PERFEVTSEL_INTR_BIT                                     20
#define IA32_PERFEVTSEL_INTR_FLAG                                    0x100000
#define IA32_PERFEVTSEL_INTR_MASK                                    0x01
#define IA32_PERFEVTSEL_INTR(_)                                      (((_) >> 20) & 0x01)
     * [Bit 21] When set to 1, it enables counting the associated event conditions occurring across all logical processors
     * sharing a processor core. When set to 0, the counter only increments the associated event conditions occurring in the
     * logical processor which programmed the MSR.
    UINT64 AnyThread                                               : 1;
#define IA32_PERFEVTSEL_ANY_THREAD_BIT                               21
#define IA32_PERFEVTSEL_ANY_THREAD_FLAG                              0x200000
#define IA32_PERFEVTSEL_ANY_THREAD_MASK                              0x01
#define IA32_PERFEVTSEL_ANY_THREAD(_)                                (((_) >> 21) & 0x01)
     * [Bit 22] Enables the corresponding performance counter to commence counting when this bit is set.
    UINT64 En                                                      : 1;
#define IA32_PERFEVTSEL_EN_BIT                                       22
#define IA32_PERFEVTSEL_EN_FLAG                                      0x400000
#define IA32_PERFEVTSEL_EN_MASK                                      0x01
#define IA32_PERFEVTSEL_EN(_)                                        (((_) >> 22) & 0x01)
     * [Bit 23] Invert the CMASK.
    UINT64 Inv                                                     : 1;
#define IA32_PERFEVTSEL_INV_BIT                                      23
#define IA32_PERFEVTSEL_INV_FLAG                                     0x800000
#define IA32_PERFEVTSEL_INV_MASK                                     0x01
#define IA32_PERFEVTSEL_INV(_)                                       (((_) >> 23) & 0x01)
     * [Bits 31:24] When CMASK is not zero, the corresponding performance counter increments each cycle if the event count is
     * greater than or equal to the CMASK.
    UINT64 Cmask                                                   : 8;
#define IA32_PERFEVTSEL_CMASK_BIT                                    24
#define IA32_PERFEVTSEL_CMASK_FLAG                                   0xFF000000
#define IA32_PERFEVTSEL_CMASK_MASK                                   0xFF
#define IA32_PERFEVTSEL_CMASK(_)                                     (((_) >> 24) & 0xFF)
    UINT64 Reserved1                                               : 32;
  };
  UINT64 AsUInt;
} IA32_PERFEVTSEL_REGISTER;*/
return true
}

func (i *ia32)#define IA32_PERF_STATUS_STATE_VALUE()(ok bool){//col:8133
/*#define IA32_PERF_STATUS_STATE_VALUE(_)                              (((_) >> 0) & 0xFFFF)
    UINT64 Reserved1                                               : 48;
  };
  UINT64 AsUInt;
} IA32_PERF_STATUS_REGISTER;*/
return true
}

func (i *ia32) * Performance Control. Software makes a request for a new Performance state ()(ok bool){//col:8173
/* * Performance Control. Software makes a request for a new Performance state (P-State) by writing this MSR.
 *
#define IA32_PERF_CTL                                                0x00000199
typedef union
{
  struct
  {
     * [Bits 15:0] Target performance State Value.
    UINT64 TargetStateValue                                        : 16;
#define IA32_PERF_CTL_TARGET_STATE_VALUE_BIT                         0
#define IA32_PERF_CTL_TARGET_STATE_VALUE_FLAG                        0xFFFF
#define IA32_PERF_CTL_TARGET_STATE_VALUE_MASK                        0xFFFF
#define IA32_PERF_CTL_TARGET_STATE_VALUE(_)                          (((_) >> 0) & 0xFFFF)
    UINT64 Reserved1                                               : 16;
     * [Bit 32] IDA Engage.
     *
    UINT64 IdaEngage                                               : 1;
#define IA32_PERF_CTL_IDA_ENGAGE_BIT                                 32
#define IA32_PERF_CTL_IDA_ENGAGE_FLAG                                0x100000000
#define IA32_PERF_CTL_IDA_ENGAGE_MASK                                0x01
#define IA32_PERF_CTL_IDA_ENGAGE(_)                                  (((_) >> 32) & 0x01)
    UINT64 Reserved2                                               : 31;
  };
  UINT64 AsUInt;
} IA32_PERF_CTL_REGISTER;*/
return true
}

func (i *ia32)#define IA32_CLOCK_MODULATION_EXTENDED_ON_DEMAND_CLOCK_MODULATION_DUTY_CYCLE()(ok bool){//col:8227
/*#define IA32_CLOCK_MODULATION_EXTENDED_ON_DEMAND_CLOCK_MODULATION_DUTY_CYCLE(_) (((_) >> 0) & 0x01)
     *
     * [Bits 3:1] On-Demand Clock Modulation Duty Cycle: Specific encoded values for target duty cycle modulation.
     *
    UINT64 OnDemandClockModulationDutyCycle                        : 3;
#define IA32_CLOCK_MODULATION_ON_DEMAND_CLOCK_MODULATION_DUTY_CYCLE_BIT 1
#define IA32_CLOCK_MODULATION_ON_DEMAND_CLOCK_MODULATION_DUTY_CYCLE_FLAG 0x0E
#define IA32_CLOCK_MODULATION_ON_DEMAND_CLOCK_MODULATION_DUTY_CYCLE_MASK 0x07
#define IA32_CLOCK_MODULATION_ON_DEMAND_CLOCK_MODULATION_DUTY_CYCLE(_) (((_) >> 1) & 0x07)
     *
     * [Bit 4] On-Demand Clock Modulation Enable: Set 1 to enable modulation.
     *
    UINT64 OnDemandClockModulationEnable                           : 1;
#define IA32_CLOCK_MODULATION_ON_DEMAND_CLOCK_MODULATION_ENABLE_BIT  4
#define IA32_CLOCK_MODULATION_ON_DEMAND_CLOCK_MODULATION_ENABLE_FLAG 0x10
#define IA32_CLOCK_MODULATION_ON_DEMAND_CLOCK_MODULATION_ENABLE_MASK 0x01
#define IA32_CLOCK_MODULATION_ON_DEMAND_CLOCK_MODULATION_ENABLE(_)   (((_) >> 4) & 0x01)
    UINT64 Reserved1                                               : 59;
  };
  UINT64 AsUInt;
} IA32_CLOCK_MODULATION_REGISTER;*/
return true
}

func (i *ia32)#define IA32_THERM_INTERRUPT_HIGH_TEMPERATURE_INTERRUPT_ENABLE()(ok bool){//col:8358
/*#define IA32_THERM_INTERRUPT_HIGH_TEMPERATURE_INTERRUPT_ENABLE(_)    (((_) >> 0) & 0x01)
     * [Bit 1] Low-Temperature Interrupt Enable.
     *
    UINT64 LowTemperatureInterruptEnable                           : 1;
#define IA32_THERM_INTERRUPT_LOW_TEMPERATURE_INTERRUPT_ENABLE_BIT    1
#define IA32_THERM_INTERRUPT_LOW_TEMPERATURE_INTERRUPT_ENABLE_FLAG   0x02
#define IA32_THERM_INTERRUPT_LOW_TEMPERATURE_INTERRUPT_ENABLE_MASK   0x01
#define IA32_THERM_INTERRUPT_LOW_TEMPERATURE_INTERRUPT_ENABLE(_)     (((_) >> 1) & 0x01)
     * [Bit 2] PROCHOT\# Interrupt Enable.
     *
    UINT64 ProchotInterruptEnable                                  : 1;
#define IA32_THERM_INTERRUPT_PROCHOT_INTERRUPT_ENABLE_BIT            2
#define IA32_THERM_INTERRUPT_PROCHOT_INTERRUPT_ENABLE_FLAG           0x04
#define IA32_THERM_INTERRUPT_PROCHOT_INTERRUPT_ENABLE_MASK           0x01
#define IA32_THERM_INTERRUPT_PROCHOT_INTERRUPT_ENABLE(_)             (((_) >> 2) & 0x01)
     * [Bit 3] FORCEPR\# Interrupt Enable.
     *
    UINT64 ForceprInterruptEnable                                  : 1;
#define IA32_THERM_INTERRUPT_FORCEPR_INTERRUPT_ENABLE_BIT            3
#define IA32_THERM_INTERRUPT_FORCEPR_INTERRUPT_ENABLE_FLAG           0x08
#define IA32_THERM_INTERRUPT_FORCEPR_INTERRUPT_ENABLE_MASK           0x01
#define IA32_THERM_INTERRUPT_FORCEPR_INTERRUPT_ENABLE(_)             (((_) >> 3) & 0x01)
     * [Bit 4] Critical Temperature Interrupt Enable.
     *
    UINT64 CriticalTemperatureInterruptEnable                      : 1;
#define IA32_THERM_INTERRUPT_CRITICAL_TEMPERATURE_INTERRUPT_ENABLE_BIT 4
#define IA32_THERM_INTERRUPT_CRITICAL_TEMPERATURE_INTERRUPT_ENABLE_FLAG 0x10
#define IA32_THERM_INTERRUPT_CRITICAL_TEMPERATURE_INTERRUPT_ENABLE_MASK 0x01
#define IA32_THERM_INTERRUPT_CRITICAL_TEMPERATURE_INTERRUPT_ENABLE(_) (((_) >> 4) & 0x01)
    UINT64 Reserved1                                               : 3;
     * [Bits 14:8] Threshold \#1 Value
     *
    UINT64 Threshold1Value                                         : 7;
#define IA32_THERM_INTERRUPT_THRESHOLD1_VALUE_BIT                    8
#define IA32_THERM_INTERRUPT_THRESHOLD1_VALUE_FLAG                   0x7F00
#define IA32_THERM_INTERRUPT_THRESHOLD1_VALUE_MASK                   0x7F
#define IA32_THERM_INTERRUPT_THRESHOLD1_VALUE(_)                     (((_) >> 8) & 0x7F)
     * [Bit 15] Threshold \#1 Interrupt Enable.
     *
    UINT64 Threshold1InterruptEnable                               : 1;
#define IA32_THERM_INTERRUPT_THRESHOLD1_INTERRUPT_ENABLE_BIT         15
#define IA32_THERM_INTERRUPT_THRESHOLD1_INTERRUPT_ENABLE_FLAG        0x8000
#define IA32_THERM_INTERRUPT_THRESHOLD1_INTERRUPT_ENABLE_MASK        0x01
#define IA32_THERM_INTERRUPT_THRESHOLD1_INTERRUPT_ENABLE(_)          (((_) >> 15) & 0x01)
     * [Bits 22:16] Threshold \#2 Value.
     *
    UINT64 Threshold2Value                                         : 7;
#define IA32_THERM_INTERRUPT_THRESHOLD2_VALUE_BIT                    16
#define IA32_THERM_INTERRUPT_THRESHOLD2_VALUE_FLAG                   0x7F0000
#define IA32_THERM_INTERRUPT_THRESHOLD2_VALUE_MASK                   0x7F
#define IA32_THERM_INTERRUPT_THRESHOLD2_VALUE(_)                     (((_) >> 16) & 0x7F)
     * [Bit 23] Threshold \#2 Interrupt Enable.
     *
    UINT64 Threshold2InterruptEnable                               : 1;
#define IA32_THERM_INTERRUPT_THRESHOLD2_INTERRUPT_ENABLE_BIT         23
#define IA32_THERM_INTERRUPT_THRESHOLD2_INTERRUPT_ENABLE_FLAG        0x800000
#define IA32_THERM_INTERRUPT_THRESHOLD2_INTERRUPT_ENABLE_MASK        0x01
#define IA32_THERM_INTERRUPT_THRESHOLD2_INTERRUPT_ENABLE(_)          (((_) >> 23) & 0x01)
     * [Bit 24] Power Limit Notification Enable.
     *
    UINT64 PowerLimitNotificationEnable                            : 1;
#define IA32_THERM_INTERRUPT_POWER_LIMIT_NOTIFICATION_ENABLE_BIT     24
#define IA32_THERM_INTERRUPT_POWER_LIMIT_NOTIFICATION_ENABLE_FLAG    0x1000000
#define IA32_THERM_INTERRUPT_POWER_LIMIT_NOTIFICATION_ENABLE_MASK    0x01
#define IA32_THERM_INTERRUPT_POWER_LIMIT_NOTIFICATION_ENABLE(_)      (((_) >> 24) & 0x01)
    UINT64 Reserved2                                               : 39;
  };
  UINT64 AsUInt;
} IA32_THERM_INTERRUPT_REGISTER;*/
return true
}

func (i *ia32)#define IA32_THERM_STATUS_THERMAL_STATUS()(ok bool){//col:8588
/*#define IA32_THERM_STATUS_THERMAL_STATUS(_)                          (((_) >> 0) & 0x01)
     * [Bit 1] Thermal Status Log
     *
    UINT64 ThermalStatusLog                                        : 1;
#define IA32_THERM_STATUS_THERMAL_STATUS_LOG_BIT                     1
#define IA32_THERM_STATUS_THERMAL_STATUS_LOG_FLAG                    0x02
#define IA32_THERM_STATUS_THERMAL_STATUS_LOG_MASK                    0x01
#define IA32_THERM_STATUS_THERMAL_STATUS_LOG(_)                      (((_) >> 1) & 0x01)
     * [Bit 2] PROCHOT \# or FORCEPR\# event
     *
    UINT64 ProchotForceprEvent                                     : 1;
#define IA32_THERM_STATUS_PROCHOT_FORCEPR_EVENT_BIT                  2
#define IA32_THERM_STATUS_PROCHOT_FORCEPR_EVENT_FLAG                 0x04
#define IA32_THERM_STATUS_PROCHOT_FORCEPR_EVENT_MASK                 0x01
#define IA32_THERM_STATUS_PROCHOT_FORCEPR_EVENT(_)                   (((_) >> 2) & 0x01)
     * [Bit 3] PROCHOT \# or FORCEPR\# log
     *
    UINT64 ProchotForceprLog                                       : 1;
#define IA32_THERM_STATUS_PROCHOT_FORCEPR_LOG_BIT                    3
#define IA32_THERM_STATUS_PROCHOT_FORCEPR_LOG_FLAG                   0x08
#define IA32_THERM_STATUS_PROCHOT_FORCEPR_LOG_MASK                   0x01
#define IA32_THERM_STATUS_PROCHOT_FORCEPR_LOG(_)                     (((_) >> 3) & 0x01)
     * [Bit 4] Critical Temperature Status
     *
    UINT64 CriticalTemperatureStatus                               : 1;
#define IA32_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_BIT            4
#define IA32_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_FLAG           0x10
#define IA32_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_MASK           0x01
#define IA32_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS(_)             (((_) >> 4) & 0x01)
     * [Bit 5] Critical Temperature Status log
     *
    UINT64 CriticalTemperatureStatusLog                            : 1;
#define IA32_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_LOG_BIT        5
#define IA32_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_LOG_FLAG       0x20
#define IA32_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_LOG_MASK       0x01
#define IA32_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_LOG(_)         (((_) >> 5) & 0x01)
     * [Bit 6] Thermal Threshold \#1 Status
     *
    UINT64 ThermalThreshold1Status                                 : 1;
#define IA32_THERM_STATUS_THERMAL_THRESHOLD1_STATUS_BIT              6
#define IA32_THERM_STATUS_THERMAL_THRESHOLD1_STATUS_FLAG             0x40
#define IA32_THERM_STATUS_THERMAL_THRESHOLD1_STATUS_MASK             0x01
#define IA32_THERM_STATUS_THERMAL_THRESHOLD1_STATUS(_)               (((_) >> 6) & 0x01)
     * [Bit 7] Thermal Threshold \#1 log
     *
    UINT64 ThermalThreshold1Log                                    : 1;
#define IA32_THERM_STATUS_THERMAL_THRESHOLD1_LOG_BIT                 7
#define IA32_THERM_STATUS_THERMAL_THRESHOLD1_LOG_FLAG                0x80
#define IA32_THERM_STATUS_THERMAL_THRESHOLD1_LOG_MASK                0x01
#define IA32_THERM_STATUS_THERMAL_THRESHOLD1_LOG(_)                  (((_) >> 7) & 0x01)
     * [Bit 8] Thermal Threshold \#2 Status
     *
    UINT64 ThermalThreshold2Status                                 : 1;
#define IA32_THERM_STATUS_THERMAL_THRESHOLD2_STATUS_BIT              8
#define IA32_THERM_STATUS_THERMAL_THRESHOLD2_STATUS_FLAG             0x100
#define IA32_THERM_STATUS_THERMAL_THRESHOLD2_STATUS_MASK             0x01
#define IA32_THERM_STATUS_THERMAL_THRESHOLD2_STATUS(_)               (((_) >> 8) & 0x01)
     * [Bit 9] Thermal Threshold \#2 log
     *
    UINT64 ThermalThreshold2Log                                    : 1;
#define IA32_THERM_STATUS_THERMAL_THRESHOLD2_LOG_BIT                 9
#define IA32_THERM_STATUS_THERMAL_THRESHOLD2_LOG_FLAG                0x200
#define IA32_THERM_STATUS_THERMAL_THRESHOLD2_LOG_MASK                0x01
#define IA32_THERM_STATUS_THERMAL_THRESHOLD2_LOG(_)                  (((_) >> 9) & 0x01)
     * [Bit 10] Power Limitation Status
     *
    UINT64 PowerLimitationStatus                                   : 1;
#define IA32_THERM_STATUS_POWER_LIMITATION_STATUS_BIT                10
#define IA32_THERM_STATUS_POWER_LIMITATION_STATUS_FLAG               0x400
#define IA32_THERM_STATUS_POWER_LIMITATION_STATUS_MASK               0x01
#define IA32_THERM_STATUS_POWER_LIMITATION_STATUS(_)                 (((_) >> 10) & 0x01)
     * [Bit 11] Power Limitation log
     *
    UINT64 PowerLimitationLog                                      : 1;
#define IA32_THERM_STATUS_POWER_LIMITATION_LOG_BIT                   11
#define IA32_THERM_STATUS_POWER_LIMITATION_LOG_FLAG                  0x800
#define IA32_THERM_STATUS_POWER_LIMITATION_LOG_MASK                  0x01
#define IA32_THERM_STATUS_POWER_LIMITATION_LOG(_)                    (((_) >> 11) & 0x01)
     * [Bit 12] Current Limit Status
     *
    UINT64 CurrentLimitStatus                                      : 1;
#define IA32_THERM_STATUS_CURRENT_LIMIT_STATUS_BIT                   12
#define IA32_THERM_STATUS_CURRENT_LIMIT_STATUS_FLAG                  0x1000
#define IA32_THERM_STATUS_CURRENT_LIMIT_STATUS_MASK                  0x01
#define IA32_THERM_STATUS_CURRENT_LIMIT_STATUS(_)                    (((_) >> 12) & 0x01)
     * [Bit 13] Current Limit log
     *
    UINT64 CurrentLimitLog                                         : 1;
#define IA32_THERM_STATUS_CURRENT_LIMIT_LOG_BIT                      13
#define IA32_THERM_STATUS_CURRENT_LIMIT_LOG_FLAG                     0x2000
#define IA32_THERM_STATUS_CURRENT_LIMIT_LOG_MASK                     0x01
#define IA32_THERM_STATUS_CURRENT_LIMIT_LOG(_)                       (((_) >> 13) & 0x01)
     * [Bit 14] Cross Domain Limit Status
     *
    UINT64 CrossDomainLimitStatus                                  : 1;
#define IA32_THERM_STATUS_CROSS_DOMAIN_LIMIT_STATUS_BIT              14
#define IA32_THERM_STATUS_CROSS_DOMAIN_LIMIT_STATUS_FLAG             0x4000
#define IA32_THERM_STATUS_CROSS_DOMAIN_LIMIT_STATUS_MASK             0x01
#define IA32_THERM_STATUS_CROSS_DOMAIN_LIMIT_STATUS(_)               (((_) >> 14) & 0x01)
     * [Bit 15] Cross Domain Limit log
     *
    UINT64 CrossDomainLimitLog                                     : 1;
#define IA32_THERM_STATUS_CROSS_DOMAIN_LIMIT_LOG_BIT                 15
#define IA32_THERM_STATUS_CROSS_DOMAIN_LIMIT_LOG_FLAG                0x8000
#define IA32_THERM_STATUS_CROSS_DOMAIN_LIMIT_LOG_MASK                0x01
#define IA32_THERM_STATUS_CROSS_DOMAIN_LIMIT_LOG(_)                  (((_) >> 15) & 0x01)
     * [Bits 22:16] Digital Readout
     *
    UINT64 DigitalReadout                                          : 7;
#define IA32_THERM_STATUS_DIGITAL_READOUT_BIT                        16
#define IA32_THERM_STATUS_DIGITAL_READOUT_FLAG                       0x7F0000
#define IA32_THERM_STATUS_DIGITAL_READOUT_MASK                       0x7F
#define IA32_THERM_STATUS_DIGITAL_READOUT(_)                         (((_) >> 16) & 0x7F)
    UINT64 Reserved1                                               : 4;
     * [Bits 30:27] Resolution in Degrees Celsius
     *
    UINT64 ResolutionInDegreesCelsius                              : 4;
#define IA32_THERM_STATUS_RESOLUTION_IN_DEGREES_CELSIUS_BIT          27
#define IA32_THERM_STATUS_RESOLUTION_IN_DEGREES_CELSIUS_FLAG         0x78000000
#define IA32_THERM_STATUS_RESOLUTION_IN_DEGREES_CELSIUS_MASK         0x0F
#define IA32_THERM_STATUS_RESOLUTION_IN_DEGREES_CELSIUS(_)           (((_) >> 27) & 0x0F)
     * [Bit 31] Reading Valid
     *
    UINT64 ReadingValid                                            : 1;
#define IA32_THERM_STATUS_READING_VALID_BIT                          31
#define IA32_THERM_STATUS_READING_VALID_FLAG                         0x80000000
#define IA32_THERM_STATUS_READING_VALID_MASK                         0x01
#define IA32_THERM_STATUS_READING_VALID(_)                           (((_) >> 31) & 0x01)
    UINT64 Reserved2                                               : 32;
  };
  UINT64 AsUInt;
} IA32_THERM_STATUS_REGISTER;*/
return true
}

func (i *ia32)     * [Bit 0] When set, the fast-strings feature ()(ok bool){//col:8766
/*     * [Bit 0] When set, the fast-strings feature (for REP MOVS and REP STORS) is enabled (default). When clear, fast-strings
     * are disabled.
     *
    UINT64 FastStringsEnable                                       : 1;
#define IA32_MISC_ENABLE_FAST_STRINGS_ENABLE_BIT                     0
#define IA32_MISC_ENABLE_FAST_STRINGS_ENABLE_FLAG                    0x01
#define IA32_MISC_ENABLE_FAST_STRINGS_ENABLE_MASK                    0x01
#define IA32_MISC_ENABLE_FAST_STRINGS_ENABLE(_)                      (((_) >> 0) & 0x01)
    UINT64 Reserved1                                               : 2;
     *
     * [Bit 3] - 1 = Setting this bit enables the thermal control circuit (TCC) portion of the Intel Thermal Monitor feature.
     * This allows the processor to automatically reduce power consumption in response to TCC activation.
     * - 0 = Disabled.
     *
     *       thermal throttling will still be activated. The default value of this field varies with product.
    UINT64 AutomaticThermalControlCircuitEnable                    : 1;
#define IA32_MISC_ENABLE_AUTOMATIC_THERMAL_CONTROL_CIRCUIT_ENABLE_BIT 3
#define IA32_MISC_ENABLE_AUTOMATIC_THERMAL_CONTROL_CIRCUIT_ENABLE_FLAG 0x08
#define IA32_MISC_ENABLE_AUTOMATIC_THERMAL_CONTROL_CIRCUIT_ENABLE_MASK 0x01
#define IA32_MISC_ENABLE_AUTOMATIC_THERMAL_CONTROL_CIRCUIT_ENABLE(_) (((_) >> 3) & 0x01)
    UINT64 Reserved2                                               : 3;
     *
     * [Bit 7] - 1 = Performance monitoring enabled.
     * - 0 = Performance monitoring disabled.
     *
    UINT64 PerformanceMonitoringAvailable                          : 1;
#define IA32_MISC_ENABLE_PERFORMANCE_MONITORING_AVAILABLE_BIT        7
#define IA32_MISC_ENABLE_PERFORMANCE_MONITORING_AVAILABLE_FLAG       0x80
#define IA32_MISC_ENABLE_PERFORMANCE_MONITORING_AVAILABLE_MASK       0x01
#define IA32_MISC_ENABLE_PERFORMANCE_MONITORING_AVAILABLE(_)         (((_) >> 7) & 0x01)
    UINT64 Reserved3                                               : 3;
     *
     * [Bit 11] - 1 = Processor doesn't support branch trace storage (BTS).
     * - 0 = BTS is supported.
     *
    UINT64 BranchTraceStorageUnavailable                           : 1;
#define IA32_MISC_ENABLE_BRANCH_TRACE_STORAGE_UNAVAILABLE_BIT        11
#define IA32_MISC_ENABLE_BRANCH_TRACE_STORAGE_UNAVAILABLE_FLAG       0x800
#define IA32_MISC_ENABLE_BRANCH_TRACE_STORAGE_UNAVAILABLE_MASK       0x01
#define IA32_MISC_ENABLE_BRANCH_TRACE_STORAGE_UNAVAILABLE(_)         (((_) >> 11) & 0x01)
     *
     * [Bit 12] - 1 = PEBS is not supported.
     * - 0 = PEBS is supported.
     *
    UINT64 ProcessorEventBasedSamplingUnavailable                  : 1;
#define IA32_MISC_ENABLE_PROCESSOR_EVENT_BASED_SAMPLING_UNAVAILABLE_BIT 12
#define IA32_MISC_ENABLE_PROCESSOR_EVENT_BASED_SAMPLING_UNAVAILABLE_FLAG 0x1000
#define IA32_MISC_ENABLE_PROCESSOR_EVENT_BASED_SAMPLING_UNAVAILABLE_MASK 0x01
#define IA32_MISC_ENABLE_PROCESSOR_EVENT_BASED_SAMPLING_UNAVAILABLE(_) (((_) >> 12) & 0x01)
    UINT64 Reserved4                                               : 3;
     *
     * [Bit 16] - 0 = Enhanced Intel SpeedStep Technology disabled.
     * - 1 = Enhanced Intel SpeedStep Technology enabled.
     *
    UINT64 EnhancedIntelSpeedstepTechnologyEnable                  : 1;
#define IA32_MISC_ENABLE_ENHANCED_INTEL_SPEEDSTEP_TECHNOLOGY_ENABLE_BIT 16
#define IA32_MISC_ENABLE_ENHANCED_INTEL_SPEEDSTEP_TECHNOLOGY_ENABLE_FLAG 0x10000
#define IA32_MISC_ENABLE_ENHANCED_INTEL_SPEEDSTEP_TECHNOLOGY_ENABLE_MASK 0x01
#define IA32_MISC_ENABLE_ENHANCED_INTEL_SPEEDSTEP_TECHNOLOGY_ENABLE(_) (((_) >> 16) & 0x01)
    UINT64 Reserved5                                               : 1;
     *
     * [Bit 18] When this bit is set to 0, the MONITOR feature flag is not set (CPUID.01H:ECX[bit3] = 0). This indicates that
     * MONITOR/MWAIT are not supported. Software attempts to execute MONITOR/MWAIT will cause \#UD when this bit is 0.
     * When this bit is set to 1 (default), MONITOR/MWAIT are supported (CPUID.01H:ECX[bit 3] = 1). If the SSE3 feature flag
     * ECX[0] is not set (CPUID.01H:ECX[bit 0] = 0), the OS must not attempt to alter this bit. BIOS must leave it in the
     * default state. Writing this bit when the SSE3 feature flag is set to 0 may generate a \#GP exception.
     *
    UINT64 EnableMonitorFsm                                        : 1;
#define IA32_MISC_ENABLE_ENABLE_MONITOR_FSM_BIT                      18
#define IA32_MISC_ENABLE_ENABLE_MONITOR_FSM_FLAG                     0x40000
#define IA32_MISC_ENABLE_ENABLE_MONITOR_FSM_MASK                     0x01
#define IA32_MISC_ENABLE_ENABLE_MONITOR_FSM(_)                       (((_) >> 18) & 0x01)
    UINT64 Reserved6                                               : 3;
     *
     * [Bit 22] When this bit is set to 1, CPUID.00H returns a maximum value in EAX[7:0] of 2. BIOS should contain a setup
     * question that allows users to specify when the installed OS does not support CPUID functions greater than 2.
     * Before setting this bit, BIOS must execute the CPUID.0H and examine the maximum value returned in EAX[7:0]. If the
     * maximum value is greater than 2, this bit is supported.
     * Otherwise, this bit is not supported. Setting this bit when the maximum value is not greater than 2 may generate a \#GP
     * exception. Setting this bit may cause unexpected behavior in software that depends on the availability of CPUID leaves
     * greater than 2.
     *
    UINT64 LimitCpuidMaxval                                        : 1;
#define IA32_MISC_ENABLE_LIMIT_CPUID_MAXVAL_BIT                      22
#define IA32_MISC_ENABLE_LIMIT_CPUID_MAXVAL_FLAG                     0x400000
#define IA32_MISC_ENABLE_LIMIT_CPUID_MAXVAL_MASK                     0x01
#define IA32_MISC_ENABLE_LIMIT_CPUID_MAXVAL(_)                       (((_) >> 22) & 0x01)
     *
     * [Bit 23] When set to 1, xTPR messages are disabled. xTPR messages are optional messages that allow the processor to
     * inform the chipset of its priority.
     *
    UINT64 XtprMessageDisable                                      : 1;
#define IA32_MISC_ENABLE_XTPR_MESSAGE_DISABLE_BIT                    23
#define IA32_MISC_ENABLE_XTPR_MESSAGE_DISABLE_FLAG                   0x800000
#define IA32_MISC_ENABLE_XTPR_MESSAGE_DISABLE_MASK                   0x01
#define IA32_MISC_ENABLE_XTPR_MESSAGE_DISABLE(_)                     (((_) >> 23) & 0x01)
    UINT64 Reserved7                                               : 10;
     *
     * [Bit 34] When set to 1, the Execute Disable Bit feature (XD Bit) is disabled and the XD Bit extended feature flag will
     * be clear (CPUID.80000001H: EDX[20]=0).
     * When set to a 0 (default), the Execute Disable Bit feature (if available) allows the OS to enable PAE paging and take
     * advantage of data only pages.
     * BIOS must not alter the contents of this bit location, if XD bit is not supported. Writing this bit to 1 when the XD Bit
     * extended feature flag is set to 0 may generate a \#GP exception.
     *
    UINT64 XdBitDisable                                            : 1;
#define IA32_MISC_ENABLE_XD_BIT_DISABLE_BIT                          34
#define IA32_MISC_ENABLE_XD_BIT_DISABLE_FLAG                         0x400000000
#define IA32_MISC_ENABLE_XD_BIT_DISABLE_MASK                         0x01
#define IA32_MISC_ENABLE_XD_BIT_DISABLE(_)                           (((_) >> 34) & 0x01)
    UINT64 Reserved8                                               : 29;
  };
  UINT64 AsUInt;
} IA32_MISC_ENABLE_REGISTER;*/
return true
}

func (i *ia32)#define IA32_ENERGY_PERF_BIAS_POWER_POLICY_PREFERENCE()(ok bool){//col:8794
/*#define IA32_ENERGY_PERF_BIAS_POWER_POLICY_PREFERENCE(_)             (((_) >> 0) & 0x0F)
    UINT64 Reserved1                                               : 60;
  };
  UINT64 AsUInt;
} IA32_ENERGY_PERF_BIAS_REGISTER;*/
return true
}

func (i *ia32)#define IA32_PACKAGE_THERM_STATUS_THERMAL_STATUS()(ok bool){//col:8931
/*#define IA32_PACKAGE_THERM_STATUS_THERMAL_STATUS(_)                  (((_) >> 0) & 0x01)
     * [Bit 1] Pkg Thermal Status Log
    UINT64 ThermalStatusLog                                        : 1;
#define IA32_PACKAGE_THERM_STATUS_THERMAL_STATUS_LOG_BIT             1
#define IA32_PACKAGE_THERM_STATUS_THERMAL_STATUS_LOG_FLAG            0x02
#define IA32_PACKAGE_THERM_STATUS_THERMAL_STATUS_LOG_MASK            0x01
#define IA32_PACKAGE_THERM_STATUS_THERMAL_STATUS_LOG(_)              (((_) >> 1) & 0x01)
     * [Bit 2] Pkg PROCHOT \# event
    UINT64 ProchotEvent                                            : 1;
#define IA32_PACKAGE_THERM_STATUS_PROCHOT_EVENT_BIT                  2
#define IA32_PACKAGE_THERM_STATUS_PROCHOT_EVENT_FLAG                 0x04
#define IA32_PACKAGE_THERM_STATUS_PROCHOT_EVENT_MASK                 0x01
#define IA32_PACKAGE_THERM_STATUS_PROCHOT_EVENT(_)                   (((_) >> 2) & 0x01)
     * [Bit 3] Pkg PROCHOT \# log
    UINT64 ProchotLog                                              : 1;
#define IA32_PACKAGE_THERM_STATUS_PROCHOT_LOG_BIT                    3
#define IA32_PACKAGE_THERM_STATUS_PROCHOT_LOG_FLAG                   0x08
#define IA32_PACKAGE_THERM_STATUS_PROCHOT_LOG_MASK                   0x01
#define IA32_PACKAGE_THERM_STATUS_PROCHOT_LOG(_)                     (((_) >> 3) & 0x01)
     * [Bit 4] Pkg Critical Temperature Status
    UINT64 CriticalTemperatureStatus                               : 1;
#define IA32_PACKAGE_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_BIT    4
#define IA32_PACKAGE_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_FLAG   0x10
#define IA32_PACKAGE_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_MASK   0x01
#define IA32_PACKAGE_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS(_)     (((_) >> 4) & 0x01)
     * [Bit 5] Pkg Critical Temperature Status Log
    UINT64 CriticalTemperatureStatusLog                            : 1;
#define IA32_PACKAGE_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_LOG_BIT 5
#define IA32_PACKAGE_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_LOG_FLAG 0x20
#define IA32_PACKAGE_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_LOG_MASK 0x01
#define IA32_PACKAGE_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_LOG(_) (((_) >> 5) & 0x01)
     * [Bit 6] Pkg Thermal Threshold \#1 Status
    UINT64 ThermalThreshold1Status                                 : 1;
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD1_STATUS_BIT      6
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD1_STATUS_FLAG     0x40
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD1_STATUS_MASK     0x01
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD1_STATUS(_)       (((_) >> 6) & 0x01)
     * [Bit 7] Pkg Thermal Threshold \#1 log
    UINT64 ThermalThreshold1Log                                    : 1;
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD1_LOG_BIT         7
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD1_LOG_FLAG        0x80
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD1_LOG_MASK        0x01
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD1_LOG(_)          (((_) >> 7) & 0x01)
     * [Bit 8] Pkg Thermal Threshold \#2 Status
    UINT64 ThermalThreshold2Status                                 : 1;
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD2_STATUS_BIT      8
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD2_STATUS_FLAG     0x100
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD2_STATUS_MASK     0x01
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD2_STATUS(_)       (((_) >> 8) & 0x01)
     * [Bit 9] Pkg Thermal Threshold \#2 log
    UINT64 ThermalThreshold2Log                                    : 1;
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD2_LOG_BIT         9
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD2_LOG_FLAG        0x200
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD2_LOG_MASK        0x01
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD2_LOG(_)          (((_) >> 9) & 0x01)
     * [Bit 10] Pkg Power Limitation Status
    UINT64 PowerLimitationStatus                                   : 1;
#define IA32_PACKAGE_THERM_STATUS_POWER_LIMITATION_STATUS_BIT        10
#define IA32_PACKAGE_THERM_STATUS_POWER_LIMITATION_STATUS_FLAG       0x400
#define IA32_PACKAGE_THERM_STATUS_POWER_LIMITATION_STATUS_MASK       0x01
#define IA32_PACKAGE_THERM_STATUS_POWER_LIMITATION_STATUS(_)         (((_) >> 10) & 0x01)
     * [Bit 11] Pkg Power Limitation log
    UINT64 PowerLimitationLog                                      : 1;
#define IA32_PACKAGE_THERM_STATUS_POWER_LIMITATION_LOG_BIT           11
#define IA32_PACKAGE_THERM_STATUS_POWER_LIMITATION_LOG_FLAG          0x800
#define IA32_PACKAGE_THERM_STATUS_POWER_LIMITATION_LOG_MASK          0x01
#define IA32_PACKAGE_THERM_STATUS_POWER_LIMITATION_LOG(_)            (((_) >> 11) & 0x01)
    UINT64 Reserved1                                               : 4;
     * [Bits 22:16] Pkg Digital Readout
    UINT64 DigitalReadout                                          : 7;
#define IA32_PACKAGE_THERM_STATUS_DIGITAL_READOUT_BIT                16
#define IA32_PACKAGE_THERM_STATUS_DIGITAL_READOUT_FLAG               0x7F0000
#define IA32_PACKAGE_THERM_STATUS_DIGITAL_READOUT_MASK               0x7F
#define IA32_PACKAGE_THERM_STATUS_DIGITAL_READOUT(_)                 (((_) >> 16) & 0x7F)
    UINT64 Reserved2                                               : 41;
  };
  UINT64 AsUInt;
} IA32_PACKAGE_THERM_STATUS_REGISTER;*/
return true
}

func (i *ia32)#define IA32_PACKAGE_THERM_INTERRUPT_HIGH_TEMPERATURE_INTERRUPT_ENABLE()(ok bool){//col:9034
/*#define IA32_PACKAGE_THERM_INTERRUPT_HIGH_TEMPERATURE_INTERRUPT_ENABLE(_) (((_) >> 0) & 0x01)
     * [Bit 1] Pkg Low-Temperature Interrupt Enable.
    UINT64 LowTemperatureInterruptEnable                           : 1;
#define IA32_PACKAGE_THERM_INTERRUPT_LOW_TEMPERATURE_INTERRUPT_ENABLE_BIT 1
#define IA32_PACKAGE_THERM_INTERRUPT_LOW_TEMPERATURE_INTERRUPT_ENABLE_FLAG 0x02
#define IA32_PACKAGE_THERM_INTERRUPT_LOW_TEMPERATURE_INTERRUPT_ENABLE_MASK 0x01
#define IA32_PACKAGE_THERM_INTERRUPT_LOW_TEMPERATURE_INTERRUPT_ENABLE(_) (((_) >> 1) & 0x01)
     * [Bit 2] Pkg PROCHOT\# Interrupt Enable.
    UINT64 ProchotInterruptEnable                                  : 1;
#define IA32_PACKAGE_THERM_INTERRUPT_PROCHOT_INTERRUPT_ENABLE_BIT    2
#define IA32_PACKAGE_THERM_INTERRUPT_PROCHOT_INTERRUPT_ENABLE_FLAG   0x04
#define IA32_PACKAGE_THERM_INTERRUPT_PROCHOT_INTERRUPT_ENABLE_MASK   0x01
#define IA32_PACKAGE_THERM_INTERRUPT_PROCHOT_INTERRUPT_ENABLE(_)     (((_) >> 2) & 0x01)
    UINT64 Reserved1                                               : 1;
     * [Bit 4] Pkg Overheat Interrupt Enable.
    UINT64 OverheatInterruptEnable                                 : 1;
#define IA32_PACKAGE_THERM_INTERRUPT_OVERHEAT_INTERRUPT_ENABLE_BIT   4
#define IA32_PACKAGE_THERM_INTERRUPT_OVERHEAT_INTERRUPT_ENABLE_FLAG  0x10
#define IA32_PACKAGE_THERM_INTERRUPT_OVERHEAT_INTERRUPT_ENABLE_MASK  0x01
#define IA32_PACKAGE_THERM_INTERRUPT_OVERHEAT_INTERRUPT_ENABLE(_)    (((_) >> 4) & 0x01)
    UINT64 Reserved2                                               : 3;
     * [Bits 14:8] Pkg Threshold \#1 Value
    UINT64 Threshold1Value                                         : 7;
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD1_VALUE_BIT            8
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD1_VALUE_FLAG           0x7F00
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD1_VALUE_MASK           0x7F
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD1_VALUE(_)             (((_) >> 8) & 0x7F)
     * [Bit 15] Pkg Threshold \#1 Interrupt Enable.
    UINT64 Threshold1InterruptEnable                               : 1;
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD1_INTERRUPT_ENABLE_BIT 15
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD1_INTERRUPT_ENABLE_FLAG 0x8000
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD1_INTERRUPT_ENABLE_MASK 0x01
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD1_INTERRUPT_ENABLE(_)  (((_) >> 15) & 0x01)
     * [Bits 22:16] Pkg Threshold \#2 Value.
    UINT64 Threshold2Value                                         : 7;
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD2_VALUE_BIT            16
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD2_VALUE_FLAG           0x7F0000
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD2_VALUE_MASK           0x7F
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD2_VALUE(_)             (((_) >> 16) & 0x7F)
     * [Bit 23] Pkg Threshold \#2 Interrupt Enable.
    UINT64 Threshold2InterruptEnable                               : 1;
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD2_INTERRUPT_ENABLE_BIT 23
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD2_INTERRUPT_ENABLE_FLAG 0x800000
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD2_INTERRUPT_ENABLE_MASK 0x01
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD2_INTERRUPT_ENABLE(_)  (((_) >> 23) & 0x01)
     * [Bit 24] Pkg Power Limit Notification Enable.
    UINT64 PowerLimitNotificationEnable                            : 1;
#define IA32_PACKAGE_THERM_INTERRUPT_POWER_LIMIT_NOTIFICATION_ENABLE_BIT 24
#define IA32_PACKAGE_THERM_INTERRUPT_POWER_LIMIT_NOTIFICATION_ENABLE_FLAG 0x1000000
#define IA32_PACKAGE_THERM_INTERRUPT_POWER_LIMIT_NOTIFICATION_ENABLE_MASK 0x01
#define IA32_PACKAGE_THERM_INTERRUPT_POWER_LIMIT_NOTIFICATION_ENABLE(_) (((_) >> 24) & 0x01)
    UINT64 Reserved3                                               : 39;
  };
  UINT64 AsUInt;
} IA32_PACKAGE_THERM_INTERRUPT_REGISTER;*/
return true
}

func (i *ia32)#define IA32_DEBUGCTL_LBR()(ok bool){//col:9186
/*#define IA32_DEBUGCTL_LBR(_)                                         (((_) >> 0) & 0x01)
     * [Bit 1] Setting this bit to 1 enables the processor to treat EFLAGS.TF as single-step on branches instead of single-step
     * on instructions.
     *
    UINT64 Btf                                                     : 1;
#define IA32_DEBUGCTL_BTF_BIT                                        1
#define IA32_DEBUGCTL_BTF_FLAG                                       0x02
#define IA32_DEBUGCTL_BTF_MASK                                       0x01
#define IA32_DEBUGCTL_BTF(_)                                         (((_) >> 1) & 0x01)
    UINT64 Reserved1                                               : 4;
     * [Bit 6] Setting this bit to 1 enables branch trace messages to be sent.
     *
    UINT64 Tr                                                      : 1;
#define IA32_DEBUGCTL_TR_BIT                                         6
#define IA32_DEBUGCTL_TR_FLAG                                        0x40
#define IA32_DEBUGCTL_TR_MASK                                        0x01
#define IA32_DEBUGCTL_TR(_)                                          (((_) >> 6) & 0x01)
     * [Bit 7] Setting this bit enables branch trace messages (BTMs) to be logged in a BTS buffer.
     *
    UINT64 Bts                                                     : 1;
#define IA32_DEBUGCTL_BTS_BIT                                        7
#define IA32_DEBUGCTL_BTS_FLAG                                       0x80
#define IA32_DEBUGCTL_BTS_MASK                                       0x01
#define IA32_DEBUGCTL_BTS(_)                                         (((_) >> 7) & 0x01)
     * [Bit 8] When clear, BTMs are logged in a BTS buffer in circular fashion. When this bit is set, an interrupt is generated
     * by the BTS facility when the BTS buffer is full.
     *
    UINT64 Btint                                                   : 1;
#define IA32_DEBUGCTL_BTINT_BIT                                      8
#define IA32_DEBUGCTL_BTINT_FLAG                                     0x100
#define IA32_DEBUGCTL_BTINT_MASK                                     0x01
#define IA32_DEBUGCTL_BTINT(_)                                       (((_) >> 8) & 0x01)
     * [Bit 9] When set, BTS or BTM is skipped if CPL = 0.
     *
    UINT64 BtsOffOs                                                : 1;
#define IA32_DEBUGCTL_BTS_OFF_OS_BIT                                 9
#define IA32_DEBUGCTL_BTS_OFF_OS_FLAG                                0x200
#define IA32_DEBUGCTL_BTS_OFF_OS_MASK                                0x01
#define IA32_DEBUGCTL_BTS_OFF_OS(_)                                  (((_) >> 9) & 0x01)
     * [Bit 10] When set, BTS or BTM is skipped if CPL > 0.
     *
    UINT64 BtsOffUsr                                               : 1;
#define IA32_DEBUGCTL_BTS_OFF_USR_BIT                                10
#define IA32_DEBUGCTL_BTS_OFF_USR_FLAG                               0x400
#define IA32_DEBUGCTL_BTS_OFF_USR_MASK                               0x01
#define IA32_DEBUGCTL_BTS_OFF_USR(_)                                 (((_) >> 10) & 0x01)
     * [Bit 11] When set, the LBR stack is frozen on a PMI request.
     *
    UINT64 FreezeLbrsOnPmi                                         : 1;
#define IA32_DEBUGCTL_FREEZE_LBRS_ON_PMI_BIT                         11
#define IA32_DEBUGCTL_FREEZE_LBRS_ON_PMI_FLAG                        0x800
#define IA32_DEBUGCTL_FREEZE_LBRS_ON_PMI_MASK                        0x01
#define IA32_DEBUGCTL_FREEZE_LBRS_ON_PMI(_)                          (((_) >> 11) & 0x01)
     * [Bit 12] When set, each ENABLE bit of the global counter control MSR are frozen (address 38FH) on a PMI request.
     *
    UINT64 FreezePerfmonOnPmi                                      : 1;
#define IA32_DEBUGCTL_FREEZE_PERFMON_ON_PMI_BIT                      12
#define IA32_DEBUGCTL_FREEZE_PERFMON_ON_PMI_FLAG                     0x1000
#define IA32_DEBUGCTL_FREEZE_PERFMON_ON_PMI_MASK                     0x01
#define IA32_DEBUGCTL_FREEZE_PERFMON_ON_PMI(_)                       (((_) >> 12) & 0x01)
     * [Bit 13] When set, enables the logical processor to receive and generate PMI on behalf of the uncore.
     *
    UINT64 EnableUncorePmi                                         : 1;
#define IA32_DEBUGCTL_ENABLE_UNCORE_PMI_BIT                          13
#define IA32_DEBUGCTL_ENABLE_UNCORE_PMI_FLAG                         0x2000
#define IA32_DEBUGCTL_ENABLE_UNCORE_PMI_MASK                         0x01
#define IA32_DEBUGCTL_ENABLE_UNCORE_PMI(_)                           (((_) >> 13) & 0x01)
     * [Bit 14] When set, freezes perfmon and trace messages while in SMM.
     *
    UINT64 FreezeWhileSmm                                          : 1;
#define IA32_DEBUGCTL_FREEZE_WHILE_SMM_BIT                           14
#define IA32_DEBUGCTL_FREEZE_WHILE_SMM_FLAG                          0x4000
#define IA32_DEBUGCTL_FREEZE_WHILE_SMM_MASK                          0x01
#define IA32_DEBUGCTL_FREEZE_WHILE_SMM(_)                            (((_) >> 14) & 0x01)
     * [Bit 15] When set, enables DR7 debug bit on XBEGIN.
     *
    UINT64 RtmDebug                                                : 1;
#define IA32_DEBUGCTL_RTM_DEBUG_BIT                                  15
#define IA32_DEBUGCTL_RTM_DEBUG_FLAG                                 0x8000
#define IA32_DEBUGCTL_RTM_DEBUG_MASK                                 0x01
#define IA32_DEBUGCTL_RTM_DEBUG(_)                                   (((_) >> 15) & 0x01)
    UINT64 Reserved2                                               : 48;
  };
  UINT64 AsUInt;
} IA32_DEBUGCTL_REGISTER;*/
return true
}

func (i *ia32)#define IA32_SMRR_PHYSBASE_TYPE()(ok bool){//col:9225
/*#define IA32_SMRR_PHYSBASE_TYPE(_)                                   (((_) >> 0) & 0xFF)
    UINT64 Reserved1                                               : 4;
     * [Bits 31:12] SMRR physical Base Address.
    UINT64 SmrrPhysicalBaseAddress                                 : 20;
#define IA32_SMRR_PHYSBASE_SMRR_PHYSICAL_BASE_ADDRESS_BIT            12
#define IA32_SMRR_PHYSBASE_SMRR_PHYSICAL_BASE_ADDRESS_FLAG           0xFFFFF000
#define IA32_SMRR_PHYSBASE_SMRR_PHYSICAL_BASE_ADDRESS_MASK           0xFFFFF
#define IA32_SMRR_PHYSBASE_SMRR_PHYSICAL_BASE_ADDRESS(_)             (((_) >> 12) & 0xFFFFF)
    UINT64 Reserved2                                               : 32;
  };
  UINT64 AsUInt;
} IA32_SMRR_PHYSBASE_REGISTER;*/
return true
}

func (i *ia32)#define IA32_SMRR_PHYSMASK_ENABLE_RANGE_MASK()(ok bool){//col:9263
/*#define IA32_SMRR_PHYSMASK_ENABLE_RANGE_MASK(_)                      (((_) >> 11) & 0x01)
     * [Bits 31:12] SMRR address range mask.
    UINT64 SmrrAddressRangeMask                                    : 20;
#define IA32_SMRR_PHYSMASK_SMRR_ADDRESS_RANGE_MASK_BIT               12
#define IA32_SMRR_PHYSMASK_SMRR_ADDRESS_RANGE_MASK_FLAG              0xFFFFF000
#define IA32_SMRR_PHYSMASK_SMRR_ADDRESS_RANGE_MASK_MASK              0xFFFFF
#define IA32_SMRR_PHYSMASK_SMRR_ADDRESS_RANGE_MASK(_)                (((_) >> 12) & 0xFFFFF)
    UINT64 Reserved2                                               : 32;
  };
  UINT64 AsUInt;
} IA32_SMRR_PHYSMASK_REGISTER;*/
return true
}

func (i *ia32)#define IA32_DCA_0_CAP_DCA_ACTIVE()(ok bool){//col:9359
/*#define IA32_DCA_0_CAP_DCA_ACTIVE(_)                                 (((_) >> 0) & 0x01)
     * [Bits 2:1] TRANSACTION.
    UINT64 Transaction                                             : 2;
#define IA32_DCA_0_CAP_TRANSACTION_BIT                               1
#define IA32_DCA_0_CAP_TRANSACTION_FLAG                              0x06
#define IA32_DCA_0_CAP_TRANSACTION_MASK                              0x03
#define IA32_DCA_0_CAP_TRANSACTION(_)                                (((_) >> 1) & 0x03)
     * [Bits 6:3] DCA_TYPE.
    UINT64 DcaType                                                 : 4;
#define IA32_DCA_0_CAP_DCA_TYPE_BIT                                  3
#define IA32_DCA_0_CAP_DCA_TYPE_FLAG                                 0x78
#define IA32_DCA_0_CAP_DCA_TYPE_MASK                                 0x0F
#define IA32_DCA_0_CAP_DCA_TYPE(_)                                   (((_) >> 3) & 0x0F)
     * [Bits 10:7] DCA_QUEUE_SIZE.
    UINT64 DcaQueueSize                                            : 4;
#define IA32_DCA_0_CAP_DCA_QUEUE_SIZE_BIT                            7
#define IA32_DCA_0_CAP_DCA_QUEUE_SIZE_FLAG                           0x780
#define IA32_DCA_0_CAP_DCA_QUEUE_SIZE_MASK                           0x0F
#define IA32_DCA_0_CAP_DCA_QUEUE_SIZE(_)                             (((_) >> 7) & 0x0F)
    UINT64 Reserved1                                               : 2;
     * [Bits 16:13] Writes will update the register but have no HW side-effect.
    UINT64 DcaDelay                                                : 4;
#define IA32_DCA_0_CAP_DCA_DELAY_BIT                                 13
#define IA32_DCA_0_CAP_DCA_DELAY_FLAG                                0x1E000
#define IA32_DCA_0_CAP_DCA_DELAY_MASK                                0x0F
#define IA32_DCA_0_CAP_DCA_DELAY(_)                                  (((_) >> 13) & 0x0F)
    UINT64 Reserved2                                               : 7;
     * [Bit 24] SW can request DCA block by setting this bit.
    UINT64 SwBlock                                                 : 1;
#define IA32_DCA_0_CAP_SW_BLOCK_BIT                                  24
#define IA32_DCA_0_CAP_SW_BLOCK_FLAG                                 0x1000000
#define IA32_DCA_0_CAP_SW_BLOCK_MASK                                 0x01
#define IA32_DCA_0_CAP_SW_BLOCK(_)                                   (((_) >> 24) & 0x01)
    UINT64 Reserved3                                               : 1;
     * [Bit 26] Set when DCA is blocked by HW (e.g. CR0.CD = 1).
    UINT64 HwBlock                                                 : 1;
#define IA32_DCA_0_CAP_HW_BLOCK_BIT                                  26
#define IA32_DCA_0_CAP_HW_BLOCK_FLAG                                 0x4000000
#define IA32_DCA_0_CAP_HW_BLOCK_MASK                                 0x01
#define IA32_DCA_0_CAP_HW_BLOCK(_)                                   (((_) >> 26) & 0x01)
    UINT64 Reserved4                                               : 37;
  };
  UINT64 AsUInt;
} IA32_DCA_0_CAP_REGISTER;*/
return true
}

func (i *ia32) *           IA32_MTRR_PHYSBASE()(ok bool){//col:9399
/* *           IA32_MTRR_PHYSBASE(n)
 *
 * IA32_MTRR_PHYSBASE(0-9).
 *
typedef union
{
  struct
  {
     * [Bits 7:0] Specifies the memory type for the range.
    UINT64 Type                                                    : 8;
#define IA32_MTRR_PHYSBASE_TYPE_BIT                                  0
#define IA32_MTRR_PHYSBASE_TYPE_FLAG                                 0xFF
#define IA32_MTRR_PHYSBASE_TYPE_MASK                                 0xFF
#define IA32_MTRR_PHYSBASE_TYPE(_)                                   (((_) >> 0) & 0xFF)
    UINT64 Reserved1                                               : 4;
     * [Bits 47:12] Specifies the base address of the address range. This 24-bit value, in the case where MAXPHYADDR is 36
     * bits, is extended by 12 bits at the low end to form the base address (this automatically aligns the address on a 4-KByte
     * boundary).
    UINT64 PageFrameNumber                                         : 36;
#define IA32_MTRR_PHYSBASE_PAGE_FRAME_NUMBER_BIT                     12
#define IA32_MTRR_PHYSBASE_PAGE_FRAME_NUMBER_FLAG                    0xFFFFFFFFF000
#define IA32_MTRR_PHYSBASE_PAGE_FRAME_NUMBER_MASK                    0xFFFFFFFFF
#define IA32_MTRR_PHYSBASE_PAGE_FRAME_NUMBER(_)                      (((_) >> 12) & 0xFFFFFFFFF)
    UINT64 Reserved2                                               : 16;
  };
  UINT64 AsUInt;
} IA32_MTRR_PHYSBASE_REGISTER;*/
return true
}

func (i *ia32) *           IA32_MTRR_PHYSMASK()(ok bool){//col:9461
/* *           IA32_MTRR_PHYSMASK(n)
 *
 * IA32_MTRR_PHYSMASK(0-9).
 *
typedef union
{
  struct
  {
    UINT64 Reserved1                                               : 11;
     * [Bit 11] Enables the register pair when set; disables register pair when clear.
    UINT64 Valid                                                   : 1;
#define IA32_MTRR_PHYSMASK_VALID_BIT                                 11
#define IA32_MTRR_PHYSMASK_VALID_FLAG                                0x800
#define IA32_MTRR_PHYSMASK_VALID_MASK                                0x01
#define IA32_MTRR_PHYSMASK_VALID(_)                                  (((_) >> 11) & 0x01)
     * [Bits 47:12] Specifies a mask (24 bits if the maximum physical address size is 36 bits, 28 bits if the maximum physical
     * address size is 40 bits). The mask determines the range of the region being mapped, according to the following
     * relationships:
     * - Address_Within_Range AND PhysMask = PhysBase AND PhysMask
     * - This value is extended by 12 bits at the low end to form the mask value.
     * - The width of the PhysMask field depends on the maximum physical address size supported by the processor.
     * CPUID.80000008H reports the maximum physical address size supported by the processor. If CPUID.80000008H is not
     * available, software may assume that the processor supports a 36-bit physical address size.
     *
    UINT64 PageFrameNumber                                         : 36;
#define IA32_MTRR_PHYSMASK_PAGE_FRAME_NUMBER_BIT                     12
#define IA32_MTRR_PHYSMASK_PAGE_FRAME_NUMBER_FLAG                    0xFFFFFFFFF000
#define IA32_MTRR_PHYSMASK_PAGE_FRAME_NUMBER_MASK                    0xFFFFFFFFF
#define IA32_MTRR_PHYSMASK_PAGE_FRAME_NUMBER(_)                      (((_) >> 12) & 0xFFFFFFFFF)
    UINT64 Reserved2                                               : 16;
  };
  UINT64 AsUInt;
} IA32_MTRR_PHYSMASK_REGISTER;*/
return true
}

func (i *ia32) *           IA32_MTRR_FIX()(ok bool){//col:9650
/* *           IA32_MTRR_FIX(x)
 *
 * IA32_MTRR_FIX(x).
 *
 *           IA32_MTRR_FIX64K(x)
 *
 * IA32_MTRR_FIX64K(x).
#define IA32_MTRR_FIX64K_BASE                                        0x00000000
#define IA32_MTRR_FIX64K_SIZE                                        0x00010000
#define IA32_MTRR_FIX64K_00000                                       0x00000250
 *           IA32_MTRR_FIX16K(x)
 *
 * IA32_MTRR_FIX16K(x).
#define IA32_MTRR_FIX16K_BASE                                        0x00080000
#define IA32_MTRR_FIX16K_SIZE                                        0x00004000
#define IA32_MTRR_FIX16K_80000                                       0x00000258
#define IA32_MTRR_FIX16K_A0000                                       0x00000259
 *           IA32_MTRR_FIX4K(x)
 *
 * IA32_MTRR_FIX4K(x).
#define IA32_MTRR_FIX4K_BASE                                         0x000C0000
#define IA32_MTRR_FIX4K_SIZE                                         0x00001000
#define IA32_MTRR_FIX4K_C0000                                        0x00000268
#define IA32_MTRR_FIX4K_C8000                                        0x00000269
#define IA32_MTRR_FIX4K_D0000                                        0x0000026A
#define IA32_MTRR_FIX4K_D8000                                        0x0000026B
#define IA32_MTRR_FIX4K_E0000                                        0x0000026C
#define IA32_MTRR_FIX4K_E8000                                        0x0000026D
#define IA32_MTRR_FIX4K_F0000                                        0x0000026E
#define IA32_MTRR_FIX4K_F8000                                        0x0000026F
 * Architecture defined number of fixed range MTRRs (1 for 64k, 2 for 16k, 8 for 4k).
#define IA32_MTRR_FIX_COUNT                                          ((1 + 2 + 8) * 8)
 * Architecture defined number of variable range MTRRs. See: Table 2-2. IA-32 Architectural MSRs
 *
#define IA32_MTRR_VARIABLE_COUNT                                     0x0000000A
 * A size of array to store all possible MTRRs.
#define IA32_MTRR_COUNT                                              (IA32_MTRR_FIX_COUNT + IA32_MTRR_VARIABLE_COUNT)
 * IA32_PAT.
 *
#define IA32_PAT                                                     0x00000277
typedef union
{
  struct
  {
     * [Bits 2:0] PA0.
    UINT64 Pa0                                                     : 3;
#define IA32_PAT_PA0_BIT                                             0
#define IA32_PAT_PA0_FLAG                                            0x07
#define IA32_PAT_PA0_MASK                                            0x07
#define IA32_PAT_PA0(_)                                              (((_) >> 0) & 0x07)
    UINT64 Reserved1                                               : 5;
     * [Bits 10:8] PA1.
    UINT64 Pa1                                                     : 3;
#define IA32_PAT_PA1_BIT                                             8
#define IA32_PAT_PA1_FLAG                                            0x700
#define IA32_PAT_PA1_MASK                                            0x07
#define IA32_PAT_PA1(_)                                              (((_) >> 8) & 0x07)
    UINT64 Reserved2                                               : 5;
     * [Bits 18:16] PA2.
    UINT64 Pa2                                                     : 3;
#define IA32_PAT_PA2_BIT                                             16
#define IA32_PAT_PA2_FLAG                                            0x70000
#define IA32_PAT_PA2_MASK                                            0x07
#define IA32_PAT_PA2(_)                                              (((_) >> 16) & 0x07)
    UINT64 Reserved3                                               : 5;
     * [Bits 26:24] PA3.
    UINT64 Pa3                                                     : 3;
#define IA32_PAT_PA3_BIT                                             24
#define IA32_PAT_PA3_FLAG                                            0x7000000
#define IA32_PAT_PA3_MASK                                            0x07
#define IA32_PAT_PA3(_)                                              (((_) >> 24) & 0x07)
    UINT64 Reserved4                                               : 5;
     * [Bits 34:32] PA4.
    UINT64 Pa4                                                     : 3;
#define IA32_PAT_PA4_BIT                                             32
#define IA32_PAT_PA4_FLAG                                            0x700000000
#define IA32_PAT_PA4_MASK                                            0x07
#define IA32_PAT_PA4(_)                                              (((_) >> 32) & 0x07)
    UINT64 Reserved5                                               : 5;
     * [Bits 42:40] PA5.
    UINT64 Pa5                                                     : 3;
#define IA32_PAT_PA5_BIT                                             40
#define IA32_PAT_PA5_FLAG                                            0x70000000000
#define IA32_PAT_PA5_MASK                                            0x07
#define IA32_PAT_PA5(_)                                              (((_) >> 40) & 0x07)
    UINT64 Reserved6                                               : 5;
     * [Bits 50:48] PA6.
    UINT64 Pa6                                                     : 3;
#define IA32_PAT_PA6_BIT                                             48
#define IA32_PAT_PA6_FLAG                                            0x7000000000000
#define IA32_PAT_PA6_MASK                                            0x07
#define IA32_PAT_PA6(_)                                              (((_) >> 48) & 0x07)
    UINT64 Reserved7                                               : 5;
     * [Bits 58:56] PA7.
    UINT64 Pa7                                                     : 3;
#define IA32_PAT_PA7_BIT                                             56
#define IA32_PAT_PA7_FLAG                                            0x700000000000000
#define IA32_PAT_PA7_MASK                                            0x07
#define IA32_PAT_PA7(_)                                              (((_) >> 56) & 0x07)
    UINT64 Reserved8                                               : 5;
  };
  UINT64 AsUInt;
} IA32_PAT_REGISTER;*/
return true
}

func (i *ia32) *           IA32_MC()(ok bool){//col:9720
/* *           IA32_MC(i)_CTL2
 *
 * MSR to enable/disable CMCI capability for bank n.
 *
#define IA32_MC0_CTL2                                                0x00000280
#define IA32_MC1_CTL2                                                0x00000281
#define IA32_MC2_CTL2                                                0x00000282
#define IA32_MC3_CTL2                                                0x00000283
#define IA32_MC4_CTL2                                                0x00000284
#define IA32_MC5_CTL2                                                0x00000285
#define IA32_MC6_CTL2                                                0x00000286
#define IA32_MC7_CTL2                                                0x00000287
#define IA32_MC8_CTL2                                                0x00000288
#define IA32_MC9_CTL2                                                0x00000289
#define IA32_MC10_CTL2                                               0x0000028A
#define IA32_MC11_CTL2                                               0x0000028B
#define IA32_MC12_CTL2                                               0x0000028C
#define IA32_MC13_CTL2                                               0x0000028D
#define IA32_MC14_CTL2                                               0x0000028E
#define IA32_MC15_CTL2                                               0x0000028F
#define IA32_MC16_CTL2                                               0x00000290
#define IA32_MC17_CTL2                                               0x00000291
#define IA32_MC18_CTL2                                               0x00000292
#define IA32_MC19_CTL2                                               0x00000293
#define IA32_MC20_CTL2                                               0x00000294
#define IA32_MC21_CTL2                                               0x00000295
#define IA32_MC22_CTL2                                               0x00000296
#define IA32_MC23_CTL2                                               0x00000297
#define IA32_MC24_CTL2                                               0x00000298
#define IA32_MC25_CTL2                                               0x00000299
#define IA32_MC26_CTL2                                               0x0000029A
#define IA32_MC27_CTL2                                               0x0000029B
#define IA32_MC28_CTL2                                               0x0000029C
#define IA32_MC29_CTL2                                               0x0000029D
#define IA32_MC30_CTL2                                               0x0000029E
#define IA32_MC31_CTL2                                               0x0000029F
typedef union
{
  struct
  {
     * [Bits 14:0] Corrected error count threshold.
    UINT64 CorrectedErrorCountThreshold                            : 15;
#define IA32_MC_CTL2_CORRECTED_ERROR_COUNT_THRESHOLD_BIT             0
#define IA32_MC_CTL2_CORRECTED_ERROR_COUNT_THRESHOLD_FLAG            0x7FFF
#define IA32_MC_CTL2_CORRECTED_ERROR_COUNT_THRESHOLD_MASK            0x7FFF
#define IA32_MC_CTL2_CORRECTED_ERROR_COUNT_THRESHOLD(_)              (((_) >> 0) & 0x7FFF)
    UINT64 Reserved1                                               : 15;
     * [Bit 30] CMCI_EN.
    UINT64 CmciEn                                                  : 1;
#define IA32_MC_CTL2_CMCI_EN_BIT                                     30
#define IA32_MC_CTL2_CMCI_EN_FLAG                                    0x40000000
#define IA32_MC_CTL2_CMCI_EN_MASK                                    0x01
#define IA32_MC_CTL2_CMCI_EN(_)                                      (((_) >> 30) & 0x01)
    UINT64 Reserved2                                               : 33;
  };
  UINT64 AsUInt;
} IA32_MC_CTL2_REGISTER;*/
return true
}

func (i *ia32)#define IA32_MTRR_DEF_TYPE_DEFAULT_MEMORY_TYPE()(ok bool){//col:9768
/*#define IA32_MTRR_DEF_TYPE_DEFAULT_MEMORY_TYPE(_)                    (((_) >> 0) & 0x07)
    UINT64 Reserved1                                               : 7;
     * [Bit 10] Fixed Range MTRR Enable.
    UINT64 FixedRangeMtrrEnable                                    : 1;
#define IA32_MTRR_DEF_TYPE_FIXED_RANGE_MTRR_ENABLE_BIT               10
#define IA32_MTRR_DEF_TYPE_FIXED_RANGE_MTRR_ENABLE_FLAG              0x400
#define IA32_MTRR_DEF_TYPE_FIXED_RANGE_MTRR_ENABLE_MASK              0x01
#define IA32_MTRR_DEF_TYPE_FIXED_RANGE_MTRR_ENABLE(_)                (((_) >> 10) & 0x01)
     * [Bit 11] MTRR Enable.
    UINT64 MtrrEnable                                              : 1;
#define IA32_MTRR_DEF_TYPE_MTRR_ENABLE_BIT                           11
#define IA32_MTRR_DEF_TYPE_MTRR_ENABLE_FLAG                          0x800
#define IA32_MTRR_DEF_TYPE_MTRR_ENABLE_MASK                          0x01
#define IA32_MTRR_DEF_TYPE_MTRR_ENABLE(_)                            (((_) >> 11) & 0x01)
    UINT64 Reserved2                                               : 52;
  };
  UINT64 AsUInt;
} IA32_MTRR_DEF_TYPE_REGISTER;*/
return true
}

func (i *ia32) *           IA32_FIXED_CTR()(ok bool){//col:9865
/* *           IA32_FIXED_CTR(n)
 *
 * Fixed-Function Performance Counter n.
 *
 * Counts Instr_Retired.Any.
#define IA32_FIXED_CTR0                                              0x00000309
 * Counts CPU_CLK_Unhalted.Core
#define IA32_FIXED_CTR1                                              0x0000030A
 * Counts CPU_CLK_Unhalted.Ref
#define IA32_FIXED_CTR2                                              0x0000030B
 * Read Only MSR that enumerates the existence of performance monitoring features.
 *
#define IA32_PERF_CAPABILITIES                                       0x00000345
typedef union
{
  struct
  {
     * [Bits 5:0] LBR format.
    UINT64 LbrFormat                                               : 6;
#define IA32_PERF_CAPABILITIES_LBR_FORMAT_BIT                        0
#define IA32_PERF_CAPABILITIES_LBR_FORMAT_FLAG                       0x3F
#define IA32_PERF_CAPABILITIES_LBR_FORMAT_MASK                       0x3F
#define IA32_PERF_CAPABILITIES_LBR_FORMAT(_)                         (((_) >> 0) & 0x3F)
     * [Bit 6] PEBS Trap.
    UINT64 PebsTrap                                                : 1;
#define IA32_PERF_CAPABILITIES_PEBS_TRAP_BIT                         6
#define IA32_PERF_CAPABILITIES_PEBS_TRAP_FLAG                        0x40
#define IA32_PERF_CAPABILITIES_PEBS_TRAP_MASK                        0x01
#define IA32_PERF_CAPABILITIES_PEBS_TRAP(_)                          (((_) >> 6) & 0x01)
     * [Bit 7] PEBSSaveArchRegs.
    UINT64 PebsSaveArchRegs                                        : 1;
#define IA32_PERF_CAPABILITIES_PEBS_SAVE_ARCH_REGS_BIT               7
#define IA32_PERF_CAPABILITIES_PEBS_SAVE_ARCH_REGS_FLAG              0x80
#define IA32_PERF_CAPABILITIES_PEBS_SAVE_ARCH_REGS_MASK              0x01
#define IA32_PERF_CAPABILITIES_PEBS_SAVE_ARCH_REGS(_)                (((_) >> 7) & 0x01)
     * [Bits 11:8] PEBS Record Format.
    UINT64 PebsRecordFormat                                        : 4;
#define IA32_PERF_CAPABILITIES_PEBS_RECORD_FORMAT_BIT                8
#define IA32_PERF_CAPABILITIES_PEBS_RECORD_FORMAT_FLAG               0xF00
#define IA32_PERF_CAPABILITIES_PEBS_RECORD_FORMAT_MASK               0x0F
#define IA32_PERF_CAPABILITIES_PEBS_RECORD_FORMAT(_)                 (((_) >> 8) & 0x0F)
     * [Bit 12] Freeze while SMM is supported.
    UINT64 FreezeWhileSmmIsSupported                               : 1;
#define IA32_PERF_CAPABILITIES_FREEZE_WHILE_SMM_IS_SUPPORTED_BIT     12
#define IA32_PERF_CAPABILITIES_FREEZE_WHILE_SMM_IS_SUPPORTED_FLAG    0x1000
#define IA32_PERF_CAPABILITIES_FREEZE_WHILE_SMM_IS_SUPPORTED_MASK    0x01
#define IA32_PERF_CAPABILITIES_FREEZE_WHILE_SMM_IS_SUPPORTED(_)      (((_) >> 12) & 0x01)
     * [Bit 13] Full width of counter writable via IA32_A_PMCx.
    UINT64 FullWidthCounterWrite                                   : 1;
#define IA32_PERF_CAPABILITIES_FULL_WIDTH_COUNTER_WRITE_BIT          13
#define IA32_PERF_CAPABILITIES_FULL_WIDTH_COUNTER_WRITE_FLAG         0x2000
#define IA32_PERF_CAPABILITIES_FULL_WIDTH_COUNTER_WRITE_MASK         0x01
#define IA32_PERF_CAPABILITIES_FULL_WIDTH_COUNTER_WRITE(_)           (((_) >> 13) & 0x01)
    UINT64 Reserved1                                               : 50;
  };
  UINT64 AsUInt;
} IA32_PERF_CAPABILITIES_REGISTER;*/
return true
}

func (i *ia32)#define IA32_FIXED_CTR_CTRL_EN0_OS()(ok bool){//col:10002
/*#define IA32_FIXED_CTR_CTRL_EN0_OS(_)                                (((_) >> 0) & 0x01)
     * [Bit 1] EN0_Usr: Enable Fixed Counter 0 to count while CPL > 0.
    UINT64 En0Usr                                                  : 1;
#define IA32_FIXED_CTR_CTRL_EN0_USR_BIT                              1
#define IA32_FIXED_CTR_CTRL_EN0_USR_FLAG                             0x02
#define IA32_FIXED_CTR_CTRL_EN0_USR_MASK                             0x01
#define IA32_FIXED_CTR_CTRL_EN0_USR(_)                               (((_) >> 1) & 0x01)
     * [Bit 2] AnyThread: When set to 1, it enables counting the associated event conditions occurring across all logical
     * processors sharing a processor core. When set to 0, the counter only increments the associated event conditions
     * occurring in the logical processor which programmed the MSR.
    UINT64 AnyThread0                                              : 1;
#define IA32_FIXED_CTR_CTRL_ANY_THREAD0_BIT                          2
#define IA32_FIXED_CTR_CTRL_ANY_THREAD0_FLAG                         0x04
#define IA32_FIXED_CTR_CTRL_ANY_THREAD0_MASK                         0x01
#define IA32_FIXED_CTR_CTRL_ANY_THREAD0(_)                           (((_) >> 2) & 0x01)
     * [Bit 3] EN0_PMI: Enable PMI when fixed counter 0 overflows.
    UINT64 En0Pmi                                                  : 1;
#define IA32_FIXED_CTR_CTRL_EN0_PMI_BIT                              3
#define IA32_FIXED_CTR_CTRL_EN0_PMI_FLAG                             0x08
#define IA32_FIXED_CTR_CTRL_EN0_PMI_MASK                             0x01
#define IA32_FIXED_CTR_CTRL_EN0_PMI(_)                               (((_) >> 3) & 0x01)
     * [Bit 4] EN1_OS: Enable Fixed Counter 1 to count while CPL = 0.
    UINT64 En1Os                                                   : 1;
#define IA32_FIXED_CTR_CTRL_EN1_OS_BIT                               4
#define IA32_FIXED_CTR_CTRL_EN1_OS_FLAG                              0x10
#define IA32_FIXED_CTR_CTRL_EN1_OS_MASK                              0x01
#define IA32_FIXED_CTR_CTRL_EN1_OS(_)                                (((_) >> 4) & 0x01)
     * [Bit 5] EN1_Usr: Enable Fixed Counter 1 to count while CPL > 0.
    UINT64 En1Usr                                                  : 1;
#define IA32_FIXED_CTR_CTRL_EN1_USR_BIT                              5
#define IA32_FIXED_CTR_CTRL_EN1_USR_FLAG                             0x20
#define IA32_FIXED_CTR_CTRL_EN1_USR_MASK                             0x01
#define IA32_FIXED_CTR_CTRL_EN1_USR(_)                               (((_) >> 5) & 0x01)
     * [Bit 6] AnyThread: When set to 1, it enables counting the associated event conditions occurring across all logical
     * processors sharing a processor core. When set to 0, the counter only increments the associated event conditions
     * occurring in the logical processor which programmed the MSR.
     *
    UINT64 AnyThread1                                              : 1;
#define IA32_FIXED_CTR_CTRL_ANY_THREAD1_BIT                          6
#define IA32_FIXED_CTR_CTRL_ANY_THREAD1_FLAG                         0x40
#define IA32_FIXED_CTR_CTRL_ANY_THREAD1_MASK                         0x01
#define IA32_FIXED_CTR_CTRL_ANY_THREAD1(_)                           (((_) >> 6) & 0x01)
     * [Bit 7] EN1_PMI: Enable PMI when fixed counter 1 overflows.
    UINT64 En1Pmi                                                  : 1;
#define IA32_FIXED_CTR_CTRL_EN1_PMI_BIT                              7
#define IA32_FIXED_CTR_CTRL_EN1_PMI_FLAG                             0x80
#define IA32_FIXED_CTR_CTRL_EN1_PMI_MASK                             0x01
#define IA32_FIXED_CTR_CTRL_EN1_PMI(_)                               (((_) >> 7) & 0x01)
     * [Bit 8] EN2_OS: Enable Fixed Counter 2 to count while CPL = 0.
    UINT64 En2Os                                                   : 1;
#define IA32_FIXED_CTR_CTRL_EN2_OS_BIT                               8
#define IA32_FIXED_CTR_CTRL_EN2_OS_FLAG                              0x100
#define IA32_FIXED_CTR_CTRL_EN2_OS_MASK                              0x01
#define IA32_FIXED_CTR_CTRL_EN2_OS(_)                                (((_) >> 8) & 0x01)
     * [Bit 9] EN2_Usr: Enable Fixed Counter 2 to count while CPL > 0.
    UINT64 En2Usr                                                  : 1;
#define IA32_FIXED_CTR_CTRL_EN2_USR_BIT                              9
#define IA32_FIXED_CTR_CTRL_EN2_USR_FLAG                             0x200
#define IA32_FIXED_CTR_CTRL_EN2_USR_MASK                             0x01
#define IA32_FIXED_CTR_CTRL_EN2_USR(_)                               (((_) >> 9) & 0x01)
     * [Bit 10] AnyThread: When set to 1, it enables counting the associated event conditions occurring across all logical
     * processors sharing a processor core. When set to 0, the counter only increments the associated event conditions
     * occurring in the logical processor which programmed the MSR.
     *
    UINT64 AnyThread2                                              : 1;
#define IA32_FIXED_CTR_CTRL_ANY_THREAD2_BIT                          10
#define IA32_FIXED_CTR_CTRL_ANY_THREAD2_FLAG                         0x400
#define IA32_FIXED_CTR_CTRL_ANY_THREAD2_MASK                         0x01
#define IA32_FIXED_CTR_CTRL_ANY_THREAD2(_)                           (((_) >> 10) & 0x01)
     * [Bit 11] EN2_PMI: Enable PMI when fixed counter 2 overflows.
    UINT64 En2Pmi                                                  : 1;
#define IA32_FIXED_CTR_CTRL_EN2_PMI_BIT                              11
#define IA32_FIXED_CTR_CTRL_EN2_PMI_FLAG                             0x800
#define IA32_FIXED_CTR_CTRL_EN2_PMI_MASK                             0x01
#define IA32_FIXED_CTR_CTRL_EN2_PMI(_)                               (((_) >> 11) & 0x01)
    UINT64 Reserved1                                               : 52;
  };
  UINT64 AsUInt;
} IA32_FIXED_CTR_CTRL_REGISTER;*/
return true
}

func (i *ia32)#define IA32_PERF_GLOBAL_STATUS_OVF_PMC0()(ok bool){//col:10179
/*#define IA32_PERF_GLOBAL_STATUS_OVF_PMC0(_)                          (((_) >> 0) & 0x01)
     * [Bit 1] Ovf_PMC1: Overflow status of IA32_PMC1.
     *
    UINT64 OvfPmc1                                                 : 1;
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC1_BIT                         1
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC1_FLAG                        0x02
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC1_MASK                        0x01
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC1(_)                          (((_) >> 1) & 0x01)
     * [Bit 2] Ovf_PMC2: Overflow status of IA32_PMC2.
     *
    UINT64 OvfPmc2                                                 : 1;
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC2_BIT                         2
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC2_FLAG                        0x04
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC2_MASK                        0x01
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC2(_)                          (((_) >> 2) & 0x01)
     * [Bit 3] Ovf_PMC3: Overflow status of IA32_PMC3.
     *
    UINT64 OvfPmc3                                                 : 1;
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC3_BIT                         3
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC3_FLAG                        0x08
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC3_MASK                        0x01
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC3(_)                          (((_) >> 3) & 0x01)
    UINT64 Reserved1                                               : 28;
     * [Bit 32] Ovf_FixedCtr0: Overflow status of IA32_FIXED_CTR0.
     *
    UINT64 OvfFixedctr0                                            : 1;
#define IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR0_BIT                    32
#define IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR0_FLAG                   0x100000000
#define IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR0_MASK                   0x01
#define IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR0(_)                     (((_) >> 32) & 0x01)
     * [Bit 33] Ovf_FixedCtr1: Overflow status of IA32_FIXED_CTR1.
     *
    UINT64 OvfFixedctr1                                            : 1;
#define IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR1_BIT                    33
#define IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR1_FLAG                   0x200000000
#define IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR1_MASK                   0x01
#define IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR1(_)                     (((_) >> 33) & 0x01)
     * [Bit 34] Ovf_FixedCtr2: Overflow status of IA32_FIXED_CTR2.
     *
    UINT64 OvfFixedctr2                                            : 1;
#define IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR2_BIT                    34
#define IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR2_FLAG                   0x400000000
#define IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR2_MASK                   0x01
#define IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR2(_)                     (((_) >> 34) & 0x01)
    UINT64 Reserved2                                               : 20;
     * [Bit 55] Trace_ToPA_PMI: A PMI occurred due to a ToPA entry memory buffer that was completely filled.
     *
    UINT64 TraceTopaPmi                                            : 1;
#define IA32_PERF_GLOBAL_STATUS_TRACE_TOPA_PMI_BIT                   55
#define IA32_PERF_GLOBAL_STATUS_TRACE_TOPA_PMI_FLAG                  0x80000000000000
#define IA32_PERF_GLOBAL_STATUS_TRACE_TOPA_PMI_MASK                  0x01
#define IA32_PERF_GLOBAL_STATUS_TRACE_TOPA_PMI(_)                    (((_) >> 55) & 0x01)
    UINT64 Reserved3                                               : 2;
     * [Bit 58] LBR_Frz. LBRs are frozen due to:
     * * IA32_DEBUGCTL.FREEZE_LBR_ON_PMI=1.
     * * The LBR stack overflowed.
     *
    UINT64 LbrFrz                                                  : 1;
#define IA32_PERF_GLOBAL_STATUS_LBR_FRZ_BIT                          58
#define IA32_PERF_GLOBAL_STATUS_LBR_FRZ_FLAG                         0x400000000000000
#define IA32_PERF_GLOBAL_STATUS_LBR_FRZ_MASK                         0x01
#define IA32_PERF_GLOBAL_STATUS_LBR_FRZ(_)                           (((_) >> 58) & 0x01)
     * [Bit 59] CTR_Frz. Performance counters in the core PMU are frozen due to:
     * * IA32_DEBUGCTL.FREEZE_PERFMON_ON_PMI=1.
     * * One or more core PMU counters overflowed.
     *
    UINT64 CtrFrz                                                  : 1;
#define IA32_PERF_GLOBAL_STATUS_CTR_FRZ_BIT                          59
#define IA32_PERF_GLOBAL_STATUS_CTR_FRZ_FLAG                         0x800000000000000
#define IA32_PERF_GLOBAL_STATUS_CTR_FRZ_MASK                         0x01
#define IA32_PERF_GLOBAL_STATUS_CTR_FRZ(_)                           (((_) >> 59) & 0x01)
     * [Bit 60] ASCI: Data in the performance counters in the core PMU may include contributions from the direct or indirect
     * operation Intel SGX to protect an enclave.
     *
    UINT64 Asci                                                    : 1;
#define IA32_PERF_GLOBAL_STATUS_ASCI_BIT                             60
#define IA32_PERF_GLOBAL_STATUS_ASCI_FLAG                            0x1000000000000000
#define IA32_PERF_GLOBAL_STATUS_ASCI_MASK                            0x01
#define IA32_PERF_GLOBAL_STATUS_ASCI(_)                              (((_) >> 60) & 0x01)
     * [Bit 61] Uncore counter overflow status.
     *
    UINT64 OvfUncore                                               : 1;
#define IA32_PERF_GLOBAL_STATUS_OVF_UNCORE_BIT                       61
#define IA32_PERF_GLOBAL_STATUS_OVF_UNCORE_FLAG                      0x2000000000000000
#define IA32_PERF_GLOBAL_STATUS_OVF_UNCORE_MASK                      0x01
#define IA32_PERF_GLOBAL_STATUS_OVF_UNCORE(_)                        (((_) >> 61) & 0x01)
     * [Bit 62] OvfBuf: DS SAVE area Buffer overflow status.
     *
    UINT64 OvfBuf                                                  : 1;
#define IA32_PERF_GLOBAL_STATUS_OVF_BUF_BIT                          62
#define IA32_PERF_GLOBAL_STATUS_OVF_BUF_FLAG                         0x4000000000000000
#define IA32_PERF_GLOBAL_STATUS_OVF_BUF_MASK                         0x01
#define IA32_PERF_GLOBAL_STATUS_OVF_BUF(_)                           (((_) >> 62) & 0x01)
     * [Bit 63] CondChgd: Status bits of this register have changed.
     *
    UINT64 CondChgd                                                : 1;
#define IA32_PERF_GLOBAL_STATUS_COND_CHGD_BIT                        63
#define IA32_PERF_GLOBAL_STATUS_COND_CHGD_FLAG                       0x8000000000000000
#define IA32_PERF_GLOBAL_STATUS_COND_CHGD_MASK                       0x01
#define IA32_PERF_GLOBAL_STATUS_COND_CHGD(_)                         (((_) >> 63) & 0x01)
  };
  UINT64 AsUInt;
} IA32_PERF_GLOBAL_STATUS_REGISTER;*/
return true
}

func (i *ia32)     * [Bits 31:0] EN_PMC()(ok bool){//col:10219
/*     * [Bits 31:0] EN_PMC(n). Enable bitmask. Only the first n-1 bits are valid. Bits 31:n are reserved.
     *
    UINT64 EnPmcn                                                  : 32;
#define IA32_PERF_GLOBAL_CTRL_EN_PMCN_BIT                            0
#define IA32_PERF_GLOBAL_CTRL_EN_PMCN_FLAG                           0xFFFFFFFF
#define IA32_PERF_GLOBAL_CTRL_EN_PMCN_MASK                           0xFFFFFFFF
#define IA32_PERF_GLOBAL_CTRL_EN_PMCN(_)                             (((_) >> 0) & 0xFFFFFFFF)
     * [Bits 63:32] EN_FIXED_CTR(n). Enable bitmask. Only the first n-1 bits are valid. Bits 31:n are reserved.
     *
    UINT64 EnFixedCtrn                                             : 32;
#define IA32_PERF_GLOBAL_CTRL_EN_FIXED_CTRN_BIT                      32
#define IA32_PERF_GLOBAL_CTRL_EN_FIXED_CTRN_FLAG                     0xFFFFFFFF00000000
#define IA32_PERF_GLOBAL_CTRL_EN_FIXED_CTRN_MASK                     0xFFFFFFFF
#define IA32_PERF_GLOBAL_CTRL_EN_FIXED_CTRN(_)                       (((_) >> 32) & 0xFFFFFFFF)
  };
  UINT64 AsUInt;
} IA32_PERF_GLOBAL_CTRL_REGISTER;*/
return true
}

func (i *ia32)     * [Bits 31:0] Set 1 to clear Ovf_PMC()(ok bool){//col:10336
/*     * [Bits 31:0] Set 1 to clear Ovf_PMC(n) bit. Clear bitmask. Only the first n-1 bits are valid. Bits 31:n are reserved.
     *
    UINT64 ClearOvfPmcn                                            : 32;
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_PMCN_BIT             0
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_PMCN_FLAG            0xFFFFFFFF
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_PMCN_MASK            0xFFFFFFFF
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_PMCN(_)              (((_) >> 0) & 0xFFFFFFFF)
     * [Bits 34:32] Set 1 to clear Ovf_FIXED_CTR(n) bit. Clear bitmask. Only the first n-1 bits are valid. Bits 31:n are
     * reserved.
     *
    UINT64 ClearOvfFixedCtrn                                       : 3;
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_FIXED_CTRN_BIT       32
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_FIXED_CTRN_FLAG      0x700000000
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_FIXED_CTRN_MASK      0x07
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_FIXED_CTRN(_)        (((_) >> 32) & 0x07)
    UINT64 Reserved1                                               : 20;
     * [Bit 55] Set 1 to clear Trace_ToPA_PMI bit.
     *
    UINT64 ClearTraceTopaPmi                                       : 1;
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_TRACE_TOPA_PMI_BIT       55
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_TRACE_TOPA_PMI_FLAG      0x80000000000000
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_TRACE_TOPA_PMI_MASK      0x01
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_TRACE_TOPA_PMI(_)        (((_) >> 55) & 0x01)
    UINT64 Reserved2                                               : 2;
     * [Bit 58] Set 1 to clear LBR_Frz bit.
     *
    UINT64 ClearLbrFrz                                             : 1;
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_LBR_FRZ_BIT              58
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_LBR_FRZ_FLAG             0x400000000000000
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_LBR_FRZ_MASK             0x01
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_LBR_FRZ(_)               (((_) >> 58) & 0x01)
     * [Bit 59] Set 1 to clear CTR_Frz bit.
     *
    UINT64 ClearCtrFrz                                             : 1;
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_CTR_FRZ_BIT              59
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_CTR_FRZ_FLAG             0x800000000000000
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_CTR_FRZ_MASK             0x01
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_CTR_FRZ(_)               (((_) >> 59) & 0x01)
     * [Bit 60] Set 1 to clear ASCI bit.
     *
    UINT64 ClearAsci                                               : 1;
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_ASCI_BIT                 60
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_ASCI_FLAG                0x1000000000000000
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_ASCI_MASK                0x01
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_ASCI(_)                  (((_) >> 60) & 0x01)
     * [Bit 61] Set 1 to clear Ovf_Uncore bit.
     *
    UINT64 ClearOvfUncore                                          : 1;
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_UNCORE_BIT           61
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_UNCORE_FLAG          0x2000000000000000
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_UNCORE_MASK          0x01
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_UNCORE(_)            (((_) >> 61) & 0x01)
     * [Bit 62] Set 1 to clear OvfBuf bit.
     *
    UINT64 ClearOvfBuf                                             : 1;
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_BUF_BIT              62
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_BUF_FLAG             0x4000000000000000
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_BUF_MASK             0x01
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_BUF(_)               (((_) >> 62) & 0x01)
     * [Bit 63] Set 1 to clear CondChgd bit.
     *
    UINT64 ClearCondChgd                                           : 1;
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_COND_CHGD_BIT            63
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_COND_CHGD_FLAG           0x8000000000000000
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_COND_CHGD_MASK           0x01
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_COND_CHGD(_)             (((_) >> 63) & 0x01)
  };
  UINT64 AsUInt;
} IA32_PERF_GLOBAL_STATUS_RESET_REGISTER;*/
return true
}

func (i *ia32)     * [Bits 31:0] Set 1 to cause Ovf_PMC()(ok bool){//col:10443
/*     * [Bits 31:0] Set 1 to cause Ovf_PMC(n) = 1. Set bitmask. Only the first n-1 bits are valid. Bits 31:n are reserved.
     *
    UINT64 OvfPmcn                                                 : 32;
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_PMCN_BIT                     0
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_PMCN_FLAG                    0xFFFFFFFF
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_PMCN_MASK                    0xFFFFFFFF
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_PMCN(_)                      (((_) >> 0) & 0xFFFFFFFF)
     * [Bits 34:32] Set 1 to cause Ovf_FIXED_CTR(n) = 1. Set bitmask. Only the first n-1 bits are valid. Bits 31:n are
     * reserved.
     *
    UINT64 OvfFixedCtrn                                            : 3;
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_FIXED_CTRN_BIT               32
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_FIXED_CTRN_FLAG              0x700000000
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_FIXED_CTRN_MASK              0x07
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_FIXED_CTRN(_)                (((_) >> 32) & 0x07)
    UINT64 Reserved1                                               : 20;
     * [Bit 55] Set 1 to cause Trace_ToPA_PMI = 1.
     *
    UINT64 TraceTopaPmi                                            : 1;
#define IA32_PERF_GLOBAL_STATUS_SET_TRACE_TOPA_PMI_BIT               55
#define IA32_PERF_GLOBAL_STATUS_SET_TRACE_TOPA_PMI_FLAG              0x80000000000000
#define IA32_PERF_GLOBAL_STATUS_SET_TRACE_TOPA_PMI_MASK              0x01
#define IA32_PERF_GLOBAL_STATUS_SET_TRACE_TOPA_PMI(_)                (((_) >> 55) & 0x01)
    UINT64 Reserved2                                               : 2;
     * [Bit 58] Set 1 to cause LBR_Frz = 1.
     *
    UINT64 LbrFrz                                                  : 1;
#define IA32_PERF_GLOBAL_STATUS_SET_LBR_FRZ_BIT                      58
#define IA32_PERF_GLOBAL_STATUS_SET_LBR_FRZ_FLAG                     0x400000000000000
#define IA32_PERF_GLOBAL_STATUS_SET_LBR_FRZ_MASK                     0x01
#define IA32_PERF_GLOBAL_STATUS_SET_LBR_FRZ(_)                       (((_) >> 58) & 0x01)
     * [Bit 59] Set 1 to cause CTR_Frz = 1.
     *
    UINT64 CtrFrz                                                  : 1;
#define IA32_PERF_GLOBAL_STATUS_SET_CTR_FRZ_BIT                      59
#define IA32_PERF_GLOBAL_STATUS_SET_CTR_FRZ_FLAG                     0x800000000000000
#define IA32_PERF_GLOBAL_STATUS_SET_CTR_FRZ_MASK                     0x01
#define IA32_PERF_GLOBAL_STATUS_SET_CTR_FRZ(_)                       (((_) >> 59) & 0x01)
     * [Bit 60] Set 1 to cause ASCI = 1.
     *
    UINT64 Asci                                                    : 1;
#define IA32_PERF_GLOBAL_STATUS_SET_ASCI_BIT                         60
#define IA32_PERF_GLOBAL_STATUS_SET_ASCI_FLAG                        0x1000000000000000
#define IA32_PERF_GLOBAL_STATUS_SET_ASCI_MASK                        0x01
#define IA32_PERF_GLOBAL_STATUS_SET_ASCI(_)                          (((_) >> 60) & 0x01)
     * [Bit 61] Set 1 to cause Ovf_Uncore = 1.
     *
    UINT64 OvfUncore                                               : 1;
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_UNCORE_BIT                   61
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_UNCORE_FLAG                  0x2000000000000000
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_UNCORE_MASK                  0x01
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_UNCORE(_)                    (((_) >> 61) & 0x01)
     * [Bit 62] Set 1 to cause OvfBuf = 1.
     *
    UINT64 OvfBuf                                                  : 1;
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_BUF_BIT                      62
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_BUF_FLAG                     0x4000000000000000
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_BUF_MASK                     0x01
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_BUF(_)                       (((_) >> 62) & 0x01)
    UINT64 Reserved3                                               : 1;
  };
  UINT64 AsUInt;
} IA32_PERF_GLOBAL_STATUS_SET_REGISTER;*/
return true
}

func (i *ia32)     * [Bits 31:0] IA32_PERFEVTSEL()(ok bool){//col:10488
/*     * [Bits 31:0] IA32_PERFEVTSEL(n) in use. Status bitmask. Only the first n-1 bits are valid. Bits 31:n are reserved.
     *
    UINT64 Ia32PerfevtselnInUse                                    : 32;
#define IA32_PERF_GLOBAL_INUSE_IA32_PERFEVTSELN_IN_USE_BIT           0
#define IA32_PERF_GLOBAL_INUSE_IA32_PERFEVTSELN_IN_USE_FLAG          0xFFFFFFFF
#define IA32_PERF_GLOBAL_INUSE_IA32_PERFEVTSELN_IN_USE_MASK          0xFFFFFFFF
#define IA32_PERF_GLOBAL_INUSE_IA32_PERFEVTSELN_IN_USE(_)            (((_) >> 0) & 0xFFFFFFFF)
     * [Bits 34:32] IA32_FIXED_CTR(n) in use. Status bitmask. Only the first n-1 bits are valid. Bits 31:n are reserved.
    UINT64 Ia32FixedCtrnInUse                                      : 3;
#define IA32_PERF_GLOBAL_INUSE_IA32_FIXED_CTRN_IN_USE_BIT            32
#define IA32_PERF_GLOBAL_INUSE_IA32_FIXED_CTRN_IN_USE_FLAG           0x700000000
#define IA32_PERF_GLOBAL_INUSE_IA32_FIXED_CTRN_IN_USE_MASK           0x07
#define IA32_PERF_GLOBAL_INUSE_IA32_FIXED_CTRN_IN_USE(_)             (((_) >> 32) & 0x07)
    UINT64 Reserved1                                               : 28;
     * [Bit 63] PMI in use.
    UINT64 PmiInUse                                                : 1;
#define IA32_PERF_GLOBAL_INUSE_PMI_IN_USE_BIT                        63
#define IA32_PERF_GLOBAL_INUSE_PMI_IN_USE_FLAG                       0x8000000000000000
#define IA32_PERF_GLOBAL_INUSE_PMI_IN_USE_MASK                       0x01
#define IA32_PERF_GLOBAL_INUSE_PMI_IN_USE(_)                         (((_) >> 63) & 0x01)
  };
  UINT64 AsUInt;
} IA32_PERF_GLOBAL_INUSE_REGISTER;*/
return true
}

func (i *ia32)#define IA32_PEBS_ENABLE_ENABLE_PEBS()(ok bool){//col:10534
/*#define IA32_PEBS_ENABLE_ENABLE_PEBS(_)                              (((_) >> 0) & 0x01)
     * [Bits 3:1] Reserved or model specific.
    UINT64 Reservedormodelspecific1                                : 3;
#define IA32_PEBS_ENABLE_RESERVEDORMODELSPECIFIC1_BIT                1
#define IA32_PEBS_ENABLE_RESERVEDORMODELSPECIFIC1_FLAG               0x0E
#define IA32_PEBS_ENABLE_RESERVEDORMODELSPECIFIC1_MASK               0x07
#define IA32_PEBS_ENABLE_RESERVEDORMODELSPECIFIC1(_)                 (((_) >> 1) & 0x07)
    UINT64 Reserved1                                               : 28;
     * [Bits 35:32] Reserved or model specific.
    UINT64 Reservedormodelspecific2                                : 4;
#define IA32_PEBS_ENABLE_RESERVEDORMODELSPECIFIC2_BIT                32
#define IA32_PEBS_ENABLE_RESERVEDORMODELSPECIFIC2_FLAG               0xF00000000
#define IA32_PEBS_ENABLE_RESERVEDORMODELSPECIFIC2_MASK               0x0F
#define IA32_PEBS_ENABLE_RESERVEDORMODELSPECIFIC2(_)                 (((_) >> 32) & 0x0F)
    UINT64 Reserved2                                               : 28;
  };
  UINT64 AsUInt;
} IA32_PEBS_ENABLE_REGISTER;*/
return true
}

func (i *ia32) *           IA32_MC()(ok bool){//col:10835
/* *           IA32_MC(i)_CTL
 *
 * IA32_MC(0-28)_CTL.
 *
#define IA32_MC0_CTL                                                 0x00000400
#define IA32_MC1_CTL                                                 0x00000404
#define IA32_MC2_CTL                                                 0x00000408
#define IA32_MC3_CTL                                                 0x0000040C
#define IA32_MC4_CTL                                                 0x00000410
#define IA32_MC5_CTL                                                 0x00000414
#define IA32_MC6_CTL                                                 0x00000418
#define IA32_MC7_CTL                                                 0x0000041C
#define IA32_MC8_CTL                                                 0x00000420
#define IA32_MC9_CTL                                                 0x00000424
#define IA32_MC10_CTL                                                0x00000428
#define IA32_MC11_CTL                                                0x0000042C
#define IA32_MC12_CTL                                                0x00000430
#define IA32_MC13_CTL                                                0x00000434
#define IA32_MC14_CTL                                                0x00000438
#define IA32_MC15_CTL                                                0x0000043C
#define IA32_MC16_CTL                                                0x00000440
#define IA32_MC17_CTL                                                0x00000444
#define IA32_MC18_CTL                                                0x00000448
#define IA32_MC19_CTL                                                0x0000044C
#define IA32_MC20_CTL                                                0x00000450
#define IA32_MC21_CTL                                                0x00000454
#define IA32_MC22_CTL                                                0x00000458
#define IA32_MC23_CTL                                                0x0000045C
#define IA32_MC24_CTL                                                0x00000460
#define IA32_MC25_CTL                                                0x00000464
#define IA32_MC26_CTL                                                0x00000468
#define IA32_MC27_CTL                                                0x0000046C
#define IA32_MC28_CTL                                                0x00000470
 *           IA32_MC(i)_STATUS
 *
 * IA32_MC(0-28)_STATUS.
 *
#define IA32_MC0_STATUS                                              0x00000401
#define IA32_MC1_STATUS                                              0x00000405
#define IA32_MC2_STATUS                                              0x00000409
#define IA32_MC3_STATUS                                              0x0000040D
#define IA32_MC4_STATUS                                              0x00000411
#define IA32_MC5_STATUS                                              0x00000415
#define IA32_MC6_STATUS                                              0x00000419
#define IA32_MC7_STATUS                                              0x0000041D
#define IA32_MC8_STATUS                                              0x00000421
#define IA32_MC9_STATUS                                              0x00000425
#define IA32_MC10_STATUS                                             0x00000429
#define IA32_MC11_STATUS                                             0x0000042D
#define IA32_MC12_STATUS                                             0x00000431
#define IA32_MC13_STATUS                                             0x00000435
#define IA32_MC14_STATUS                                             0x00000439
#define IA32_MC15_STATUS                                             0x0000043D
#define IA32_MC16_STATUS                                             0x00000441
#define IA32_MC17_STATUS                                             0x00000445
#define IA32_MC18_STATUS                                             0x00000449
#define IA32_MC19_STATUS                                             0x0000044D
#define IA32_MC20_STATUS                                             0x00000451
#define IA32_MC21_STATUS                                             0x00000455
#define IA32_MC22_STATUS                                             0x00000459
#define IA32_MC23_STATUS                                             0x0000045D
#define IA32_MC24_STATUS                                             0x00000461
#define IA32_MC25_STATUS                                             0x00000465
#define IA32_MC26_STATUS                                             0x00000469
#define IA32_MC27_STATUS                                             0x0000046D
#define IA32_MC28_STATUS                                             0x00000471
 *           IA32_MC(i)_ADDR
 *
 * IA32_MC(0-28)_ADDR.
 *
#define IA32_MC0_ADDR                                                0x00000402
#define IA32_MC1_ADDR                                                0x00000406
#define IA32_MC2_ADDR                                                0x0000040A
#define IA32_MC3_ADDR                                                0x0000040E
#define IA32_MC4_ADDR                                                0x00000412
#define IA32_MC5_ADDR                                                0x00000416
#define IA32_MC6_ADDR                                                0x0000041A
#define IA32_MC7_ADDR                                                0x0000041E
#define IA32_MC8_ADDR                                                0x00000422
#define IA32_MC9_ADDR                                                0x00000426
#define IA32_MC10_ADDR                                               0x0000042A
#define IA32_MC11_ADDR                                               0x0000042E
#define IA32_MC12_ADDR                                               0x00000432
#define IA32_MC13_ADDR                                               0x00000436
#define IA32_MC14_ADDR                                               0x0000043A
#define IA32_MC15_ADDR                                               0x0000043E
#define IA32_MC16_ADDR                                               0x00000442
#define IA32_MC17_ADDR                                               0x00000446
#define IA32_MC18_ADDR                                               0x0000044A
#define IA32_MC19_ADDR                                               0x0000044E
#define IA32_MC20_ADDR                                               0x00000452
#define IA32_MC21_ADDR                                               0x00000456
#define IA32_MC22_ADDR                                               0x0000045A
#define IA32_MC23_ADDR                                               0x0000045E
#define IA32_MC24_ADDR                                               0x00000462
#define IA32_MC25_ADDR                                               0x00000466
#define IA32_MC26_ADDR                                               0x0000046A
#define IA32_MC27_ADDR                                               0x0000046E
#define IA32_MC28_ADDR                                               0x00000472
 *           IA32_MC(i)_MISC
 *
 * IA32_MC(0-28)_MISC.
 *
#define IA32_MC0_MISC                                                0x00000403
#define IA32_MC1_MISC                                                0x00000407
#define IA32_MC2_MISC                                                0x0000040B
#define IA32_MC3_MISC                                                0x0000040F
#define IA32_MC4_MISC                                                0x00000413
#define IA32_MC5_MISC                                                0x00000417
#define IA32_MC6_MISC                                                0x0000041B
#define IA32_MC7_MISC                                                0x0000041F
#define IA32_MC8_MISC                                                0x00000423
#define IA32_MC9_MISC                                                0x00000427
#define IA32_MC10_MISC                                               0x0000042B
#define IA32_MC11_MISC                                               0x0000042F
#define IA32_MC12_MISC                                               0x00000433
#define IA32_MC13_MISC                                               0x00000437
#define IA32_MC14_MISC                                               0x0000043B
#define IA32_MC15_MISC                                               0x0000043F
#define IA32_MC16_MISC                                               0x00000443
#define IA32_MC17_MISC                                               0x00000447
#define IA32_MC18_MISC                                               0x0000044B
#define IA32_MC19_MISC                                               0x0000044F
#define IA32_MC20_MISC                                               0x00000453
#define IA32_MC21_MISC                                               0x00000457
#define IA32_MC22_MISC                                               0x0000045B
#define IA32_MC23_MISC                                               0x0000045F
#define IA32_MC24_MISC                                               0x00000463
#define IA32_MC25_MISC                                               0x00000467
#define IA32_MC26_MISC                                               0x0000046B
#define IA32_MC27_MISC                                               0x0000046F
#define IA32_MC28_MISC                                               0x00000473
 * Reporting Register of Basic VMX Capabilities.
 *
#define IA32_VMX_BASIC                                               0x00000480
typedef union
{
  struct
  {
     *
     * [Bits 30:0] 31-bit VMCS revision identifier used by the processor. Processors that use the same VMCS revision identifier
     * use the same size for VMCS regions.
    UINT64 VmcsRevisionId                                          : 31;
#define IA32_VMX_BASIC_VMCS_REVISION_ID_BIT                          0
#define IA32_VMX_BASIC_VMCS_REVISION_ID_FLAG                         0x7FFFFFFF
#define IA32_VMX_BASIC_VMCS_REVISION_ID_MASK                         0x7FFFFFFF
#define IA32_VMX_BASIC_VMCS_REVISION_ID(_)                           (((_) >> 0) & 0x7FFFFFFF)
     * [Bit 31] Bit 31 is always 0.
    UINT64 MustBeZero                                              : 1;
#define IA32_VMX_BASIC_MUST_BE_ZERO_BIT                              31
#define IA32_VMX_BASIC_MUST_BE_ZERO_FLAG                             0x80000000
#define IA32_VMX_BASIC_MUST_BE_ZERO_MASK                             0x01
#define IA32_VMX_BASIC_MUST_BE_ZERO(_)                               (((_) >> 31) & 0x01)
     *
     * [Bits 44:32] Report the number of bytes that software should allocate for the VMXON region and any VMCS region. It is a
     * value greater than 0 and at most 4096 (bit 44 is set if and only if bits 43:32 are clear).
    UINT64 VmcsSizeInBytes                                         : 13;
#define IA32_VMX_BASIC_VMCS_SIZE_IN_BYTES_BIT                        32
#define IA32_VMX_BASIC_VMCS_SIZE_IN_BYTES_FLAG                       0x1FFF00000000
#define IA32_VMX_BASIC_VMCS_SIZE_IN_BYTES_MASK                       0x1FFF
#define IA32_VMX_BASIC_VMCS_SIZE_IN_BYTES(_)                         (((_) >> 32) & 0x1FFF)
    UINT64 Reserved1                                               : 3;
     *        - 0 -> limited to the available amount of physical RAM
     *        - 1 -> within the first 4 GB
     *
     * [Bit 48] Indicates the width of the physical addresses that may be used for the VMXON region, each VMCS, and data
     * structures referenced by pointers in a VMCS (I/O bitmaps, virtual-APIC page, MSR areas for VMX transitions). If the bit
     * is 0, these addresses are limited to the processor's physical-address width.2 If the bit is 1, these addresses are
     * limited to 32 bits. This bit is always 0 for processors that support Intel 64 architecture.
    UINT64 VmcsPhysicalAddressWidth                                : 1;
#define IA32_VMX_BASIC_VMCS_PHYSICAL_ADDRESS_WIDTH_BIT               48
#define IA32_VMX_BASIC_VMCS_PHYSICAL_ADDRESS_WIDTH_FLAG              0x1000000000000
#define IA32_VMX_BASIC_VMCS_PHYSICAL_ADDRESS_WIDTH_MASK              0x01
#define IA32_VMX_BASIC_VMCS_PHYSICAL_ADDRESS_WIDTH(_)                (((_) >> 48) & 0x01)
     *        code (always 1)
     *
     * [Bit 49] Read as 1, the logical processor supports the dual-monitor treatment of system-management interrupts and
     * system-management mode.
     *
    UINT64 DualMonitorSupport                                      : 1;
#define IA32_VMX_BASIC_DUAL_MONITOR_SUPPORT_BIT                      49
#define IA32_VMX_BASIC_DUAL_MONITOR_SUPPORT_FLAG                     0x2000000000000
#define IA32_VMX_BASIC_DUAL_MONITOR_SUPPORT_MASK                     0x01
#define IA32_VMX_BASIC_DUAL_MONITOR_SUPPORT(_)                       (((_) >> 49) & 0x01)
     *
     * [Bits 53:50] Report the memory type that should be used for the VMCS, for data structures referenced by pointers in the
     * VMCS (I/O bitmaps, virtual-APIC page, MSR areas for VMX transitions), and for the MSEG header. If software needs to
     * access these data structures (e.g., to modify the contents of the MSR bitmaps), it can configure the paging structures
     * to map them into the linear-address space. If it does so, it should establish mappings that use the memory type reported
     * bits 53:50 in this MSR.
     * As of this writing, all processors that support VMX operation indicate the write-back type.
    UINT64 MemoryType                                              : 4;
#define IA32_VMX_BASIC_MEMORY_TYPE_BIT                               50
#define IA32_VMX_BASIC_MEMORY_TYPE_FLAG                              0x3C000000000000
#define IA32_VMX_BASIC_MEMORY_TYPE_MASK                              0x0F
#define IA32_VMX_BASIC_MEMORY_TYPE(_)                                (((_) >> 50) & 0x0F)
     *
     * [Bit 54] When set to 1, the processor reports information in the VM-exit instruction-information field on VM exits due
     * to execution of the INS and OUTS instructions. This reporting is done only if this bit is read as 1.
     *
    UINT64 InsOutsReporting                                        : 1;
#define IA32_VMX_BASIC_INS_OUTS_REPORTING_BIT                        54
#define IA32_VMX_BASIC_INS_OUTS_REPORTING_FLAG                       0x40000000000000
#define IA32_VMX_BASIC_INS_OUTS_REPORTING_MASK                       0x01
#define IA32_VMX_BASIC_INS_OUTS_REPORTING(_)                         (((_) >> 54) & 0x01)
     *        supported
     *
     * [Bit 55] Is read as 1 if any VMX controls that default to 1 may be cleared to 0. It also reports support for the VMX
     * capability MSRs IA32_VMX_TRUE_PINBASED_CTLS, IA32_VMX_TRUE_PROCBASED_CTLS, IA32_VMX_TRUE_EXIT_CTLS, and
     * IA32_VMX_TRUE_ENTRY_CTLS.
     *
    UINT64 VmxControls                                             : 1;
#define IA32_VMX_BASIC_VMX_CONTROLS_BIT                              55
#define IA32_VMX_BASIC_VMX_CONTROLS_FLAG                             0x80000000000000
#define IA32_VMX_BASIC_VMX_CONTROLS_MASK                             0x01
#define IA32_VMX_BASIC_VMX_CONTROLS(_)                               (((_) >> 55) & 0x01)
    UINT64 Reserved2                                               : 8;
  };
  UINT64 AsUInt;
} IA32_VMX_BASIC_REGISTER;*/
return true
}

func (i *ia32)     * guest interrupt-descriptor table ()(ok bool){//col:10925
/*     * guest interrupt-descriptor table (IDT). If this control is 1, the value of RFLAGS.IF does not affect interrupt blocking.
    UINT64 ExternalInterruptExiting                                : 1;
#define IA32_VMX_PINBASED_CTLS_EXTERNAL_INTERRUPT_EXITING_BIT        0
#define IA32_VMX_PINBASED_CTLS_EXTERNAL_INTERRUPT_EXITING_FLAG       0x01
#define IA32_VMX_PINBASED_CTLS_EXTERNAL_INTERRUPT_EXITING_MASK       0x01
#define IA32_VMX_PINBASED_CTLS_EXTERNAL_INTERRUPT_EXITING(_)         (((_) >> 0) & 0x01)
    UINT64 Reserved1                                               : 2;
     *
     * [Bit 3] If this control is 1, non-maskable interrupts (NMIs) cause VM exits. Otherwise, they are delivered normally
     * using descriptor 2 of the IDT. This control also determines interactions between IRET and blocking by NMI.
     *
    UINT64 NmiExiting                                              : 1;
#define IA32_VMX_PINBASED_CTLS_NMI_EXITING_BIT                       3
#define IA32_VMX_PINBASED_CTLS_NMI_EXITING_FLAG                      0x08
#define IA32_VMX_PINBASED_CTLS_NMI_EXITING_MASK                      0x01
#define IA32_VMX_PINBASED_CTLS_NMI_EXITING(_)                        (((_) >> 3) & 0x01)
    UINT64 Reserved2                                               : 1;
     *
     * [Bit 5] If this control is 1, NMIs are never blocked and the "blocking by NMI" bit (bit 3) in the interruptibility-state
     * field indicates "virtual-NMI blocking". This control also interacts with the "NMI-window exiting" VM-execution control.
     *
    UINT64 VirtualNmi                                              : 1;
#define IA32_VMX_PINBASED_CTLS_VIRTUAL_NMI_BIT                       5
#define IA32_VMX_PINBASED_CTLS_VIRTUAL_NMI_FLAG                      0x20
#define IA32_VMX_PINBASED_CTLS_VIRTUAL_NMI_MASK                      0x01
#define IA32_VMX_PINBASED_CTLS_VIRTUAL_NMI(_)                        (((_) >> 5) & 0x01)
     *
     * [Bit 6] If this control is 1, the VMX-preemption timer counts down in VMX non-root operation. A VM exit occurs when the
     * timer counts down to zero.
     *
    UINT64 ActivateVmxPreemptionTimer                              : 1;
#define IA32_VMX_PINBASED_CTLS_ACTIVATE_VMX_PREEMPTION_TIMER_BIT     6
#define IA32_VMX_PINBASED_CTLS_ACTIVATE_VMX_PREEMPTION_TIMER_FLAG    0x40
#define IA32_VMX_PINBASED_CTLS_ACTIVATE_VMX_PREEMPTION_TIMER_MASK    0x01
#define IA32_VMX_PINBASED_CTLS_ACTIVATE_VMX_PREEMPTION_TIMER(_)      (((_) >> 6) & 0x01)
     *
     * [Bit 7] If this control is 1, the processor treats interrupts with the posted-interrupt notification vector specially,
     * updating the virtual-APIC page with posted-interrupt requests.
     *
    UINT64 ProcessPostedInterrupts                                 : 1;
#define IA32_VMX_PINBASED_CTLS_PROCESS_POSTED_INTERRUPTS_BIT         7
#define IA32_VMX_PINBASED_CTLS_PROCESS_POSTED_INTERRUPTS_FLAG        0x80
#define IA32_VMX_PINBASED_CTLS_PROCESS_POSTED_INTERRUPTS_MASK        0x01
#define IA32_VMX_PINBASED_CTLS_PROCESS_POSTED_INTERRUPTS(_)          (((_) >> 7) & 0x01)
    UINT64 Reserved3                                               : 56;
  };
  UINT64 AsUInt;
} IA32_VMX_PINBASED_CTLS_REGISTER;*/
return true
}

func (i *ia32)#define IA32_VMX_PROCBASED_CTLS_INTERRUPT_WINDOW_EXITING()(ok bool){//col:11225
/*#define IA32_VMX_PROCBASED_CTLS_INTERRUPT_WINDOW_EXITING(_)          (((_) >> 2) & 0x01)
     *
     * [Bit 3] This control determines whether executions of RDTSC, executions of RDTSCP, and executions of RDMSR that read
     * from the IA32_TIME_STAMP_COUNTER MSR return a value modified by the TSC offset field.
     *
    UINT64 UseTscOffsetting                                        : 1;
#define IA32_VMX_PROCBASED_CTLS_USE_TSC_OFFSETTING_BIT               3
#define IA32_VMX_PROCBASED_CTLS_USE_TSC_OFFSETTING_FLAG              0x08
#define IA32_VMX_PROCBASED_CTLS_USE_TSC_OFFSETTING_MASK              0x01
#define IA32_VMX_PROCBASED_CTLS_USE_TSC_OFFSETTING(_)                (((_) >> 3) & 0x01)
    UINT64 Reserved2                                               : 3;
     *
     * [Bit 7] This control determines whether executions of HLT cause VM exits.
    UINT64 HltExiting                                              : 1;
#define IA32_VMX_PROCBASED_CTLS_HLT_EXITING_BIT                      7
#define IA32_VMX_PROCBASED_CTLS_HLT_EXITING_FLAG                     0x80
#define IA32_VMX_PROCBASED_CTLS_HLT_EXITING_MASK                     0x01
#define IA32_VMX_PROCBASED_CTLS_HLT_EXITING(_)                       (((_) >> 7) & 0x01)
    UINT64 Reserved3                                               : 1;
     *
     * [Bit 9] This control determines whether executions of INVLPG cause VM exits.
    UINT64 InvlpgExiting                                           : 1;
#define IA32_VMX_PROCBASED_CTLS_INVLPG_EXITING_BIT                   9
#define IA32_VMX_PROCBASED_CTLS_INVLPG_EXITING_FLAG                  0x200
#define IA32_VMX_PROCBASED_CTLS_INVLPG_EXITING_MASK                  0x01
#define IA32_VMX_PROCBASED_CTLS_INVLPG_EXITING(_)                    (((_) >> 9) & 0x01)
     *
     * [Bit 10] This control determines whether executions of MWAIT cause VM exits.
    UINT64 MwaitExiting                                            : 1;
#define IA32_VMX_PROCBASED_CTLS_MWAIT_EXITING_BIT                    10
#define IA32_VMX_PROCBASED_CTLS_MWAIT_EXITING_FLAG                   0x400
#define IA32_VMX_PROCBASED_CTLS_MWAIT_EXITING_MASK                   0x01
#define IA32_VMX_PROCBASED_CTLS_MWAIT_EXITING(_)                     (((_) >> 10) & 0x01)
     *
     * [Bit 11] This control determines whether executions of RDPMC cause VM exits.
    UINT64 RdpmcExiting                                            : 1;
#define IA32_VMX_PROCBASED_CTLS_RDPMC_EXITING_BIT                    11
#define IA32_VMX_PROCBASED_CTLS_RDPMC_EXITING_FLAG                   0x800
#define IA32_VMX_PROCBASED_CTLS_RDPMC_EXITING_MASK                   0x01
#define IA32_VMX_PROCBASED_CTLS_RDPMC_EXITING(_)                     (((_) >> 11) & 0x01)
     *
     * [Bit 12] This control determines whether executions of RDTSC and RDTSCP cause VM exits.
    UINT64 RdtscExiting                                            : 1;
#define IA32_VMX_PROCBASED_CTLS_RDTSC_EXITING_BIT                    12
#define IA32_VMX_PROCBASED_CTLS_RDTSC_EXITING_FLAG                   0x1000
#define IA32_VMX_PROCBASED_CTLS_RDTSC_EXITING_MASK                   0x01
#define IA32_VMX_PROCBASED_CTLS_RDTSC_EXITING(_)                     (((_) >> 12) & 0x01)
    UINT64 Reserved4                                               : 2;
     *        includes the newest Nehalem CPUs)
     *
     * [Bit 15] In conjunction with the CR3-target controls, this control determines whether executions of MOV to CR3 cause VM
     * exits. The first processors to support the virtual-machine extensions supported only the 1-setting of this control.
     *
    UINT64 Cr3LoadExiting                                          : 1;
#define IA32_VMX_PROCBASED_CTLS_CR3_LOAD_EXITING_BIT                 15
#define IA32_VMX_PROCBASED_CTLS_CR3_LOAD_EXITING_FLAG                0x8000
#define IA32_VMX_PROCBASED_CTLS_CR3_LOAD_EXITING_MASK                0x01
#define IA32_VMX_PROCBASED_CTLS_CR3_LOAD_EXITING(_)                  (((_) >> 15) & 0x01)
     *        includes the newest Nehalem CPUs)
     *
     * [Bit 16] This control determines whether executions of MOV from CR3 cause VM exits. The first processors to support the
     * virtual-machine extensions supported only the 1-setting of this control.
    UINT64 Cr3StoreExiting                                         : 1;
#define IA32_VMX_PROCBASED_CTLS_CR3_STORE_EXITING_BIT                16
#define IA32_VMX_PROCBASED_CTLS_CR3_STORE_EXITING_FLAG               0x10000
#define IA32_VMX_PROCBASED_CTLS_CR3_STORE_EXITING_MASK               0x01
#define IA32_VMX_PROCBASED_CTLS_CR3_STORE_EXITING(_)                 (((_) >> 16) & 0x01)
     *
     * [Bit 17] This control determines whether the tertiary processor-based VM-execution controls are used. If this control is
     * 0, the logical processor operates as if all the tertiary processor-based VM-execution controls were also 0.
    UINT64 ActivateTertiaryControls                                : 1;
#define IA32_VMX_PROCBASED_CTLS_ACTIVATE_TERTIARY_CONTROLS_BIT       17
#define IA32_VMX_PROCBASED_CTLS_ACTIVATE_TERTIARY_CONTROLS_FLAG      0x20000
#define IA32_VMX_PROCBASED_CTLS_ACTIVATE_TERTIARY_CONTROLS_MASK      0x01
#define IA32_VMX_PROCBASED_CTLS_ACTIVATE_TERTIARY_CONTROLS(_)        (((_) >> 17) & 0x01)
    UINT64 Reserved5                                               : 1;
     *
     * [Bit 19] This control determines whether executions of MOV to CR8 cause VM exits.
    UINT64 Cr8LoadExiting                                          : 1;
#define IA32_VMX_PROCBASED_CTLS_CR8_LOAD_EXITING_BIT                 19
#define IA32_VMX_PROCBASED_CTLS_CR8_LOAD_EXITING_FLAG                0x80000
#define IA32_VMX_PROCBASED_CTLS_CR8_LOAD_EXITING_MASK                0x01
#define IA32_VMX_PROCBASED_CTLS_CR8_LOAD_EXITING(_)                  (((_) >> 19) & 0x01)
     *
     * [Bit 20] This control determines whether executions of MOV from CR8 cause VM exits.
    UINT64 Cr8StoreExiting                                         : 1;
#define IA32_VMX_PROCBASED_CTLS_CR8_STORE_EXITING_BIT                20
#define IA32_VMX_PROCBASED_CTLS_CR8_STORE_EXITING_FLAG               0x100000
#define IA32_VMX_PROCBASED_CTLS_CR8_STORE_EXITING_MASK               0x01
#define IA32_VMX_PROCBASED_CTLS_CR8_STORE_EXITING(_)                 (((_) >> 20) & 0x01)
     *
     * [Bit 21] Setting this control to 1 enables TPR virtualization and other APIC-virtualization features.
     *
    UINT64 UseTprShadow                                            : 1;
#define IA32_VMX_PROCBASED_CTLS_USE_TPR_SHADOW_BIT                   21
#define IA32_VMX_PROCBASED_CTLS_USE_TPR_SHADOW_FLAG                  0x200000
#define IA32_VMX_PROCBASED_CTLS_USE_TPR_SHADOW_MASK                  0x01
#define IA32_VMX_PROCBASED_CTLS_USE_TPR_SHADOW(_)                    (((_) >> 21) & 0x01)
     *
     * [Bit 22] If this control is 1, a VM exit occurs at the beginning of any instruction if there is no virtual-NMI blocking.
     *
    UINT64 NmiWindowExiting                                        : 1;
#define IA32_VMX_PROCBASED_CTLS_NMI_WINDOW_EXITING_BIT               22
#define IA32_VMX_PROCBASED_CTLS_NMI_WINDOW_EXITING_FLAG              0x400000
#define IA32_VMX_PROCBASED_CTLS_NMI_WINDOW_EXITING_MASK              0x01
#define IA32_VMX_PROCBASED_CTLS_NMI_WINDOW_EXITING(_)                (((_) >> 22) & 0x01)
     *
     * [Bit 23] This control determines whether executions of MOV DR cause VM exits.
    UINT64 MovDrExiting                                            : 1;
#define IA32_VMX_PROCBASED_CTLS_MOV_DR_EXITING_BIT                   23
#define IA32_VMX_PROCBASED_CTLS_MOV_DR_EXITING_FLAG                  0x800000
#define IA32_VMX_PROCBASED_CTLS_MOV_DR_EXITING_MASK                  0x01
#define IA32_VMX_PROCBASED_CTLS_MOV_DR_EXITING(_)                    (((_) >> 23) & 0x01)
     *
     * [Bit 24] This control determines whether executions of I/O instructions (IN, INS/INSB/INSW/INSD, OUT, and
     * OUTS/OUTSB/OUTSW/OUTSD) cause VM exits.
    UINT64 UnconditionalIoExiting                                  : 1;
#define IA32_VMX_PROCBASED_CTLS_UNCONDITIONAL_IO_EXITING_BIT         24
#define IA32_VMX_PROCBASED_CTLS_UNCONDITIONAL_IO_EXITING_FLAG        0x1000000
#define IA32_VMX_PROCBASED_CTLS_UNCONDITIONAL_IO_EXITING_MASK        0x01
#define IA32_VMX_PROCBASED_CTLS_UNCONDITIONAL_IO_EXITING(_)          (((_) >> 24) & 0x01)
     *
     * [Bit 25] This control determines whether I/O bitmaps are used to restrict executions of I/O instructions For this
     * control, "0" means "do not use I/O bitmaps" and "1" means "use I/O bitmaps." If the I/O bitmaps are used, the setting of
     * the "unconditional I/O exiting" control is ignored.
     *
    UINT64 UseIoBitmaps                                            : 1;
#define IA32_VMX_PROCBASED_CTLS_USE_IO_BITMAPS_BIT                   25
#define IA32_VMX_PROCBASED_CTLS_USE_IO_BITMAPS_FLAG                  0x2000000
#define IA32_VMX_PROCBASED_CTLS_USE_IO_BITMAPS_MASK                  0x01
#define IA32_VMX_PROCBASED_CTLS_USE_IO_BITMAPS(_)                    (((_) >> 25) & 0x01)
    UINT64 Reserved6                                               : 1;
     *
     * [Bit 27] If this control is 1, the monitor trap flag debugging feature is enabled.
     *
    UINT64 MonitorTrapFlag                                         : 1;
#define IA32_VMX_PROCBASED_CTLS_MONITOR_TRAP_FLAG_BIT                27
#define IA32_VMX_PROCBASED_CTLS_MONITOR_TRAP_FLAG_FLAG               0x8000000
#define IA32_VMX_PROCBASED_CTLS_MONITOR_TRAP_FLAG_MASK               0x01
#define IA32_VMX_PROCBASED_CTLS_MONITOR_TRAP_FLAG(_)                 (((_) >> 27) & 0x01)
     *
     * [Bit 28] This control determines whether MSR bitmaps are used to control execution of the RDMSR and WRMSR instructions.
     * For this control, "0" means "do not use MSR bitmaps" and "1" means "use MSR bitmaps." If the MSR bitmaps are not used,
     * all executions of the RDMSR and WRMSR instructions cause VM exits.
     *
    UINT64 UseMsrBitmaps                                           : 1;
#define IA32_VMX_PROCBASED_CTLS_USE_MSR_BITMAPS_BIT                  28
#define IA32_VMX_PROCBASED_CTLS_USE_MSR_BITMAPS_FLAG                 0x10000000
#define IA32_VMX_PROCBASED_CTLS_USE_MSR_BITMAPS_MASK                 0x01
#define IA32_VMX_PROCBASED_CTLS_USE_MSR_BITMAPS(_)                   (((_) >> 28) & 0x01)
     *
     * [Bit 29] This control determines whether executions of MONITOR cause VM exits.
    UINT64 MonitorExiting                                          : 1;
#define IA32_VMX_PROCBASED_CTLS_MONITOR_EXITING_BIT                  29
#define IA32_VMX_PROCBASED_CTLS_MONITOR_EXITING_FLAG                 0x20000000
#define IA32_VMX_PROCBASED_CTLS_MONITOR_EXITING_MASK                 0x01
#define IA32_VMX_PROCBASED_CTLS_MONITOR_EXITING(_)                   (((_) >> 29) & 0x01)
     *
     * [Bit 30] This control determines whether executions of PAUSE cause VM exits.
    UINT64 PauseExiting                                            : 1;
#define IA32_VMX_PROCBASED_CTLS_PAUSE_EXITING_BIT                    30
#define IA32_VMX_PROCBASED_CTLS_PAUSE_EXITING_FLAG                   0x40000000
#define IA32_VMX_PROCBASED_CTLS_PAUSE_EXITING_MASK                   0x01
#define IA32_VMX_PROCBASED_CTLS_PAUSE_EXITING(_)                     (((_) >> 30) & 0x01)
     *
     * [Bit 31] This control determines whether the secondary processor-based VM-execution controls are used. If this control
     * is 0, the logical processor operates as if all the secondary processor-based VM-execution controls were also 0.
    UINT64 ActivateSecondaryControls                               : 1;
#define IA32_VMX_PROCBASED_CTLS_ACTIVATE_SECONDARY_CONTROLS_BIT      31
#define IA32_VMX_PROCBASED_CTLS_ACTIVATE_SECONDARY_CONTROLS_FLAG     0x80000000
#define IA32_VMX_PROCBASED_CTLS_ACTIVATE_SECONDARY_CONTROLS_MASK     0x01
#define IA32_VMX_PROCBASED_CTLS_ACTIVATE_SECONDARY_CONTROLS(_)       (((_) >> 31) & 0x01)
    UINT64 Reserved7                                               : 32;
  };
  UINT64 AsUInt;
} IA32_VMX_PROCBASED_CTLS_REGISTER;*/
return true
}

func (i *ia32)#define IA32_VMX_EXIT_CTLS_SAVE_DEBUG_CONTROLS()(ok bool){//col:11429
/*#define IA32_VMX_EXIT_CTLS_SAVE_DEBUG_CONTROLS(_)                    (((_) >> 2) & 0x01)
    UINT64 Reserved2                                               : 6;
     *
     * [Bit 9] On processors that support Intel 64 architecture, this control determines whether a logical processor is in
     * 64-bit mode after the next VM exit. Its value is loaded into CS.L, IA32_EFER.LME, and IA32_EFER.LMA on every VM exit.1
     * This control must be 0 on processors that do not support Intel 64 architecture.
    UINT64 HostAddressSpaceSize                                    : 1;
#define IA32_VMX_EXIT_CTLS_HOST_ADDRESS_SPACE_SIZE_BIT               9
#define IA32_VMX_EXIT_CTLS_HOST_ADDRESS_SPACE_SIZE_FLAG              0x200
#define IA32_VMX_EXIT_CTLS_HOST_ADDRESS_SPACE_SIZE_MASK              0x01
#define IA32_VMX_EXIT_CTLS_HOST_ADDRESS_SPACE_SIZE(_)                (((_) >> 9) & 0x01)
    UINT64 Reserved3                                               : 2;
     *
     * [Bit 12] This control determines whether the IA32_PERF_GLOBAL_CTRL MSR is loaded on VM exit.
    UINT64 LoadIa32PerfGlobalCtrl                                  : 1;
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_PERF_GLOBAL_CTRL_BIT            12
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_PERF_GLOBAL_CTRL_FLAG           0x1000
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_PERF_GLOBAL_CTRL_MASK           0x01
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_PERF_GLOBAL_CTRL(_)             (((_) >> 12) & 0x01)
    UINT64 Reserved4                                               : 2;
     *
     * [Bit 15] This control affects VM exits due to external interrupts:
     * - If such a VM exit occurs and this control is 1, the logical processor acknowledges the interrupt controller, acquiring
     * the interrupt's vector. The vector is stored in the VM-exit interruption-information field, which is marked valid.
     * - If such a VM exit occurs and this control is 0, the interrupt is not acknowledged and the VM-exit
     * interruption-information field is marked invalid.
    UINT64 AcknowledgeInterruptOnExit                              : 1;
#define IA32_VMX_EXIT_CTLS_ACKNOWLEDGE_INTERRUPT_ON_EXIT_BIT         15
#define IA32_VMX_EXIT_CTLS_ACKNOWLEDGE_INTERRUPT_ON_EXIT_FLAG        0x8000
#define IA32_VMX_EXIT_CTLS_ACKNOWLEDGE_INTERRUPT_ON_EXIT_MASK        0x01
#define IA32_VMX_EXIT_CTLS_ACKNOWLEDGE_INTERRUPT_ON_EXIT(_)          (((_) >> 15) & 0x01)
    UINT64 Reserved5                                               : 2;
     *
     * [Bit 18] This control determines whether the IA32_PAT MSR is saved on VM exit.
    UINT64 SaveIa32Pat                                             : 1;
#define IA32_VMX_EXIT_CTLS_SAVE_IA32_PAT_BIT                         18
#define IA32_VMX_EXIT_CTLS_SAVE_IA32_PAT_FLAG                        0x40000
#define IA32_VMX_EXIT_CTLS_SAVE_IA32_PAT_MASK                        0x01
#define IA32_VMX_EXIT_CTLS_SAVE_IA32_PAT(_)                          (((_) >> 18) & 0x01)
     *
     * [Bit 19] This control determines whether the IA32_PAT MSR is loaded on VM exit.
    UINT64 LoadIa32Pat                                             : 1;
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_PAT_BIT                         19
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_PAT_FLAG                        0x80000
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_PAT_MASK                        0x01
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_PAT(_)                          (((_) >> 19) & 0x01)
     *
     * [Bit 20] This control determines whether the IA32_EFER MSR is saved on VM exit.
    UINT64 SaveIa32Efer                                            : 1;
#define IA32_VMX_EXIT_CTLS_SAVE_IA32_EFER_BIT                        20
#define IA32_VMX_EXIT_CTLS_SAVE_IA32_EFER_FLAG                       0x100000
#define IA32_VMX_EXIT_CTLS_SAVE_IA32_EFER_MASK                       0x01
#define IA32_VMX_EXIT_CTLS_SAVE_IA32_EFER(_)                         (((_) >> 20) & 0x01)
     *
     * [Bit 21] This control determines whether the IA32_EFER MSR is loaded on VM exit.
    UINT64 LoadIa32Efer                                            : 1;
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_EFER_BIT                        21
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_EFER_FLAG                       0x200000
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_EFER_MASK                       0x01
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_EFER(_)                         (((_) >> 21) & 0x01)
     *
     * [Bit 22] This control determines whether the value of the VMX-preemption timer is saved on VM exit.
    UINT64 SaveVmxPreemptionTimerValue                             : 1;
#define IA32_VMX_EXIT_CTLS_SAVE_VMX_PREEMPTION_TIMER_VALUE_BIT       22
#define IA32_VMX_EXIT_CTLS_SAVE_VMX_PREEMPTION_TIMER_VALUE_FLAG      0x400000
#define IA32_VMX_EXIT_CTLS_SAVE_VMX_PREEMPTION_TIMER_VALUE_MASK      0x01
#define IA32_VMX_EXIT_CTLS_SAVE_VMX_PREEMPTION_TIMER_VALUE(_)        (((_) >> 22) & 0x01)
     * [Bit 23] This control determines whether the IA32_BNDCFGS MSR is cleared on VM exit.
    UINT64 ClearIa32Bndcfgs                                        : 1;
#define IA32_VMX_EXIT_CTLS_CLEAR_IA32_BNDCFGS_BIT                    23
#define IA32_VMX_EXIT_CTLS_CLEAR_IA32_BNDCFGS_FLAG                   0x800000
#define IA32_VMX_EXIT_CTLS_CLEAR_IA32_BNDCFGS_MASK                   0x01
#define IA32_VMX_EXIT_CTLS_CLEAR_IA32_BNDCFGS(_)                     (((_) >> 23) & 0x01)
     * [Bit 24] If this control is 1, Intel Processor Trace does not produce a paging information packet (PIP) on a VM exit or
     * a VMCS packet on an SMM VM exit.
     *
    UINT64 ConcealVmxFromPt                                        : 1;
#define IA32_VMX_EXIT_CTLS_CONCEAL_VMX_FROM_PT_BIT                   24
#define IA32_VMX_EXIT_CTLS_CONCEAL_VMX_FROM_PT_FLAG                  0x1000000
#define IA32_VMX_EXIT_CTLS_CONCEAL_VMX_FROM_PT_MASK                  0x01
#define IA32_VMX_EXIT_CTLS_CONCEAL_VMX_FROM_PT(_)                    (((_) >> 24) & 0x01)
     * [Bit 25] This control determines whether the IA32_RTIT_CTL MSR is cleared on VM exit.
     *
    UINT64 ClearIa32RtitCtl                                        : 1;
#define IA32_VMX_EXIT_CTLS_CLEAR_IA32_RTIT_CTL_BIT                   25
#define IA32_VMX_EXIT_CTLS_CLEAR_IA32_RTIT_CTL_FLAG                  0x2000000
#define IA32_VMX_EXIT_CTLS_CLEAR_IA32_RTIT_CTL_MASK                  0x01
#define IA32_VMX_EXIT_CTLS_CLEAR_IA32_RTIT_CTL(_)                    (((_) >> 25) & 0x01)
     * [Bit 26] This control determines whether the IA32_LBR_CTL MSR is cleared on VM exit.
    UINT64 ClearIa32LbrCtl                                         : 1;
#define IA32_VMX_EXIT_CTLS_CLEAR_IA32_LBR_CTL_BIT                    26
#define IA32_VMX_EXIT_CTLS_CLEAR_IA32_LBR_CTL_FLAG                   0x4000000
#define IA32_VMX_EXIT_CTLS_CLEAR_IA32_LBR_CTL_MASK                   0x01
#define IA32_VMX_EXIT_CTLS_CLEAR_IA32_LBR_CTL(_)                     (((_) >> 26) & 0x01)
    UINT64 Reserved6                                               : 1;
     * [Bit 28] This control determines whether CET-related MSRs and SPP are loaded on VM exit.
     *
    UINT64 LoadIa32CetState                                        : 1;
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_CET_STATE_BIT                   28
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_CET_STATE_FLAG                  0x10000000
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_CET_STATE_MASK                  0x01
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_CET_STATE(_)                    (((_) >> 28) & 0x01)
     * [Bit 29] This control determines whether the IA32_PKRS MSR is loaded on VM exit.
    UINT64 LoadIa32Pkrs                                            : 1;
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_PKRS_BIT                        29
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_PKRS_FLAG                       0x20000000
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_PKRS_MASK                       0x01
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_PKRS(_)                         (((_) >> 29) & 0x01)
    UINT64 Reserved7                                               : 1;
     * [Bit 31] This control determines whether the secondary VM-exit controls are used. If this control is 0, the logical
     * processor operates as if all the secondary VM-exit controls were also 0.
    UINT64 ActivateSecondaryControls                               : 1;
#define IA32_VMX_EXIT_CTLS_ACTIVATE_SECONDARY_CONTROLS_BIT           31
#define IA32_VMX_EXIT_CTLS_ACTIVATE_SECONDARY_CONTROLS_FLAG          0x80000000
#define IA32_VMX_EXIT_CTLS_ACTIVATE_SECONDARY_CONTROLS_MASK          0x01
#define IA32_VMX_EXIT_CTLS_ACTIVATE_SECONDARY_CONTROLS(_)            (((_) >> 31) & 0x01)
    UINT64 Reserved8                                               : 32;
  };
  UINT64 AsUInt;
} IA32_VMX_EXIT_CTLS_REGISTER;*/
return true
}

func (i *ia32)#define IA32_VMX_ENTRY_CTLS_LOAD_DEBUG_CONTROLS()(ok bool){//col:11594
/*#define IA32_VMX_ENTRY_CTLS_LOAD_DEBUG_CONTROLS(_)                   (((_) >> 2) & 0x01)
    UINT64 Reserved2                                               : 6;
     *
     * [Bit 9] On processors that support Intel 64 architecture, this control determines whether the logical processor is in
     * IA-32e mode after VM entry. Its value is loaded into IA32_EFER.LMA as part of VM entry. This control must be 0 on
     * processors that do not support Intel 64 architecture.
    UINT64 Ia32EModeGuest                                          : 1;
#define IA32_VMX_ENTRY_CTLS_IA32E_MODE_GUEST_BIT                     9
#define IA32_VMX_ENTRY_CTLS_IA32E_MODE_GUEST_FLAG                    0x200
#define IA32_VMX_ENTRY_CTLS_IA32E_MODE_GUEST_MASK                    0x01
#define IA32_VMX_ENTRY_CTLS_IA32E_MODE_GUEST(_)                      (((_) >> 9) & 0x01)
     *
     * [Bit 10] This control determines whether the logical processor is in system-management mode (SMM) after VM entry. This
     * control must be 0 for any VM entry from outside SMM.
    UINT64 EntryToSmm                                              : 1;
#define IA32_VMX_ENTRY_CTLS_ENTRY_TO_SMM_BIT                         10
#define IA32_VMX_ENTRY_CTLS_ENTRY_TO_SMM_FLAG                        0x400
#define IA32_VMX_ENTRY_CTLS_ENTRY_TO_SMM_MASK                        0x01
#define IA32_VMX_ENTRY_CTLS_ENTRY_TO_SMM(_)                          (((_) >> 10) & 0x01)
     *
     * [Bit 11] If set to 1, the default treatment of SMIs and SMM is in effect after the VM entry. This control must be 0 for
     * any VM entry from outside SMM
     *
    UINT64 DeactivateDualMonitorTreatment                          : 1;
#define IA32_VMX_ENTRY_CTLS_DEACTIVATE_DUAL_MONITOR_TREATMENT_BIT    11
#define IA32_VMX_ENTRY_CTLS_DEACTIVATE_DUAL_MONITOR_TREATMENT_FLAG   0x800
#define IA32_VMX_ENTRY_CTLS_DEACTIVATE_DUAL_MONITOR_TREATMENT_MASK   0x01
#define IA32_VMX_ENTRY_CTLS_DEACTIVATE_DUAL_MONITOR_TREATMENT(_)     (((_) >> 11) & 0x01)
    UINT64 Reserved3                                               : 1;
     *
     * [Bit 13] This control determines whether the IA32_PERF_GLOBAL_CTRL MSR is loaded on VM entry.
    UINT64 LoadIa32PerfGlobalCtrl                                  : 1;
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_PERF_GLOBAL_CTRL_BIT           13
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_PERF_GLOBAL_CTRL_FLAG          0x2000
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_PERF_GLOBAL_CTRL_MASK          0x01
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_PERF_GLOBAL_CTRL(_)            (((_) >> 13) & 0x01)
     *
     * [Bit 14] This control determines whether the IA32_PAT MSR is loaded on VM entry.
    UINT64 LoadIa32Pat                                             : 1;
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_PAT_BIT                        14
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_PAT_FLAG                       0x4000
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_PAT_MASK                       0x01
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_PAT(_)                         (((_) >> 14) & 0x01)
     *
     * [Bit 15] This control determines whether the IA32_EFER MSR is loaded on VM entry.
    UINT64 LoadIa32Efer                                            : 1;
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_EFER_BIT                       15
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_EFER_FLAG                      0x8000
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_EFER_MASK                      0x01
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_EFER(_)                        (((_) >> 15) & 0x01)
     * [Bit 16] This control determines whether the IA32_BNDCFGS MSR is loaded on VM entry.
    UINT64 LoadIa32Bndcfgs                                         : 1;
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_BNDCFGS_BIT                    16
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_BNDCFGS_FLAG                   0x10000
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_BNDCFGS_MASK                   0x01
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_BNDCFGS(_)                     (((_) >> 16) & 0x01)
     * [Bit 17] If this control is 1, Intel Processor Trace does not produce a paging information packet (PIP) on a VM entry or
     * a VMCS packet on a VM entry that returns from SMM.
     *
    UINT64 ConcealVmxFromPt                                        : 1;
#define IA32_VMX_ENTRY_CTLS_CONCEAL_VMX_FROM_PT_BIT                  17
#define IA32_VMX_ENTRY_CTLS_CONCEAL_VMX_FROM_PT_FLAG                 0x20000
#define IA32_VMX_ENTRY_CTLS_CONCEAL_VMX_FROM_PT_MASK                 0x01
#define IA32_VMX_ENTRY_CTLS_CONCEAL_VMX_FROM_PT(_)                   (((_) >> 17) & 0x01)
     * [Bit 18] This control determines whether the IA32_RTIT_CTL MSR is loaded on VM entry.
    UINT64 LoadIa32RtitCtl                                         : 1;
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_RTIT_CTL_BIT                   18
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_RTIT_CTL_FLAG                  0x40000
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_RTIT_CTL_MASK                  0x01
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_RTIT_CTL(_)                    (((_) >> 18) & 0x01)
    UINT64 Reserved4                                               : 1;
     * [Bit 20] This control determines whether CET-related MSRs and SPP are loaded on VM entry.
    UINT64 LoadCetState                                            : 1;
#define IA32_VMX_ENTRY_CTLS_LOAD_CET_STATE_BIT                       20
#define IA32_VMX_ENTRY_CTLS_LOAD_CET_STATE_FLAG                      0x100000
#define IA32_VMX_ENTRY_CTLS_LOAD_CET_STATE_MASK                      0x01
#define IA32_VMX_ENTRY_CTLS_LOAD_CET_STATE(_)                        (((_) >> 20) & 0x01)
     * [Bit 21] This control determines whether the IA32_LBR_CTL MSR is loaded on VM entry.
    UINT64 LoadIa32LbrCtl                                          : 1;
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_LBR_CTL_BIT                    21
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_LBR_CTL_FLAG                   0x200000
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_LBR_CTL_MASK                   0x01
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_LBR_CTL(_)                     (((_) >> 21) & 0x01)
     * [Bit 22] This control determines whether the IA32_PKRS MSR is loaded on VM entry.
    UINT64 LoadIa32Pkrs                                            : 1;
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_PKRS_BIT                       22
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_PKRS_FLAG                      0x400000
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_PKRS_MASK                      0x01
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_PKRS(_)                        (((_) >> 22) & 0x01)
    UINT64 Reserved5                                               : 41;
  };
  UINT64 AsUInt;
} IA32_VMX_ENTRY_CTLS_REGISTER;*/
return true
}

func (i *ia32)     * timestamp counter ()(ok bool){//col:11758
/*     * timestamp counter (TSC). Specifically, the VMX-preemption timer (if it is active) counts down by 1 every time bit X in
     * the TSC changes due to a TSC increment.
    UINT64 PreemptionTimerTscRelationship                          : 5;
#define IA32_VMX_MISC_PREEMPTION_TIMER_TSC_RELATIONSHIP_BIT          0
#define IA32_VMX_MISC_PREEMPTION_TIMER_TSC_RELATIONSHIP_FLAG         0x1F
#define IA32_VMX_MISC_PREEMPTION_TIMER_TSC_RELATIONSHIP_MASK         0x1F
#define IA32_VMX_MISC_PREEMPTION_TIMER_TSC_RELATIONSHIP(_)           (((_) >> 0) & 0x1F)
     *
     * [Bit 5] When set to 1, VM exits store the value of IA32_EFER.LMA into the "IA-32e mode guest" VM-entry control. This bit
     * is read as 1 on any logical processor that supports the 1-setting of the "unrestricted guest" VM-execution control.
     *
    UINT64 StoreEferLmaOnVmexit                                    : 1;
#define IA32_VMX_MISC_STORE_EFER_LMA_ON_VMEXIT_BIT                   5
#define IA32_VMX_MISC_STORE_EFER_LMA_ON_VMEXIT_FLAG                  0x20
#define IA32_VMX_MISC_STORE_EFER_LMA_ON_VMEXIT_MASK                  0x01
#define IA32_VMX_MISC_STORE_EFER_LMA_ON_VMEXIT(_)                    (((_) >> 5) & 0x01)
     *
     * [Bits 8:6] Report, as a bitmap, the activity states supported by the implementation:
     * - Bit 6 reports (if set) the support for activity state 1 (HLT).
     * - Bit 7 reports (if set) the support for activity state 2 (shutdown).
     * - Bit 8 reports (if set) the support for activity state 3 (wait-for-SIPI).
     * If an activity state is not supported, the implementation causes a VM entry to fail if it attempts to establish that
     * activity state. All implementations support VM entry to activity state 0 (active).
    UINT64 ActivityStates                                          : 3;
#define IA32_VMX_MISC_ACTIVITY_STATES_BIT                            6
#define IA32_VMX_MISC_ACTIVITY_STATES_FLAG                           0x1C0
#define IA32_VMX_MISC_ACTIVITY_STATES_MASK                           0x07
#define IA32_VMX_MISC_ACTIVITY_STATES(_)                             (((_) >> 6) & 0x07)
    UINT64 Reserved1                                               : 5;
     *
     * [Bit 14] When set to 1, Intel(R) Processor Trace (Intel PT) can be used in VMX operation. If the processor supports Intel
     * PT but does not allow it to be used in VMX operation, execution of VMXON clears IA32_RTIT_CTL.TraceEn; any attempt to
     * write IA32_RTIT_CTL while in VMX operation (including VMX root operation) causes a general-protection exception.
     *
    UINT64 IntelPtAvailableInVmx                                   : 1;
#define IA32_VMX_MISC_INTEL_PT_AVAILABLE_IN_VMX_BIT                  14
#define IA32_VMX_MISC_INTEL_PT_AVAILABLE_IN_VMX_FLAG                 0x4000
#define IA32_VMX_MISC_INTEL_PT_AVAILABLE_IN_VMX_MASK                 0x01
#define IA32_VMX_MISC_INTEL_PT_AVAILABLE_IN_VMX(_)                   (((_) >> 14) & 0x01)
     *
     * [Bit 15] When set to 1, the RDMSR instruction can be used in system-management mode (SMM) to read the IA32_SMBASE MSR
     * (MSR address 9EH).
     *
    UINT64 RdmsrCanReadIa32SmbaseMsrInSmm                          : 1;
#define IA32_VMX_MISC_RDMSR_CAN_READ_IA32_SMBASE_MSR_IN_SMM_BIT      15
#define IA32_VMX_MISC_RDMSR_CAN_READ_IA32_SMBASE_MSR_IN_SMM_FLAG     0x8000
#define IA32_VMX_MISC_RDMSR_CAN_READ_IA32_SMBASE_MSR_IN_SMM_MASK     0x01
#define IA32_VMX_MISC_RDMSR_CAN_READ_IA32_SMBASE_MSR_IN_SMM(_)       (((_) >> 15) & 0x01)
     *
     * [Bits 24:16] Indicate the number of CR3-target values supported by the processor. This number is a value between 0 and
     * 256, inclusive (bit 24 is set if and only if bits 23:16 are clear).
    UINT64 Cr3TargetCount                                          : 9;
#define IA32_VMX_MISC_CR3_TARGET_COUNT_BIT                           16
#define IA32_VMX_MISC_CR3_TARGET_COUNT_FLAG                          0x1FF0000
#define IA32_VMX_MISC_CR3_TARGET_COUNT_MASK                          0x1FF
#define IA32_VMX_MISC_CR3_TARGET_COUNT(_)                            (((_) >> 16) & 0x1FF)
     *
     * [Bits 27:25] Used to compute the recommended maximum number of MSRs that should appear in the VM-exit MSR-store list,
     * the VM-exit MSR-load list, or the VM-entry MSR-load list. Specifically, if the value bits 27:25 of IA32_VMX_MISC is N,
     * then 512 * (N + 1) is the recommended maximum number of MSRs to be included in each list. If the limit is exceeded,
     * undefined processor behavior may result (including a machine check during the VMX transition).
    UINT64 MaxNumberOfMsr                                          : 3;
#define IA32_VMX_MISC_MAX_NUMBER_OF_MSR_BIT                          25
#define IA32_VMX_MISC_MAX_NUMBER_OF_MSR_FLAG                         0xE000000
#define IA32_VMX_MISC_MAX_NUMBER_OF_MSR_MASK                         0x07
#define IA32_VMX_MISC_MAX_NUMBER_OF_MSR(_)                           (((_) >> 25) & 0x07)
     *
     * [Bit 28] When set to 1, bit 2 of the IA32_SMM_MONITOR_CTL can be set to 1. VMXOFF unblocks SMIs unless
     * IA32_SMM_MONITOR_CTL[bit 2] is 1.
     *
    UINT64 SmmMonitorCtlB2                                         : 1;
#define IA32_VMX_MISC_SMM_MONITOR_CTL_B2_BIT                         28
#define IA32_VMX_MISC_SMM_MONITOR_CTL_B2_FLAG                        0x10000000
#define IA32_VMX_MISC_SMM_MONITOR_CTL_B2_MASK                        0x01
#define IA32_VMX_MISC_SMM_MONITOR_CTL_B2(_)                          (((_) >> 28) & 0x01)
     *
     * [Bit 29] When set to 1, software can use VMWRITE to write to any supported field in the VMCS; otherwise, VMWRITE cannot
     * be used to modify VM-exit information fields.
    UINT64 VmwriteVmexitInfo                                       : 1;
#define IA32_VMX_MISC_VMWRITE_VMEXIT_INFO_BIT                        29
#define IA32_VMX_MISC_VMWRITE_VMEXIT_INFO_FLAG                       0x20000000
#define IA32_VMX_MISC_VMWRITE_VMEXIT_INFO_MASK                       0x01
#define IA32_VMX_MISC_VMWRITE_VMEXIT_INFO(_)                         (((_) >> 29) & 0x01)
     * [Bit 30] When set to 1, VM entry allows injection of a software interrupt, software exception, or privileged software
     * exception with an instruction length of 0.
    UINT64 ZeroLengthInstructionVmentryInjection                   : 1;
#define IA32_VMX_MISC_ZERO_LENGTH_INSTRUCTION_VMENTRY_INJECTION_BIT  30
#define IA32_VMX_MISC_ZERO_LENGTH_INSTRUCTION_VMENTRY_INJECTION_FLAG 0x40000000
#define IA32_VMX_MISC_ZERO_LENGTH_INSTRUCTION_VMENTRY_INJECTION_MASK 0x01
#define IA32_VMX_MISC_ZERO_LENGTH_INSTRUCTION_VMENTRY_INJECTION(_)   (((_) >> 30) & 0x01)
    UINT64 Reserved2                                               : 1;
     *
     * [Bits 63:32] Report the 32-bit MSEG revision identifier used by the processor.
    UINT64 MsegId                                                  : 32;
#define IA32_VMX_MISC_MSEG_ID_BIT                                    32
#define IA32_VMX_MISC_MSEG_ID_FLAG                                   0xFFFFFFFF00000000
#define IA32_VMX_MISC_MSEG_ID_MASK                                   0xFFFFFFFF
#define IA32_VMX_MISC_MSEG_ID(_)                                     (((_) >> 32) & 0xFFFFFFFF)
  };
  UINT64 AsUInt;
} IA32_VMX_MISC_REGISTER;*/
return true
}

func (i *ia32)#define IA32_VMX_VMCS_ENUM_ACCESS_TYPE()(ok bool){//col:11849
/*#define IA32_VMX_VMCS_ENUM_ACCESS_TYPE(_)                            (((_) >> 0) & 0x01)
     * [Bits 9:1] Highest index value used for any VMCS encoding.
    UINT64 HighestIndexValue                                       : 9;
#define IA32_VMX_VMCS_ENUM_HIGHEST_INDEX_VALUE_BIT                   1
#define IA32_VMX_VMCS_ENUM_HIGHEST_INDEX_VALUE_FLAG                  0x3FE
#define IA32_VMX_VMCS_ENUM_HIGHEST_INDEX_VALUE_MASK                  0x1FF
#define IA32_VMX_VMCS_ENUM_HIGHEST_INDEX_VALUE(_)                    (((_) >> 1) & 0x1FF)
     * [Bits 11:10] Indicate the field's type.
    UINT64 FieldType                                               : 2;
#define IA32_VMX_VMCS_ENUM_FIELD_TYPE_BIT                            10
#define IA32_VMX_VMCS_ENUM_FIELD_TYPE_FLAG                           0xC00
#define IA32_VMX_VMCS_ENUM_FIELD_TYPE_MASK                           0x03
#define IA32_VMX_VMCS_ENUM_FIELD_TYPE(_)                             (((_) >> 10) & 0x03)
    UINT64 Reserved1                                               : 1;
     * [Bits 14:13] Indicate the field's width.
    UINT64 FieldWidth                                              : 2;
#define IA32_VMX_VMCS_ENUM_FIELD_WIDTH_BIT                           13
#define IA32_VMX_VMCS_ENUM_FIELD_WIDTH_FLAG                          0x6000
#define IA32_VMX_VMCS_ENUM_FIELD_WIDTH_MASK                          0x03
#define IA32_VMX_VMCS_ENUM_FIELD_WIDTH(_)                            (((_) >> 13) & 0x03)
    UINT64 Reserved2                                               : 49;
  };
  UINT64 AsUInt;
} IA32_VMX_VMCS_ENUM_REGISTER;*/
return true
}

func (i *ia32)#define IA32_VMX_PROCBASED_CTLS2_VIRTUALIZE_APIC_ACCESSES()(ok bool){//col:12211
/*#define IA32_VMX_PROCBASED_CTLS2_VIRTUALIZE_APIC_ACCESSES(_)         (((_) >> 0) & 0x01)
     *
     * [Bit 1] If this control is 1, extended page tables (EPT) are enabled.
     *
    UINT64 EnableEpt                                               : 1;
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_EPT_BIT                      1
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_EPT_FLAG                     0x02
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_EPT_MASK                     0x01
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_EPT(_)                       (((_) >> 1) & 0x01)
     *
     * [Bit 2] This control determines whether executions of LGDT, LIDT, LLDT, LTR, SGDT, SIDT, SLDT, and STR cause VM exits.
    UINT64 DescriptorTableExiting                                  : 1;
#define IA32_VMX_PROCBASED_CTLS2_DESCRIPTOR_TABLE_EXITING_BIT        2
#define IA32_VMX_PROCBASED_CTLS2_DESCRIPTOR_TABLE_EXITING_FLAG       0x04
#define IA32_VMX_PROCBASED_CTLS2_DESCRIPTOR_TABLE_EXITING_MASK       0x01
#define IA32_VMX_PROCBASED_CTLS2_DESCRIPTOR_TABLE_EXITING(_)         (((_) >> 2) & 0x01)
     *
     * [Bit 3] If this control is 0, any execution of RDTSCP causes an invalid-opcode exception (\#UD).
    UINT64 EnableRdtscp                                            : 1;
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_RDTSCP_BIT                   3
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_RDTSCP_FLAG                  0x08
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_RDTSCP_MASK                  0x01
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_RDTSCP(_)                    (((_) >> 3) & 0x01)
     *
     * [Bit 4] If this control is 1, the logical processor treats specially RDMSR and WRMSR to APIC MSRs (in the range
     * 800H-8FFH).
     *
    UINT64 VirtualizeX2ApicMode                                    : 1;
#define IA32_VMX_PROCBASED_CTLS2_VIRTUALIZE_X2APIC_MODE_BIT          4
#define IA32_VMX_PROCBASED_CTLS2_VIRTUALIZE_X2APIC_MODE_FLAG         0x10
#define IA32_VMX_PROCBASED_CTLS2_VIRTUALIZE_X2APIC_MODE_MASK         0x01
#define IA32_VMX_PROCBASED_CTLS2_VIRTUALIZE_X2APIC_MODE(_)           (((_) >> 4) & 0x01)
     *
     * [Bit 5] If this control is 1, cached translations of linear addresses are associated with a virtualprocessor identifier
     * (VPID).
     *
    UINT64 EnableVpid                                              : 1;
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_VPID_BIT                     5
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_VPID_FLAG                    0x20
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_VPID_MASK                    0x01
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_VPID(_)                      (((_) >> 5) & 0x01)
     *
     * [Bit 6] This control determines whether executions of WBINVD cause VM exits.
    UINT64 WbinvdExiting                                           : 1;
#define IA32_VMX_PROCBASED_CTLS2_WBINVD_EXITING_BIT                  6
#define IA32_VMX_PROCBASED_CTLS2_WBINVD_EXITING_FLAG                 0x40
#define IA32_VMX_PROCBASED_CTLS2_WBINVD_EXITING_MASK                 0x01
#define IA32_VMX_PROCBASED_CTLS2_WBINVD_EXITING(_)                   (((_) >> 6) & 0x01)
     *
     * [Bit 7] This control determines whether guest software may run in unpaged protected mode or in realaddress mode.
    UINT64 UnrestrictedGuest                                       : 1;
#define IA32_VMX_PROCBASED_CTLS2_UNRESTRICTED_GUEST_BIT              7
#define IA32_VMX_PROCBASED_CTLS2_UNRESTRICTED_GUEST_FLAG             0x80
#define IA32_VMX_PROCBASED_CTLS2_UNRESTRICTED_GUEST_MASK             0x01
#define IA32_VMX_PROCBASED_CTLS2_UNRESTRICTED_GUEST(_)               (((_) >> 7) & 0x01)
     *
     * [Bit 8] If this control is 1, the logical processor virtualizes certain APIC accesses.
     *
    UINT64 ApicRegisterVirtualization                              : 1;
#define IA32_VMX_PROCBASED_CTLS2_APIC_REGISTER_VIRTUALIZATION_BIT    8
#define IA32_VMX_PROCBASED_CTLS2_APIC_REGISTER_VIRTUALIZATION_FLAG   0x100
#define IA32_VMX_PROCBASED_CTLS2_APIC_REGISTER_VIRTUALIZATION_MASK   0x01
#define IA32_VMX_PROCBASED_CTLS2_APIC_REGISTER_VIRTUALIZATION(_)     (((_) >> 8) & 0x01)
     *
     * [Bit 9] This controls enables the evaluation and delivery of pending virtual interrupts as well as the emulation of
     * writes to the APIC registers that control interrupt prioritization.
    UINT64 VirtualInterruptDelivery                                : 1;
#define IA32_VMX_PROCBASED_CTLS2_VIRTUAL_INTERRUPT_DELIVERY_BIT      9
#define IA32_VMX_PROCBASED_CTLS2_VIRTUAL_INTERRUPT_DELIVERY_FLAG     0x200
#define IA32_VMX_PROCBASED_CTLS2_VIRTUAL_INTERRUPT_DELIVERY_MASK     0x01
#define IA32_VMX_PROCBASED_CTLS2_VIRTUAL_INTERRUPT_DELIVERY(_)       (((_) >> 9) & 0x01)
     *
     * [Bit 10] This control determines whether a series of executions of PAUSE can cause a VM exit.
     *
    UINT64 PauseLoopExiting                                        : 1;
#define IA32_VMX_PROCBASED_CTLS2_PAUSE_LOOP_EXITING_BIT              10
#define IA32_VMX_PROCBASED_CTLS2_PAUSE_LOOP_EXITING_FLAG             0x400
#define IA32_VMX_PROCBASED_CTLS2_PAUSE_LOOP_EXITING_MASK             0x01
#define IA32_VMX_PROCBASED_CTLS2_PAUSE_LOOP_EXITING(_)               (((_) >> 10) & 0x01)
     *
     * [Bit 11] This control determines whether executions of RDRAND cause VM exits.
    UINT64 RdrandExiting                                           : 1;
#define IA32_VMX_PROCBASED_CTLS2_RDRAND_EXITING_BIT                  11
#define IA32_VMX_PROCBASED_CTLS2_RDRAND_EXITING_FLAG                 0x800
#define IA32_VMX_PROCBASED_CTLS2_RDRAND_EXITING_MASK                 0x01
#define IA32_VMX_PROCBASED_CTLS2_RDRAND_EXITING(_)                   (((_) >> 11) & 0x01)
     *
     * [Bit 12] If this control is 0, any execution of INVPCID causes a \#UD.
    UINT64 EnableInvpcid                                           : 1;
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_INVPCID_BIT                  12
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_INVPCID_FLAG                 0x1000
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_INVPCID_MASK                 0x01
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_INVPCID(_)                   (((_) >> 12) & 0x01)
     *
     * [Bit 13] Setting this control to 1 enables use of the VMFUNC instruction in VMX non-root operation.
     *
    UINT64 EnableVmFunctions                                       : 1;
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_VM_FUNCTIONS_BIT             13
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_VM_FUNCTIONS_FLAG            0x2000
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_VM_FUNCTIONS_MASK            0x01
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_VM_FUNCTIONS(_)              (((_) >> 13) & 0x01)
     *
     * [Bit 14] If this control is 1, executions of VMREAD and VMWRITE in VMX non-root operation may access a shadow VMCS
     * (instead of causing VM exits).
     *
    UINT64 VmcsShadowing                                           : 1;
#define IA32_VMX_PROCBASED_CTLS2_VMCS_SHADOWING_BIT                  14
#define IA32_VMX_PROCBASED_CTLS2_VMCS_SHADOWING_FLAG                 0x4000
#define IA32_VMX_PROCBASED_CTLS2_VMCS_SHADOWING_MASK                 0x01
#define IA32_VMX_PROCBASED_CTLS2_VMCS_SHADOWING(_)                   (((_) >> 14) & 0x01)
     *
     * [Bit 15] If this control is 1, executions of ENCLS consult the ENCLS-exiting bitmap to determine whether the instruction
     * causes a VM exit.
     *
    UINT64 EnableEnclsExiting                                      : 1;
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_ENCLS_EXITING_BIT            15
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_ENCLS_EXITING_FLAG           0x8000
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_ENCLS_EXITING_MASK           0x01
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_ENCLS_EXITING(_)             (((_) >> 15) & 0x01)
     *
     * [Bit 16] This control determines whether executions of RDSEED cause VM exits.
    UINT64 RdseedExiting                                           : 1;
#define IA32_VMX_PROCBASED_CTLS2_RDSEED_EXITING_BIT                  16
#define IA32_VMX_PROCBASED_CTLS2_RDSEED_EXITING_FLAG                 0x10000
#define IA32_VMX_PROCBASED_CTLS2_RDSEED_EXITING_MASK                 0x01
#define IA32_VMX_PROCBASED_CTLS2_RDSEED_EXITING(_)                   (((_) >> 16) & 0x01)
     *
     * [Bit 17] If this control is 1, an access to a guest-physical address that sets an EPT dirty bit first adds an entry to
     * the page-modification log.
     *
    UINT64 EnablePml                                               : 1;
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_PML_BIT                      17
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_PML_FLAG                     0x20000
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_PML_MASK                     0x01
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_PML(_)                       (((_) >> 17) & 0x01)
     *
     * [Bit 18] If this control is 1, EPT violations may cause virtualization exceptions (\#VE) instead of VM exits.
     *
    UINT64 EptViolation                                            : 1;
#define IA32_VMX_PROCBASED_CTLS2_EPT_VIOLATION_BIT                   18
#define IA32_VMX_PROCBASED_CTLS2_EPT_VIOLATION_FLAG                  0x40000
#define IA32_VMX_PROCBASED_CTLS2_EPT_VIOLATION_MASK                  0x01
#define IA32_VMX_PROCBASED_CTLS2_EPT_VIOLATION(_)                    (((_) >> 18) & 0x01)
     *
     * [Bit 19] If this control is 1, Intel Processor Trace suppresses from PIPs an indication that the processor was in VMX
     * non-root operation and omits a VMCS packet from any PSB+ produced in VMX nonroot operation.
     *
    UINT64 ConcealVmxFromPt                                        : 1;
#define IA32_VMX_PROCBASED_CTLS2_CONCEAL_VMX_FROM_PT_BIT             19
#define IA32_VMX_PROCBASED_CTLS2_CONCEAL_VMX_FROM_PT_FLAG            0x80000
#define IA32_VMX_PROCBASED_CTLS2_CONCEAL_VMX_FROM_PT_MASK            0x01
#define IA32_VMX_PROCBASED_CTLS2_CONCEAL_VMX_FROM_PT(_)              (((_) >> 19) & 0x01)
     *
     * [Bit 20] If this control is 0, any execution of XSAVES or XRSTORS causes a \#UD.
    UINT64 EnableXsaves                                            : 1;
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_XSAVES_BIT                   20
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_XSAVES_FLAG                  0x100000
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_XSAVES_MASK                  0x01
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_XSAVES(_)                    (((_) >> 20) & 0x01)
    UINT64 Reserved1                                               : 1;
     * [Bit 22] If this control is 1, EPT execute permissions are based on whether the linear address being accessed is
     * supervisor mode or user mode.
     *
    UINT64 ModeBasedExecuteControlForEpt                           : 1;
#define IA32_VMX_PROCBASED_CTLS2_MODE_BASED_EXECUTE_CONTROL_FOR_EPT_BIT 22
#define IA32_VMX_PROCBASED_CTLS2_MODE_BASED_EXECUTE_CONTROL_FOR_EPT_FLAG 0x400000
#define IA32_VMX_PROCBASED_CTLS2_MODE_BASED_EXECUTE_CONTROL_FOR_EPT_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS2_MODE_BASED_EXECUTE_CONTROL_FOR_EPT(_) (((_) >> 22) & 0x01)
     * [Bit 23] If this control is 1, EPT write permissions may be specified at the granularity of 128 bytes.
     *
    UINT64 SubPageWritePermissionsForEpt                           : 1;
#define IA32_VMX_PROCBASED_CTLS2_SUB_PAGE_WRITE_PERMISSIONS_FOR_EPT_BIT 23
#define IA32_VMX_PROCBASED_CTLS2_SUB_PAGE_WRITE_PERMISSIONS_FOR_EPT_FLAG 0x800000
#define IA32_VMX_PROCBASED_CTLS2_SUB_PAGE_WRITE_PERMISSIONS_FOR_EPT_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS2_SUB_PAGE_WRITE_PERMISSIONS_FOR_EPT(_) (((_) >> 23) & 0x01)
     * [Bit 24] If this control is 1, all output addresses used by Intel Processor Trace are treated as guestphysical addresses
     * and translated using EPT.
     *
    UINT64 PtUsesGuestPhysicalAddresses                            : 1;
#define IA32_VMX_PROCBASED_CTLS2_PT_USES_GUEST_PHYSICAL_ADDRESSES_BIT 24
#define IA32_VMX_PROCBASED_CTLS2_PT_USES_GUEST_PHYSICAL_ADDRESSES_FLAG 0x1000000
#define IA32_VMX_PROCBASED_CTLS2_PT_USES_GUEST_PHYSICAL_ADDRESSES_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS2_PT_USES_GUEST_PHYSICAL_ADDRESSES(_) (((_) >> 24) & 0x01)
     *
     * [Bit 25] This control determines whether executions of RDTSC, executions of RDTSCP, and executions of RDMSR that read
     * from the IA32_TIME_STAMP_COUNTER MSR return a value modified by the TSC multiplier field.
     *
    UINT64 UseTscScaling                                           : 1;
#define IA32_VMX_PROCBASED_CTLS2_USE_TSC_SCALING_BIT                 25
#define IA32_VMX_PROCBASED_CTLS2_USE_TSC_SCALING_FLAG                0x2000000
#define IA32_VMX_PROCBASED_CTLS2_USE_TSC_SCALING_MASK                0x01
#define IA32_VMX_PROCBASED_CTLS2_USE_TSC_SCALING(_)                  (((_) >> 25) & 0x01)
     *
     * [Bit 26] If this control is 0, any execution of TPAUSE, UMONITOR, or UMWAIT causes a \#UD.
    UINT64 EnableUserWaitPause                                     : 1;
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_USER_WAIT_PAUSE_BIT          26
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_USER_WAIT_PAUSE_FLAG         0x4000000
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_USER_WAIT_PAUSE_MASK         0x01
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_USER_WAIT_PAUSE(_)           (((_) >> 26) & 0x01)
    UINT64 Reserved2                                               : 1;
     *
     * [Bit 28] If this control is 1, executions of ENCLV consult the ENCLV-exiting bitmap to determine whether the instruction
     * causes a VM exit.
     *
    UINT64 EnableEnclvExiting                                      : 1;
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_ENCLV_EXITING_BIT            28
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_ENCLV_EXITING_FLAG           0x10000000
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_ENCLV_EXITING_MASK           0x01
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_ENCLV_EXITING(_)             (((_) >> 28) & 0x01)
    UINT64 Reserved3                                               : 35;
  };
  UINT64 AsUInt;
} IA32_VMX_PROCBASED_CTLS2_REGISTER;*/
return true
}

func (i *ia32)     * configure EPT paging-structure entries in which bits 1:0 are clear ()(ok bool){//col:12428
/*     * configure EPT paging-structure entries in which bits 1:0 are clear (indicating that data accesses are not allowed) and
     * bit 2 is set (indicating that instruction fetches are allowed).
    UINT64 ExecuteOnlyPages                                        : 1;
#define IA32_VMX_EPT_VPID_CAP_EXECUTE_ONLY_PAGES_BIT                 0
#define IA32_VMX_EPT_VPID_CAP_EXECUTE_ONLY_PAGES_FLAG                0x01
#define IA32_VMX_EPT_VPID_CAP_EXECUTE_ONLY_PAGES_MASK                0x01
#define IA32_VMX_EPT_VPID_CAP_EXECUTE_ONLY_PAGES(_)                  (((_) >> 0) & 0x01)
    UINT64 Reserved1                                               : 5;
     * [Bit 6] Indicates support for a page-walk length of 4.
    UINT64 PageWalkLength4                                         : 1;
#define IA32_VMX_EPT_VPID_CAP_PAGE_WALK_LENGTH_4_BIT                 6
#define IA32_VMX_EPT_VPID_CAP_PAGE_WALK_LENGTH_4_FLAG                0x40
#define IA32_VMX_EPT_VPID_CAP_PAGE_WALK_LENGTH_4_MASK                0x01
#define IA32_VMX_EPT_VPID_CAP_PAGE_WALK_LENGTH_4(_)                  (((_) >> 6) & 0x01)
    UINT64 Reserved2                                               : 1;
     * [Bit 8] When set to 1, the logical processor allows software to configure the EPT paging-structure memory type to be
     * uncacheable (UC).
     *
    UINT64 MemoryTypeUncacheable                                   : 1;
#define IA32_VMX_EPT_VPID_CAP_MEMORY_TYPE_UNCACHEABLE_BIT            8
#define IA32_VMX_EPT_VPID_CAP_MEMORY_TYPE_UNCACHEABLE_FLAG           0x100
#define IA32_VMX_EPT_VPID_CAP_MEMORY_TYPE_UNCACHEABLE_MASK           0x01
#define IA32_VMX_EPT_VPID_CAP_MEMORY_TYPE_UNCACHEABLE(_)             (((_) >> 8) & 0x01)
    UINT64 Reserved3                                               : 5;
     * [Bit 14] When set to 1, the logical processor allows software to configure the EPT paging-structure memory type to be
     * write-back (WB).
    UINT64 MemoryTypeWriteBack                                     : 1;
#define IA32_VMX_EPT_VPID_CAP_MEMORY_TYPE_WRITE_BACK_BIT             14
#define IA32_VMX_EPT_VPID_CAP_MEMORY_TYPE_WRITE_BACK_FLAG            0x4000
#define IA32_VMX_EPT_VPID_CAP_MEMORY_TYPE_WRITE_BACK_MASK            0x01
#define IA32_VMX_EPT_VPID_CAP_MEMORY_TYPE_WRITE_BACK(_)              (((_) >> 14) & 0x01)
    UINT64 Reserved4                                               : 1;
     * [Bit 16] When set to 1, the logical processor allows software to configure a EPT PDE to map a 2-Mbyte page (by setting
     * bit 7 in the EPT PDE).
    UINT64 Pde2MbPages                                             : 1;
#define IA32_VMX_EPT_VPID_CAP_PDE_2MB_PAGES_BIT                      16
#define IA32_VMX_EPT_VPID_CAP_PDE_2MB_PAGES_FLAG                     0x10000
#define IA32_VMX_EPT_VPID_CAP_PDE_2MB_PAGES_MASK                     0x01
#define IA32_VMX_EPT_VPID_CAP_PDE_2MB_PAGES(_)                       (((_) >> 16) & 0x01)
     * [Bit 17] When set to 1, the logical processor allows software to configure a EPT PDPTE to map a 1-Gbyte page (by setting
     * bit 7 in the EPT PDPTE).
    UINT64 Pdpte1GbPages                                           : 1;
#define IA32_VMX_EPT_VPID_CAP_PDPTE_1GB_PAGES_BIT                    17
#define IA32_VMX_EPT_VPID_CAP_PDPTE_1GB_PAGES_FLAG                   0x20000
#define IA32_VMX_EPT_VPID_CAP_PDPTE_1GB_PAGES_MASK                   0x01
#define IA32_VMX_EPT_VPID_CAP_PDPTE_1GB_PAGES(_)                     (((_) >> 17) & 0x01)
    UINT64 Reserved5                                               : 2;
     * [Bit 20] If bit 20 is read as 1, the INVEPT instruction is supported.
     *
    UINT64 Invept                                                  : 1;
#define IA32_VMX_EPT_VPID_CAP_INVEPT_BIT                             20
#define IA32_VMX_EPT_VPID_CAP_INVEPT_FLAG                            0x100000
#define IA32_VMX_EPT_VPID_CAP_INVEPT_MASK                            0x01
#define IA32_VMX_EPT_VPID_CAP_INVEPT(_)                              (((_) >> 20) & 0x01)
     * [Bit 21] When set to 1, accessed and dirty flags for EPT are supported.
     *
    UINT64 EptAccessedAndDirtyFlags                                : 1;
#define IA32_VMX_EPT_VPID_CAP_EPT_ACCESSED_AND_DIRTY_FLAGS_BIT       21
#define IA32_VMX_EPT_VPID_CAP_EPT_ACCESSED_AND_DIRTY_FLAGS_FLAG      0x200000
#define IA32_VMX_EPT_VPID_CAP_EPT_ACCESSED_AND_DIRTY_FLAGS_MASK      0x01
#define IA32_VMX_EPT_VPID_CAP_EPT_ACCESSED_AND_DIRTY_FLAGS(_)        (((_) >> 21) & 0x01)
     * [Bit 22] When set to 1, the processor reports advanced VM-exit information for EPT violations. This reporting is done
     * only if this bit is read as 1.
     *
    UINT64 AdvancedVmexitEptViolationsInformation                  : 1;
#define IA32_VMX_EPT_VPID_CAP_ADVANCED_VMEXIT_EPT_VIOLATIONS_INFORMATION_BIT 22
#define IA32_VMX_EPT_VPID_CAP_ADVANCED_VMEXIT_EPT_VIOLATIONS_INFORMATION_FLAG 0x400000
#define IA32_VMX_EPT_VPID_CAP_ADVANCED_VMEXIT_EPT_VIOLATIONS_INFORMATION_MASK 0x01
#define IA32_VMX_EPT_VPID_CAP_ADVANCED_VMEXIT_EPT_VIOLATIONS_INFORMATION(_) (((_) >> 22) & 0x01)
     * [Bit 23] If bit 23 is read as 1, supervisor shadow-stack control is supported.
     *
    UINT64 SupervisorShadowStack                                   : 1;
#define IA32_VMX_EPT_VPID_CAP_SUPERVISOR_SHADOW_STACK_BIT            23
#define IA32_VMX_EPT_VPID_CAP_SUPERVISOR_SHADOW_STACK_FLAG           0x800000
#define IA32_VMX_EPT_VPID_CAP_SUPERVISOR_SHADOW_STACK_MASK           0x01
#define IA32_VMX_EPT_VPID_CAP_SUPERVISOR_SHADOW_STACK(_)             (((_) >> 23) & 0x01)
    UINT64 Reserved6                                               : 1;
     * [Bit 25] When set to 1, the single-context INVEPT type is supported.
     *
    UINT64 InveptSingleContext                                     : 1;
#define IA32_VMX_EPT_VPID_CAP_INVEPT_SINGLE_CONTEXT_BIT              25
#define IA32_VMX_EPT_VPID_CAP_INVEPT_SINGLE_CONTEXT_FLAG             0x2000000
#define IA32_VMX_EPT_VPID_CAP_INVEPT_SINGLE_CONTEXT_MASK             0x01
#define IA32_VMX_EPT_VPID_CAP_INVEPT_SINGLE_CONTEXT(_)               (((_) >> 25) & 0x01)
     * [Bit 26] When set to 1, the all-context INVEPT type is supported.
     *
    UINT64 InveptAllContexts                                       : 1;
#define IA32_VMX_EPT_VPID_CAP_INVEPT_ALL_CONTEXTS_BIT                26
#define IA32_VMX_EPT_VPID_CAP_INVEPT_ALL_CONTEXTS_FLAG               0x4000000
#define IA32_VMX_EPT_VPID_CAP_INVEPT_ALL_CONTEXTS_MASK               0x01
#define IA32_VMX_EPT_VPID_CAP_INVEPT_ALL_CONTEXTS(_)                 (((_) >> 26) & 0x01)
    UINT64 Reserved7                                               : 5;
     * [Bit 32] When set to 1, the INVVPID instruction is supported.
    UINT64 Invvpid                                                 : 1;
#define IA32_VMX_EPT_VPID_CAP_INVVPID_BIT                            32
#define IA32_VMX_EPT_VPID_CAP_INVVPID_FLAG                           0x100000000
#define IA32_VMX_EPT_VPID_CAP_INVVPID_MASK                           0x01
#define IA32_VMX_EPT_VPID_CAP_INVVPID(_)                             (((_) >> 32) & 0x01)
    UINT64 Reserved8                                               : 7;
     * [Bit 40] When set to 1, the individual-address INVVPID type is supported.
    UINT64 InvvpidIndividualAddress                                : 1;
#define IA32_VMX_EPT_VPID_CAP_INVVPID_INDIVIDUAL_ADDRESS_BIT         40
#define IA32_VMX_EPT_VPID_CAP_INVVPID_INDIVIDUAL_ADDRESS_FLAG        0x10000000000
#define IA32_VMX_EPT_VPID_CAP_INVVPID_INDIVIDUAL_ADDRESS_MASK        0x01
#define IA32_VMX_EPT_VPID_CAP_INVVPID_INDIVIDUAL_ADDRESS(_)          (((_) >> 40) & 0x01)
     * [Bit 41] When set to 1, the single-context INVVPID type is supported.
    UINT64 InvvpidSingleContext                                    : 1;
#define IA32_VMX_EPT_VPID_CAP_INVVPID_SINGLE_CONTEXT_BIT             41
#define IA32_VMX_EPT_VPID_CAP_INVVPID_SINGLE_CONTEXT_FLAG            0x20000000000
#define IA32_VMX_EPT_VPID_CAP_INVVPID_SINGLE_CONTEXT_MASK            0x01
#define IA32_VMX_EPT_VPID_CAP_INVVPID_SINGLE_CONTEXT(_)              (((_) >> 41) & 0x01)
     * [Bit 42] When set to 1, the all-context INVVPID type is supported.
    UINT64 InvvpidAllContexts                                      : 1;
#define IA32_VMX_EPT_VPID_CAP_INVVPID_ALL_CONTEXTS_BIT               42
#define IA32_VMX_EPT_VPID_CAP_INVVPID_ALL_CONTEXTS_FLAG              0x40000000000
#define IA32_VMX_EPT_VPID_CAP_INVVPID_ALL_CONTEXTS_MASK              0x01
#define IA32_VMX_EPT_VPID_CAP_INVVPID_ALL_CONTEXTS(_)                (((_) >> 42) & 0x01)
     * [Bit 43] When set to 1, the single-context-retaining-globals INVVPID type is supported.
    UINT64 InvvpidSingleContextRetainGlobals                       : 1;
#define IA32_VMX_EPT_VPID_CAP_INVVPID_SINGLE_CONTEXT_RETAIN_GLOBALS_BIT 43
#define IA32_VMX_EPT_VPID_CAP_INVVPID_SINGLE_CONTEXT_RETAIN_GLOBALS_FLAG 0x80000000000
#define IA32_VMX_EPT_VPID_CAP_INVVPID_SINGLE_CONTEXT_RETAIN_GLOBALS_MASK 0x01
#define IA32_VMX_EPT_VPID_CAP_INVVPID_SINGLE_CONTEXT_RETAIN_GLOBALS(_) (((_) >> 43) & 0x01)
    UINT64 Reserved9                                               : 4;
     * [Bits 53:48] Enumerate the maximum HLAT prefix size. It is expected that any processor that supports the 1-setting of
     * the "enable HLAT" VM-execution control will enumerate this value as 1.
     *
    UINT64 MaxHlatPrefixSize                                       : 6;
#define IA32_VMX_EPT_VPID_CAP_MAX_HLAT_PREFIX_SIZE_BIT               48
#define IA32_VMX_EPT_VPID_CAP_MAX_HLAT_PREFIX_SIZE_FLAG              0x3F000000000000
#define IA32_VMX_EPT_VPID_CAP_MAX_HLAT_PREFIX_SIZE_MASK              0x3F
#define IA32_VMX_EPT_VPID_CAP_MAX_HLAT_PREFIX_SIZE(_)                (((_) >> 48) & 0x3F)
    UINT64 Reserved10                                              : 10;
  };
  UINT64 AsUInt;
} IA32_VMX_EPT_VPID_CAP_REGISTER;*/
return true
}

func (i *ia32) *           IA32_VMX_TRUE_()(ok bool){//col:12478
/* *           IA32_VMX_TRUE_(x)_CTLS
 *
 * Capability Reporting Register of Pin-Based VM-Execution Flex Controls, Primary Processor-Based VM-Execution Flex
 * Controls, VM-Exit Flex Controls and VM-Entry Flex Controls.
 *
#define IA32_VMX_TRUE_PINBASED_CTLS                                  0x0000048D
#define IA32_VMX_TRUE_PROCBASED_CTLS                                 0x0000048E
#define IA32_VMX_TRUE_EXIT_CTLS                                      0x0000048F
#define IA32_VMX_TRUE_ENTRY_CTLS                                     0x00000490
typedef union
{
  struct
  {
     * [Bits 31:0] Indicate the allowed 0-settings of these controls. VM entry allows control X to be 0 if bit X in the MSR is
     * cleared to 0; if bit X in the MSR is set to 1, VM entry fails if control X is 0.
    UINT64 Allowed0Settings                                        : 32;
#define IA32_VMX_TRUE_CTLS_ALLOWED_0_SETTINGS_BIT                    0
#define IA32_VMX_TRUE_CTLS_ALLOWED_0_SETTINGS_FLAG                   0xFFFFFFFF
#define IA32_VMX_TRUE_CTLS_ALLOWED_0_SETTINGS_MASK                   0xFFFFFFFF
#define IA32_VMX_TRUE_CTLS_ALLOWED_0_SETTINGS(_)                     (((_) >> 0) & 0xFFFFFFFF)
     * [Bits 63:32] Indicate the allowed 1-settings of these controls. VM entry allows control X to be 1 if bit 32+X in the MSR
     * is set to 1; if bit 32+X in the MSR is cleared to 0, VM entry fails if control X is 1.
    UINT64 Allowed1Settings                                        : 32;
#define IA32_VMX_TRUE_CTLS_ALLOWED_1_SETTINGS_BIT                    32
#define IA32_VMX_TRUE_CTLS_ALLOWED_1_SETTINGS_FLAG                   0xFFFFFFFF00000000
#define IA32_VMX_TRUE_CTLS_ALLOWED_1_SETTINGS_MASK                   0xFFFFFFFF
#define IA32_VMX_TRUE_CTLS_ALLOWED_1_SETTINGS(_)                     (((_) >> 32) & 0xFFFFFFFF)
  };
  UINT64 AsUInt;
} IA32_VMX_TRUE_CTLS_REGISTER;*/
return true
}

func (i *ia32)#define IA32_VMX_VMFUNC_EPTP_SWITCHING()(ok bool){//col:12511
/*#define IA32_VMX_VMFUNC_EPTP_SWITCHING(_)                            (((_) >> 0) & 0x01)
    UINT64 Reserved1                                               : 63;
  };
  UINT64 AsUInt;
} IA32_VMX_VMFUNC_REGISTER;*/
return true
}

func (i *ia32)#define IA32_VMX_PROCBASED_CTLS3_LOADIWKEY_EXITING()(ok bool){//col:12578
/*#define IA32_VMX_PROCBASED_CTLS3_LOADIWKEY_EXITING(_)                (((_) >> 0) & 0x01)
     *
     * [Bit 1] This control enables hypervisor-managed linear-address translation.
     *
    UINT64 EnableHlat                                              : 1;
#define IA32_VMX_PROCBASED_CTLS3_ENABLE_HLAT_BIT                     1
#define IA32_VMX_PROCBASED_CTLS3_ENABLE_HLAT_FLAG                    0x02
#define IA32_VMX_PROCBASED_CTLS3_ENABLE_HLAT_MASK                    0x01
#define IA32_VMX_PROCBASED_CTLS3_ENABLE_HLAT(_)                      (((_) >> 1) & 0x01)
     *
     * [Bit 2] If this control is 1, EPT permissions can be specified to allow writes only for paging-related control updates.
     *
    UINT64 EptPagingWrite                                          : 1;
#define IA32_VMX_PROCBASED_CTLS3_EPT_PAGING_WRITE_BIT                2
#define IA32_VMX_PROCBASED_CTLS3_EPT_PAGING_WRITE_FLAG               0x04
#define IA32_VMX_PROCBASED_CTLS3_EPT_PAGING_WRITE_MASK               0x01
#define IA32_VMX_PROCBASED_CTLS3_EPT_PAGING_WRITE(_)                 (((_) >> 2) & 0x01)
     * [Bit 3] If this control is 1, EPT permissions can be specified to prevent accesses using linear addresses verification
     * whose translation has certain properties.
     *
    UINT64 GuestPaging                                             : 1;
#define IA32_VMX_PROCBASED_CTLS3_GUEST_PAGING_BIT                    3
#define IA32_VMX_PROCBASED_CTLS3_GUEST_PAGING_FLAG                   0x08
#define IA32_VMX_PROCBASED_CTLS3_GUEST_PAGING_MASK                   0x01
#define IA32_VMX_PROCBASED_CTLS3_GUEST_PAGING(_)                     (((_) >> 3) & 0x01)
    UINT64 Reserved1                                               : 60;
  };
  UINT64 AsUInt;
} IA32_VMX_PROCBASED_CTLS3_REGISTER;*/
return true
}

func (i *ia32)#define IA32_VMX_EXIT_CTLS2_RESERVED()(ok bool){//col:12601
/*#define IA32_VMX_EXIT_CTLS2_RESERVED(_)                              (((_) >> 0) & 0xFFFFFFFFFFFFFFFF)
  };
  UINT64 AsUInt;
} IA32_VMX_EXIT_CTLS2_REGISTER;*/
return true
}

func (i *ia32) *           IA32_A_PMC()(ok bool){//col:12645
/* *           IA32_A_PMC(n)
 *
 * Full Width Writable IA32_PMC(n) Alias.
 *
#define IA32_A_PMC0                                                  0x000004C1
#define IA32_A_PMC1                                                  0x000004C2
#define IA32_A_PMC2                                                  0x000004C3
#define IA32_A_PMC3                                                  0x000004C4
#define IA32_A_PMC4                                                  0x000004C5
#define IA32_A_PMC5                                                  0x000004C6
#define IA32_A_PMC6                                                  0x000004C7
#define IA32_A_PMC7                                                  0x000004C8
 * Allows software to signal some MCEs to only a single logical processor in the system.
 *
#define IA32_MCG_EXT_CTL                                             0x000004D0
typedef union
{
  struct
  {
    UINT64 LmceEn                                                  : 1;
#define IA32_MCG_EXT_CTL_LMCE_EN_BIT                                 0
#define IA32_MCG_EXT_CTL_LMCE_EN_FLAG                                0x01
#define IA32_MCG_EXT_CTL_LMCE_EN_MASK                                0x01
#define IA32_MCG_EXT_CTL_LMCE_EN(_)                                  (((_) >> 0) & 0x01)
    UINT64 Reserved1                                               : 63;
  };
  UINT64 AsUInt;
} IA32_MCG_EXT_CTL_REGISTER;*/
return true
}

func (i *ia32)#define IA32_SGX_SVN_STATUS_LOCK()(ok bool){//col:12698
/*#define IA32_SGX_SVN_STATUS_LOCK(_)                                  (((_) >> 0) & 0x01)
    UINT64 Reserved1                                               : 15;
     *
     * [Bits 23:16] - If CPUID.01H:ECX.SMX = 1, this field reflects the expected threshold of Intel SGX SVN for the SINIT ACM.
     * - If CPUID.01H:ECX.SMX = 0, this field is reserved (0).
     *
    UINT64 SgxSvnSinit                                             : 8;
#define IA32_SGX_SVN_STATUS_SGX_SVN_SINIT_BIT                        16
#define IA32_SGX_SVN_STATUS_SGX_SVN_SINIT_FLAG                       0xFF0000
#define IA32_SGX_SVN_STATUS_SGX_SVN_SINIT_MASK                       0xFF
#define IA32_SGX_SVN_STATUS_SGX_SVN_SINIT(_)                         (((_) >> 16) & 0xFF)
    UINT64 Reserved2                                               : 40;
  };
  UINT64 AsUInt;
} IA32_SGX_SVN_STATUS_REGISTER;*/
return true
}

func (i *ia32) *          ()(ok bool){//col:12738
/* *          (CPUID.(EAX=14H,ECX=0):ECX[2] = 1) ) )
#define IA32_RTIT_OUTPUT_BASE                                        0x00000560
typedef union
{
  struct
  {
    UINT64 Reserved1                                               : 7;
     *
     * [Bits 47:7] The base physical address. How this address is used depends on the value of IA32_RTIT_CTL.ToPA:
     * - 0: This is the base physical address of a single, contiguous physical output region. This could be mapped to DRAM or
     * to MMIO, depending on the value. The base address should be aligned with the size of the region, such that none of the
     * 1s in the mask value overlap with 1s in the base address. If the base is not aligned, an operational error will result.
     * - 1: The base physical address of the current ToPA table. The address must be 4K aligned. Writing an address in which
     * bits 11:7 are non-zero will not cause a \#GP, but an operational error will be signaled once TraceEn is set.
     *
    UINT64 BasePhysicalAddress                                     : 41;
#define IA32_RTIT_OUTPUT_BASE_BASE_PHYSICAL_ADDRESS_BIT              7
#define IA32_RTIT_OUTPUT_BASE_BASE_PHYSICAL_ADDRESS_FLAG             0xFFFFFFFFFF80
#define IA32_RTIT_OUTPUT_BASE_BASE_PHYSICAL_ADDRESS_MASK             0x1FFFFFFFFFF
#define IA32_RTIT_OUTPUT_BASE_BASE_PHYSICAL_ADDRESS(_)               (((_) >> 7) & 0x1FFFFFFFFFF)
    UINT64 Reserved2                                               : 16;
  };
  UINT64 AsUInt;
} IA32_RTIT_OUTPUT_BASE_REGISTER;*/
return true
}

func (i *ia32) *          ()(ok bool){//col:12807
/* *          (CPUID.(EAX=14H,ECX=0):ECX[2] = 1) ) )
#define IA32_RTIT_OUTPUT_MASK_PTRS                                   0x00000561
typedef union
{
  struct
  {
     * [Bits 6:0] Forced to 1, writes are ignored.
    UINT64 LowerMask                                               : 7;
#define IA32_RTIT_OUTPUT_MASK_PTRS_LOWER_MASK_BIT                    0
#define IA32_RTIT_OUTPUT_MASK_PTRS_LOWER_MASK_FLAG                   0x7F
#define IA32_RTIT_OUTPUT_MASK_PTRS_LOWER_MASK_MASK                   0x7F
#define IA32_RTIT_OUTPUT_MASK_PTRS_LOWER_MASK(_)                     (((_) >> 0) & 0x7F)
     *
     * [Bits 31:7] The use of this field depends on the value of IA32_RTIT_CTL.ToPA:
     * - 0: This field holds bits 31:7 of the mask value for the single, contiguous physical output region. The size of this
     * field indicates that regions can be of size 128B up to 4GB. This value (combined with the lower 7 bits, which are
     * reserved to 1) will be ANDed with the OutputOffset field to determine the next write address. All 1s in this field
     * should be consecutive and starting at bit 7, otherwise the region will not be contiguous, and an operational error will
     * be signaled when TraceEn is set.
     * - 1: This field holds bits 27:3 of the offset pointer into the current ToPA table. This value can be added to the
     * IA32_RTIT_OUTPUT_BASE value to produce a pointer to the current ToPA table entry, which itself is a pointer to the
     * current output region. In this scenario, the lower 7 reserved bits are ignored. This field supports tables up to 256
     * MBytes in size.
     *
    UINT64 MaskOrTableOffset                                       : 25;
#define IA32_RTIT_OUTPUT_MASK_PTRS_MASK_OR_TABLE_OFFSET_BIT          7
#define IA32_RTIT_OUTPUT_MASK_PTRS_MASK_OR_TABLE_OFFSET_FLAG         0xFFFFFF80
#define IA32_RTIT_OUTPUT_MASK_PTRS_MASK_OR_TABLE_OFFSET_MASK         0x1FFFFFF
#define IA32_RTIT_OUTPUT_MASK_PTRS_MASK_OR_TABLE_OFFSET(_)           (((_) >> 7) & 0x1FFFFFF)
     *
     * [Bits 63:32] The use of this field depends on the value of IA32_RTIT_CTL.ToPA:
     * - 0: This is bits 31:0 of the offset pointer into the single, contiguous physical output region. This value will be
     * added to the IA32_RTIT_OUTPUT_BASE value to form the physical address at which the next byte of packet output data will
     * be written. This value must be less than or equal to the MaskOrTableOffset field, otherwise an operational error will be
     * signaled when TraceEn is set.
     * - 1: This field holds bits 31:0 of the offset pointer into the current ToPA output region. This value will be added to
     * the output region base field, found in the current ToPA table entry, to form the physical address at which the next byte
     * of trace output data will be written. This value must be less than the ToPA entry size, otherwise an operational error
     * will be signaled when TraceEn is set.
     *
    UINT64 OutputOffset                                            : 32;
#define IA32_RTIT_OUTPUT_MASK_PTRS_OUTPUT_OFFSET_BIT                 32
#define IA32_RTIT_OUTPUT_MASK_PTRS_OUTPUT_OFFSET_FLAG                0xFFFFFFFF00000000
#define IA32_RTIT_OUTPUT_MASK_PTRS_OUTPUT_OFFSET_MASK                0xFFFFFFFF
#define IA32_RTIT_OUTPUT_MASK_PTRS_OUTPUT_OFFSET(_)                  (((_) >> 32) & 0xFFFFFFFF)
  };
  UINT64 AsUInt;
} IA32_RTIT_OUTPUT_MASK_PTRS_REGISTER;*/
return true
}

func (i *ia32)     * Note that the processor will clear this bit on \#SMI ()(ok bool){//col:13179
/*     * Note that the processor will clear this bit on \#SMI (Section) and warm reset. Other MSR bits of IA32_RTIT_CTL (and
     * other trace configuration MSRs) are not impacted by these events.
     *
    UINT64 TraceEnabled                                            : 1;
#define IA32_RTIT_CTL_TRACE_ENABLED_BIT                              0
#define IA32_RTIT_CTL_TRACE_ENABLED_FLAG                             0x01
#define IA32_RTIT_CTL_TRACE_ENABLED_MASK                             0x01
#define IA32_RTIT_CTL_TRACE_ENABLED(_)                               (((_) >> 0) & 0x01)
     *
     * [Bit 1] - 0: Disables CYC Packet.
     * - 1: Enables CYC Packet.
     *
    UINT64 CycEnabled                                              : 1;
#define IA32_RTIT_CTL_CYC_ENABLED_BIT                                1
#define IA32_RTIT_CTL_CYC_ENABLED_FLAG                               0x02
#define IA32_RTIT_CTL_CYC_ENABLED_MASK                               0x01
#define IA32_RTIT_CTL_CYC_ENABLED(_)                                 (((_) >> 1) & 0x01)
     *
     * [Bit 2] - 0: Packet generation is disabled when CPL = 0.
     * - 1: Packet generation may be enabled when CPL = 0.
    UINT64 Os                                                      : 1;
#define IA32_RTIT_CTL_OS_BIT                                         2
#define IA32_RTIT_CTL_OS_FLAG                                        0x04
#define IA32_RTIT_CTL_OS_MASK                                        0x01
#define IA32_RTIT_CTL_OS(_)                                          (((_) >> 2) & 0x01)
     *
     * [Bit 3] - 0: Packet generation is disabled when CPL > 0.
     * - 1: Packet generation may be enabled when CPL > 0.
    UINT64 User                                                    : 1;
#define IA32_RTIT_CTL_USER_BIT                                       3
#define IA32_RTIT_CTL_USER_FLAG                                      0x08
#define IA32_RTIT_CTL_USER_MASK                                      0x01
#define IA32_RTIT_CTL_USER(_)                                        (((_) >> 3) & 0x01)
     *
     * [Bit 4] - 0: Power Event Trace packets are disabled.
     * - 1: Power Event Trace packets are enabled.
     *
    UINT64 PowerEventTraceEnabled                                  : 1;
#define IA32_RTIT_CTL_POWER_EVENT_TRACE_ENABLED_BIT                  4
#define IA32_RTIT_CTL_POWER_EVENT_TRACE_ENABLED_FLAG                 0x10
#define IA32_RTIT_CTL_POWER_EVENT_TRACE_ENABLED_MASK                 0x01
#define IA32_RTIT_CTL_POWER_EVENT_TRACE_ENABLED(_)                   (((_) >> 4) & 0x01)
     *
     * [Bit 5] - 0: PTW packets are not followed by FUPs.
     * - 1: PTW packets are followed by FUPs.
    UINT64 FupOnPtw                                                : 1;
#define IA32_RTIT_CTL_FUP_ON_PTW_BIT                                 5
#define IA32_RTIT_CTL_FUP_ON_PTW_FLAG                                0x20
#define IA32_RTIT_CTL_FUP_ON_PTW_MASK                                0x01
#define IA32_RTIT_CTL_FUP_ON_PTW(_)                                  (((_) >> 5) & 0x01)
     *
     * [Bit 6] - 0: Trace output is directed to the memory subsystem, mechanism depends on IA32_RTIT_CTL.ToPA.
     * - 1: Trace output is directed to the trace transport subsystem, IA32_RTIT_CTL.ToPA is ignored.
     *
    UINT64 FabricEnabled                                           : 1;
#define IA32_RTIT_CTL_FABRIC_ENABLED_BIT                             6
#define IA32_RTIT_CTL_FABRIC_ENABLED_FLAG                            0x40
#define IA32_RTIT_CTL_FABRIC_ENABLED_MASK                            0x01
#define IA32_RTIT_CTL_FABRIC_ENABLED(_)                              (((_) >> 6) & 0x01)
     *
     * [Bit 7] - 0: Disables CR3 filtering.
     * - 1: Enables CR3 filtering.
    UINT64 Cr3Filter                                               : 1;
#define IA32_RTIT_CTL_CR3_FILTER_BIT                                 7
#define IA32_RTIT_CTL_CR3_FILTER_FLAG                                0x80
#define IA32_RTIT_CTL_CR3_FILTER_MASK                                0x01
#define IA32_RTIT_CTL_CR3_FILTER(_)                                  (((_) >> 7) & 0x01)
     *
     * [Bit 8] - 0: Single-range output scheme enabled.
     * - 1: ToPA output scheme enabled.
     *
     *          ECX=0):ECX.TOPA[bit 0] = 1, and IA32_RTIT_CTL.FabricEn=0
     *          WRMSR to IA32_RTIT_CTL that sets TraceEn but clears this bit and FabricEn would cause \#GP: If CPUID.(EAX=14H,
     *          ECX=0):ECX.SNGLRGNOUT[bit 2] = 0 WRMSR to IA32_RTIT_CTL that sets this bit causes \#GP: If CPUID.(EAX=14H,
     *          ECX=0):ECX.TOPA[bit 0] = 0
    UINT64 Topa                                                    : 1;
#define IA32_RTIT_CTL_TOPA_BIT                                       8
#define IA32_RTIT_CTL_TOPA_FLAG                                      0x100
#define IA32_RTIT_CTL_TOPA_MASK                                      0x01
#define IA32_RTIT_CTL_TOPA(_)                                        (((_) >> 8) & 0x01)
     *
     * [Bit 9] - 0: Disables MTC Packet.
     * - 1: Enables MTC Packet.
     *
    UINT64 MtcEnabled                                              : 1;
#define IA32_RTIT_CTL_MTC_ENABLED_BIT                                9
#define IA32_RTIT_CTL_MTC_ENABLED_FLAG                               0x200
#define IA32_RTIT_CTL_MTC_ENABLED_MASK                               0x01
#define IA32_RTIT_CTL_MTC_ENABLED(_)                                 (((_) >> 9) & 0x01)
     *
     * [Bit 10] - 0: Disable TSC packets.
     * - 1: Enable TSC packets.
     *
    UINT64 TscEnabled                                              : 1;
#define IA32_RTIT_CTL_TSC_ENABLED_BIT                                10
#define IA32_RTIT_CTL_TSC_ENABLED_FLAG                               0x400
#define IA32_RTIT_CTL_TSC_ENABLED_MASK                               0x01
#define IA32_RTIT_CTL_TSC_ENABLED(_)                                 (((_) >> 10) & 0x01)
     *
     * [Bit 11] - 0: Enable RET compression.
     * - 1: Disable RET compression.
     *
    UINT64 RetCompressionDisabled                                  : 1;
#define IA32_RTIT_CTL_RET_COMPRESSION_DISABLED_BIT                   11
#define IA32_RTIT_CTL_RET_COMPRESSION_DISABLED_FLAG                  0x800
#define IA32_RTIT_CTL_RET_COMPRESSION_DISABLED_MASK                  0x01
#define IA32_RTIT_CTL_RET_COMPRESSION_DISABLED(_)                    (((_) >> 11) & 0x01)
     *
     * [Bit 12] - 0: PTWRITE packet generation disabled.
     * - 1: PTWRITE packet generation enabled.
    UINT64 PtwEnabled                                              : 1;
#define IA32_RTIT_CTL_PTW_ENABLED_BIT                                12
#define IA32_RTIT_CTL_PTW_ENABLED_FLAG                               0x1000
#define IA32_RTIT_CTL_PTW_ENABLED_MASK                               0x01
#define IA32_RTIT_CTL_PTW_ENABLED(_)                                 (((_) >> 12) & 0x01)
     *
     * [Bit 13] - 0: Disable COFI-based packets.
     * - 1: Enable COFI-based packets: FUP, TIP, TIP.PGE, TIP.PGD, TNT, MODE.Exec, MODE.TSX.
     *
    UINT64 BranchEnabled                                           : 1;
#define IA32_RTIT_CTL_BRANCH_ENABLED_BIT                             13
#define IA32_RTIT_CTL_BRANCH_ENABLED_FLAG                            0x2000
#define IA32_RTIT_CTL_BRANCH_ENABLED_MASK                            0x01
#define IA32_RTIT_CTL_BRANCH_ENABLED(_)                              (((_) >> 13) & 0x01)
     *
     * [Bits 17:14] Defines MTC packet Frequency, which is based on the core crystal clock, or Always Running Timer (ART). MTC
     * will be sent each time the selected ART bit toggles. The following Encodings are defined:
     * 0: ART(0), 1: ART(1), 2: ART(2), 3: ART(3), 4: ART(4), 5: ART(5), 6: ART(6), 7: ART(7), 8: ART(8), 9: ART(9), 10:
     * ART(10), 11: ART(11), 12: ART(12), 13: ART(13), 14: ART(14), 15: ART(15)
     *
    UINT64 MtcFrequency                                            : 4;
#define IA32_RTIT_CTL_MTC_FREQUENCY_BIT                              14
#define IA32_RTIT_CTL_MTC_FREQUENCY_FLAG                             0x3C000
#define IA32_RTIT_CTL_MTC_FREQUENCY_MASK                             0x0F
#define IA32_RTIT_CTL_MTC_FREQUENCY(_)                               (((_) >> 14) & 0x0F)
    UINT64 Reserved1                                               : 1;
     *
     * [Bits 22:19] CYC packet threshold. CYC packets will be sent with the first eligible packet after N cycles have passed
     * since the last CYC packet. If CycThresh is 0 then N=0, otherwise N is defined as 2(CycThresh-1). The following Encodings
     * are defined:
     * 0: 0, 1: 1, 2: 2, 3: 4, 4: 8, 5: 16, 6: 32, 7: 64, 8: 128, 9: 256, 10: 512, 11: 1024, 12: 2048, 13: 4096, 14: 8192, 15:
     * 16384
     *
    UINT64 CycThreshold                                            : 4;
#define IA32_RTIT_CTL_CYC_THRESHOLD_BIT                              19
#define IA32_RTIT_CTL_CYC_THRESHOLD_FLAG                             0x780000
#define IA32_RTIT_CTL_CYC_THRESHOLD_MASK                             0x0F
#define IA32_RTIT_CTL_CYC_THRESHOLD(_)                               (((_) >> 19) & 0x0F)
    UINT64 Reserved2                                               : 1;
     *
     * [Bits 27:24] Indicates the frequency of PSB packets. PSB packet frequency is based on the number of Intel PT packet
     * bytes output, so this field allows the user to determine the increment of IA32_IA32_RTIT_STATUS.PacketByteCnt that
     * should cause a PSB to be generated. Note that PSB insertion is not precise, but the average output bytes per PSB should
     * approximate the SW selected period. The following Encodings are defined:
     * 0: 2K, 1: 4K, 2: 8K, 3: 16K, 4: 32K, 5: 64K, 6: 128K, 7: 256K, 8: 512K, 9: 1M, 10: 2M, 11: 4M, 12: 8M, 13: 16M, 14: 32M,
     * 15: 64M
     *
    UINT64 PsbFrequency                                            : 4;
#define IA32_RTIT_CTL_PSB_FREQUENCY_BIT                              24
#define IA32_RTIT_CTL_PSB_FREQUENCY_FLAG                             0xF000000
#define IA32_RTIT_CTL_PSB_FREQUENCY_MASK                             0x0F
#define IA32_RTIT_CTL_PSB_FREQUENCY(_)                               (((_) >> 24) & 0x0F)
    UINT64 Reserved3                                               : 4;
     *
     * [Bits 35:32] Configures the base/limit register pair IA32_RTIT_ADDR0_A/B based on the following encodings:
     * - 0: ADDR0 range unused.
     * - 1: The [IA32_RTIT_ADDR0_A..IA32_RTIT_ADDR0_B] range defines a FilterEn range. FilterEn will only be set when the IP is
     * within this range, though other FilterEn ranges can additionally be used.
     * - 2: The [IA32_RTIT_ADDR0_A..IA32_RTIT_ADDR0_B] range defines a TraceStop range. TraceStop will be asserted if code
     * branches into this range.
     * - 3..15: Reserved (\#GP).
     *
    UINT64 Addr0Cfg                                                : 4;
#define IA32_RTIT_CTL_ADDR0_CFG_BIT                                  32
#define IA32_RTIT_CTL_ADDR0_CFG_FLAG                                 0xF00000000
#define IA32_RTIT_CTL_ADDR0_CFG_MASK                                 0x0F
#define IA32_RTIT_CTL_ADDR0_CFG(_)                                   (((_) >> 32) & 0x0F)
     *
     * [Bits 39:36] Configures the base/limit register pair IA32_RTIT_ADDR1_A/B based on the following encodings:
     * - 0: ADDR1 range unused.
     * - 1: The [IA32_RTIT_ADDR1_A..IA32_RTIT_ADDR1_B] range defines a FilterEn range. FilterEn will only be set when the IP is
     * within this range, though other FilterEn ranges can additionally be used.
     * - 2: The [IA32_RTIT_ADDR1_A..IA32_RTIT_ADDR1_B] range defines a TraceStop range. TraceStop will be asserted if code
     * branches into this range.
     * - 3..15: Reserved (\#GP).
     *
    UINT64 Addr1Cfg                                                : 4;
#define IA32_RTIT_CTL_ADDR1_CFG_BIT                                  36
#define IA32_RTIT_CTL_ADDR1_CFG_FLAG                                 0xF000000000
#define IA32_RTIT_CTL_ADDR1_CFG_MASK                                 0x0F
#define IA32_RTIT_CTL_ADDR1_CFG(_)                                   (((_) >> 36) & 0x0F)
     *
     * [Bits 43:40] Configures the base/limit register pair IA32_RTIT_ADDR2_A/B based on the following encodings:
     * - 0: ADDR2 range unused.
     * - 1: The [IA32_RTIT_ADDR2_A..IA32_RTIT_ADDR2_B] range defines a FilterEn range. FilterEn will only be set when the IP is
     * within this range, though other FilterEn ranges can additionally be used.
     * - 2: The [IA32_RTIT_ADDR2_A..IA32_RTIT_ADDR2_B] range defines a TraceStop range. TraceStop will be asserted if code
     * branches into this range.
     * - 3..15: Reserved (\#GP).
     *
    UINT64 Addr2Cfg                                                : 4;
#define IA32_RTIT_CTL_ADDR2_CFG_BIT                                  40
#define IA32_RTIT_CTL_ADDR2_CFG_FLAG                                 0xF0000000000
#define IA32_RTIT_CTL_ADDR2_CFG_MASK                                 0x0F
#define IA32_RTIT_CTL_ADDR2_CFG(_)                                   (((_) >> 40) & 0x0F)
     *
     * [Bits 47:44] Configures the base/limit register pair IA32_RTIT_ADDR3_A/B based on the following encodings:
     * - 0: ADDR3 range unused.
     * - 1: The [IA32_RTIT_ADDR3_A..IA32_RTIT_ADDR3_B] range defines a FilterEn range. FilterEn will only be set when the IP is
     * within this range, though other FilterEn ranges can additionally be used.
     * - 2: The [IA32_RTIT_ADDR3_A..IA32_RTIT_ADDR3_B] range defines a TraceStop range. TraceStop will be asserted if code
     * branches into this range.
     * - 3..15: Reserved (\#GP).
     *
    UINT64 Addr3Cfg                                                : 4;
#define IA32_RTIT_CTL_ADDR3_CFG_BIT                                  44
#define IA32_RTIT_CTL_ADDR3_CFG_FLAG                                 0xF00000000000
#define IA32_RTIT_CTL_ADDR3_CFG_MASK                                 0x0F
#define IA32_RTIT_CTL_ADDR3_CFG(_)                                   (((_) >> 44) & 0x0F)
    UINT64 Reserved4                                               : 8;
     *
     * [Bit 56] - 1: Enables use of IA32_RTIT_STATUS bits PendPSB[6] and PendTopaPMI[7].
     * - 0: IA32_RTIT_STATUS bits 6 and 7 are ignored.
     *
    UINT64 InjectPsbPmiOnEnable                                    : 1;
#define IA32_RTIT_CTL_INJECT_PSB_PMI_ON_ENABLE_BIT                   56
#define IA32_RTIT_CTL_INJECT_PSB_PMI_ON_ENABLE_FLAG                  0x100000000000000
#define IA32_RTIT_CTL_INJECT_PSB_PMI_ON_ENABLE_MASK                  0x01
#define IA32_RTIT_CTL_INJECT_PSB_PMI_ON_ENABLE(_)                    (((_) >> 56) & 0x01)
    UINT64 Reserved5                                               : 7;
  };
  UINT64 AsUInt;
} IA32_RTIT_CTL_REGISTER;*/
return true
}

func (i *ia32)#define IA32_RTIT_STATUS_FILTER_ENABLED()(ok bool){//col:13319
/*#define IA32_RTIT_STATUS_FILTER_ENABLED(_)                           (((_) >> 0) & 0x01)
     *
     * [Bit 1] The processor sets this bit to indicate that tracing is allowed for the current context. Writes are ignored.
     *
    UINT64 ContextEnabled                                          : 1;
#define IA32_RTIT_STATUS_CONTEXT_ENABLED_BIT                         1
#define IA32_RTIT_STATUS_CONTEXT_ENABLED_FLAG                        0x02
#define IA32_RTIT_STATUS_CONTEXT_ENABLED_MASK                        0x01
#define IA32_RTIT_STATUS_CONTEXT_ENABLED(_)                          (((_) >> 1) & 0x01)
     *
     * [Bit 2] The processor sets this bit to indicate that tracing is enabled. Writes are ignored.
     *
    UINT64 TriggerEnabled                                          : 1;
#define IA32_RTIT_STATUS_TRIGGER_ENABLED_BIT                         2
#define IA32_RTIT_STATUS_TRIGGER_ENABLED_FLAG                        0x04
#define IA32_RTIT_STATUS_TRIGGER_ENABLED_MASK                        0x01
#define IA32_RTIT_STATUS_TRIGGER_ENABLED(_)                          (((_) >> 2) & 0x01)
    UINT64 Reserved1                                               : 1;
     *
     * [Bit 4] The processor sets this bit to indicate that an operational error has been encountered. When this bit is set,
     * TriggerEn is cleared to 0 and packet generation is disabled.
     * When TraceEn is cleared, software can write this bit. Once it is set, only software can clear it. It is not recommended
     * that software ever set this bit, except in cases where it is restoring a prior saved state.
     *
    UINT64 Error                                                   : 1;
#define IA32_RTIT_STATUS_ERROR_BIT                                   4
#define IA32_RTIT_STATUS_ERROR_FLAG                                  0x10
#define IA32_RTIT_STATUS_ERROR_MASK                                  0x01
#define IA32_RTIT_STATUS_ERROR(_)                                    (((_) >> 4) & 0x01)
     *
     * [Bit 5] The processor sets this bit to indicate that a ToPA Stop condition has been encountered. When this bit is set,
     * TriggerEn is cleared to 0 and packet generation is disabled.
     * When TraceEn is cleared, software can write this bit. Once it is set, only software can clear it. It is not recommended
     * that software ever set this bit, except in cases where it is restoring a prior saved state.
     *
    UINT64 Stopped                                                 : 1;
#define IA32_RTIT_STATUS_STOPPED_BIT                                 5
#define IA32_RTIT_STATUS_STOPPED_FLAG                                0x20
#define IA32_RTIT_STATUS_STOPPED_MASK                                0x01
#define IA32_RTIT_STATUS_STOPPED(_)                                  (((_) >> 5) & 0x01)
     *
     * [Bit 6] If IA32_RTIT_CTL.InjectPsbPmiOnEnable[56] = 1, the processor sets this bit when the threshold for a PSB+ to be
     * inserted has been reached. The processor will clear this bit when the PSB+ has been inserted into the trace. If PendPSB
     * = 1 and InjectPsbPmiOnEnable = 1 when IA32_RTIT_CTL.TraceEn[0] transitions from 0 to 1, a PSB+ will be inserted into the
     * trace.
     *
    UINT64 PendPsb                                                 : 1;
#define IA32_RTIT_STATUS_PEND_PSB_BIT                                6
#define IA32_RTIT_STATUS_PEND_PSB_FLAG                               0x40
#define IA32_RTIT_STATUS_PEND_PSB_MASK                               0x01
#define IA32_RTIT_STATUS_PEND_PSB(_)                                 (((_) >> 6) & 0x01)
     *
     * [Bit 7] If IA32_RTIT_CTL.InjectPsbPmiOnEnable[56] = 1, the processor sets this bit when the threshold for a ToPA PMI to
     * be inserted has been reached. Software should clear this bit once the ToPA PMI has been handled. If PendTopaPMI = 1 and
     * InjectPsbPmiOnEnable = 1 when IA32_RTIT_CTL.TraceEn[0] transitions from 0 to 1, a PMI will be pended.
     *
    UINT64 PendTopaPmi                                             : 1;
#define IA32_RTIT_STATUS_PEND_TOPA_PMI_BIT                           7
#define IA32_RTIT_STATUS_PEND_TOPA_PMI_FLAG                          0x80
#define IA32_RTIT_STATUS_PEND_TOPA_PMI_MASK                          0x01
#define IA32_RTIT_STATUS_PEND_TOPA_PMI(_)                            (((_) >> 7) & 0x01)
    UINT64 Reserved2                                               : 24;
     *
     * [Bits 48:32] This field is written by the processor, and holds a count of packet bytes that have been sent out. The
     * processor also uses this field to determine when the next PSB packet should be inserted. Note that the processor may
     * clear or modify this field at any time while IA32_RTIT_CTL.TraceEn=1. It will have a stable value when
     * IA32_RTIT_CTL.TraceEn=0.
     *
    UINT64 PacketByteCount                                         : 17;
#define IA32_RTIT_STATUS_PACKET_BYTE_COUNT_BIT                       32
#define IA32_RTIT_STATUS_PACKET_BYTE_COUNT_FLAG                      0x1FFFF00000000
#define IA32_RTIT_STATUS_PACKET_BYTE_COUNT_MASK                      0x1FFFF
#define IA32_RTIT_STATUS_PACKET_BYTE_COUNT(_)                        (((_) >> 32) & 0x1FFFF)
    UINT64 Reserved3                                               : 15;
  };
  UINT64 AsUInt;
} IA32_RTIT_STATUS_REGISTER;*/
return true
}

func (i *ia32)#define IA32_RTIT_CR3_MATCH_CR3_VALUE_TO_MATCH()(ok bool){//col:13350
/*#define IA32_RTIT_CR3_MATCH_CR3_VALUE_TO_MATCH(_)                    (((_) >> 5) & 0x7FFFFFFFFFFFFFF)
  };
  UINT64 AsUInt;
} IA32_RTIT_CR3_MATCH_REGISTER;*/
return true
}

func (i *ia32) *           IA32_RTIT_ADDR()(ok bool){//col:13422
/* *           IA32_RTIT_ADDR(x)
 *
 * The role of the IA32_RTIT_ADDRn_A/B register pairs, for each n, is determined by the corresponding ADDRn_CFG fields in
 * IA32_RTIT_CTL. The number of these register pairs is enumerated by CPUID.(EAX=14H, ECX=1):EAX.RANGECNT[2:0].
 *
 *           IA32_RTIT_ADDR(n)_A
 *
 * Region n Start Address.
 *
#define IA32_RTIT_ADDR0_A                                            0x00000580
#define IA32_RTIT_ADDR1_A                                            0x00000582
#define IA32_RTIT_ADDR2_A                                            0x00000584
#define IA32_RTIT_ADDR3_A                                            0x00000586
 *           IA32_RTIT_ADDR(n)_B
 *
 * Region n End Address.
 *
#define IA32_RTIT_ADDR0_B                                            0x00000581
#define IA32_RTIT_ADDR1_B                                            0x00000583
#define IA32_RTIT_ADDR2_B                                            0x00000585
#define IA32_RTIT_ADDR3_B                                            0x00000587
typedef union
{
  struct
  {
     * [Bits 47:0] Virtual Address.
    UINT64 VirtualAddress                                          : 48;
#define IA32_RTIT_ADDR_VIRTUAL_ADDRESS_BIT                           0
#define IA32_RTIT_ADDR_VIRTUAL_ADDRESS_FLAG                          0xFFFFFFFFFFFF
#define IA32_RTIT_ADDR_VIRTUAL_ADDRESS_MASK                          0xFFFFFFFFFFFF
#define IA32_RTIT_ADDR_VIRTUAL_ADDRESS(_)                            (((_) >> 0) & 0xFFFFFFFFFFFF)
     * [Bits 63:48] SignExt_VA.
    UINT64 SignExtVa                                               : 16;
#define IA32_RTIT_ADDR_SIGN_EXT_VA_BIT                               48
#define IA32_RTIT_ADDR_SIGN_EXT_VA_FLAG                              0xFFFF000000000000
#define IA32_RTIT_ADDR_SIGN_EXT_VA_MASK                              0xFFFF
#define IA32_RTIT_ADDR_SIGN_EXT_VA(_)                                (((_) >> 48) & 0xFFFF)
  };
  UINT64 AsUInt;
} IA32_RTIT_ADDR_REGISTER;*/
return true
}

func (i *ia32) *          CPUID.()(ok bool){//col:13560
/* *          CPUID.(EAX=07H,ECX=0H):EDX.CET_IBT[20] = 1.
#define IA32_U_CET                                                   0x000006A0
typedef union
{
  struct
  {
     * [Bit 0] When set to 1, enable shadow stacks at CPL3.
     *
    UINT64 ShStkEn                                                 : 1;
#define IA32_U_CET_SH_STK_EN_BIT                                     0
#define IA32_U_CET_SH_STK_EN_FLAG                                    0x01
#define IA32_U_CET_SH_STK_EN_MASK                                    0x01
#define IA32_U_CET_SH_STK_EN(_)                                      (((_) >> 0) & 0x01)
     * [Bit 1] When set to 1, enables the WRSSD/WRSSQ instructions.
     *
    UINT64 WrShstkEn                                               : 1;
#define IA32_U_CET_WR_SHSTK_EN_BIT                                   1
#define IA32_U_CET_WR_SHSTK_EN_FLAG                                  0x02
#define IA32_U_CET_WR_SHSTK_EN_MASK                                  0x01
#define IA32_U_CET_WR_SHSTK_EN(_)                                    (((_) >> 1) & 0x01)
     * [Bit 2] When set to 1, enables indirect branch tracking
     *
    UINT64 EndbrEn                                                 : 1;
#define IA32_U_CET_ENDBR_EN_BIT                                      2
#define IA32_U_CET_ENDBR_EN_FLAG                                     0x04
#define IA32_U_CET_ENDBR_EN_MASK                                     0x01
#define IA32_U_CET_ENDBR_EN(_)                                       (((_) >> 2) & 0x01)
     * [Bit 3] Enable legacy compatibility treatment for indirect branch tracking.
     *
    UINT64 LegIwEn                                                 : 1;
#define IA32_U_CET_LEG_IW_EN_BIT                                     3
#define IA32_U_CET_LEG_IW_EN_FLAG                                    0x08
#define IA32_U_CET_LEG_IW_EN_MASK                                    0x01
#define IA32_U_CET_LEG_IW_EN(_)                                      (((_) >> 3) & 0x01)
     * [Bit 4] When set to 1, enables use of no-track prefix for indirect branch tracking.
     *
    UINT64 NoTrackEn                                               : 1;
#define IA32_U_CET_NO_TRACK_EN_BIT                                   4
#define IA32_U_CET_NO_TRACK_EN_FLAG                                  0x10
#define IA32_U_CET_NO_TRACK_EN_MASK                                  0x01
#define IA32_U_CET_NO_TRACK_EN(_)                                    (((_) >> 4) & 0x01)
     * [Bit 5] When set to 1, disables suppression of CET indirect branch tracking on legacy compatibility.
     *
    UINT64 SuppressDis                                             : 1;
#define IA32_U_CET_SUPPRESS_DIS_BIT                                  5
#define IA32_U_CET_SUPPRESS_DIS_FLAG                                 0x20
#define IA32_U_CET_SUPPRESS_DIS_MASK                                 0x01
#define IA32_U_CET_SUPPRESS_DIS(_)                                   (((_) >> 5) & 0x01)
    UINT64 Reserved1                                               : 4;
     * [Bit 10] When set to 1, indirect branch tracking is suppressed. This bit can be written to 1 only if TRACKER is written
     * as IDLE.
     *
    UINT64 Suppress                                                : 1;
#define IA32_U_CET_SUPPRESS_BIT                                      10
#define IA32_U_CET_SUPPRESS_FLAG                                     0x400
#define IA32_U_CET_SUPPRESS_MASK                                     0x01
#define IA32_U_CET_SUPPRESS(_)                                       (((_) >> 10) & 0x01)
     * [Bit 11] Value of the indirect branch tracking state machine. Values: IDLE (0), WAIT_FOR_ENDBRANCH(1).
     *
    UINT64 Tracker                                                 : 1;
#define IA32_U_CET_TRACKER_BIT                                       11
#define IA32_U_CET_TRACKER_FLAG                                      0x800
#define IA32_U_CET_TRACKER_MASK                                      0x01
#define IA32_U_CET_TRACKER(_)                                        (((_) >> 11) & 0x01)
     * [Bits 63:12] Linear address bits 63:12 of a legacy code page bitmap used for legacy compatibility when indirect branch
     * tracking is enabled. If the processor does not support Intel 64 architecture, these fields have only 32 bits; bits 63:32
     * of the MSRs are reserved. On processors that support Intel 64 architecture this value cannot represent a non-canonical
     * address. In protected mode, only 31:0 are loaded. The linear address written must be aligned to 8 bytes and bits 2:0
     * must be 0 (hardware requires bits 1:0 to be 0).
     *
    UINT64 EbLegBitmapBase                                         : 52;
#define IA32_U_CET_EB_LEG_BITMAP_BASE_BIT                            12
#define IA32_U_CET_EB_LEG_BITMAP_BASE_FLAG                           0xFFFFFFFFFFFFF000
#define IA32_U_CET_EB_LEG_BITMAP_BASE_MASK                           0xFFFFFFFFFFFFF
#define IA32_U_CET_EB_LEG_BITMAP_BASE(_)                             (((_) >> 12) & 0xFFFFFFFFFFFFF)
  };
  UINT64 AsUInt;
} IA32_U_CET_REGISTER;*/
return true
}

func (i *ia32) *          CPUID.()(ok bool){//col:13681
/* *          CPUID.(EAX=07H,ECX=0H):EDX.CET_IBT[20] = 1.
#define IA32_S_CET                                                   0x000006A2
typedef union
{
  struct
  {
     * [Bit 0] When set to 1, enable shadow stacks at CPL0.
     *
    UINT64 ShStkEn                                                 : 1;
#define IA32_S_CET_SH_STK_EN_BIT                                     0
#define IA32_S_CET_SH_STK_EN_FLAG                                    0x01
#define IA32_S_CET_SH_STK_EN_MASK                                    0x01
#define IA32_S_CET_SH_STK_EN(_)                                      (((_) >> 0) & 0x01)
     * [Bit 1] When set to 1, enables the WRSSD/WRSSQ instructions.
     *
    UINT64 WrShstkEn                                               : 1;
#define IA32_S_CET_WR_SHSTK_EN_BIT                                   1
#define IA32_S_CET_WR_SHSTK_EN_FLAG                                  0x02
#define IA32_S_CET_WR_SHSTK_EN_MASK                                  0x01
#define IA32_S_CET_WR_SHSTK_EN(_)                                    (((_) >> 1) & 0x01)
     * [Bit 2] When set to 1, enables indirect branch tracking
     *
    UINT64 EndbrEn                                                 : 1;
#define IA32_S_CET_ENDBR_EN_BIT                                      2
#define IA32_S_CET_ENDBR_EN_FLAG                                     0x04
#define IA32_S_CET_ENDBR_EN_MASK                                     0x01
#define IA32_S_CET_ENDBR_EN(_)                                       (((_) >> 2) & 0x01)
     * [Bit 3] Enable legacy compatibility treatment for indirect branch tracking.
     *
    UINT64 LegIwEn                                                 : 1;
#define IA32_S_CET_LEG_IW_EN_BIT                                     3
#define IA32_S_CET_LEG_IW_EN_FLAG                                    0x08
#define IA32_S_CET_LEG_IW_EN_MASK                                    0x01
#define IA32_S_CET_LEG_IW_EN(_)                                      (((_) >> 3) & 0x01)
     * [Bit 4] When set to 1, enables use of no-track prefix for indirect branch tracking.
     *
    UINT64 NoTrackEn                                               : 1;
#define IA32_S_CET_NO_TRACK_EN_BIT                                   4
#define IA32_S_CET_NO_TRACK_EN_FLAG                                  0x10
#define IA32_S_CET_NO_TRACK_EN_MASK                                  0x01
#define IA32_S_CET_NO_TRACK_EN(_)                                    (((_) >> 4) & 0x01)
     * [Bit 5] When set to 1, disables suppression of CET indirect branch tracking on legacy compatibility.
     *
    UINT64 SuppressDis                                             : 1;
#define IA32_S_CET_SUPPRESS_DIS_BIT                                  5
#define IA32_S_CET_SUPPRESS_DIS_FLAG                                 0x20
#define IA32_S_CET_SUPPRESS_DIS_MASK                                 0x01
#define IA32_S_CET_SUPPRESS_DIS(_)                                   (((_) >> 5) & 0x01)
    UINT64 Reserved1                                               : 4;
     * [Bit 10] When set to 1, indirect branch tracking is suppressed. This bit can be written to 1 only if TRACKER is written
     * as IDLE.
     *
    UINT64 Suppress                                                : 1;
#define IA32_S_CET_SUPPRESS_BIT                                      10
#define IA32_S_CET_SUPPRESS_FLAG                                     0x400
#define IA32_S_CET_SUPPRESS_MASK                                     0x01
#define IA32_S_CET_SUPPRESS(_)                                       (((_) >> 10) & 0x01)
     * [Bit 11] Value of the indirect branch tracking state machine. Values: IDLE (0), WAIT_FOR_ENDBRANCH(1).
     *
    UINT64 Tracker                                                 : 1;
#define IA32_S_CET_TRACKER_BIT                                       11
#define IA32_S_CET_TRACKER_FLAG                                      0x800
#define IA32_S_CET_TRACKER_MASK                                      0x01
#define IA32_S_CET_TRACKER(_)                                        (((_) >> 11) & 0x01)
     * [Bits 63:12] Linear address bits 63:12 of a legacy code page bitmap used for legacy compatibility when indirect branch
     * tracking is enabled. If the processor does not support Intel 64 architecture, these fields have only 32 bits; bits 63:32
     * of the MSRs are reserved. On processors that support Intel 64 architecture this value cannot represent a non-canonical
     * address. In protected mode, only 31:0 are loaded. The linear address written must be aligned to 8 bytes and bits 2:0
     * must be 0 (hardware requires bits 1:0 to be 0).
     *
    UINT64 EbLegBitmapBase                                         : 52;
#define IA32_S_CET_EB_LEG_BITMAP_BASE_BIT                            12
#define IA32_S_CET_EB_LEG_BITMAP_BASE_FLAG                           0xFFFFFFFFFFFFF000
#define IA32_S_CET_EB_LEG_BITMAP_BASE_MASK                           0xFFFFFFFFFFFFF
#define IA32_S_CET_EB_LEG_BITMAP_BASE(_)                             (((_) >> 12) & 0xFFFFFFFFFFFFF)
  };
  UINT64 AsUInt;
} IA32_S_CET_REGISTER;*/
return true
}

func (i *ia32) * ()(ok bool){//col:13770
/* * (hardware requires bits 1:0 to be 0).
 *
#define IA32_PL0_SSP                                                 0x000006A4
 * Linear address to be loaded into SSP on transition to privilege level 1.
 * If the processor does not support Intel 64 architecture, these fields have only 32 bits; bits 63:32 of the MSRs are
 * reserved. On processors that support Intel 64 architecture this value cannot represent a non-canonical address. In
 * protected mode, only 31:0 are loaded. The linear address written must be aligned to 8 bytes and bits 2:0 must be 0
 * (hardware requires bits 1:0 to be 0).
 *
#define IA32_PL1_SSP                                                 0x000006A5
 * Linear address to be loaded into SSP on transition to privilege level 2.
 * If the processor does not support Intel 64 architecture, these fields have only 32 bits; bits 63:32 of the MSRs are
 * reserved. On processors that support Intel 64 architecture this value cannot represent a non-canonical address. In
 * protected mode, only 31:0 are loaded. The linear address written must be aligned to 8 bytes and bits 2:0 must be 0
 * (hardware requires bits 1:0 to be 0).
 *
#define IA32_PL2_SSP                                                 0x000006A6
 * Linear address to be loaded into SSP on transition to privilege level 3.
 * If the processor does not support Intel 64 architecture, these fields have only 32 bits; bits 63:32 of the MSRs are
 * reserved. On processors that support Intel 64 architecture this value cannot represent a non-canonical address. In
 * protected mode, only 31:0 are loaded. The linear address written must be aligned to 8 bytes and bits 2:0 must be 0
 * (hardware requires bits 1:0 to be 0).
 *
#define IA32_PL3_SSP                                                 0x000006A7
 * Linear address of a table of seven shadow stack pointers that are selected in IA-32e mode using the IST index (when not
 * 0) from the interrupt gate descriptor.
 * This MSR is not present on processors that do not support Intel 64 architecture. This field cannot represent a
 * non-canonical address.
 *
#define IA32_INTERRUPT_SSP_TABLE_ADDR                                0x000006A8
 * TSC Target of Local APIC's TSC Deadline Mode.
 *
#define IA32_TSC_DEADLINE                                            0x000006E0
 * Enable/disable HWP.
 *
#define IA32_PM_ENABLE                                               0x00000770
typedef union
{
  struct
  {
     * [Bit 0] HWP_ENABLE.
     *
    UINT64 HwpEnable                                               : 1;
#define IA32_PM_ENABLE_HWP_ENABLE_BIT                                0
#define IA32_PM_ENABLE_HWP_ENABLE_FLAG                               0x01
#define IA32_PM_ENABLE_HWP_ENABLE_MASK                               0x01
#define IA32_PM_ENABLE_HWP_ENABLE(_)                                 (((_) >> 0) & 0x01)
    UINT64 Reserved1                                               : 63;
  };
  UINT64 AsUInt;
} IA32_PM_ENABLE_REGISTER;*/
return true
}

func (i *ia32)#define IA32_HWP_CAPABILITIES_HIGHEST_PERFORMANCE()(ok bool){//col:13834
/*#define IA32_HWP_CAPABILITIES_HIGHEST_PERFORMANCE(_)                 (((_) >> 0) & 0xFF)
     * [Bits 15:8] Guaranteed_Performance.
     *
    UINT64 GuaranteedPerformance                                   : 8;
#define IA32_HWP_CAPABILITIES_GUARANTEED_PERFORMANCE_BIT             8
#define IA32_HWP_CAPABILITIES_GUARANTEED_PERFORMANCE_FLAG            0xFF00
#define IA32_HWP_CAPABILITIES_GUARANTEED_PERFORMANCE_MASK            0xFF
#define IA32_HWP_CAPABILITIES_GUARANTEED_PERFORMANCE(_)              (((_) >> 8) & 0xFF)
     * [Bits 23:16] Most_Efficient_Performance.
     *
    UINT64 MostEfficientPerformance                                : 8;
#define IA32_HWP_CAPABILITIES_MOST_EFFICIENT_PERFORMANCE_BIT         16
#define IA32_HWP_CAPABILITIES_MOST_EFFICIENT_PERFORMANCE_FLAG        0xFF0000
#define IA32_HWP_CAPABILITIES_MOST_EFFICIENT_PERFORMANCE_MASK        0xFF
#define IA32_HWP_CAPABILITIES_MOST_EFFICIENT_PERFORMANCE(_)          (((_) >> 16) & 0xFF)
     * [Bits 31:24] Lowest_Performance.
     *
    UINT64 LowestPerformance                                       : 8;
#define IA32_HWP_CAPABILITIES_LOWEST_PERFORMANCE_BIT                 24
#define IA32_HWP_CAPABILITIES_LOWEST_PERFORMANCE_FLAG                0xFF000000
#define IA32_HWP_CAPABILITIES_LOWEST_PERFORMANCE_MASK                0xFF
#define IA32_HWP_CAPABILITIES_LOWEST_PERFORMANCE(_)                  (((_) >> 24) & 0xFF)
    UINT64 Reserved1                                               : 32;
  };
  UINT64 AsUInt;
} IA32_HWP_CAPABILITIES_REGISTER;*/
return true
}

func (i *ia32)#define IA32_HWP_REQUEST_PKG_MINIMUM_PERFORMANCE()(ok bool){//col:13910
/*#define IA32_HWP_REQUEST_PKG_MINIMUM_PERFORMANCE(_)                  (((_) >> 0) & 0xFF)
     * [Bits 15:8] Maximum_Performance.
     *
    UINT64 MaximumPerformance                                      : 8;
#define IA32_HWP_REQUEST_PKG_MAXIMUM_PERFORMANCE_BIT                 8
#define IA32_HWP_REQUEST_PKG_MAXIMUM_PERFORMANCE_FLAG                0xFF00
#define IA32_HWP_REQUEST_PKG_MAXIMUM_PERFORMANCE_MASK                0xFF
#define IA32_HWP_REQUEST_PKG_MAXIMUM_PERFORMANCE(_)                  (((_) >> 8) & 0xFF)
     * [Bits 23:16] Desired_Performance.
     *
    UINT64 DesiredPerformance                                      : 8;
#define IA32_HWP_REQUEST_PKG_DESIRED_PERFORMANCE_BIT                 16
#define IA32_HWP_REQUEST_PKG_DESIRED_PERFORMANCE_FLAG                0xFF0000
#define IA32_HWP_REQUEST_PKG_DESIRED_PERFORMANCE_MASK                0xFF
#define IA32_HWP_REQUEST_PKG_DESIRED_PERFORMANCE(_)                  (((_) >> 16) & 0xFF)
     * [Bits 31:24] Energy_Performance_Preference.
     *
    UINT64 EnergyPerformancePreference                             : 8;
#define IA32_HWP_REQUEST_PKG_ENERGY_PERFORMANCE_PREFERENCE_BIT       24
#define IA32_HWP_REQUEST_PKG_ENERGY_PERFORMANCE_PREFERENCE_FLAG      0xFF000000
#define IA32_HWP_REQUEST_PKG_ENERGY_PERFORMANCE_PREFERENCE_MASK      0xFF
#define IA32_HWP_REQUEST_PKG_ENERGY_PERFORMANCE_PREFERENCE(_)        (((_) >> 24) & 0xFF)
     * [Bits 41:32] Activity_Window.
     *
    UINT64 ActivityWindow                                          : 10;
#define IA32_HWP_REQUEST_PKG_ACTIVITY_WINDOW_BIT                     32
#define IA32_HWP_REQUEST_PKG_ACTIVITY_WINDOW_FLAG                    0x3FF00000000
#define IA32_HWP_REQUEST_PKG_ACTIVITY_WINDOW_MASK                    0x3FF
#define IA32_HWP_REQUEST_PKG_ACTIVITY_WINDOW(_)                      (((_) >> 32) & 0x3FF)
    UINT64 Reserved1                                               : 22;
  };
  UINT64 AsUInt;
} IA32_HWP_REQUEST_PKG_REGISTER;*/
return true
}

func (i *ia32)#define IA32_HWP_INTERRUPT_EN_GUARANTEED_PERFORMANCE_CHANGE()(ok bool){//col:13950
/*#define IA32_HWP_INTERRUPT_EN_GUARANTEED_PERFORMANCE_CHANGE(_)       (((_) >> 0) & 0x01)
     * [Bit 1] EN_Excursion_Minimum.
     *
    UINT64 EnExcursionMinimum                                      : 1;
#define IA32_HWP_INTERRUPT_EN_EXCURSION_MINIMUM_BIT                  1
#define IA32_HWP_INTERRUPT_EN_EXCURSION_MINIMUM_FLAG                 0x02
#define IA32_HWP_INTERRUPT_EN_EXCURSION_MINIMUM_MASK                 0x01
#define IA32_HWP_INTERRUPT_EN_EXCURSION_MINIMUM(_)                   (((_) >> 1) & 0x01)
    UINT64 Reserved1                                               : 62;
  };
  UINT64 AsUInt;
} IA32_HWP_INTERRUPT_REGISTER;*/
return true
}

func (i *ia32)#define IA32_HWP_REQUEST_MINIMUM_PERFORMANCE()(ok bool){//col:14038
/*#define IA32_HWP_REQUEST_MINIMUM_PERFORMANCE(_)                      (((_) >> 0) & 0xFF)
     * [Bits 15:8] Maximum_Performance.
     *
    UINT64 MaximumPerformance                                      : 8;
#define IA32_HWP_REQUEST_MAXIMUM_PERFORMANCE_BIT                     8
#define IA32_HWP_REQUEST_MAXIMUM_PERFORMANCE_FLAG                    0xFF00
#define IA32_HWP_REQUEST_MAXIMUM_PERFORMANCE_MASK                    0xFF
#define IA32_HWP_REQUEST_MAXIMUM_PERFORMANCE(_)                      (((_) >> 8) & 0xFF)
     * [Bits 23:16] Desired_Performance.
     *
    UINT64 DesiredPerformance                                      : 8;
#define IA32_HWP_REQUEST_DESIRED_PERFORMANCE_BIT                     16
#define IA32_HWP_REQUEST_DESIRED_PERFORMANCE_FLAG                    0xFF0000
#define IA32_HWP_REQUEST_DESIRED_PERFORMANCE_MASK                    0xFF
#define IA32_HWP_REQUEST_DESIRED_PERFORMANCE(_)                      (((_) >> 16) & 0xFF)
     * [Bits 31:24] Energy_Performance_Preference.
     *
    UINT64 EnergyPerformancePreference                             : 8;
#define IA32_HWP_REQUEST_ENERGY_PERFORMANCE_PREFERENCE_BIT           24
#define IA32_HWP_REQUEST_ENERGY_PERFORMANCE_PREFERENCE_FLAG          0xFF000000
#define IA32_HWP_REQUEST_ENERGY_PERFORMANCE_PREFERENCE_MASK          0xFF
#define IA32_HWP_REQUEST_ENERGY_PERFORMANCE_PREFERENCE(_)            (((_) >> 24) & 0xFF)
     * [Bits 41:32] Activity_Window.
     *
    UINT64 ActivityWindow                                          : 10;
#define IA32_HWP_REQUEST_ACTIVITY_WINDOW_BIT                         32
#define IA32_HWP_REQUEST_ACTIVITY_WINDOW_FLAG                        0x3FF00000000
#define IA32_HWP_REQUEST_ACTIVITY_WINDOW_MASK                        0x3FF
#define IA32_HWP_REQUEST_ACTIVITY_WINDOW(_)                          (((_) >> 32) & 0x3FF)
     * [Bit 42] Package_Control.
     *
    UINT64 PackageControl                                          : 1;
#define IA32_HWP_REQUEST_PACKAGE_CONTROL_BIT                         42
#define IA32_HWP_REQUEST_PACKAGE_CONTROL_FLAG                        0x40000000000
#define IA32_HWP_REQUEST_PACKAGE_CONTROL_MASK                        0x01
#define IA32_HWP_REQUEST_PACKAGE_CONTROL(_)                          (((_) >> 42) & 0x01)
    UINT64 Reserved1                                               : 21;
  };
  UINT64 AsUInt;
} IA32_HWP_REQUEST_REGISTER;*/
return true
}

func (i *ia32)#define IA32_HWP_STATUS_GUARANTEED_PERFORMANCE_CHANGE()(ok bool){//col:14079
/*#define IA32_HWP_STATUS_GUARANTEED_PERFORMANCE_CHANGE(_)             (((_) >> 0) & 0x01)
    UINT64 Reserved1                                               : 1;
     * [Bit 2] Excursion_To_Minimum.
     *
    UINT64 ExcursionToMinimum                                      : 1;
#define IA32_HWP_STATUS_EXCURSION_TO_MINIMUM_BIT                     2
#define IA32_HWP_STATUS_EXCURSION_TO_MINIMUM_FLAG                    0x04
#define IA32_HWP_STATUS_EXCURSION_TO_MINIMUM_MASK                    0x01
#define IA32_HWP_STATUS_EXCURSION_TO_MINIMUM(_)                      (((_) >> 2) & 0x01)
    UINT64 Reserved2                                               : 61;
  };
  UINT64 AsUInt;
} IA32_HWP_STATUS_REGISTER;*/
return true
}

func (i *ia32) *           IA32_X2APIC_ISR()(ok bool){//col:14340
/* *           IA32_X2APIC_ISR(n)
 *
 * x2APIC In-Service Register Bits (n * 32 + 31):(n * 32).
 *
#define IA32_X2APIC_ISR0                                             0x00000810
#define IA32_X2APIC_ISR1                                             0x00000811
#define IA32_X2APIC_ISR2                                             0x00000812
#define IA32_X2APIC_ISR3                                             0x00000813
#define IA32_X2APIC_ISR4                                             0x00000814
#define IA32_X2APIC_ISR5                                             0x00000815
#define IA32_X2APIC_ISR6                                             0x00000816
#define IA32_X2APIC_ISR7                                             0x00000817
 *           IA32_X2APIC_TMR(n)
 *
 * x2APIC Trigger Mode Register Bits (n * 32 + 31):(n * 32).
 *
#define IA32_X2APIC_TMR0                                             0x00000818
#define IA32_X2APIC_TMR1                                             0x00000819
#define IA32_X2APIC_TMR2                                             0x0000081A
#define IA32_X2APIC_TMR3                                             0x0000081B
#define IA32_X2APIC_TMR4                                             0x0000081C
#define IA32_X2APIC_TMR5                                             0x0000081D
#define IA32_X2APIC_TMR6                                             0x0000081E
#define IA32_X2APIC_TMR7                                             0x0000081F
 *           IA32_X2APIC_IRR(n)
 *
 * x2APIC Interrupt Request Register Bits (n * 32 + 31):(n * 32).
 *
#define IA32_X2APIC_IRR0                                             0x00000820
#define IA32_X2APIC_IRR1                                             0x00000821
#define IA32_X2APIC_IRR2                                             0x00000822
#define IA32_X2APIC_IRR3                                             0x00000823
#define IA32_X2APIC_IRR4                                             0x00000824
#define IA32_X2APIC_IRR5                                             0x00000825
#define IA32_X2APIC_IRR6                                             0x00000826
#define IA32_X2APIC_IRR7                                             0x00000827
 * x2APIC Error Status Register.
 *
#define IA32_X2APIC_ESR                                              0x00000828
 * x2APIC LVT Corrected Machine Check Interrupt Register.
 *
#define IA32_X2APIC_LVT_CMCI                                         0x0000082F
 * x2APIC Interrupt Command Register.
 *
#define IA32_X2APIC_ICR                                              0x00000830
 * x2APIC LVT Timer Interrupt Register.
 *
#define IA32_X2APIC_LVT_TIMER                                        0x00000832
 * x2APIC LVT Thermal Sensor Interrupt Register.
 *
#define IA32_X2APIC_LVT_THERMAL                                      0x00000833
 * x2APIC LVT Performance Monitor Interrupt Register.
 *
#define IA32_X2APIC_LVT_PMI                                          0x00000834
 * x2APIC LVT LINT0 Register.
 *
#define IA32_X2APIC_LVT_LINT0                                        0x00000835
 * x2APIC LVT LINT1 Register.
 *
#define IA32_X2APIC_LVT_LINT1                                        0x00000836
 * x2APIC LVT Error Register.
 *
#define IA32_X2APIC_LVT_ERROR                                        0x00000837
 * x2APIC Initial Count Register.
 *
#define IA32_X2APIC_INIT_COUNT                                       0x00000838
 * x2APIC Current Count Register.
 *
#define IA32_X2APIC_CUR_COUNT                                        0x00000839
 * x2APIC Divide Configuration Register.
 *
#define IA32_X2APIC_DIV_CONF                                         0x0000083E
 * x2APIC Self IPI Register.
 *
#define IA32_X2APIC_SELF_IPI                                         0x0000083F
 * Silicon Debug Feature Control.
 *
#define IA32_DEBUG_INTERFACE                                         0x00000C80
typedef union
{
  struct
  {
     *
     * [Bit 0] BIOS set 1 to enable Silicon debug features. Default is 0.
     *
    UINT64 Enable                                                  : 1;
#define IA32_DEBUG_INTERFACE_ENABLE_BIT                              0
#define IA32_DEBUG_INTERFACE_ENABLE_FLAG                             0x01
#define IA32_DEBUG_INTERFACE_ENABLE_MASK                             0x01
#define IA32_DEBUG_INTERFACE_ENABLE(_)                               (((_) >> 0) & 0x01)
    UINT64 Reserved1                                               : 29;
     *
     * [Bit 30] If 1, locks any further change to the MSR. The lock bit is set automatically on the first SMI assertion even if
     * not explicitly set by BIOS. Default is 0.
     *
    UINT64 Lock                                                    : 1;
#define IA32_DEBUG_INTERFACE_LOCK_BIT                                30
#define IA32_DEBUG_INTERFACE_LOCK_FLAG                               0x40000000
#define IA32_DEBUG_INTERFACE_LOCK_MASK                               0x01
#define IA32_DEBUG_INTERFACE_LOCK(_)                                 (((_) >> 30) & 0x01)
     *
     * [Bit 31] This "sticky bit" is set by hardware to indicate the status of bit 0. Default is 0.
     *
    UINT64 DebugOccurred                                           : 1;
#define IA32_DEBUG_INTERFACE_DEBUG_OCCURRED_BIT                      31
#define IA32_DEBUG_INTERFACE_DEBUG_OCCURRED_FLAG                     0x80000000
#define IA32_DEBUG_INTERFACE_DEBUG_OCCURRED_MASK                     0x01
#define IA32_DEBUG_INTERFACE_DEBUG_OCCURRED(_)                       (((_) >> 31) & 0x01)
    UINT64 Reserved2                                               : 32;
  };
  UINT64 AsUInt;
} IA32_DEBUG_INTERFACE_REGISTER;*/
return true
}

func (i *ia32)     * [Bit 0] Set 1 to enable L3 CAT masks and COS to operate in Code and Data Prioritization ()(ok bool){//col:14367
/*     * [Bit 0] Set 1 to enable L3 CAT masks and COS to operate in Code and Data Prioritization (CDP) mode.
    UINT64 Enable                                                  : 1;
#define IA32_L3_QOS_CFG_ENABLE_BIT                                   0
#define IA32_L3_QOS_CFG_ENABLE_FLAG                                  0x01
#define IA32_L3_QOS_CFG_ENABLE_MASK                                  0x01
#define IA32_L3_QOS_CFG_ENABLE(_)                                    (((_) >> 0) & 0x01)
    UINT64 Reserved1                                               : 63;
  };
  UINT64 AsUInt;
} IA32_L3_QOS_CFG_REGISTER;*/
return true
}

func (i *ia32)     * [Bit 0] Set 1 to enable L2 CAT masks and COS to operate in Code and Data Prioritization ()(ok bool){//col:14394
/*     * [Bit 0] Set 1 to enable L2 CAT masks and COS to operate in Code and Data Prioritization (CDP) mode.
    UINT64 Enable                                                  : 1;
#define IA32_L2_QOS_CFG_ENABLE_BIT                                   0
#define IA32_L2_QOS_CFG_ENABLE_FLAG                                  0x01
#define IA32_L2_QOS_CFG_ENABLE_MASK                                  0x01
#define IA32_L2_QOS_CFG_ENABLE(_)                                    (((_) >> 0) & 0x01)
    UINT64 Reserved1                                               : 63;
  };
  UINT64 AsUInt;
} IA32_L2_QOS_CFG_REGISTER;*/
return true
}

func (i *ia32)#define IA32_QM_EVTSEL_EVENT_ID()(ok bool){//col:14434
/*#define IA32_QM_EVTSEL_EVENT_ID(_)                                   (((_) >> 0) & 0xFF)
    UINT64 Reserved1                                               : 24;
     *
     * [Bits 63:32] ID for monitoring hardware to report monitored data via IA32_QM_CTR.
     *
    UINT64 ResourceMonitoringId                                    : 32;
#define IA32_QM_EVTSEL_RESOURCE_MONITORING_ID_BIT                    32
#define IA32_QM_EVTSEL_RESOURCE_MONITORING_ID_FLAG                   0xFFFFFFFF00000000
#define IA32_QM_EVTSEL_RESOURCE_MONITORING_ID_MASK                   0xFFFFFFFF
#define IA32_QM_EVTSEL_RESOURCE_MONITORING_ID(_)                     (((_) >> 32) & 0xFFFFFFFF)
  };
  UINT64 AsUInt;
} IA32_QM_EVTSEL_REGISTER;*/
return true
}

func (i *ia32)#define IA32_QM_CTR_RESOURCE_MONITORED_DATA()(ok bool){//col:14480
/*#define IA32_QM_CTR_RESOURCE_MONITORED_DATA(_)                       (((_) >> 0) & 0x3FFFFFFFFFFFFFFF)
     *
     * [Bit 62] If 1, indicates data for this RMID is not available or not monitored for this resource or RMID.
    UINT64 Unavailable                                             : 1;
#define IA32_QM_CTR_UNAVAILABLE_BIT                                  62
#define IA32_QM_CTR_UNAVAILABLE_FLAG                                 0x4000000000000000
#define IA32_QM_CTR_UNAVAILABLE_MASK                                 0x01
#define IA32_QM_CTR_UNAVAILABLE(_)                                   (((_) >> 62) & 0x01)
     *
     * [Bit 63] If 1, indicates an unsupported RMID or event type was written to IA32_PQR_QM_EVTSEL.
    UINT64 Error                                                   : 1;
#define IA32_QM_CTR_ERROR_BIT                                        63
#define IA32_QM_CTR_ERROR_FLAG                                       0x8000000000000000
#define IA32_QM_CTR_ERROR_MASK                                       0x01
#define IA32_QM_CTR_ERROR(_)                                         (((_) >> 63) & 0x01)
  };
  UINT64 AsUInt;
} IA32_QM_CTR_REGISTER;*/
return true
}

func (i *ia32)#define IA32_PQR_ASSOC_RESOURCE_MONITORING_ID()(ok bool){//col:14521
/*#define IA32_PQR_ASSOC_RESOURCE_MONITORING_ID(_)                     (((_) >> 0) & 0xFFFFFFFF)
     *
     * [Bits 63:32] The class of service (COS) to enforce (on writes); returns the current COS when read.
     *
    UINT64 Cos                                                     : 32;
#define IA32_PQR_ASSOC_COS_BIT                                       32
#define IA32_PQR_ASSOC_COS_FLAG                                      0xFFFFFFFF00000000
#define IA32_PQR_ASSOC_COS_MASK                                      0xFFFFFFFF
#define IA32_PQR_ASSOC_COS(_)                                        (((_) >> 32) & 0xFFFFFFFF)
  };
  UINT64 AsUInt;
} IA32_PQR_ASSOC_REGISTER;*/
return true
}

func (i *ia32)#define IA32_BNDCFGS_ENABLE()(ok bool){//col:14564
/*#define IA32_BNDCFGS_ENABLE(_)                                       (((_) >> 0) & 0x01)
     * [Bit 1] Preserve the bounds registers for near branch instructions in the absence of the BND prefix.
    UINT64 BndPreserve                                             : 1;
#define IA32_BNDCFGS_BND_PRESERVE_BIT                                1
#define IA32_BNDCFGS_BND_PRESERVE_FLAG                               0x02
#define IA32_BNDCFGS_BND_PRESERVE_MASK                               0x01
#define IA32_BNDCFGS_BND_PRESERVE(_)                                 (((_) >> 1) & 0x01)
    UINT64 Reserved1                                               : 10;
     * [Bits 63:12] Base Address of Bound Directory.
    UINT64 BoundDirectoryBaseAddress                               : 52;
#define IA32_BNDCFGS_BOUND_DIRECTORY_BASE_ADDRESS_BIT                12
#define IA32_BNDCFGS_BOUND_DIRECTORY_BASE_ADDRESS_FLAG               0xFFFFFFFFFFFFF000
#define IA32_BNDCFGS_BOUND_DIRECTORY_BASE_ADDRESS_MASK               0xFFFFFFFFFFFFF
#define IA32_BNDCFGS_BOUND_DIRECTORY_BASE_ADDRESS(_)                 (((_) >> 12) & 0xFFFFFFFFFFFFF)
  };
  UINT64 AsUInt;
} IA32_BNDCFGS_REGISTER;*/
return true
}

func (i *ia32)#define IA32_XSS_TRACE_PACKET_CONFIGURATION_STATE()(ok bool){//col:14591
/*#define IA32_XSS_TRACE_PACKET_CONFIGURATION_STATE(_)                 (((_) >> 8) & 0x01)
    UINT64 Reserved2                                               : 55;
  };
  UINT64 AsUInt;
} IA32_XSS_REGISTER;*/
return true
}

func (i *ia32)#define IA32_PKG_HDC_CTL_HDC_PKG_ENABLE()(ok bool){//col:14621
/*#define IA32_PKG_HDC_CTL_HDC_PKG_ENABLE(_)                           (((_) >> 0) & 0x01)
    UINT64 Reserved1                                               : 63;
  };
  UINT64 AsUInt;
} IA32_PKG_HDC_CTL_REGISTER;*/
return true
}

func (i *ia32)#define IA32_PM_CTL1_HDC_ALLOW_BLOCK()(ok bool){//col:14651
/*#define IA32_PM_CTL1_HDC_ALLOW_BLOCK(_)                              (((_) >> 0) & 0x01)
    UINT64 Reserved1                                               : 63;
  };
  UINT64 AsUInt;
} IA32_PM_CTL1_REGISTER;*/
return true
}

func (i *ia32)#define IA32_EFER_SYSCALL_ENABLE()(ok bool){//col:14731
/*#define IA32_EFER_SYSCALL_ENABLE(_)                                  (((_) >> 0) & 0x01)
    UINT64 Reserved1                                               : 7;
     *
     * [Bit 8] Enables IA-32e mode operation.
    UINT64 Ia32EModeEnable                                         : 1;
#define IA32_EFER_IA32E_MODE_ENABLE_BIT                              8
#define IA32_EFER_IA32E_MODE_ENABLE_FLAG                             0x100
#define IA32_EFER_IA32E_MODE_ENABLE_MASK                             0x01
#define IA32_EFER_IA32E_MODE_ENABLE(_)                               (((_) >> 8) & 0x01)
    UINT64 Reserved2                                               : 1;
     *
     * [Bit 10] Indicates IA-32e mode is active when set.
    UINT64 Ia32EModeActive                                         : 1;
#define IA32_EFER_IA32E_MODE_ACTIVE_BIT                              10
#define IA32_EFER_IA32E_MODE_ACTIVE_FLAG                             0x400
#define IA32_EFER_IA32E_MODE_ACTIVE_MASK                             0x01
#define IA32_EFER_IA32E_MODE_ACTIVE(_)                               (((_) >> 10) & 0x01)
     * [Bit 11] Execute Disable Bit Enable.
    UINT64 ExecuteDisableBitEnable                                 : 1;
#define IA32_EFER_EXECUTE_DISABLE_BIT_ENABLE_BIT                     11
#define IA32_EFER_EXECUTE_DISABLE_BIT_ENABLE_FLAG                    0x800
#define IA32_EFER_EXECUTE_DISABLE_BIT_ENABLE_MASK                    0x01
#define IA32_EFER_EXECUTE_DISABLE_BIT_ENABLE(_)                      (((_) >> 11) & 0x01)
    UINT64 Reserved3                                               : 52;
  };
  UINT64 AsUInt;
} IA32_EFER_REGISTER;*/
return true
}

func (i *ia32)#define IA32_TSC_AUX_TSC_AUXILIARY_SIGNATURE()(ok bool){//col:14809
/*#define IA32_TSC_AUX_TSC_AUXILIARY_SIGNATURE(_)                      (((_) >> 0) & 0xFFFFFFFF)
    UINT64 Reserved1                                               : 32;
  };
  UINT64 AsUInt;
} IA32_TSC_AUX_REGISTER;*/
return true
}

func (i *ia32)#define PDE_4MB_32_PRESENT()(ok bool){//col:14979
/*#define PDE_4MB_32_PRESENT(_)                                        (((_) >> 0) & 0x01)
     * [Bit 1] Read/write; if 0, writes may not be allowed to the 4-MByte page referenced by this entry.
     *
    UINT32 Write                                                   : 1;
#define PDE_4MB_32_WRITE_BIT                                         1
#define PDE_4MB_32_WRITE_FLAG                                        0x02
#define PDE_4MB_32_WRITE_MASK                                        0x01
#define PDE_4MB_32_WRITE(_)                                          (((_) >> 1) & 0x01)
     * [Bit 2] User/supervisor; if 0, user-mode accesses are not allowed to the 4-MByte page referenced by this entry.
     *
    UINT32 Supervisor                                              : 1;
#define PDE_4MB_32_SUPERVISOR_BIT                                    2
#define PDE_4MB_32_SUPERVISOR_FLAG                                   0x04
#define PDE_4MB_32_SUPERVISOR_MASK                                   0x01
#define PDE_4MB_32_SUPERVISOR(_)                                     (((_) >> 2) & 0x01)
     * [Bit 3] Page-level write-through; indirectly determines the memory type used to access the 4-MByte page referenced by
     * this entry.
     *
    UINT32 PageLevelWriteThrough                                   : 1;
#define PDE_4MB_32_PAGE_LEVEL_WRITE_THROUGH_BIT                      3
#define PDE_4MB_32_PAGE_LEVEL_WRITE_THROUGH_FLAG                     0x08
#define PDE_4MB_32_PAGE_LEVEL_WRITE_THROUGH_MASK                     0x01
#define PDE_4MB_32_PAGE_LEVEL_WRITE_THROUGH(_)                       (((_) >> 3) & 0x01)
     * [Bit 4] Page-level cache disable; indirectly determines the memory type used to access the 4-MByte page referenced by
     * this entry.
     *
    UINT32 PageLevelCacheDisable                                   : 1;
#define PDE_4MB_32_PAGE_LEVEL_CACHE_DISABLE_BIT                      4
#define PDE_4MB_32_PAGE_LEVEL_CACHE_DISABLE_FLAG                     0x10
#define PDE_4MB_32_PAGE_LEVEL_CACHE_DISABLE_MASK                     0x01
#define PDE_4MB_32_PAGE_LEVEL_CACHE_DISABLE(_)                       (((_) >> 4) & 0x01)
     * [Bit 5] Accessed; indicates whether software has accessed the 4-MByte page referenced by this entry.
     *
    UINT32 Accessed                                                : 1;
#define PDE_4MB_32_ACCESSED_BIT                                      5
#define PDE_4MB_32_ACCESSED_FLAG                                     0x20
#define PDE_4MB_32_ACCESSED_MASK                                     0x01
#define PDE_4MB_32_ACCESSED(_)                                       (((_) >> 5) & 0x01)
     * [Bit 6] Dirty; indicates whether software has written to the 4-MByte page referenced by this entry.
     *
    UINT32 Dirty                                                   : 1;
#define PDE_4MB_32_DIRTY_BIT                                         6
#define PDE_4MB_32_DIRTY_FLAG                                        0x40
#define PDE_4MB_32_DIRTY_MASK                                        0x01
#define PDE_4MB_32_DIRTY(_)                                          (((_) >> 6) & 0x01)
     * [Bit 7] Page size; must be 1 (otherwise, this entry references a page table).
    UINT32 LargePage                                               : 1;
#define PDE_4MB_32_LARGE_PAGE_BIT                                    7
#define PDE_4MB_32_LARGE_PAGE_FLAG                                   0x80
#define PDE_4MB_32_LARGE_PAGE_MASK                                   0x01
#define PDE_4MB_32_LARGE_PAGE(_)                                     (((_) >> 7) & 0x01)
     * [Bit 8] Global; if CR4.PGE = 1, determines whether the translation is global; ignored otherwise.
     *
    UINT32 Global                                                  : 1;
#define PDE_4MB_32_GLOBAL_BIT                                        8
#define PDE_4MB_32_GLOBAL_FLAG                                       0x100
#define PDE_4MB_32_GLOBAL_MASK                                       0x01
#define PDE_4MB_32_GLOBAL(_)                                         (((_) >> 8) & 0x01)
     * [Bits 11:9] Ignored.
    UINT32 Ignored1                                                : 3;
#define PDE_4MB_32_IGNORED_1_BIT                                     9
#define PDE_4MB_32_IGNORED_1_FLAG                                    0xE00
#define PDE_4MB_32_IGNORED_1_MASK                                    0x07
#define PDE_4MB_32_IGNORED_1(_)                                      (((_) >> 9) & 0x07)
     * [Bit 12] Indirectly determines the memory type used to access the 4-MByte page referenced by this entry.
     *
    UINT32 Pat                                                     : 1;
#define PDE_4MB_32_PAT_BIT                                           12
#define PDE_4MB_32_PAT_FLAG                                          0x1000
#define PDE_4MB_32_PAT_MASK                                          0x01
#define PDE_4MB_32_PAT(_)                                            (((_) >> 12) & 0x01)
     * [Bits 20:13] Bits (M-1):32 of physical address of the 4-MByte page referenced by this entry.
    UINT32 PageFrameNumberLow                                      : 8;
#define PDE_4MB_32_PAGE_FRAME_NUMBER_LOW_BIT                         13
#define PDE_4MB_32_PAGE_FRAME_NUMBER_LOW_FLAG                        0x1FE000
#define PDE_4MB_32_PAGE_FRAME_NUMBER_LOW_MASK                        0xFF
#define PDE_4MB_32_PAGE_FRAME_NUMBER_LOW(_)                          (((_) >> 13) & 0xFF)
    UINT32 Reserved1                                               : 1;
     * [Bits 31:22] Bits 31:22 of physical address of the 4-MByte page referenced by this entry.
    UINT32 PageFrameNumberHigh                                     : 10;
#define PDE_4MB_32_PAGE_FRAME_NUMBER_HIGH_BIT                        22
#define PDE_4MB_32_PAGE_FRAME_NUMBER_HIGH_FLAG                       0xFFC00000
#define PDE_4MB_32_PAGE_FRAME_NUMBER_HIGH_MASK                       0x3FF
#define PDE_4MB_32_PAGE_FRAME_NUMBER_HIGH(_)                         (((_) >> 22) & 0x3FF)
  };
  UINT32 AsUInt;
} PDE_4MB_32;*/
return true
}

func (i *ia32)#define PDE_32_PRESENT()(ok bool){//col:15092
/*#define PDE_32_PRESENT(_)                                            (((_) >> 0) & 0x01)
     * [Bit 1] Read/write; if 0, writes may not be allowed to the 4-MByte region controlled by this entry.
     *
    UINT32 Write                                                   : 1;
#define PDE_32_WRITE_BIT                                             1
#define PDE_32_WRITE_FLAG                                            0x02
#define PDE_32_WRITE_MASK                                            0x01
#define PDE_32_WRITE(_)                                              (((_) >> 1) & 0x01)
     * [Bit 2] User/supervisor; if 0, user-mode accesses are not allowed to the 4-MByte region controlled by this entry.
     *
    UINT32 Supervisor                                              : 1;
#define PDE_32_SUPERVISOR_BIT                                        2
#define PDE_32_SUPERVISOR_FLAG                                       0x04
#define PDE_32_SUPERVISOR_MASK                                       0x01
#define PDE_32_SUPERVISOR(_)                                         (((_) >> 2) & 0x01)
     * [Bit 3] Page-level write-through; indirectly determines the memory type used to access the page table referenced by this
     * entry.
     *
    UINT32 PageLevelWriteThrough                                   : 1;
#define PDE_32_PAGE_LEVEL_WRITE_THROUGH_BIT                          3
#define PDE_32_PAGE_LEVEL_WRITE_THROUGH_FLAG                         0x08
#define PDE_32_PAGE_LEVEL_WRITE_THROUGH_MASK                         0x01
#define PDE_32_PAGE_LEVEL_WRITE_THROUGH(_)                           (((_) >> 3) & 0x01)
     * [Bit 4] Page-level cache disable; indirectly determines the memory type used to access the page table referenced by this
     * entry.
     *
    UINT32 PageLevelCacheDisable                                   : 1;
#define PDE_32_PAGE_LEVEL_CACHE_DISABLE_BIT                          4
#define PDE_32_PAGE_LEVEL_CACHE_DISABLE_FLAG                         0x10
#define PDE_32_PAGE_LEVEL_CACHE_DISABLE_MASK                         0x01
#define PDE_32_PAGE_LEVEL_CACHE_DISABLE(_)                           (((_) >> 4) & 0x01)
     * [Bit 5] Accessed; indicates whether this entry has been used for linear-address translation.
     *
    UINT32 Accessed                                                : 1;
#define PDE_32_ACCESSED_BIT                                          5
#define PDE_32_ACCESSED_FLAG                                         0x20
#define PDE_32_ACCESSED_MASK                                         0x01
#define PDE_32_ACCESSED(_)                                           (((_) >> 5) & 0x01)
     * [Bit 6] Ignored.
    UINT32 Ignored1                                                : 1;
#define PDE_32_IGNORED_1_BIT                                         6
#define PDE_32_IGNORED_1_FLAG                                        0x40
#define PDE_32_IGNORED_1_MASK                                        0x01
#define PDE_32_IGNORED_1(_)                                          (((_) >> 6) & 0x01)
     * [Bit 7] If CR4.PSE = 1, must be 0 (otherwise, this entry maps a 4-MByte page); otherwise, ignored.
    UINT32 LargePage                                               : 1;
#define PDE_32_LARGE_PAGE_BIT                                        7
#define PDE_32_LARGE_PAGE_FLAG                                       0x80
#define PDE_32_LARGE_PAGE_MASK                                       0x01
#define PDE_32_LARGE_PAGE(_)                                         (((_) >> 7) & 0x01)
     * [Bits 11:8] Ignored.
    UINT32 Ignored2                                                : 4;
#define PDE_32_IGNORED_2_BIT                                         8
#define PDE_32_IGNORED_2_FLAG                                        0xF00
#define PDE_32_IGNORED_2_MASK                                        0x0F
#define PDE_32_IGNORED_2(_)                                          (((_) >> 8) & 0x0F)
     * [Bits 31:12] Physical address of 4-KByte aligned page table referenced by this entry.
    UINT32 PageFrameNumber                                         : 20;
#define PDE_32_PAGE_FRAME_NUMBER_BIT                                 12
#define PDE_32_PAGE_FRAME_NUMBER_FLAG                                0xFFFFF000
#define PDE_32_PAGE_FRAME_NUMBER_MASK                                0xFFFFF
#define PDE_32_PAGE_FRAME_NUMBER(_)                                  (((_) >> 12) & 0xFFFFF)
  };
  UINT32 AsUInt;
} PDE_32;*/
return true
}

func (i *ia32)#define PTE_32_PRESENT()(ok bool){//col:15220
/*#define PTE_32_PRESENT(_)                                            (((_) >> 0) & 0x01)
     * [Bit 1] Read/write; if 0, writes may not be allowed to the 4-KByte page referenced by this entry.
     *
    UINT32 Write                                                   : 1;
#define PTE_32_WRITE_BIT                                             1
#define PTE_32_WRITE_FLAG                                            0x02
#define PTE_32_WRITE_MASK                                            0x01
#define PTE_32_WRITE(_)                                              (((_) >> 1) & 0x01)
     * [Bit 2] User/supervisor; if 0, user-mode accesses are not allowed to the 4-KByte page referenced by this entry.
     *
    UINT32 Supervisor                                              : 1;
#define PTE_32_SUPERVISOR_BIT                                        2
#define PTE_32_SUPERVISOR_FLAG                                       0x04
#define PTE_32_SUPERVISOR_MASK                                       0x01
#define PTE_32_SUPERVISOR(_)                                         (((_) >> 2) & 0x01)
     * [Bit 3] Page-level write-through; indirectly determines the memory type used to access the 4-KByte page referenced by
     * this entry.
     *
    UINT32 PageLevelWriteThrough                                   : 1;
#define PTE_32_PAGE_LEVEL_WRITE_THROUGH_BIT                          3
#define PTE_32_PAGE_LEVEL_WRITE_THROUGH_FLAG                         0x08
#define PTE_32_PAGE_LEVEL_WRITE_THROUGH_MASK                         0x01
#define PTE_32_PAGE_LEVEL_WRITE_THROUGH(_)                           (((_) >> 3) & 0x01)
     * [Bit 4] Page-level cache disable; indirectly determines the memory type used to access the 4-KByte page referenced by
     * this entry.
     *
    UINT32 PageLevelCacheDisable                                   : 1;
#define PTE_32_PAGE_LEVEL_CACHE_DISABLE_BIT                          4
#define PTE_32_PAGE_LEVEL_CACHE_DISABLE_FLAG                         0x10
#define PTE_32_PAGE_LEVEL_CACHE_DISABLE_MASK                         0x01
#define PTE_32_PAGE_LEVEL_CACHE_DISABLE(_)                           (((_) >> 4) & 0x01)
     * [Bit 5] Accessed; indicates whether software has accessed the 4-KByte page referenced by this entry.
     *
    UINT32 Accessed                                                : 1;
#define PTE_32_ACCESSED_BIT                                          5
#define PTE_32_ACCESSED_FLAG                                         0x20
#define PTE_32_ACCESSED_MASK                                         0x01
#define PTE_32_ACCESSED(_)                                           (((_) >> 5) & 0x01)
     * [Bit 6] Dirty; indicates whether software has written to the 4-KByte page referenced by this entry.
     *
    UINT32 Dirty                                                   : 1;
#define PTE_32_DIRTY_BIT                                             6
#define PTE_32_DIRTY_FLAG                                            0x40
#define PTE_32_DIRTY_MASK                                            0x01
#define PTE_32_DIRTY(_)                                              (((_) >> 6) & 0x01)
     * [Bit 7] Indirectly determines the memory type used to access the 4-KByte page referenced by this entry.
     *
    UINT32 Pat                                                     : 1;
#define PTE_32_PAT_BIT                                               7
#define PTE_32_PAT_FLAG                                              0x80
#define PTE_32_PAT_MASK                                              0x01
#define PTE_32_PAT(_)                                                (((_) >> 7) & 0x01)
     * [Bit 8] Global; if CR4.PGE = 1, determines whether the translation is global; ignored otherwise.
     *
    UINT32 Global                                                  : 1;
#define PTE_32_GLOBAL_BIT                                            8
#define PTE_32_GLOBAL_FLAG                                           0x100
#define PTE_32_GLOBAL_MASK                                           0x01
#define PTE_32_GLOBAL(_)                                             (((_) >> 8) & 0x01)
     * [Bits 11:9] Ignored.
    UINT32 Ignored1                                                : 3;
#define PTE_32_IGNORED_1_BIT                                         9
#define PTE_32_IGNORED_1_FLAG                                        0xE00
#define PTE_32_IGNORED_1_MASK                                        0x07
#define PTE_32_IGNORED_1(_)                                          (((_) >> 9) & 0x07)
     * [Bits 31:12] Physical address of 4-KByte aligned page table referenced by this entry.
    UINT32 PageFrameNumber                                         : 20;
#define PTE_32_PAGE_FRAME_NUMBER_BIT                                 12
#define PTE_32_PAGE_FRAME_NUMBER_FLAG                                0xFFFFF000
#define PTE_32_PAGE_FRAME_NUMBER_MASK                                0xFFFFF
#define PTE_32_PAGE_FRAME_NUMBER(_)                                  (((_) >> 12) & 0xFFFFF)
  };
  UINT32 AsUInt;
} PTE_32;*/
return true
}

func (i *ia32)#define PT_ENTRY_32_PRESENT()(ok bool){//col:15295
/*#define PT_ENTRY_32_PRESENT(_)                                       (((_) >> 0) & 0x01)
    UINT32 Write                                                   : 1;
#define PT_ENTRY_32_WRITE_BIT                                        1
#define PT_ENTRY_32_WRITE_FLAG                                       0x02
#define PT_ENTRY_32_WRITE_MASK                                       0x01
#define PT_ENTRY_32_WRITE(_)                                         (((_) >> 1) & 0x01)
    UINT32 Supervisor                                              : 1;
#define PT_ENTRY_32_SUPERVISOR_BIT                                   2
#define PT_ENTRY_32_SUPERVISOR_FLAG                                  0x04
#define PT_ENTRY_32_SUPERVISOR_MASK                                  0x01
#define PT_ENTRY_32_SUPERVISOR(_)                                    (((_) >> 2) & 0x01)
    UINT32 PageLevelWriteThrough                                   : 1;
#define PT_ENTRY_32_PAGE_LEVEL_WRITE_THROUGH_BIT                     3
#define PT_ENTRY_32_PAGE_LEVEL_WRITE_THROUGH_FLAG                    0x08
#define PT_ENTRY_32_PAGE_LEVEL_WRITE_THROUGH_MASK                    0x01
#define PT_ENTRY_32_PAGE_LEVEL_WRITE_THROUGH(_)                      (((_) >> 3) & 0x01)
    UINT32 PageLevelCacheDisable                                   : 1;
#define PT_ENTRY_32_PAGE_LEVEL_CACHE_DISABLE_BIT                     4
#define PT_ENTRY_32_PAGE_LEVEL_CACHE_DISABLE_FLAG                    0x10
#define PT_ENTRY_32_PAGE_LEVEL_CACHE_DISABLE_MASK                    0x01
#define PT_ENTRY_32_PAGE_LEVEL_CACHE_DISABLE(_)                      (((_) >> 4) & 0x01)
    UINT32 Accessed                                                : 1;
#define PT_ENTRY_32_ACCESSED_BIT                                     5
#define PT_ENTRY_32_ACCESSED_FLAG                                    0x20
#define PT_ENTRY_32_ACCESSED_MASK                                    0x01
#define PT_ENTRY_32_ACCESSED(_)                                      (((_) >> 5) & 0x01)
    UINT32 Dirty                                                   : 1;
#define PT_ENTRY_32_DIRTY_BIT                                        6
#define PT_ENTRY_32_DIRTY_FLAG                                       0x40
#define PT_ENTRY_32_DIRTY_MASK                                       0x01
#define PT_ENTRY_32_DIRTY(_)                                         (((_) >> 6) & 0x01)
    UINT32 LargePage                                               : 1;
#define PT_ENTRY_32_LARGE_PAGE_BIT                                   7
#define PT_ENTRY_32_LARGE_PAGE_FLAG                                  0x80
#define PT_ENTRY_32_LARGE_PAGE_MASK                                  0x01
#define PT_ENTRY_32_LARGE_PAGE(_)                                    (((_) >> 7) & 0x01)
    UINT32 Global                                                  : 1;
#define PT_ENTRY_32_GLOBAL_BIT                                       8
#define PT_ENTRY_32_GLOBAL_FLAG                                      0x100
#define PT_ENTRY_32_GLOBAL_MASK                                      0x01
#define PT_ENTRY_32_GLOBAL(_)                                        (((_) >> 8) & 0x01)
     * [Bits 11:9] Ignored.
    UINT32 Ignored1                                                : 3;
#define PT_ENTRY_32_IGNORED_1_BIT                                    9
#define PT_ENTRY_32_IGNORED_1_FLAG                                   0xE00
#define PT_ENTRY_32_IGNORED_1_MASK                                   0x07
#define PT_ENTRY_32_IGNORED_1(_)                                     (((_) >> 9) & 0x07)
     * [Bits 31:12] Physical address of the 4-KByte page referenced by this entry.
    UINT32 PageFrameNumber                                         : 20;
#define PT_ENTRY_32_PAGE_FRAME_NUMBER_BIT                            12
#define PT_ENTRY_32_PAGE_FRAME_NUMBER_FLAG                           0xFFFFF000
#define PT_ENTRY_32_PAGE_FRAME_NUMBER_MASK                           0xFFFFF
#define PT_ENTRY_32_PAGE_FRAME_NUMBER(_)                             (((_) >> 12) & 0xFFFFF)
  };
  UINT32 AsUInt;
} PT_ENTRY_32;*/
return true
}

func (i *ia32) *           64-Bit ()(ok bool){//col:15466
/* *           64-Bit (4-Level) Paging
 *
 * A logical processor uses 4-level paging if CR0.PG = 1, CR4.PAE = 1, and IA32_EFER.LME = 1. With 4-level paging, linear
 * address are translated using a hierarchy of in-memory paging structures located using the contents of CR3. 4-level
 * paging translates 48-bit linear addresses to 52-bit physical addresses. Although 52 bits corresponds to 4 PBytes, linear
 * addresses are limited to 48 bits; at most 256 TBytes of linear-address space may be accessed at any given time.
 * 4-level paging uses a hierarchy of paging structures to produce a translation for a linear address. CR3 is used to
 * locate the first paging-structure, the PML4 table. Use of CR3 with 4-level paging depends on whether processcontext
 * identifiers (PCIDs) have been enabled by setting CR4.PCIDE.
 *
typedef union
{
  struct
  {
     * [Bit 0] Present; must be 1 to reference a page-directory-pointer table.
    UINT64 Present                                                 : 1;
#define PML4E_64_PRESENT_BIT                                         0
#define PML4E_64_PRESENT_FLAG                                        0x01
#define PML4E_64_PRESENT_MASK                                        0x01
#define PML4E_64_PRESENT(_)                                          (((_) >> 0) & 0x01)
     * [Bit 1] Read/write; if 0, writes may not be allowed to the 512-GByte region controlled by this entry.
     *
    UINT64 Write                                                   : 1;
#define PML4E_64_WRITE_BIT                                           1
#define PML4E_64_WRITE_FLAG                                          0x02
#define PML4E_64_WRITE_MASK                                          0x01
#define PML4E_64_WRITE(_)                                            (((_) >> 1) & 0x01)
     * [Bit 2] User/supervisor; if 0, user-mode accesses are not allowed to the 512-GByte region controlled by this entry.
     *
    UINT64 Supervisor                                              : 1;
#define PML4E_64_SUPERVISOR_BIT                                      2
#define PML4E_64_SUPERVISOR_FLAG                                     0x04
#define PML4E_64_SUPERVISOR_MASK                                     0x01
#define PML4E_64_SUPERVISOR(_)                                       (((_) >> 2) & 0x01)
     * [Bit 3] Page-level write-through; indirectly determines the memory type used to access the page-directory-pointer table
     * referenced by this entry.
     *
    UINT64 PageLevelWriteThrough                                   : 1;
#define PML4E_64_PAGE_LEVEL_WRITE_THROUGH_BIT                        3
#define PML4E_64_PAGE_LEVEL_WRITE_THROUGH_FLAG                       0x08
#define PML4E_64_PAGE_LEVEL_WRITE_THROUGH_MASK                       0x01
#define PML4E_64_PAGE_LEVEL_WRITE_THROUGH(_)                         (((_) >> 3) & 0x01)
     * [Bit 4] Page-level cache disable; indirectly determines the memory type used to access the page-directory-pointer table
     * referenced by this entry.
     *
    UINT64 PageLevelCacheDisable                                   : 1;
#define PML4E_64_PAGE_LEVEL_CACHE_DISABLE_BIT                        4
#define PML4E_64_PAGE_LEVEL_CACHE_DISABLE_FLAG                       0x10
#define PML4E_64_PAGE_LEVEL_CACHE_DISABLE_MASK                       0x01
#define PML4E_64_PAGE_LEVEL_CACHE_DISABLE(_)                         (((_) >> 4) & 0x01)
     * [Bit 5] Accessed; indicates whether this entry has been used for linear-address translation.
     *
    UINT64 Accessed                                                : 1;
#define PML4E_64_ACCESSED_BIT                                        5
#define PML4E_64_ACCESSED_FLAG                                       0x20
#define PML4E_64_ACCESSED_MASK                                       0x01
#define PML4E_64_ACCESSED(_)                                         (((_) >> 5) & 0x01)
    UINT64 Reserved1                                               : 1;
     * [Bit 7] Reserved (must be 0).
    UINT64 MustBeZero                                              : 1;
#define PML4E_64_MUST_BE_ZERO_BIT                                    7
#define PML4E_64_MUST_BE_ZERO_FLAG                                   0x80
#define PML4E_64_MUST_BE_ZERO_MASK                                   0x01
#define PML4E_64_MUST_BE_ZERO(_)                                     (((_) >> 7) & 0x01)
     * [Bits 10:8] Ignored.
    UINT64 Ignored1                                                : 3;
#define PML4E_64_IGNORED_1_BIT                                       8
#define PML4E_64_IGNORED_1_FLAG                                      0x700
#define PML4E_64_IGNORED_1_MASK                                      0x07
#define PML4E_64_IGNORED_1(_)                                        (((_) >> 8) & 0x07)
     * [Bit 11] For ordinary paging, ignored; for HLAT paging, restart (if 1, linear-address translation is restarted with
     * ordinary paging)
     *
    UINT64 Restart                                                 : 1;
#define PML4E_64_RESTART_BIT                                         11
#define PML4E_64_RESTART_FLAG                                        0x800
#define PML4E_64_RESTART_MASK                                        0x01
#define PML4E_64_RESTART(_)                                          (((_) >> 11) & 0x01)
     * [Bits 47:12] Physical address of 4-KByte aligned page-directory-pointer table referenced by this entry.
    UINT64 PageFrameNumber                                         : 36;
#define PML4E_64_PAGE_FRAME_NUMBER_BIT                               12
#define PML4E_64_PAGE_FRAME_NUMBER_FLAG                              0xFFFFFFFFF000
#define PML4E_64_PAGE_FRAME_NUMBER_MASK                              0xFFFFFFFFF
#define PML4E_64_PAGE_FRAME_NUMBER(_)                                (((_) >> 12) & 0xFFFFFFFFF)
    UINT64 Reserved2                                               : 4;
     * [Bits 62:52] Ignored.
    UINT64 Ignored2                                                : 11;
#define PML4E_64_IGNORED_2_BIT                                       52
#define PML4E_64_IGNORED_2_FLAG                                      0x7FF0000000000000
#define PML4E_64_IGNORED_2_MASK                                      0x7FF
#define PML4E_64_IGNORED_2(_)                                        (((_) >> 52) & 0x7FF)
     * [Bit 63] If IA32_EFER.NXE = 1, execute-disable (if 1, instruction fetches are not allowed from the 512-GByte region
     * controlled by this entry); otherwise, reserved (must be 0).
     *
    UINT64 ExecuteDisable                                          : 1;
#define PML4E_64_EXECUTE_DISABLE_BIT                                 63
#define PML4E_64_EXECUTE_DISABLE_FLAG                                0x8000000000000000
#define PML4E_64_EXECUTE_DISABLE_MASK                                0x01
#define PML4E_64_EXECUTE_DISABLE(_)                                  (((_) >> 63) & 0x01)
  };
  UINT64 AsUInt;
} PML4E_64;*/
return true
}

func (i *ia32)#define PDPTE_1GB_64_PRESENT()(ok bool){//col:15650
/*#define PDPTE_1GB_64_PRESENT(_)                                      (((_) >> 0) & 0x01)
     * [Bit 1] Read/write; if 0, writes may not be allowed to the 1-GByte page referenced by this entry.
     *
    UINT64 Write                                                   : 1;
#define PDPTE_1GB_64_WRITE_BIT                                       1
#define PDPTE_1GB_64_WRITE_FLAG                                      0x02
#define PDPTE_1GB_64_WRITE_MASK                                      0x01
#define PDPTE_1GB_64_WRITE(_)                                        (((_) >> 1) & 0x01)
     * [Bit 2] User/supervisor; if 0, user-mode accesses are not allowed to the 1-GByte page referenced by this entry.
     *
    UINT64 Supervisor                                              : 1;
#define PDPTE_1GB_64_SUPERVISOR_BIT                                  2
#define PDPTE_1GB_64_SUPERVISOR_FLAG                                 0x04
#define PDPTE_1GB_64_SUPERVISOR_MASK                                 0x01
#define PDPTE_1GB_64_SUPERVISOR(_)                                   (((_) >> 2) & 0x01)
     * [Bit 3] Page-level write-through; indirectly determines the memory type used to access the 1-GByte page referenced by
     * this entry.
     *
    UINT64 PageLevelWriteThrough                                   : 1;
#define PDPTE_1GB_64_PAGE_LEVEL_WRITE_THROUGH_BIT                    3
#define PDPTE_1GB_64_PAGE_LEVEL_WRITE_THROUGH_FLAG                   0x08
#define PDPTE_1GB_64_PAGE_LEVEL_WRITE_THROUGH_MASK                   0x01
#define PDPTE_1GB_64_PAGE_LEVEL_WRITE_THROUGH(_)                     (((_) >> 3) & 0x01)
     * [Bit 4] Page-level cache disable; indirectly determines the memory type used to access the 1-GByte page referenced by
     * this entry.
     *
    UINT64 PageLevelCacheDisable                                   : 1;
#define PDPTE_1GB_64_PAGE_LEVEL_CACHE_DISABLE_BIT                    4
#define PDPTE_1GB_64_PAGE_LEVEL_CACHE_DISABLE_FLAG                   0x10
#define PDPTE_1GB_64_PAGE_LEVEL_CACHE_DISABLE_MASK                   0x01
#define PDPTE_1GB_64_PAGE_LEVEL_CACHE_DISABLE(_)                     (((_) >> 4) & 0x01)
     * [Bit 5] Accessed; indicates whether software has accessed the 1-GByte page referenced by this entry.
     *
    UINT64 Accessed                                                : 1;
#define PDPTE_1GB_64_ACCESSED_BIT                                    5
#define PDPTE_1GB_64_ACCESSED_FLAG                                   0x20
#define PDPTE_1GB_64_ACCESSED_MASK                                   0x01
#define PDPTE_1GB_64_ACCESSED(_)                                     (((_) >> 5) & 0x01)
     * [Bit 6] Dirty; indicates whether software has written to the 1-GByte page referenced by this entry.
     *
    UINT64 Dirty                                                   : 1;
#define PDPTE_1GB_64_DIRTY_BIT                                       6
#define PDPTE_1GB_64_DIRTY_FLAG                                      0x40
#define PDPTE_1GB_64_DIRTY_MASK                                      0x01
#define PDPTE_1GB_64_DIRTY(_)                                        (((_) >> 6) & 0x01)
     * [Bit 7] Page size; must be 1 (otherwise, this entry references a page directory).
    UINT64 LargePage                                               : 1;
#define PDPTE_1GB_64_LARGE_PAGE_BIT                                  7
#define PDPTE_1GB_64_LARGE_PAGE_FLAG                                 0x80
#define PDPTE_1GB_64_LARGE_PAGE_MASK                                 0x01
#define PDPTE_1GB_64_LARGE_PAGE(_)                                   (((_) >> 7) & 0x01)
     * [Bit 8] Global; if CR4.PGE = 1, determines whether the translation is global; ignored otherwise.
     *
    UINT64 Global                                                  : 1;
#define PDPTE_1GB_64_GLOBAL_BIT                                      8
#define PDPTE_1GB_64_GLOBAL_FLAG                                     0x100
#define PDPTE_1GB_64_GLOBAL_MASK                                     0x01
#define PDPTE_1GB_64_GLOBAL(_)                                       (((_) >> 8) & 0x01)
     * [Bits 10:9] Ignored.
    UINT64 Ignored1                                                : 2;
#define PDPTE_1GB_64_IGNORED_1_BIT                                   9
#define PDPTE_1GB_64_IGNORED_1_FLAG                                  0x600
#define PDPTE_1GB_64_IGNORED_1_MASK                                  0x03
#define PDPTE_1GB_64_IGNORED_1(_)                                    (((_) >> 9) & 0x03)
     * [Bit 11] For ordinary paging, ignored; for HLAT paging, restart (if 1, linear-address translation is restarted with
     * ordinary paging)
     *
    UINT64 Restart                                                 : 1;
#define PDPTE_1GB_64_RESTART_BIT                                     11
#define PDPTE_1GB_64_RESTART_FLAG                                    0x800
#define PDPTE_1GB_64_RESTART_MASK                                    0x01
#define PDPTE_1GB_64_RESTART(_)                                      (((_) >> 11) & 0x01)
     * [Bit 12] Indirectly determines the memory type used to access the 1-GByte page referenced by this entry.
     *
    UINT64 Pat                                                     : 1;
#define PDPTE_1GB_64_PAT_BIT                                         12
#define PDPTE_1GB_64_PAT_FLAG                                        0x1000
#define PDPTE_1GB_64_PAT_MASK                                        0x01
#define PDPTE_1GB_64_PAT(_)                                          (((_) >> 12) & 0x01)
    UINT64 Reserved1                                               : 17;
     * [Bits 47:30] Physical address of the 1-GByte page referenced by this entry.
    UINT64 PageFrameNumber                                         : 18;
#define PDPTE_1GB_64_PAGE_FRAME_NUMBER_BIT                           30
#define PDPTE_1GB_64_PAGE_FRAME_NUMBER_FLAG                          0xFFFFC0000000
#define PDPTE_1GB_64_PAGE_FRAME_NUMBER_MASK                          0x3FFFF
#define PDPTE_1GB_64_PAGE_FRAME_NUMBER(_)                            (((_) >> 30) & 0x3FFFF)
    UINT64 Reserved2                                               : 4;
     * [Bits 58:52] Ignored.
    UINT64 Ignored2                                                : 7;
#define PDPTE_1GB_64_IGNORED_2_BIT                                   52
#define PDPTE_1GB_64_IGNORED_2_FLAG                                  0x7F0000000000000
#define PDPTE_1GB_64_IGNORED_2_MASK                                  0x7F
#define PDPTE_1GB_64_IGNORED_2(_)                                    (((_) >> 52) & 0x7F)
     * [Bits 62:59] Protection key; if CR4.PKE = 1, determines the protection key of the page; ignored otherwise.
     *
    UINT64 ProtectionKey                                           : 4;
#define PDPTE_1GB_64_PROTECTION_KEY_BIT                              59
#define PDPTE_1GB_64_PROTECTION_KEY_FLAG                             0x7800000000000000
#define PDPTE_1GB_64_PROTECTION_KEY_MASK                             0x0F
#define PDPTE_1GB_64_PROTECTION_KEY(_)                               (((_) >> 59) & 0x0F)
     * [Bit 63] If IA32_EFER.NXE = 1, execute-disable (if 1, instruction fetches are not allowed from the 1-GByte page
     * controlled by this entry); otherwise, reserved (must be 0).
     *
    UINT64 ExecuteDisable                                          : 1;
#define PDPTE_1GB_64_EXECUTE_DISABLE_BIT                             63
#define PDPTE_1GB_64_EXECUTE_DISABLE_FLAG                            0x8000000000000000
#define PDPTE_1GB_64_EXECUTE_DISABLE_MASK                            0x01
#define PDPTE_1GB_64_EXECUTE_DISABLE(_)                              (((_) >> 63) & 0x01)
  };
  UINT64 AsUInt;
} PDPTE_1GB_64;*/
return true
}

func (i *ia32)#define PDPTE_64_PRESENT()(ok bool){//col:15789
/*#define PDPTE_64_PRESENT(_)                                          (((_) >> 0) & 0x01)
     * [Bit 1] Read/write; if 0, writes may not be allowed to the 1-GByte region controlled by this entry.
     *
    UINT64 Write                                                   : 1;
#define PDPTE_64_WRITE_BIT                                           1
#define PDPTE_64_WRITE_FLAG                                          0x02
#define PDPTE_64_WRITE_MASK                                          0x01
#define PDPTE_64_WRITE(_)                                            (((_) >> 1) & 0x01)
     * [Bit 2] User/supervisor; if 0, user-mode accesses are not allowed to the 1-GByte region controlled by this entry.
     *
    UINT64 Supervisor                                              : 1;
#define PDPTE_64_SUPERVISOR_BIT                                      2
#define PDPTE_64_SUPERVISOR_FLAG                                     0x04
#define PDPTE_64_SUPERVISOR_MASK                                     0x01
#define PDPTE_64_SUPERVISOR(_)                                       (((_) >> 2) & 0x01)
     * [Bit 3] Page-level write-through; indirectly determines the memory type used to access the page directory referenced by
     * this entry.
     *
    UINT64 PageLevelWriteThrough                                   : 1;
#define PDPTE_64_PAGE_LEVEL_WRITE_THROUGH_BIT                        3
#define PDPTE_64_PAGE_LEVEL_WRITE_THROUGH_FLAG                       0x08
#define PDPTE_64_PAGE_LEVEL_WRITE_THROUGH_MASK                       0x01
#define PDPTE_64_PAGE_LEVEL_WRITE_THROUGH(_)                         (((_) >> 3) & 0x01)
     * [Bit 4] Page-level cache disable; indirectly determines the memory type used to access the page directory referenced by
     * this entry.
     *
    UINT64 PageLevelCacheDisable                                   : 1;
#define PDPTE_64_PAGE_LEVEL_CACHE_DISABLE_BIT                        4
#define PDPTE_64_PAGE_LEVEL_CACHE_DISABLE_FLAG                       0x10
#define PDPTE_64_PAGE_LEVEL_CACHE_DISABLE_MASK                       0x01
#define PDPTE_64_PAGE_LEVEL_CACHE_DISABLE(_)                         (((_) >> 4) & 0x01)
     * [Bit 5] Accessed; indicates whether this entry has been used for linear-address translation.
     *
    UINT64 Accessed                                                : 1;
#define PDPTE_64_ACCESSED_BIT                                        5
#define PDPTE_64_ACCESSED_FLAG                                       0x20
#define PDPTE_64_ACCESSED_MASK                                       0x01
#define PDPTE_64_ACCESSED(_)                                         (((_) >> 5) & 0x01)
    UINT64 Reserved1                                               : 1;
     * [Bit 7] Page size; must be 0 (otherwise, this entry maps a 1-GByte page).
    UINT64 LargePage                                               : 1;
#define PDPTE_64_LARGE_PAGE_BIT                                      7
#define PDPTE_64_LARGE_PAGE_FLAG                                     0x80
#define PDPTE_64_LARGE_PAGE_MASK                                     0x01
#define PDPTE_64_LARGE_PAGE(_)                                       (((_) >> 7) & 0x01)
     * [Bits 10:8] Ignored.
    UINT64 Ignored1                                                : 3;
#define PDPTE_64_IGNORED_1_BIT                                       8
#define PDPTE_64_IGNORED_1_FLAG                                      0x700
#define PDPTE_64_IGNORED_1_MASK                                      0x07
#define PDPTE_64_IGNORED_1(_)                                        (((_) >> 8) & 0x07)
     * [Bit 11] For ordinary paging, ignored; for HLAT paging, restart (if 1, linear-address translation is restarted with
     * ordinary paging)
     *
    UINT64 Restart                                                 : 1;
#define PDPTE_64_RESTART_BIT                                         11
#define PDPTE_64_RESTART_FLAG                                        0x800
#define PDPTE_64_RESTART_MASK                                        0x01
#define PDPTE_64_RESTART(_)                                          (((_) >> 11) & 0x01)
     * [Bits 47:12] Physical address of 4-KByte aligned page directory referenced by this entry.
    UINT64 PageFrameNumber                                         : 36;
#define PDPTE_64_PAGE_FRAME_NUMBER_BIT                               12
#define PDPTE_64_PAGE_FRAME_NUMBER_FLAG                              0xFFFFFFFFF000
#define PDPTE_64_PAGE_FRAME_NUMBER_MASK                              0xFFFFFFFFF
#define PDPTE_64_PAGE_FRAME_NUMBER(_)                                (((_) >> 12) & 0xFFFFFFFFF)
    UINT64 Reserved2                                               : 4;
     * [Bits 62:52] Ignored.
    UINT64 Ignored2                                                : 11;
#define PDPTE_64_IGNORED_2_BIT                                       52
#define PDPTE_64_IGNORED_2_FLAG                                      0x7FF0000000000000
#define PDPTE_64_IGNORED_2_MASK                                      0x7FF
#define PDPTE_64_IGNORED_2(_)                                        (((_) >> 52) & 0x7FF)
     * [Bit 63] If IA32_EFER.NXE = 1, execute-disable (if 1, instruction fetches are not allowed from the 1-GByte region
     * controlled by this entry); otherwise, reserved (must be 0).
     *
    UINT64 ExecuteDisable                                          : 1;
#define PDPTE_64_EXECUTE_DISABLE_BIT                                 63
#define PDPTE_64_EXECUTE_DISABLE_FLAG                                0x8000000000000000
#define PDPTE_64_EXECUTE_DISABLE_MASK                                0x01
#define PDPTE_64_EXECUTE_DISABLE(_)                                  (((_) >> 63) & 0x01)
  };
  UINT64 AsUInt;
} PDPTE_64;*/
return true
}

func (i *ia32)#define PDE_2MB_64_PRESENT()(ok bool){//col:15973
/*#define PDE_2MB_64_PRESENT(_)                                        (((_) >> 0) & 0x01)
     * [Bit 1] Read/write; if 0, writes may not be allowed to the 2-MByte page referenced by this entry.
     *
    UINT64 Write                                                   : 1;
#define PDE_2MB_64_WRITE_BIT                                         1
#define PDE_2MB_64_WRITE_FLAG                                        0x02
#define PDE_2MB_64_WRITE_MASK                                        0x01
#define PDE_2MB_64_WRITE(_)                                          (((_) >> 1) & 0x01)
     * [Bit 2] User/supervisor; if 0, user-mode accesses are not allowed to the 2-MByte page referenced by this entry.
     *
    UINT64 Supervisor                                              : 1;
#define PDE_2MB_64_SUPERVISOR_BIT                                    2
#define PDE_2MB_64_SUPERVISOR_FLAG                                   0x04
#define PDE_2MB_64_SUPERVISOR_MASK                                   0x01
#define PDE_2MB_64_SUPERVISOR(_)                                     (((_) >> 2) & 0x01)
     * [Bit 3] Page-level write-through; indirectly determines the memory type used to access the 2-MByte page referenced by
     * this entry.
     *
    UINT64 PageLevelWriteThrough                                   : 1;
#define PDE_2MB_64_PAGE_LEVEL_WRITE_THROUGH_BIT                      3
#define PDE_2MB_64_PAGE_LEVEL_WRITE_THROUGH_FLAG                     0x08
#define PDE_2MB_64_PAGE_LEVEL_WRITE_THROUGH_MASK                     0x01
#define PDE_2MB_64_PAGE_LEVEL_WRITE_THROUGH(_)                       (((_) >> 3) & 0x01)
     * [Bit 4] Page-level cache disable; indirectly determines the memory type used to access the 2-MByte page referenced by
     * this entry.
     *
    UINT64 PageLevelCacheDisable                                   : 1;
#define PDE_2MB_64_PAGE_LEVEL_CACHE_DISABLE_BIT                      4
#define PDE_2MB_64_PAGE_LEVEL_CACHE_DISABLE_FLAG                     0x10
#define PDE_2MB_64_PAGE_LEVEL_CACHE_DISABLE_MASK                     0x01
#define PDE_2MB_64_PAGE_LEVEL_CACHE_DISABLE(_)                       (((_) >> 4) & 0x01)
     * [Bit 5] Accessed; indicates whether software has accessed the 2-MByte page referenced by this entry.
     *
    UINT64 Accessed                                                : 1;
#define PDE_2MB_64_ACCESSED_BIT                                      5
#define PDE_2MB_64_ACCESSED_FLAG                                     0x20
#define PDE_2MB_64_ACCESSED_MASK                                     0x01
#define PDE_2MB_64_ACCESSED(_)                                       (((_) >> 5) & 0x01)
     * [Bit 6] Dirty; indicates whether software has written to the 2-MByte page referenced by this entry.
     *
    UINT64 Dirty                                                   : 1;
#define PDE_2MB_64_DIRTY_BIT                                         6
#define PDE_2MB_64_DIRTY_FLAG                                        0x40
#define PDE_2MB_64_DIRTY_MASK                                        0x01
#define PDE_2MB_64_DIRTY(_)                                          (((_) >> 6) & 0x01)
     * [Bit 7] Page size; must be 1 (otherwise, this entry references a page directory).
    UINT64 LargePage                                               : 1;
#define PDE_2MB_64_LARGE_PAGE_BIT                                    7
#define PDE_2MB_64_LARGE_PAGE_FLAG                                   0x80
#define PDE_2MB_64_LARGE_PAGE_MASK                                   0x01
#define PDE_2MB_64_LARGE_PAGE(_)                                     (((_) >> 7) & 0x01)
     * [Bit 8] Global; if CR4.PGE = 1, determines whether the translation is global; ignored otherwise.
     *
    UINT64 Global                                                  : 1;
#define PDE_2MB_64_GLOBAL_BIT                                        8
#define PDE_2MB_64_GLOBAL_FLAG                                       0x100
#define PDE_2MB_64_GLOBAL_MASK                                       0x01
#define PDE_2MB_64_GLOBAL(_)                                         (((_) >> 8) & 0x01)
     * [Bits 10:9] Ignored.
    UINT64 Ignored1                                                : 2;
#define PDE_2MB_64_IGNORED_1_BIT                                     9
#define PDE_2MB_64_IGNORED_1_FLAG                                    0x600
#define PDE_2MB_64_IGNORED_1_MASK                                    0x03
#define PDE_2MB_64_IGNORED_1(_)                                      (((_) >> 9) & 0x03)
     * [Bit 11] For ordinary paging, ignored; for HLAT paging, restart (if 1, linear-address translation is restarted with
     * ordinary paging)
     *
    UINT64 Restart                                                 : 1;
#define PDE_2MB_64_RESTART_BIT                                       11
#define PDE_2MB_64_RESTART_FLAG                                      0x800
#define PDE_2MB_64_RESTART_MASK                                      0x01
#define PDE_2MB_64_RESTART(_)                                        (((_) >> 11) & 0x01)
     * [Bit 12] Indirectly determines the memory type used to access the 2-MByte page referenced by this entry.
     *
    UINT64 Pat                                                     : 1;
#define PDE_2MB_64_PAT_BIT                                           12
#define PDE_2MB_64_PAT_FLAG                                          0x1000
#define PDE_2MB_64_PAT_MASK                                          0x01
#define PDE_2MB_64_PAT(_)                                            (((_) >> 12) & 0x01)
    UINT64 Reserved1                                               : 8;
     * [Bits 47:21] Physical address of the 2-MByte page referenced by this entry.
    UINT64 PageFrameNumber                                         : 27;
#define PDE_2MB_64_PAGE_FRAME_NUMBER_BIT                             21
#define PDE_2MB_64_PAGE_FRAME_NUMBER_FLAG                            0xFFFFFFE00000
#define PDE_2MB_64_PAGE_FRAME_NUMBER_MASK                            0x7FFFFFF
#define PDE_2MB_64_PAGE_FRAME_NUMBER(_)                              (((_) >> 21) & 0x7FFFFFF)
    UINT64 Reserved2                                               : 4;
     * [Bits 58:52] Ignored.
    UINT64 Ignored2                                                : 7;
#define PDE_2MB_64_IGNORED_2_BIT                                     52
#define PDE_2MB_64_IGNORED_2_FLAG                                    0x7F0000000000000
#define PDE_2MB_64_IGNORED_2_MASK                                    0x7F
#define PDE_2MB_64_IGNORED_2(_)                                      (((_) >> 52) & 0x7F)
     * [Bits 62:59] Protection key; if CR4.PKE = 1, determines the protection key of the page; ignored otherwise.
     *
    UINT64 ProtectionKey                                           : 4;
#define PDE_2MB_64_PROTECTION_KEY_BIT                                59
#define PDE_2MB_64_PROTECTION_KEY_FLAG                               0x7800000000000000
#define PDE_2MB_64_PROTECTION_KEY_MASK                               0x0F
#define PDE_2MB_64_PROTECTION_KEY(_)                                 (((_) >> 59) & 0x0F)
     * [Bit 63] If IA32_EFER.NXE = 1, execute-disable (if 1, instruction fetches are not allowed from the 2-MByte page
     * controlled by this entry); otherwise, reserved (must be 0).
     *
    UINT64 ExecuteDisable                                          : 1;
#define PDE_2MB_64_EXECUTE_DISABLE_BIT                               63
#define PDE_2MB_64_EXECUTE_DISABLE_FLAG                              0x8000000000000000
#define PDE_2MB_64_EXECUTE_DISABLE_MASK                              0x01
#define PDE_2MB_64_EXECUTE_DISABLE(_)                                (((_) >> 63) & 0x01)
  };
  UINT64 AsUInt;
} PDE_2MB_64;*/
return true
}

func (i *ia32)#define PDE_64_PRESENT()(ok bool){//col:16112
/*#define PDE_64_PRESENT(_)                                            (((_) >> 0) & 0x01)
     * [Bit 1] Read/write; if 0, writes may not be allowed to the 2-MByte region controlled by this entry.
     *
    UINT64 Write                                                   : 1;
#define PDE_64_WRITE_BIT                                             1
#define PDE_64_WRITE_FLAG                                            0x02
#define PDE_64_WRITE_MASK                                            0x01
#define PDE_64_WRITE(_)                                              (((_) >> 1) & 0x01)
     * [Bit 2] User/supervisor; if 0, user-mode accesses are not allowed to the 2-MByte region controlled by this entry.
     *
    UINT64 Supervisor                                              : 1;
#define PDE_64_SUPERVISOR_BIT                                        2
#define PDE_64_SUPERVISOR_FLAG                                       0x04
#define PDE_64_SUPERVISOR_MASK                                       0x01
#define PDE_64_SUPERVISOR(_)                                         (((_) >> 2) & 0x01)
     * [Bit 3] Page-level write-through; indirectly determines the memory type used to access the page table referenced by this
     * entry.
     *
    UINT64 PageLevelWriteThrough                                   : 1;
#define PDE_64_PAGE_LEVEL_WRITE_THROUGH_BIT                          3
#define PDE_64_PAGE_LEVEL_WRITE_THROUGH_FLAG                         0x08
#define PDE_64_PAGE_LEVEL_WRITE_THROUGH_MASK                         0x01
#define PDE_64_PAGE_LEVEL_WRITE_THROUGH(_)                           (((_) >> 3) & 0x01)
     * [Bit 4] Page-level cache disable; indirectly determines the memory type used to access the page table referenced by this
     * entry.
     *
    UINT64 PageLevelCacheDisable                                   : 1;
#define PDE_64_PAGE_LEVEL_CACHE_DISABLE_BIT                          4
#define PDE_64_PAGE_LEVEL_CACHE_DISABLE_FLAG                         0x10
#define PDE_64_PAGE_LEVEL_CACHE_DISABLE_MASK                         0x01
#define PDE_64_PAGE_LEVEL_CACHE_DISABLE(_)                           (((_) >> 4) & 0x01)
     * [Bit 5] Accessed; indicates whether this entry has been used for linear-address translation.
     *
    UINT64 Accessed                                                : 1;
#define PDE_64_ACCESSED_BIT                                          5
#define PDE_64_ACCESSED_FLAG                                         0x20
#define PDE_64_ACCESSED_MASK                                         0x01
#define PDE_64_ACCESSED(_)                                           (((_) >> 5) & 0x01)
    UINT64 Reserved1                                               : 1;
     * [Bit 7] Page size; must be 0 (otherwise, this entry maps a 2-MByte page).
    UINT64 LargePage                                               : 1;
#define PDE_64_LARGE_PAGE_BIT                                        7
#define PDE_64_LARGE_PAGE_FLAG                                       0x80
#define PDE_64_LARGE_PAGE_MASK                                       0x01
#define PDE_64_LARGE_PAGE(_)                                         (((_) >> 7) & 0x01)
     * [Bits 10:8] Ignored.
    UINT64 Ignored1                                                : 3;
#define PDE_64_IGNORED_1_BIT                                         8
#define PDE_64_IGNORED_1_FLAG                                        0x700
#define PDE_64_IGNORED_1_MASK                                        0x07
#define PDE_64_IGNORED_1(_)                                          (((_) >> 8) & 0x07)
     * [Bit 11] For ordinary paging, ignored; for HLAT paging, restart (if 1, linear-address translation is restarted with
     * ordinary paging)
     *
    UINT64 Restart                                                 : 1;
#define PDE_64_RESTART_BIT                                           11
#define PDE_64_RESTART_FLAG                                          0x800
#define PDE_64_RESTART_MASK                                          0x01
#define PDE_64_RESTART(_)                                            (((_) >> 11) & 0x01)
     * [Bits 47:12] Physical address of 4-KByte aligned page table referenced by this entry.
    UINT64 PageFrameNumber                                         : 36;
#define PDE_64_PAGE_FRAME_NUMBER_BIT                                 12
#define PDE_64_PAGE_FRAME_NUMBER_FLAG                                0xFFFFFFFFF000
#define PDE_64_PAGE_FRAME_NUMBER_MASK                                0xFFFFFFFFF
#define PDE_64_PAGE_FRAME_NUMBER(_)                                  (((_) >> 12) & 0xFFFFFFFFF)
    UINT64 Reserved2                                               : 4;
     * [Bits 62:52] Ignored.
    UINT64 Ignored2                                                : 11;
#define PDE_64_IGNORED_2_BIT                                         52
#define PDE_64_IGNORED_2_FLAG                                        0x7FF0000000000000
#define PDE_64_IGNORED_2_MASK                                        0x7FF
#define PDE_64_IGNORED_2(_)                                          (((_) >> 52) & 0x7FF)
     * [Bit 63] If IA32_EFER.NXE = 1, execute-disable (if 1, instruction fetches are not allowed from the 2-MByte region
     * controlled by this entry); otherwise, reserved (must be 0).
     *
    UINT64 ExecuteDisable                                          : 1;
#define PDE_64_EXECUTE_DISABLE_BIT                                   63
#define PDE_64_EXECUTE_DISABLE_FLAG                                  0x8000000000000000
#define PDE_64_EXECUTE_DISABLE_MASK                                  0x01
#define PDE_64_EXECUTE_DISABLE(_)                                    (((_) >> 63) & 0x01)
  };
  UINT64 AsUInt;
} PDE_64;*/
return true
}

func (i *ia32)#define PTE_64_PRESENT()(ok bool){//col:16285
/*#define PTE_64_PRESENT(_)                                            (((_) >> 0) & 0x01)
     * [Bit 1] Read/write; if 0, writes may not be allowed to the 4-KByte page referenced by this entry.
     *
    UINT64 Write                                                   : 1;
#define PTE_64_WRITE_BIT                                             1
#define PTE_64_WRITE_FLAG                                            0x02
#define PTE_64_WRITE_MASK                                            0x01
#define PTE_64_WRITE(_)                                              (((_) >> 1) & 0x01)
     * [Bit 2] User/supervisor; if 0, user-mode accesses are not allowed to the 4-KByte page referenced by this entry.
     *
    UINT64 Supervisor                                              : 1;
#define PTE_64_SUPERVISOR_BIT                                        2
#define PTE_64_SUPERVISOR_FLAG                                       0x04
#define PTE_64_SUPERVISOR_MASK                                       0x01
#define PTE_64_SUPERVISOR(_)                                         (((_) >> 2) & 0x01)
     * [Bit 3] Page-level write-through; indirectly determines the memory type used to access the 4-KByte page referenced by
     * this entry.
     *
    UINT64 PageLevelWriteThrough                                   : 1;
#define PTE_64_PAGE_LEVEL_WRITE_THROUGH_BIT                          3
#define PTE_64_PAGE_LEVEL_WRITE_THROUGH_FLAG                         0x08
#define PTE_64_PAGE_LEVEL_WRITE_THROUGH_MASK                         0x01
#define PTE_64_PAGE_LEVEL_WRITE_THROUGH(_)                           (((_) >> 3) & 0x01)
     * [Bit 4] Page-level cache disable; indirectly determines the memory type used to access the 4-KByte page referenced by
     * this entry.
     *
    UINT64 PageLevelCacheDisable                                   : 1;
#define PTE_64_PAGE_LEVEL_CACHE_DISABLE_BIT                          4
#define PTE_64_PAGE_LEVEL_CACHE_DISABLE_FLAG                         0x10
#define PTE_64_PAGE_LEVEL_CACHE_DISABLE_MASK                         0x01
#define PTE_64_PAGE_LEVEL_CACHE_DISABLE(_)                           (((_) >> 4) & 0x01)
     * [Bit 5] Accessed; indicates whether software has accessed the 4-KByte page referenced by this entry.
     *
    UINT64 Accessed                                                : 1;
#define PTE_64_ACCESSED_BIT                                          5
#define PTE_64_ACCESSED_FLAG                                         0x20
#define PTE_64_ACCESSED_MASK                                         0x01
#define PTE_64_ACCESSED(_)                                           (((_) >> 5) & 0x01)
     * [Bit 6] Dirty; indicates whether software has written to the 4-KByte page referenced by this entry.
     *
    UINT64 Dirty                                                   : 1;
#define PTE_64_DIRTY_BIT                                             6
#define PTE_64_DIRTY_FLAG                                            0x40
#define PTE_64_DIRTY_MASK                                            0x01
#define PTE_64_DIRTY(_)                                              (((_) >> 6) & 0x01)
     * [Bit 7] Indirectly determines the memory type used to access the 4-KByte page referenced by this entry.
     *
    UINT64 Pat                                                     : 1;
#define PTE_64_PAT_BIT                                               7
#define PTE_64_PAT_FLAG                                              0x80
#define PTE_64_PAT_MASK                                              0x01
#define PTE_64_PAT(_)                                                (((_) >> 7) & 0x01)
     * [Bit 8] Global; if CR4.PGE = 1, determines whether the translation is global; ignored otherwise.
     *
    UINT64 Global                                                  : 1;
#define PTE_64_GLOBAL_BIT                                            8
#define PTE_64_GLOBAL_FLAG                                           0x100
#define PTE_64_GLOBAL_MASK                                           0x01
#define PTE_64_GLOBAL(_)                                             (((_) >> 8) & 0x01)
     * [Bits 10:9] Ignored.
    UINT64 Ignored1                                                : 2;
#define PTE_64_IGNORED_1_BIT                                         9
#define PTE_64_IGNORED_1_FLAG                                        0x600
#define PTE_64_IGNORED_1_MASK                                        0x03
#define PTE_64_IGNORED_1(_)                                          (((_) >> 9) & 0x03)
     * [Bit 11] For ordinary paging, ignored; for HLAT paging, restart (if 1, linear-address translation is restarted with
     * ordinary paging)
     *
    UINT64 Restart                                                 : 1;
#define PTE_64_RESTART_BIT                                           11
#define PTE_64_RESTART_FLAG                                          0x800
#define PTE_64_RESTART_MASK                                          0x01
#define PTE_64_RESTART(_)                                            (((_) >> 11) & 0x01)
     * [Bits 47:12] Physical address of the 4-KByte page referenced by this entry.
    UINT64 PageFrameNumber                                         : 36;
#define PTE_64_PAGE_FRAME_NUMBER_BIT                                 12
#define PTE_64_PAGE_FRAME_NUMBER_FLAG                                0xFFFFFFFFF000
#define PTE_64_PAGE_FRAME_NUMBER_MASK                                0xFFFFFFFFF
#define PTE_64_PAGE_FRAME_NUMBER(_)                                  (((_) >> 12) & 0xFFFFFFFFF)
    UINT64 Reserved1                                               : 4;
     * [Bits 58:52] Ignored.
    UINT64 Ignored2                                                : 7;
#define PTE_64_IGNORED_2_BIT                                         52
#define PTE_64_IGNORED_2_FLAG                                        0x7F0000000000000
#define PTE_64_IGNORED_2_MASK                                        0x7F
#define PTE_64_IGNORED_2(_)                                          (((_) >> 52) & 0x7F)
     * [Bits 62:59] Protection key; if CR4.PKE = 1, determines the protection key of the page; ignored otherwise.
     *
    UINT64 ProtectionKey                                           : 4;
#define PTE_64_PROTECTION_KEY_BIT                                    59
#define PTE_64_PROTECTION_KEY_FLAG                                   0x7800000000000000
#define PTE_64_PROTECTION_KEY_MASK                                   0x0F
#define PTE_64_PROTECTION_KEY(_)                                     (((_) >> 59) & 0x0F)
     * [Bit 63] If IA32_EFER.NXE = 1, execute-disable (if 1, instruction fetches are not allowed from the 1-GByte page
     * controlled by this entry); otherwise, reserved (must be 0).
     *
    UINT64 ExecuteDisable                                          : 1;
#define PTE_64_EXECUTE_DISABLE_BIT                                   63
#define PTE_64_EXECUTE_DISABLE_FLAG                                  0x8000000000000000
#define PTE_64_EXECUTE_DISABLE_MASK                                  0x01
#define PTE_64_EXECUTE_DISABLE(_)                                    (((_) >> 63) & 0x01)
  };
  UINT64 AsUInt;
} PTE_64;*/
return true
}

func (i *ia32)#define PT_ENTRY_64_PRESENT()(ok bool){//col:16385
/*#define PT_ENTRY_64_PRESENT(_)                                       (((_) >> 0) & 0x01)
    UINT64 Write                                                   : 1;
#define PT_ENTRY_64_WRITE_BIT                                        1
#define PT_ENTRY_64_WRITE_FLAG                                       0x02
#define PT_ENTRY_64_WRITE_MASK                                       0x01
#define PT_ENTRY_64_WRITE(_)                                         (((_) >> 1) & 0x01)
    UINT64 Supervisor                                              : 1;
#define PT_ENTRY_64_SUPERVISOR_BIT                                   2
#define PT_ENTRY_64_SUPERVISOR_FLAG                                  0x04
#define PT_ENTRY_64_SUPERVISOR_MASK                                  0x01
#define PT_ENTRY_64_SUPERVISOR(_)                                    (((_) >> 2) & 0x01)
    UINT64 PageLevelWriteThrough                                   : 1;
#define PT_ENTRY_64_PAGE_LEVEL_WRITE_THROUGH_BIT                     3
#define PT_ENTRY_64_PAGE_LEVEL_WRITE_THROUGH_FLAG                    0x08
#define PT_ENTRY_64_PAGE_LEVEL_WRITE_THROUGH_MASK                    0x01
#define PT_ENTRY_64_PAGE_LEVEL_WRITE_THROUGH(_)                      (((_) >> 3) & 0x01)
    UINT64 PageLevelCacheDisable                                   : 1;
#define PT_ENTRY_64_PAGE_LEVEL_CACHE_DISABLE_BIT                     4
#define PT_ENTRY_64_PAGE_LEVEL_CACHE_DISABLE_FLAG                    0x10
#define PT_ENTRY_64_PAGE_LEVEL_CACHE_DISABLE_MASK                    0x01
#define PT_ENTRY_64_PAGE_LEVEL_CACHE_DISABLE(_)                      (((_) >> 4) & 0x01)
    UINT64 Accessed                                                : 1;
#define PT_ENTRY_64_ACCESSED_BIT                                     5
#define PT_ENTRY_64_ACCESSED_FLAG                                    0x20
#define PT_ENTRY_64_ACCESSED_MASK                                    0x01
#define PT_ENTRY_64_ACCESSED(_)                                      (((_) >> 5) & 0x01)
    UINT64 Dirty                                                   : 1;
#define PT_ENTRY_64_DIRTY_BIT                                        6
#define PT_ENTRY_64_DIRTY_FLAG                                       0x40
#define PT_ENTRY_64_DIRTY_MASK                                       0x01
#define PT_ENTRY_64_DIRTY(_)                                         (((_) >> 6) & 0x01)
    UINT64 LargePage                                               : 1;
#define PT_ENTRY_64_LARGE_PAGE_BIT                                   7
#define PT_ENTRY_64_LARGE_PAGE_FLAG                                  0x80
#define PT_ENTRY_64_LARGE_PAGE_MASK                                  0x01
#define PT_ENTRY_64_LARGE_PAGE(_)                                    (((_) >> 7) & 0x01)
    UINT64 Global                                                  : 1;
#define PT_ENTRY_64_GLOBAL_BIT                                       8
#define PT_ENTRY_64_GLOBAL_FLAG                                      0x100
#define PT_ENTRY_64_GLOBAL_MASK                                      0x01
#define PT_ENTRY_64_GLOBAL(_)                                        (((_) >> 8) & 0x01)
     * [Bits 10:9] Ignored.
    UINT64 Ignored1                                                : 2;
#define PT_ENTRY_64_IGNORED_1_BIT                                    9
#define PT_ENTRY_64_IGNORED_1_FLAG                                   0x600
#define PT_ENTRY_64_IGNORED_1_MASK                                   0x03
#define PT_ENTRY_64_IGNORED_1(_)                                     (((_) >> 9) & 0x03)
    UINT64 Restart                                                 : 1;
#define PT_ENTRY_64_RESTART_BIT                                      11
#define PT_ENTRY_64_RESTART_FLAG                                     0x800
#define PT_ENTRY_64_RESTART_MASK                                     0x01
#define PT_ENTRY_64_RESTART(_)                                       (((_) >> 11) & 0x01)
     * [Bits 47:12] Physical address of the 4-KByte page referenced by this entry.
    UINT64 PageFrameNumber                                         : 36;
#define PT_ENTRY_64_PAGE_FRAME_NUMBER_BIT                            12
#define PT_ENTRY_64_PAGE_FRAME_NUMBER_FLAG                           0xFFFFFFFFF000
#define PT_ENTRY_64_PAGE_FRAME_NUMBER_MASK                           0xFFFFFFFFF
#define PT_ENTRY_64_PAGE_FRAME_NUMBER(_)                             (((_) >> 12) & 0xFFFFFFFFF)
    UINT64 Reserved1                                               : 4;
     * [Bits 58:52] Ignored.
    UINT64 Ignored2                                                : 7;
#define PT_ENTRY_64_IGNORED_2_BIT                                    52
#define PT_ENTRY_64_IGNORED_2_FLAG                                   0x7F0000000000000
#define PT_ENTRY_64_IGNORED_2_MASK                                   0x7F
#define PT_ENTRY_64_IGNORED_2(_)                                     (((_) >> 52) & 0x7F)
    UINT64 ProtectionKey                                           : 4;
#define PT_ENTRY_64_PROTECTION_KEY_BIT                               59
#define PT_ENTRY_64_PROTECTION_KEY_FLAG                              0x7800000000000000
#define PT_ENTRY_64_PROTECTION_KEY_MASK                              0x0F
#define PT_ENTRY_64_PROTECTION_KEY(_)                                (((_) >> 59) & 0x0F)
    UINT64 ExecuteDisable                                          : 1;
#define PT_ENTRY_64_EXECUTE_DISABLE_BIT                              63
#define PT_ENTRY_64_EXECUTE_DISABLE_FLAG                             0x8000000000000000
#define PT_ENTRY_64_EXECUTE_DISABLE_MASK                             0x01
#define PT_ENTRY_64_EXECUTE_DISABLE(_)                               (((_) >> 63) & 0x01)
  };
  UINT64 AsUInt;
} PT_ENTRY_64;*/
return true
}

func (i *ia32)   * descriptor.2 ()(ok bool){//col:16438
/*   * descriptor.2 (The instruction may also invalidate global translations, as well as mappings associated with other PCIDs
   * and for other linear addresses.)
  InvpcidIndividualAddress                                     = 0x00000000,
   * If the INVPCID type is 1, the logical processor invalidates all mappings-except global translations-associated with the
   * PCID specified in the INVPCID descriptor. (The instruction may also invalidate global translations, as well as mappings
   * associated with other PCIDs.)
  InvpcidSingleContext                                         = 0x00000001,
   * If the INVPCID type is 2, the logical processor invalidates mappings-including global translations-associated with all
   * PCIDs.
  InvpcidAllContextWithGlobals                                 = 0x00000002,
   * If the INVPCID type is 3, the logical processor invalidates mappings-except global translations- associated with all
   * PCIDs. (The instruction may also invalidate global translations.)
  InvpcidAllContext                                            = 0x00000003,
} INVPCID_TYPE;*/
return true
}

func (i *ia32)#define INVPCID_DESCRIPTOR_PCID()(ok bool){//col:16466
/*#define INVPCID_DESCRIPTOR_PCID(_)                                   (((_) >> 0) & 0xFFF)
     * [Bits 63:12] Must be zero.
    UINT64 Reserved1                                               : 52;
#define INVPCID_DESCRIPTOR_RESERVED1_BIT                             12
#define INVPCID_DESCRIPTOR_RESERVED1_FLAG                            0xFFFFFFFFFFFFF000
#define INVPCID_DESCRIPTOR_RESERVED1_MASK                            0xFFFFFFFFFFFFF
#define INVPCID_DESCRIPTOR_RESERVED1(_)                              (((_) >> 12) & 0xFFFFFFFFFFFFF)
    UINT64 LinearAddress                                           : 64;
#define INVPCID_DESCRIPTOR_LINEAR_ADDRESS_BIT                        64
#define INVPCID_DESCRIPTOR_LINEAR_ADDRESS_FLAG                       0xFFFFFFFFFFFFFFFF0000000000000000
#define INVPCID_DESCRIPTOR_LINEAR_ADDRESS_MASK                       0xFFFFFFFFFFFFFFFF
#define INVPCID_DESCRIPTOR_LINEAR_ADDRESS(_)                         (((_) >> 64) & 0xFFFFFFFFFFFFFFFF)
  };
  UINT64 AsUInt;
} INVPCID_DESCRIPTOR;*/
return true
}

func (i *ia32)#pragma pack()(ok bool){//col:16490
/*#pragma pack(push, 1)
typedef struct
{
   * Limit.
  UINT16 Limit;
   * Base Address.
  UINT32 BaseAddress;
} SEGMENT_DESCRIPTOR_REGISTER_32;*/
return true
}

func (i *ia32)#pragma pack()(ok bool){//col:16510
/*#pragma pack(pop)
 *
#pragma pack(push, 1)
typedef struct
{
   * Limit.
  UINT16 Limit;
   * Base Address.
  UINT64 BaseAddress;
} SEGMENT_DESCRIPTOR_REGISTER_64;*/
return true
}

func (i *ia32)#pragma pack()(ok bool){//col:16649
/*#pragma pack(pop)
 *
typedef union
{
  struct
  {
    UINT32 Reserved1                                               : 8;
     *
     * [Bits 11:8] Indicates the segment or gate type and specifies the kinds of access that can be made to the segment and the
     * direction of growth. The interpretation of this field depends on whether the descriptor type flag specifies an
     * application (code or data) descriptor or a system descriptor. The encoding of the type field is different for code,
     * data, and system descriptors.
     *
    UINT32 Type                                                    : 4;
#define SEGMENT_ACCESS_RIGHTS_TYPE_BIT                               8
#define SEGMENT_ACCESS_RIGHTS_TYPE_FLAG                              0xF00
#define SEGMENT_ACCESS_RIGHTS_TYPE_MASK                              0x0F
#define SEGMENT_ACCESS_RIGHTS_TYPE(_)                                (((_) >> 8) & 0x0F)
     *
     * [Bit 12] Specifies whether the segment descriptor is for a system segment (S flag is clear) or a code or data segment (S
     * flag is set).
    UINT32 DescriptorType                                          : 1;
#define SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_TYPE_BIT                    12
#define SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_TYPE_FLAG                   0x1000
#define SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_TYPE_MASK                   0x01
#define SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_TYPE(_)                     (((_) >> 12) & 0x01)
     *
     * [Bits 14:13] Specifies the privilege level of the segment. The privilege level can range from 0 to 3, with 0 being the
     * most privileged level. The DPL is used to control access to the segment. See Section 5.5, "Privilege Levels", for a
     * description of the relationship of the DPL to the CPL of the executing code segment and the RPL of a segment selector.
    UINT32 DescriptorPrivilegeLevel                                : 2;
#define SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_PRIVILEGE_LEVEL_BIT         13
#define SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_PRIVILEGE_LEVEL_FLAG        0x6000
#define SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_PRIVILEGE_LEVEL_MASK        0x03
#define SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_PRIVILEGE_LEVEL(_)          (((_) >> 13) & 0x03)
     *
     * [Bit 15] Indicates whether the segment is present in memory (set) or not present (clear). If this flag is clear, the
     * processor generates a segment-not-present exception (\#NP) when a segment selector that points to the segment descriptor
     * is loaded into a segment register. Memory management software can use this flag to control which segments are actually
     * loaded into physical memory at a given time. It offers a control in addition to paging for managing virtual memory.
    UINT32 Present                                                 : 1;
#define SEGMENT_ACCESS_RIGHTS_PRESENT_BIT                            15
#define SEGMENT_ACCESS_RIGHTS_PRESENT_FLAG                           0x8000
#define SEGMENT_ACCESS_RIGHTS_PRESENT_MASK                           0x01
#define SEGMENT_ACCESS_RIGHTS_PRESENT(_)                             (((_) >> 15) & 0x01)
    UINT32 Reserved2                                               : 4;
     *
     * [Bit 20] Bit 20 of the second doubleword of the segment descriptor is available for use by system software.
    UINT32 System                                                  : 1;
#define SEGMENT_ACCESS_RIGHTS_SYSTEM_BIT                             20
#define SEGMENT_ACCESS_RIGHTS_SYSTEM_FLAG                            0x100000
#define SEGMENT_ACCESS_RIGHTS_SYSTEM_MASK                            0x01
#define SEGMENT_ACCESS_RIGHTS_SYSTEM(_)                              (((_) >> 20) & 0x01)
     *
     * [Bit 21] In IA-32e mode, bit 21 of the second doubleword of the segment descriptor indicates whether a code segment
     * contains native 64-bit code. A value of 1 indicates instructions in this code segment are executed in 64-bit mode. A
     * value of 0 indicates the instructions in this code segment are executed in compatibility mode. If L-bit is set, then
     * D-bit must be cleared. When not in IA-32e mode or for non-code segments, bit 21 is reserved and should always be set to
     * 0.
    UINT32 LongMode                                                : 1;
#define SEGMENT_ACCESS_RIGHTS_LONG_MODE_BIT                          21
#define SEGMENT_ACCESS_RIGHTS_LONG_MODE_FLAG                         0x200000
#define SEGMENT_ACCESS_RIGHTS_LONG_MODE_MASK                         0x01
#define SEGMENT_ACCESS_RIGHTS_LONG_MODE(_)                           (((_) >> 21) & 0x01)
     *
     * [Bit 22] Performs different functions depending on whether the segment descriptor is an executable code segment, an
     * expand-down data segment, or a stack segment. (This flag should always be set to 1 for 32-bit code and data segments and
     * to 0 for 16-bit code and data segments.)
     * - Executable code segment. The flag is called the D flag and it indicates the default length for effective addresses and
     * operands referenced by instructions in the segment. If the flag is set, 32-bit addresses and 32-bit or 8-bit operands
     * are assumed; if it is clear, 16-bit addresses and 16-bit or 8-bit operands are assumed. The instruction prefix 66H can
     * be used to select an operand size other than the default, and the prefix 67H can be used select an address size other
     * than the default.
     * - Stack segment (data segment pointed to by the SS register). The flag is called the B (big) flag and it specifies the
     * size of the stack pointer used for implicit stack operations (such as pushes, pops, and calls). If the flag is set, a
     * 32-bit stack pointer is used, which is stored in the 32-bit ESP register; if the flag is clear, a 16-bit stack pointer
     * is used, which is stored in the 16- bit SP register. If the stack segment is set up to be an expand-down data segment
     * (described in the next paragraph), the B flag also specifies the upper bound of the stack segment.
     * - Expand-down data segment. The flag is called the B flag and it specifies the upper bound of the segment. If the flag
     * is set, the upper bound is FFFFFFFFH (4 GBytes); if the flag is clear, the upper bound is FFFFH (64 KBytes).
    UINT32 DefaultBig                                              : 1;
#define SEGMENT_ACCESS_RIGHTS_DEFAULT_BIG_BIT                        22
#define SEGMENT_ACCESS_RIGHTS_DEFAULT_BIG_FLAG                       0x400000
#define SEGMENT_ACCESS_RIGHTS_DEFAULT_BIG_MASK                       0x01
#define SEGMENT_ACCESS_RIGHTS_DEFAULT_BIG(_)                         (((_) >> 22) & 0x01)
     *
     * [Bit 23] Determines the scaling of the segment limit field. When the granularity flag is clear, the segment limit is
     * interpreted in byte units; when flag is set, the segment limit is interpreted in 4-KByte units. (This flag does not
     * affect the granularity of the base address; it is always byte granular.) When the granularity flag is set, the twelve
     * least significant bits of an offset are not tested when checking the offset against the segment limit. For example, when
     * the granularity flag is set, a limit of 0 results in valid offsets from 0 to 4095.
    UINT32 Granularity                                             : 1;
#define SEGMENT_ACCESS_RIGHTS_GRANULARITY_BIT                        23
#define SEGMENT_ACCESS_RIGHTS_GRANULARITY_FLAG                       0x800000
#define SEGMENT_ACCESS_RIGHTS_GRANULARITY_MASK                       0x01
#define SEGMENT_ACCESS_RIGHTS_GRANULARITY(_)                         (((_) >> 23) & 0x01)
    UINT32 Reserved3                                               : 8;
  };
  UINT32 AsUInt;
} SEGMENT_ACCESS_RIGHTS;*/
return true
}

func (i *ia32)   * processor interprets the segment limit in one of two ways, depending on the setting of the G ()(ok bool){//col:16859
/*   * processor interprets the segment limit in one of two ways, depending on the setting of the G (granularity) flag:
   * - If the granularity flag is clear, the segment size can range from 1 byte to 1 MByte, in byte increments.
   * - If the granularity flag is set, the segment size can range from 4 KBytes to 4 GBytes, in 4-KByte increments.
   * The processor uses the segment limit in two different ways, depending on whether the segment is an expand-up or an
   * expand-down segment. For expand-up segments, the offset in a logical address can range from 0 to the segment limit.
   * Offsets greater than the segment limit generate general-protection exceptions (\#GP, for all segments other than SS) or
   * stack-fault exceptions (\#SS for the SS segment). For expand-down segments, the segment limit has the reverse function;
   * the offset can range from the segment limit plus 1 to FFFFFFFFH or FFFFH, depending on the setting of the B flag.
   * Offsets less than or equal to the segment limit generate general-protection exceptions or stack-fault exceptions.
   * Decreasing the value in the segment limit field for an expanddown segment allocates new memory at the bottom of the
   * segment's address space, rather than at the top. IA-32 architecture stacks always grow downwards, making this mechanism
   * convenient for expandable stacks.
   *
  UINT16 SegmentLimitLow;
   *
   * Defines the location of byte 0 of the segment within the 4-GByte linear address space. The processor puts together the
   * three base address fields to form a single 32-bit value. Segment base addresses should be aligned to 16-byte boundaries.
   * Although 16-byte alignment is not required, this alignment allows programs to maximize performance by aligning code and
   * data on 16-byte boundaries.
  UINT16 BaseAddressLow;
  union
  {
    struct
    {
       * [Bits 7:0] Base address field (23:16); see description of $BASE_LOW for more details.
      UINT32 BaseAddressMiddle                                     : 8;
#define SEGMENT__BASE_ADDRESS_MIDDLE_BIT                             0
#define SEGMENT__BASE_ADDRESS_MIDDLE_FLAG                            0xFF
#define SEGMENT__BASE_ADDRESS_MIDDLE_MASK                            0xFF
#define SEGMENT__BASE_ADDRESS_MIDDLE(_)                              (((_) >> 0) & 0xFF)
       *
       * [Bits 11:8] Indicates the segment or gate type and specifies the kinds of access that can be made to the segment and the
       * direction of growth. The interpretation of this field depends on whether the descriptor type flag specifies an
       * application (code or data) descriptor or a system descriptor. The encoding of the type field is different for code,
       * data, and system descriptors.
       *
      UINT32 Type                                                  : 4;
#define SEGMENT__TYPE_BIT                                            8
#define SEGMENT__TYPE_FLAG                                           0xF00
#define SEGMENT__TYPE_MASK                                           0x0F
#define SEGMENT__TYPE(_)                                             (((_) >> 8) & 0x0F)
       *
       * [Bit 12] Specifies whether the segment descriptor is for a system segment (S flag is clear) or a code or data segment (S
       * flag is set).
      UINT32 DescriptorType                                        : 1;
#define SEGMENT__DESCRIPTOR_TYPE_BIT                                 12
#define SEGMENT__DESCRIPTOR_TYPE_FLAG                                0x1000
#define SEGMENT__DESCRIPTOR_TYPE_MASK                                0x01
#define SEGMENT__DESCRIPTOR_TYPE(_)                                  (((_) >> 12) & 0x01)
       *
       * [Bits 14:13] Specifies the privilege level of the segment. The privilege level can range from 0 to 3, with 0 being the
       * most privileged level. The DPL is used to control access to the segment. See Section 5.5, "Privilege Levels", for a
       * description of the relationship of the DPL to the CPL of the executing code segment and the RPL of a segment selector.
      UINT32 DescriptorPrivilegeLevel                              : 2;
#define SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL_BIT                      13
#define SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL_FLAG                     0x6000
#define SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL_MASK                     0x03
#define SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL(_)                       (((_) >> 13) & 0x03)
       *
       * [Bit 15] Indicates whether the segment is present in memory (set) or not present (clear). If this flag is clear, the
       * processor generates a segment-not-present exception (\#NP) when a segment selector that points to the segment descriptor
       * is loaded into a segment register. Memory management software can use this flag to control which segments are actually
       * loaded into physical memory at a given time. It offers a control in addition to paging for managing virtual memory.
      UINT32 Present                                               : 1;
#define SEGMENT__PRESENT_BIT                                         15
#define SEGMENT__PRESENT_FLAG                                        0x8000
#define SEGMENT__PRESENT_MASK                                        0x01
#define SEGMENT__PRESENT(_)                                          (((_) >> 15) & 0x01)
       * [Bits 19:16] Segment limit field (19:16); see description of $LIMIT_LOW for more details.
      UINT32 SegmentLimitHigh                                      : 4;
#define SEGMENT__SEGMENT_LIMIT_HIGH_BIT                              16
#define SEGMENT__SEGMENT_LIMIT_HIGH_FLAG                             0xF0000
#define SEGMENT__SEGMENT_LIMIT_HIGH_MASK                             0x0F
#define SEGMENT__SEGMENT_LIMIT_HIGH(_)                               (((_) >> 16) & 0x0F)
       *
       * [Bit 20] Bit 20 of the second doubleword of the segment descriptor is available for use by system software.
      UINT32 System                                                : 1;
#define SEGMENT__SYSTEM_BIT                                          20
#define SEGMENT__SYSTEM_FLAG                                         0x100000
#define SEGMENT__SYSTEM_MASK                                         0x01
#define SEGMENT__SYSTEM(_)                                           (((_) >> 20) & 0x01)
       *
       * [Bit 21] In IA-32e mode, bit 21 of the second doubleword of the segment descriptor indicates whether a code segment
       * contains native 64-bit code. A value of 1 indicates instructions in this code segment are executed in 64-bit mode. A
       * value of 0 indicates the instructions in this code segment are executed in compatibility mode. If L-bit is set, then
       * D-bit must be cleared. When not in IA-32e mode or for non-code segments, bit 21 is reserved and should always be set to
       * 0.
      UINT32 LongMode                                              : 1;
#define SEGMENT__LONG_MODE_BIT                                       21
#define SEGMENT__LONG_MODE_FLAG                                      0x200000
#define SEGMENT__LONG_MODE_MASK                                      0x01
#define SEGMENT__LONG_MODE(_)                                        (((_) >> 21) & 0x01)
       *
       * [Bit 22] Performs different functions depending on whether the segment descriptor is an executable code segment, an
       * expand-down data segment, or a stack segment. (This flag should always be set to 1 for 32-bit code and data segments and
       * to 0 for 16-bit code and data segments.)
       * - Executable code segment. The flag is called the D flag and it indicates the default length for effective addresses and
       * operands referenced by instructions in the segment. If the flag is set, 32-bit addresses and 32-bit or 8-bit operands
       * are assumed; if it is clear, 16-bit addresses and 16-bit or 8-bit operands are assumed. The instruction prefix 66H can
       * be used to select an operand size other than the default, and the prefix 67H can be used select an address size other
       * than the default.
       * - Stack segment (data segment pointed to by the SS register). The flag is called the B (big) flag and it specifies the
       * size of the stack pointer used for implicit stack operations (such as pushes, pops, and calls). If the flag is set, a
       * 32-bit stack pointer is used, which is stored in the 32-bit ESP register; if the flag is clear, a 16-bit stack pointer
       * is used, which is stored in the 16- bit SP register. If the stack segment is set up to be an expand-down data segment
       * (described in the next paragraph), the B flag also specifies the upper bound of the stack segment.
       * - Expand-down data segment. The flag is called the B flag and it specifies the upper bound of the segment. If the flag
       * is set, the upper bound is FFFFFFFFH (4 GBytes); if the flag is clear, the upper bound is FFFFH (64 KBytes).
      UINT32 DefaultBig                                            : 1;
#define SEGMENT__DEFAULT_BIG_BIT                                     22
#define SEGMENT__DEFAULT_BIG_FLAG                                    0x400000
#define SEGMENT__DEFAULT_BIG_MASK                                    0x01
#define SEGMENT__DEFAULT_BIG(_)                                      (((_) >> 22) & 0x01)
       *
       * [Bit 23] Determines the scaling of the segment limit field. When the granularity flag is clear, the segment limit is
       * interpreted in byte units; when flag is set, the segment limit is interpreted in 4-KByte units. (This flag does not
       * affect the granularity of the base address; it is always byte granular.) When the granularity flag is set, the twelve
       * least significant bits of an offset are not tested when checking the offset against the segment limit. For example, when
       * the granularity flag is set, a limit of 0 results in valid offsets from 0 to 4095.
      UINT32 Granularity                                           : 1;
#define SEGMENT__GRANULARITY_BIT                                     23
#define SEGMENT__GRANULARITY_FLAG                                    0x800000
#define SEGMENT__GRANULARITY_MASK                                    0x01
#define SEGMENT__GRANULARITY(_)                                      (((_) >> 23) & 0x01)
       * [Bits 31:24] Base address field (31:24); see description of $BASE_LOW for more details.
      UINT32 BaseAddressHigh                                       : 8;
#define SEGMENT__BASE_ADDRESS_HIGH_BIT                               24
#define SEGMENT__BASE_ADDRESS_HIGH_FLAG                              0xFF000000
#define SEGMENT__BASE_ADDRESS_HIGH_MASK                              0xFF
#define SEGMENT__BASE_ADDRESS_HIGH(_)                                (((_) >> 24) & 0xFF)
    };
    UINT32 AsUInt;
  } ;
} SEGMENT_DESCRIPTOR_32;*/
return true
}

func (i *ia32)   * processor interprets the segment limit in one of two ways, depending on the setting of the G ()(ok bool){//col:17071
/*   * processor interprets the segment limit in one of two ways, depending on the setting of the G (granularity) flag:
   * - If the granularity flag is clear, the segment size can range from 1 byte to 1 MByte, in byte increments.
   * - If the granularity flag is set, the segment size can range from 4 KBytes to 4 GBytes, in 4-KByte increments.
   * The processor uses the segment limit in two different ways, depending on whether the segment is an expand-up or an
   * expand-down segment. For expand-up segments, the offset in a logical address can range from 0 to the segment limit.
   * Offsets greater than the segment limit generate general-protection exceptions (\#GP, for all segments other than SS) or
   * stack-fault exceptions (\#SS for the SS segment). For expand-down segments, the segment limit has the reverse function;
   * the offset can range from the segment limit plus 1 to FFFFFFFFH or FFFFH, depending on the setting of the B flag.
   * Offsets less than or equal to the segment limit generate general-protection exceptions or stack-fault exceptions.
   * Decreasing the value in the segment limit field for an expanddown segment allocates new memory at the bottom of the
   * segment's address space, rather than at the top. IA-32 architecture stacks always grow downwards, making this mechanism
   * convenient for expandable stacks.
   *
  UINT16 SegmentLimitLow;
   *
   * Defines the location of byte 0 of the segment within the 4-GByte linear address space. The processor puts together the
   * three base address fields to form a single 32-bit value. Segment base addresses should be aligned to 16-byte boundaries.
   * Although 16-byte alignment is not required, this alignment allows programs to maximize performance by aligning code and
   * data on 16-byte boundaries.
  UINT16 BaseAddressLow;
  union
  {
    struct
    {
       * [Bits 7:0] Base address field (23:16); see description of $BASE_LOW for more details.
      UINT32 BaseAddressMiddle                                     : 8;
#define SEGMENT__BASE_ADDRESS_MIDDLE_BIT                             0
#define SEGMENT__BASE_ADDRESS_MIDDLE_FLAG                            0xFF
#define SEGMENT__BASE_ADDRESS_MIDDLE_MASK                            0xFF
#define SEGMENT__BASE_ADDRESS_MIDDLE(_)                              (((_) >> 0) & 0xFF)
       *
       * [Bits 11:8] Indicates the segment or gate type and specifies the kinds of access that can be made to the segment and the
       * direction of growth. The interpretation of this field depends on whether the descriptor type flag specifies an
       * application (code or data) descriptor or a system descriptor. The encoding of the type field is different for code,
       * data, and system descriptors.
       *
      UINT32 Type                                                  : 4;
#define SEGMENT__TYPE_BIT                                            8
#define SEGMENT__TYPE_FLAG                                           0xF00
#define SEGMENT__TYPE_MASK                                           0x0F
#define SEGMENT__TYPE(_)                                             (((_) >> 8) & 0x0F)
       *
       * [Bit 12] Specifies whether the segment descriptor is for a system segment (S flag is clear) or a code or data segment (S
       * flag is set).
      UINT32 DescriptorType                                        : 1;
#define SEGMENT__DESCRIPTOR_TYPE_BIT                                 12
#define SEGMENT__DESCRIPTOR_TYPE_FLAG                                0x1000
#define SEGMENT__DESCRIPTOR_TYPE_MASK                                0x01
#define SEGMENT__DESCRIPTOR_TYPE(_)                                  (((_) >> 12) & 0x01)
       *
       * [Bits 14:13] Specifies the privilege level of the segment. The privilege level can range from 0 to 3, with 0 being the
       * most privileged level. The DPL is used to control access to the segment. See Section 5.5, "Privilege Levels", for a
       * description of the relationship of the DPL to the CPL of the executing code segment and the RPL of a segment selector.
      UINT32 DescriptorPrivilegeLevel                              : 2;
#define SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL_BIT                      13
#define SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL_FLAG                     0x6000
#define SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL_MASK                     0x03
#define SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL(_)                       (((_) >> 13) & 0x03)
       *
       * [Bit 15] Indicates whether the segment is present in memory (set) or not present (clear). If this flag is clear, the
       * processor generates a segment-not-present exception (\#NP) when a segment selector that points to the segment descriptor
       * is loaded into a segment register. Memory management software can use this flag to control which segments are actually
       * loaded into physical memory at a given time. It offers a control in addition to paging for managing virtual memory.
      UINT32 Present                                               : 1;
#define SEGMENT__PRESENT_BIT                                         15
#define SEGMENT__PRESENT_FLAG                                        0x8000
#define SEGMENT__PRESENT_MASK                                        0x01
#define SEGMENT__PRESENT(_)                                          (((_) >> 15) & 0x01)
       * [Bits 19:16] Segment limit field (19:16); see description of $LIMIT_LOW for more details.
      UINT32 SegmentLimitHigh                                      : 4;
#define SEGMENT__SEGMENT_LIMIT_HIGH_BIT                              16
#define SEGMENT__SEGMENT_LIMIT_HIGH_FLAG                             0xF0000
#define SEGMENT__SEGMENT_LIMIT_HIGH_MASK                             0x0F
#define SEGMENT__SEGMENT_LIMIT_HIGH(_)                               (((_) >> 16) & 0x0F)
       *
       * [Bit 20] Bit 20 of the second doubleword of the segment descriptor is available for use by system software.
      UINT32 System                                                : 1;
#define SEGMENT__SYSTEM_BIT                                          20
#define SEGMENT__SYSTEM_FLAG                                         0x100000
#define SEGMENT__SYSTEM_MASK                                         0x01
#define SEGMENT__SYSTEM(_)                                           (((_) >> 20) & 0x01)
       *
       * [Bit 21] In IA-32e mode, bit 21 of the second doubleword of the segment descriptor indicates whether a code segment
       * contains native 64-bit code. A value of 1 indicates instructions in this code segment are executed in 64-bit mode. A
       * value of 0 indicates the instructions in this code segment are executed in compatibility mode. If L-bit is set, then
       * D-bit must be cleared. When not in IA-32e mode or for non-code segments, bit 21 is reserved and should always be set to
       * 0.
      UINT32 LongMode                                              : 1;
#define SEGMENT__LONG_MODE_BIT                                       21
#define SEGMENT__LONG_MODE_FLAG                                      0x200000
#define SEGMENT__LONG_MODE_MASK                                      0x01
#define SEGMENT__LONG_MODE(_)                                        (((_) >> 21) & 0x01)
       *
       * [Bit 22] Performs different functions depending on whether the segment descriptor is an executable code segment, an
       * expand-down data segment, or a stack segment. (This flag should always be set to 1 for 32-bit code and data segments and
       * to 0 for 16-bit code and data segments.)
       * - Executable code segment. The flag is called the D flag and it indicates the default length for effective addresses and
       * operands referenced by instructions in the segment. If the flag is set, 32-bit addresses and 32-bit or 8-bit operands
       * are assumed; if it is clear, 16-bit addresses and 16-bit or 8-bit operands are assumed. The instruction prefix 66H can
       * be used to select an operand size other than the default, and the prefix 67H can be used select an address size other
       * than the default.
       * - Stack segment (data segment pointed to by the SS register). The flag is called the B (big) flag and it specifies the
       * size of the stack pointer used for implicit stack operations (such as pushes, pops, and calls). If the flag is set, a
       * 32-bit stack pointer is used, which is stored in the 32-bit ESP register; if the flag is clear, a 16-bit stack pointer
       * is used, which is stored in the 16- bit SP register. If the stack segment is set up to be an expand-down data segment
       * (described in the next paragraph), the B flag also specifies the upper bound of the stack segment.
       * - Expand-down data segment. The flag is called the B flag and it specifies the upper bound of the segment. If the flag
       * is set, the upper bound is FFFFFFFFH (4 GBytes); if the flag is clear, the upper bound is FFFFH (64 KBytes).
      UINT32 DefaultBig                                            : 1;
#define SEGMENT__DEFAULT_BIG_BIT                                     22
#define SEGMENT__DEFAULT_BIG_FLAG                                    0x400000
#define SEGMENT__DEFAULT_BIG_MASK                                    0x01
#define SEGMENT__DEFAULT_BIG(_)                                      (((_) >> 22) & 0x01)
       *
       * [Bit 23] Determines the scaling of the segment limit field. When the granularity flag is clear, the segment limit is
       * interpreted in byte units; when flag is set, the segment limit is interpreted in 4-KByte units. (This flag does not
       * affect the granularity of the base address; it is always byte granular.) When the granularity flag is set, the twelve
       * least significant bits of an offset are not tested when checking the offset against the segment limit. For example, when
       * the granularity flag is set, a limit of 0 results in valid offsets from 0 to 4095.
      UINT32 Granularity                                           : 1;
#define SEGMENT__GRANULARITY_BIT                                     23
#define SEGMENT__GRANULARITY_FLAG                                    0x800000
#define SEGMENT__GRANULARITY_MASK                                    0x01
#define SEGMENT__GRANULARITY(_)                                      (((_) >> 23) & 0x01)
       * [Bits 31:24] Base address field (31:24); see description of $BASE_LOW for more details.
      UINT32 BaseAddressHigh                                       : 8;
#define SEGMENT__BASE_ADDRESS_HIGH_BIT                               24
#define SEGMENT__BASE_ADDRESS_HIGH_FLAG                              0xFF000000
#define SEGMENT__BASE_ADDRESS_HIGH_MASK                              0xFF
#define SEGMENT__BASE_ADDRESS_HIGH(_)                                (((_) >> 24) & 0xFF)
    };
    UINT32 AsUInt;
  } ;
   * Base address field (32:63); see description of $BASE_LOW for more details.
  UINT32 BaseAddressUpper;
   * This field must be set to zero.
  UINT32 MustBeZero;
} SEGMENT_DESCRIPTOR_64;*/
return true
}

func (i *ia32)   * Offset to procedure entry point ()(ok bool){//col:17166
/*   * Offset to procedure entry point (15:00).
  UINT16 OffsetLow;
   * Segment selector for destination code segment.
  UINT16 SegmentSelector;
  union
  {
    struct
    {
       * [Bits 2:0] Index into the TSS Interrupt Stack Table.
      UINT32 InterruptStackTable                                   : 3;
#define SEGMENT__INTERRUPT_STACK_TABLE_BIT                           0
#define SEGMENT__INTERRUPT_STACK_TABLE_FLAG                          0x07
#define SEGMENT__INTERRUPT_STACK_TABLE_MASK                          0x07
#define SEGMENT__INTERRUPT_STACK_TABLE(_)                            (((_) >> 0) & 0x07)
       * [Bits 7:3] This field must be set to zero.
      UINT32 MustBeZero0                                           : 5;
#define SEGMENT__MUST_BE_ZERO_0_BIT                                  3
#define SEGMENT__MUST_BE_ZERO_0_FLAG                                 0xF8
#define SEGMENT__MUST_BE_ZERO_0_MASK                                 0x1F
#define SEGMENT__MUST_BE_ZERO_0(_)                                   (((_) >> 3) & 0x1F)
       * [Bits 11:8] Indicates the segment or gate type.
      UINT32 Type                                                  : 4;
#define SEGMENT__TYPE_BIT                                            8
#define SEGMENT__TYPE_FLAG                                           0xF00
#define SEGMENT__TYPE_MASK                                           0x0F
#define SEGMENT__TYPE(_)                                             (((_) >> 8) & 0x0F)
       * [Bit 12] This field must be set to zero.
      UINT32 MustBeZero1                                           : 1;
#define SEGMENT__MUST_BE_ZERO_1_BIT                                  12
#define SEGMENT__MUST_BE_ZERO_1_FLAG                                 0x1000
#define SEGMENT__MUST_BE_ZERO_1_MASK                                 0x01
#define SEGMENT__MUST_BE_ZERO_1(_)                                   (((_) >> 12) & 0x01)
       * [Bits 14:13] Specifies the segment privilege level.
      UINT32 DescriptorPrivilegeLevel                              : 2;
#define SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL_BIT                      13
#define SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL_FLAG                     0x6000
#define SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL_MASK                     0x03
#define SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL(_)                       (((_) >> 13) & 0x03)
       * [Bit 15] Indicates whether the segment is present in memory (set) or not present (clear).
      UINT32 Present                                               : 1;
#define SEGMENT__PRESENT_BIT                                         15
#define SEGMENT__PRESENT_FLAG                                        0x8000
#define SEGMENT__PRESENT_MASK                                        0x01
#define SEGMENT__PRESENT(_)                                          (((_) >> 15) & 0x01)
       * [Bits 31:16] Offset to procedure entry point (31:16).
      UINT32 OffsetMiddle                                          : 16;
#define SEGMENT__OFFSET_MIDDLE_BIT                                   16
#define SEGMENT__OFFSET_MIDDLE_FLAG                                  0xFFFF0000
#define SEGMENT__OFFSET_MIDDLE_MASK                                  0xFFFF
#define SEGMENT__OFFSET_MIDDLE(_)                                    (((_) >> 16) & 0xFFFF)
    };
    UINT32 AsUInt;
  } ;
   * Offset to procedure entry point (63:32).
  UINT32 OffsetHigh;
  UINT32 Reserved;
} SEGMENT_DESCRIPTOR_INTERRUPT_GATE_64;*/
return true
}

func (i *ia32) * When the S ()(ok bool){//col:17431
/* * When the S (descriptor type) flag in a segment descriptor is set, the descriptor is for either a code or a data segment.
 * The highest order bit of the type field (bit 11 of the second double word of the segment descriptor) then determines
 * whether the descriptor is for a data segment (clear) or a code segment (set). For data segments, the three low-order
 * bits of the type field (bits 8, 9, and 10) are interpreted as accessed (A), write-enable (W), and expansion-direction
 * (E). See Table 3-1 for a description of the encoding of the bits in the type field for code and data segments. Data
 * segments can be read-only or read/write segments, depending on the setting of the write-enable bit.
 *
 * Read-Only.
#define SEGMENT_DESCRIPTOR_TYPE_DATA_READ_ONLY                       0x00000000
 * Data Read-Only, accessed.
#define SEGMENT_DESCRIPTOR_TYPE_DATA_READ_ONLY_ACCESSED              0x00000001
 * Data Read/Write.
#define SEGMENT_DESCRIPTOR_TYPE_DATA_READ_WRITE                      0x00000002
 * Data Read/Write, accessed.
#define SEGMENT_DESCRIPTOR_TYPE_DATA_READ_WRITE_ACCESSED             0x00000003
 * Data Read-Only, expand-down.
#define SEGMENT_DESCRIPTOR_TYPE_DATA_READ_ONLY_EXPAND_DOWN           0x00000004
 * Data Read-Only, expand-down, accessed.
#define SEGMENT_DESCRIPTOR_TYPE_DATA_READ_ONLY_EXPAND_DOWN_ACCESSED  0x00000005
 * Data Read/Write, expand-down.
#define SEGMENT_DESCRIPTOR_TYPE_DATA_READ_WRITE_EXPAND_DOWN          0x00000006
 * Data Read/Write, expand-down, accessed.
#define SEGMENT_DESCRIPTOR_TYPE_DATA_READ_WRITE_EXPAND_DOWN_ACCESSED 0x00000007
 * Code Execute-Only.
#define SEGMENT_DESCRIPTOR_TYPE_CODE_EXECUTE_ONLY                    0x00000008
 * Code Execute-Only, accessed.
#define SEGMENT_DESCRIPTOR_TYPE_CODE_EXECUTE_ONLY_ACCESSED           0x00000009
 * Code Execute/Read.
#define SEGMENT_DESCRIPTOR_TYPE_CODE_EXECUTE_READ                    0x0000000A
 * Code Execute/Read, accessed.
#define SEGMENT_DESCRIPTOR_TYPE_CODE_EXECUTE_READ_ACCESSED           0x0000000B
 * Code Execute-Only, conforming.
#define SEGMENT_DESCRIPTOR_TYPE_CODE_EXECUTE_ONLY_CONFORMING         0x0000000C
 * Code Execute-Only, conforming, accessed.
#define SEGMENT_DESCRIPTOR_TYPE_CODE_EXECUTE_ONLY_CONFORMING_ACCESSED 0x0000000D
 * Code Execute/Read, conforming.
#define SEGMENT_DESCRIPTOR_TYPE_CODE_EXECUTE_READ_CONFORMING         0x0000000E
 * Code Execute/Read, conforming, accessed.
#define SEGMENT_DESCRIPTOR_TYPE_CODE_EXECUTE_READ_CONFORMING_ACCESSED 0x0000000F
 *           System Descriptor Types
 *
 * When the S (descriptor type) flag in a segment descriptor is clear, the descriptor type is a system descriptor. The
 * processor recognizes the following types of system descriptors:
 * - Local descriptor-table (LDT) segment descriptor.
 * - Task-state segment (TSS) descriptor.
 * - Call-gate descriptor.
 * - Interrupt-gate descriptor.
 * - Trap-gate descriptor.
 * - Task-gate descriptor.
 * These descriptor types fall into two categories: system-segment descriptors and gate descriptors. Systemsegment
 * descriptors point to system segments (LDT and TSS segments). Gate descriptors are in themselves "gates," which hold
 * pointers to procedure entry points in code segments (call, interrupt, and trap gates) or which hold segment selectors
 * for TSS's (task gates).
 *
 * - 32-Bit Mode: Reserved
 * - IA-32e Mode: Reserved
#define SEGMENT_DESCRIPTOR_TYPE_RESERVED_1                           0x00000000
 * - 32-Bit Mode: 16-bit TSS (Available)
 * - IA-32e Mode: Reserved
#define SEGMENT_DESCRIPTOR_TYPE_TSS_16_AVAILABLE                     0x00000001
 * - 32-Bit Mode: LDT
 * - IA-32e Mode: LDT
#define SEGMENT_DESCRIPTOR_TYPE_LDT                                  0x00000002
 * - 32-Bit Mode: 16-bit TSS (Busy)
 * - IA-32e Mode: Reserved
#define SEGMENT_DESCRIPTOR_TYPE_TSS_16_BUSY                          0x00000003
 * - 32-Bit Mode: 16-bit Call Gate
 * - IA-32e Mode: Reserved
#define SEGMENT_DESCRIPTOR_TYPE_CALL_GATE_16                         0x00000004
 * - 32-Bit Mode: Task Gate
 * - IA-32e Mode: Reserved
#define SEGMENT_DESCRIPTOR_TYPE_TASK_GATE                            0x00000005
 * - 32-Bit Mode: 16-bit Interrupt Gate
 * - IA-32e Mode: Reserved
#define SEGMENT_DESCRIPTOR_TYPE_INTERRUPT_GATE_16                    0x00000006
 * - 32-Bit Mode: 16-bit Trap Gate
 * - IA-32e Mode: Reserved
#define SEGMENT_DESCRIPTOR_TYPE_TRAP_GATE_16                         0x00000007
 * - 32-Bit Mode: Reserved
 * - IA-32e Mode: Reserved
#define SEGMENT_DESCRIPTOR_TYPE_RESERVED_2                           0x00000008
 * - 32-Bit Mode: 32-bit TSS (Available)
 * - IA-32e Mode: 64-bit TSS (Available)
#define SEGMENT_DESCRIPTOR_TYPE_TSS_AVAILABLE                        0x00000009
 * - 32-Bit Mode: Reserved
 * - IA-32e Mode: Reserved
#define SEGMENT_DESCRIPTOR_TYPE_RESERVED_3                           0x0000000A
 * - 32-Bit Mode: 32-bit TSS (Busy)
 * - IA-32e Mode: 64-bit TSS (Busy)
#define SEGMENT_DESCRIPTOR_TYPE_TSS_BUSY                             0x0000000B
 * - 32-Bit Mode: 32-bit Call Gate
 * - IA-32e Mode: 64-bit Call Gate
#define SEGMENT_DESCRIPTOR_TYPE_CALL_GATE                            0x0000000C
 * - 32-Bit Mode: Reserved
 * - IA-32e Mode: Reserved
#define SEGMENT_DESCRIPTOR_TYPE_RESERVED_4                           0x0000000D
 * - 32-Bit Mode: 32-bit Interrupt Gate
 * - IA-32e Mode: 64-bit Interrupt Gate
#define SEGMENT_DESCRIPTOR_TYPE_INTERRUPT_GATE                       0x0000000E
 * - 32-Bit Mode: 32-bit Trap Gate
 * - IA-32e Mode: 64-bit Trap Gate
#define SEGMENT_DESCRIPTOR_TYPE_TRAP_GATE                            0x0000000F
 *        points to the segment descriptor that defines the segment
 *
typedef union
{
  struct
  {
     * [Bits 1:0] Specifies the privilege level of the selector. The privilege level can range from 0 to 3, with 0 being the
     * most privileged level.
     *
    UINT16 RequestPrivilegeLevel                                   : 2;
#define SEGMENT_SELECTOR_REQUEST_PRIVILEGE_LEVEL_BIT                 0
#define SEGMENT_SELECTOR_REQUEST_PRIVILEGE_LEVEL_FLAG                0x03
#define SEGMENT_SELECTOR_REQUEST_PRIVILEGE_LEVEL_MASK                0x03
#define SEGMENT_SELECTOR_REQUEST_PRIVILEGE_LEVEL(_)                  (((_) >> 0) & 0x03)
     * [Bit 2] Specifies the descriptor table to use: clearing this flag selects the GDT; setting this flag selects the current
     * LDT.
    UINT16 Table                                                   : 1;
#define SEGMENT_SELECTOR_TABLE_BIT                                   2
#define SEGMENT_SELECTOR_TABLE_FLAG                                  0x04
#define SEGMENT_SELECTOR_TABLE_MASK                                  0x01
#define SEGMENT_SELECTOR_TABLE(_)                                    (((_) >> 2) & 0x01)
     * [Bits 15:3] Selects one of 8192 descriptors in the GDT or LDT. The processor multiplies the index value by 8 (the number
     * of bytes in a segment descriptor) and adds the result to the base address of the GDT or LDT (from the GDTR or LDTR
     * register, respectively).
    UINT16 Index                                                   : 13;
#define SEGMENT_SELECTOR_INDEX_BIT                                   3
#define SEGMENT_SELECTOR_INDEX_FLAG                                  0xFFF8
#define SEGMENT_SELECTOR_INDEX_MASK                                  0x1FFF
#define SEGMENT_SELECTOR_INDEX(_)                                    (((_) >> 3) & 0x1FFF)
  };
  UINT16 AsUInt;
} SEGMENT_SELECTOR;*/
return true
}

func (i *ia32)#pragma pack()(ok bool){//col:17519
/*#pragma pack(push, 1)
typedef struct
{
   * Reserved bits. Set to 0.
  UINT32 Reserved0;
   * Stack pointer for privilege level 0.
  UINT64 Rsp0;
   * Stack pointer for privilege level 1.
  UINT64 Rsp1;
   * Stack pointer for privilege level 2.
  UINT64 Rsp2;
   * Reserved bits. Set to 0.
  UINT64 Reserved1;
   * Interrupt stack table pointer (1).
  UINT64 Ist1;
   * Interrupt stack table pointer (2).
  UINT64 Ist2;
   * Interrupt stack table pointer (3).
  UINT64 Ist3;
   * Interrupt stack table pointer (4).
  UINT64 Ist4;
   * Interrupt stack table pointer (5).
  UINT64 Ist5;
   * Interrupt stack table pointer (6).
  UINT64 Ist6;
   * Interrupt stack table pointer (7).
  UINT64 Ist7;
   * Reserved bits. Set to 0.
  UINT64 Reserved2;
   * Reserved bits. Set to 0.
  UINT16 Reserved3;
   * The 16-bit offset to the I/O permission bit map from the 64-bit TSS base.
  UINT16 IoMapBase;
} TASK_STATE_SEGMENT_64;*/
return true
}

func (i *ia32)#pragma pack()(ok bool){//col:18224
/*#pragma pack(pop)
 *           VMX
 *           VMX Basic Exit Reasons
 *
 * VMX Basic Exit Reasons.
 *
 *
 * Either:
 * -# Guest software caused an exception and the bit in the exception bitmap associated with exception's vector was 1. This
 * case includes executions of BOUND that cause \#BR, executions of INT1 (they cause \#DB), executions of INT3 (they cause
 * \#BP), executions of INTO that cause \#OF, and executions of UD0, UD1, and UD2 (they cause \#UD).
 * -# An NMI was delivered to the logical processor and the "NMI exiting" VM-execution control was 1.
#define VMX_EXIT_REASON_EXCEPTION_OR_NMI                             0x00000000
 *
 * An external interrupt arrived and the "external-interrupt exiting" VM-execution control was 1.
#define VMX_EXIT_REASON_EXTERNAL_INTERRUPT                           0x00000001
 *
 * The logical processor encountered an exception while attempting to call the double-fault handler and that exception did
 * not itself cause a VM exit due to the exception bitmap.
#define VMX_EXIT_REASON_TRIPLE_FAULT                                 0x00000002
 *
 * An INIT signal arrived.
#define VMX_EXIT_REASON_INIT_SIGNAL                                  0x00000003
 *
 * A SIPI arrived while the logical processor was in the "wait-for-SIPI" state.
#define VMX_EXIT_REASON_STARTUP_IPI                                  0x00000004
 *
 * An SMI arrived immediately after retirement of an I/O instruction and caused an SMM VM exit.
 *
#define VMX_EXIT_REASON_IO_SMI                                       0x00000005
 *
 * An SMI arrived and caused an SMM VM exit but not immediately after retirement of an I/O instruction.
 *
#define VMX_EXIT_REASON_SMI                                          0x00000006
 *
 * At the beginning of an instruction, RFLAGS.IF was 1; events were not blocked by STI or by MOV SS; and the
 * "interrupt-window exiting" VM-execution control was 1.
#define VMX_EXIT_REASON_INTERRUPT_WINDOW                             0x00000007
 *
 * At the beginning of an instruction, there was no virtual-NMI blocking; events were not blocked by MOV SS; and the
 * "NMI-window exiting" VM-execution control was 1.
#define VMX_EXIT_REASON_NMI_WINDOW                                   0x00000008
 *
 * Guest software attempted a task switch.
#define VMX_EXIT_REASON_TASK_SWITCH                                  0x00000009
 *
 * Guest software attempted to execute CPUID.
#define VMX_EXIT_REASON_EXECUTE_CPUID                                0x0000000A
 *
 * Guest software attempted to execute GETSEC.
#define VMX_EXIT_REASON_EXECUTE_GETSEC                               0x0000000B
 *
 * Guest software attempted to execute HLT and the "HLT exiting" VM-execution control was 1.
#define VMX_EXIT_REASON_EXECUTE_HLT                                  0x0000000C
 *
 * Guest software attempted to execute INVD.
#define VMX_EXIT_REASON_EXECUTE_INVD                                 0x0000000D
 *
 * Guest software attempted to execute INVLPG and the "INVLPG exiting" VM-execution control was 1.
#define VMX_EXIT_REASON_EXECUTE_INVLPG                               0x0000000E
 *
 * Guest software attempted to execute RDPMC and the "RDPMC exiting" VM-execution control was 1.
#define VMX_EXIT_REASON_EXECUTE_RDPMC                                0x0000000F
 *
 * Guest software attempted to execute RDTSC and the "RDTSC exiting" VM-execution control was 1.
#define VMX_EXIT_REASON_EXECUTE_RDTSC                                0x00000010
 *
 * Guest software attempted to execute RSM in SMM.
#define VMX_EXIT_REASON_EXECUTE_RSM_IN_SMM                           0x00000011
 *
 * VMCALL was executed either by guest software (causing an ordinary VM exit) or by the executive monitor (causing an SMM
 * VM exit).
 *
#define VMX_EXIT_REASON_EXECUTE_VMCALL                               0x00000012
 *
 * Guest software attempted to execute VMCLEAR.
#define VMX_EXIT_REASON_EXECUTE_VMCLEAR                              0x00000013
 *
 * Guest software attempted to execute VMLAUNCH.
#define VMX_EXIT_REASON_EXECUTE_VMLAUNCH                             0x00000014
 *
 * Guest software attempted to execute VMPTRLD.
#define VMX_EXIT_REASON_EXECUTE_VMPTRLD                              0x00000015
 *
 * Guest software attempted to execute VMPTRST.
#define VMX_EXIT_REASON_EXECUTE_VMPTRST                              0x00000016
 *
 * Guest software attempted to execute VMREAD.
#define VMX_EXIT_REASON_EXECUTE_VMREAD                               0x00000017
 *
 * Guest software attempted to execute VMRESUME.
#define VMX_EXIT_REASON_EXECUTE_VMRESUME                             0x00000018
 *
 * Guest software attempted to execute VMWRITE.
#define VMX_EXIT_REASON_EXECUTE_VMWRITE                              0x00000019
 *
 * Guest software attempted to execute VMXOFF.
#define VMX_EXIT_REASON_EXECUTE_VMXOFF                               0x0000001A
 *
 * Guest software attempted to execute VMXON.
#define VMX_EXIT_REASON_EXECUTE_VMXON                                0x0000001B
 *
 * Guest software attempted to access CR0, CR3, CR4, or CR8 using CLTS, LMSW, or MOV CR and the VM-execution control fields
 * indicate that a VM exit should occur. This basic exit reason is not used for trap-like VM exits following executions of
 * the MOV to CR8 instruction when the "use TPR shadow" VM-execution control is 1. Such VM exits instead use basic exit
 * reason 43.
 *
#define VMX_EXIT_REASON_MOV_CR                                       0x0000001C
 *
 * Guest software attempted a MOV to or from a debug register and the "MOV-DR exiting" VM-execution control was 1.
#define VMX_EXIT_REASON_MOV_DR                                       0x0000001D
 *
 * Guest software attempted to execute an I/O instruction and either:
 * -# The "use I/O bitmaps" VM-execution control was 0 and the "unconditional I/O exiting" VM-execution control was 1.
 * -# The "use I/O bitmaps" VM-execution control was 1 and a bit in the I/O bitmap associated with one of the ports
 * accessed by the I/O instruction was 1.
#define VMX_EXIT_REASON_EXECUTE_IO_INSTRUCTION                       0x0000001E
 *
 * Guest software attempted to execute RDMSR and either:
 * -# The "use MSR bitmaps" VM-execution control was 0.
 * -# The value of RCX is neither in the range 00000000H - 00001FFFH nor in the range C0000000H - C0001FFFH.
 * -# The value of RCX was in the range 00000000H - 00001FFFH and the nth bit in read bitmap for low MSRs is 1, where n was
 * the value of RCX.
 * -# The value of RCX is in the range C0000000H - C0001FFFH and the nth bit in read bitmap for high MSRs is 1, where n is
 * the value of RCX & 00001FFFH.
#define VMX_EXIT_REASON_EXECUTE_RDMSR                                0x0000001F
 *
 * Guest software attempted to execute WRMSR and either:
 * -# The "use MSR bitmaps" VM-execution control was 0.
 * -# The value of RCX is neither in the range 00000000H - 00001FFFH nor in the range C0000000H - C0001FFFH.
 * -# The value of RCX was in the range 00000000H - 00001FFFH and the nth bit in write bitmap for low MSRs is 1, where n
 * was the value of RCX.
 * -# The value of RCX is in the range C0000000H - C0001FFFH and the nth bit in write bitmap for high MSRs is 1, where n is
 * the value of RCX & 00001FFFH.
#define VMX_EXIT_REASON_EXECUTE_WRMSR                                0x00000020
 *
 * A VM entry failed one of the checks identified in Section 26.3.1.
#define VMX_EXIT_REASON_ERROR_INVALID_GUEST_STATE                    0x00000021
 *
 * A VM entry failed in an attempt to load MSRs. See Section 26.4.
#define VMX_EXIT_REASON_ERROR_MSR_LOAD                               0x00000022
 *
 * Guest software attempted to execute MWAIT and the "MWAIT exiting" VM-execution control was 1.
#define VMX_EXIT_REASON_EXECUTE_MWAIT                                0x00000024
 *
 * A VM entry occurred due to the 1-setting of the "monitor trap flag" VM-execution control and injection of an MTF VM exit
 * as part of VM entry.
 *
#define VMX_EXIT_REASON_MONITOR_TRAP_FLAG                            0x00000025
 *
 * Guest software attempted to execute MONITOR and the "MONITOR exiting" VM-execution control was 1.
#define VMX_EXIT_REASON_EXECUTE_MONITOR                              0x00000027
 *
 * Either guest software attempted to execute PAUSE and the "PAUSE exiting" VM-execution control was 1 or the "PAUSE-loop
 * exiting" VM-execution control was 1 and guest software executed a PAUSE loop with execution time exceeding PLE_Window.
 *
#define VMX_EXIT_REASON_EXECUTE_PAUSE                                0x00000028
 *
 * A machine-check event occurred during VM entry.
 *
#define VMX_EXIT_REASON_ERROR_MACHINE_CHECK                          0x00000029
 *
 * The logical processor determined that the value of bits 7:4 of the byte at offset 080H on the virtual-APIC page was
 * below that of the TPR threshold VM-execution control field while the "use TPR shadow" VMexecution control was 1 either
 * as part of TPR virtualization or VM entry.
 *
#define VMX_EXIT_REASON_TPR_BELOW_THRESHOLD                          0x0000002B
 *
 * Guest software attempted to access memory at a physical address on the APIC-access page and the "virtualize APIC
 * accesses" VM-execution control was 1.
 *
#define VMX_EXIT_REASON_APIC_ACCESS                                  0x0000002C
 *
 * EOI virtualization was performed for a virtual interrupt whose vector indexed a bit set in the EOIexit bitmap.
#define VMX_EXIT_REASON_VIRTUALIZED_EOI                              0x0000002D
 *
 * Guest software attempted to execute LGDT, LIDT, SGDT, or SIDT and the "descriptor-table exiting" VM-execution control
 * was 1.
#define VMX_EXIT_REASON_GDTR_IDTR_ACCESS                             0x0000002E
 *
 * Guest software attempted to execute LLDT, LTR, SLDT, or STR and the "descriptor-table exiting" VM-execution control was
 * 1.
#define VMX_EXIT_REASON_LDTR_TR_ACCESS                               0x0000002F
 *
 * An attempt to access memory with a guest-physical address was disallowed by the configuration of the EPT paging
 * structures.
#define VMX_EXIT_REASON_EPT_VIOLATION                                0x00000030
 *
 * An attempt to access memory with a guest-physical address encountered a misconfigured EPT paging-structure entry.
#define VMX_EXIT_REASON_EPT_MISCONFIGURATION                         0x00000031
 *
 * Guest software attempted to execute INVEPT.
#define VMX_EXIT_REASON_EXECUTE_INVEPT                               0x00000032
 *
 * Guest software attempted to execute RDTSCP and the "enable RDTSCP" and "RDTSC exiting" VM-execution controls were both
 * 1.
#define VMX_EXIT_REASON_EXECUTE_RDTSCP                               0x00000033
 *
 * The preemption timer counted down to zero.
#define VMX_EXIT_REASON_VMX_PREEMPTION_TIMER_EXPIRED                 0x00000034
 *
 * Guest software attempted to execute INVVPID.
#define VMX_EXIT_REASON_EXECUTE_INVVPID                              0x00000035
 *
 * Guest software attempted to execute WBINVD and the "WBINVD exiting" VM-execution control was 1.
#define VMX_EXIT_REASON_EXECUTE_WBINVD                               0x00000036
 *
 * Guest software attempted to execute XSETBV.
#define VMX_EXIT_REASON_EXECUTE_XSETBV                               0x00000037
 *
 * Guest software completed a write to the virtual-APIC page that must be virtualized by VMM software.
 *
#define VMX_EXIT_REASON_APIC_WRITE                                   0x00000038
 *
 * Guest software attempted to execute RDRAND and the "RDRAND exiting" VM-execution control was 1.
#define VMX_EXIT_REASON_EXECUTE_RDRAND                               0x00000039
 *
 * Guest software attempted to execute INVPCID and the "enable INVPCID" and "INVLPG exiting" VM-execution controls were
 * both 1.
#define VMX_EXIT_REASON_EXECUTE_INVPCID                              0x0000003A
 *
 * Guest software invoked a VM function with the VMFUNC instruction and the VM function either was not enabled or generated
 * a function-specific condition causing a VM exit.
#define VMX_EXIT_REASON_EXECUTE_VMFUNC                               0x0000003B
 *
 * Guest software attempted to execute ENCLS and "enable ENCLS exiting" VM-execution control was 1 and either:
 * -# EAX < 63 and the corresponding bit in the ENCLS-exiting bitmap is 1; or
 * -# EAX >= 63 and bit 63 in the ENCLS-exiting bitmap is 1.
#define VMX_EXIT_REASON_EXECUTE_ENCLS                                0x0000003C
 *
 * Guest software attempted to execute RDSEED and the "RDSEED exiting" VM-execution control was 1.
#define VMX_EXIT_REASON_EXECUTE_RDSEED                               0x0000003D
 *
 * The processor attempted to create a page-modification log entry and the value of the PML index was not in the range
 * 0-511.
#define VMX_EXIT_REASON_PAGE_MODIFICATION_LOG_FULL                   0x0000003E
 *
 * Guest software attempted to execute XSAVES, the "enable XSAVES/XRSTORS" was 1, and a bit was set in the logical-AND of
 * the following three values: EDX:EAX, the IA32_XSS MSR, and the XSS-exiting bitmap.
#define VMX_EXIT_REASON_EXECUTE_XSAVES                               0x0000003F
 *
 * Guest software attempted to execute XRSTORS, the "enable XSAVES/XRSTORS" was 1, and a bit was set in the logical-AND of
 * the following three values: EDX:EAX, the IA32_XSS MSR, and the XSS-exiting bitmap.
#define VMX_EXIT_REASON_EXECUTE_XRSTORS                              0x00000040
 *           VM-Instruction Error Numbers
 *
 * VM-Instruction Error Numbers.
 *
 * VMCALL executed in VMX root operation.
#define VMX_ERROR_VMCALL_IN_VMX_ROOT_OPERATION                       0x00000001
 * VMCLEAR with invalid physical address.
#define VMX_ERROR_VMCLEAR_INVALID_PHYSICAL_ADDRESS                   0x00000002
 * VMCLEAR with VMXON pointer.
#define VMX_ERROR_VMCLEAR_INVALID_VMXON_POINTER                      0x00000003
 * VMLAUNCH with non-clear VMCS.
#define VMX_ERROR_VMLAUCH_NON_CLEAR_VMCS                             0x00000004
 * VMRESUME with non-launched VMCS.
#define VMX_ERROR_VMRESUME_NON_LAUNCHED_VMCS                         0x00000005
 * VMRESUME after VMXOFF (VMXOFF and VMXON between VMLAUNCH and VMRESUME).
#define VMX_ERROR_VMRESUME_AFTER_VMXOFF                              0x00000006
 * VM entry with invalid control field(s).
#define VMX_ERROR_VMENTRY_INVALID_CONTROL_FIELDS                     0x00000007
 * VM entry with invalid host-state field(s).
#define VMX_ERROR_VMENTRY_INVALID_HOST_STATE                         0x00000008
 * VMPTRLD with invalid physical address.
#define VMX_ERROR_VMPTRLD_INVALID_PHYSICAL_ADDRESS                   0x00000009
 * VMPTRLD with VMXON pointer.
#define VMX_ERROR_VMPTRLD_VMXON_POINTER                              0x0000000A
 * VMPTRLD with incorrect VMCS revision identifier.
#define VMX_ERROR_VMPTRLD_INCORRECT_VMCS_REVISION_ID                 0x0000000B
 * VMREAD/VMWRITE from/to unsupported VMCS component.
#define VMX_ERROR_VMREAD_VMWRITE_INVALID_COMPONENT                   0x0000000C
 * VMWRITE to read-only VMCS component.
#define VMX_ERROR_VMWRITE_READONLY_COMPONENT                         0x0000000D
 * VMXON executed in VMX root operation.
#define VMX_ERROR_VMXON_IN_VMX_ROOT_OP                               0x0000000F
 * VM entry with invalid executive-VMCS pointer.
#define VMX_ERROR_VMENTRY_INVALID_VMCS_EXECUTIVE_POINTER             0x00000010
 * VM entry with non-launched executive VMCS.
#define VMX_ERROR_VMENTRY_NON_LAUNCHED_EXECUTIVE_VMCS                0x00000011
 * VM entry with executive-VMCS pointer not VMXON pointer (when attempting to deactivate the dual-monitor treatment of SMIs
 * and SMM).
#define VMX_ERROR_VMENTRY_EXECUTIVE_VMCS_PTR                         0x00000012
 * VMCALL with non-clear VMCS (when attempting to activate the dual-monitor treatment of SMIs and SMM).
#define VMX_ERROR_VMCALL_NON_CLEAR_VMCS                              0x00000013
 * VMCALL with invalid VM-exit control fields.
#define VMX_ERROR_VMCALL_INVALID_VMEXIT_FIELDS                       0x00000014
 * VMCALL with incorrect MSEG revision identifier (when attempting to activate the dual-monitor treatment of SMIs and SMM).
#define VMX_ERROR_VMCALL_INVALID_MSEG_REVISION_ID                    0x00000016
 * VMXOFF under dual-monitor treatment of SMIs and SMM.
#define VMX_ERROR_VMXOFF_DUAL_MONITOR                                0x00000017
 * VMCALL with invalid SMM-monitor features (when attempting to activate the dual-monitor treatment of SMIs and SMM).
#define VMX_ERROR_VMCALL_INVALID_SMM_MONITOR                         0x00000018
 * VM entry with invalid VM-execution control fields in executive VMCS (when attempting to return from SMM).
#define VMX_ERROR_VMENTRY_INVALID_VM_EXECUTION_CONTROL               0x00000019
 * VM entry with events blocked by MOV SS.
#define VMX_ERROR_VMENTRY_MOV_SS                                     0x0000001A
 * Invalid operand to INVEPT/INVVPID.
#define VMX_ERROR_INVEPT_INVVPID_INVALID_OPERAND                     0x0000001C
 *           Virtualization Exceptions
 *
 * Virtualization Exceptions.
 *
typedef struct
{
   * The 32-bit value that would have been saved into the VMCS as an exit reason had a VM exit occurred instead of the
   * virtualization exception. For EPT violations, this value is 48 (00000030H).
  UINT32 Reason;
   * FFFFFFFFH
  UINT32 ExceptionMask;
   * The 64-bit value that would have been saved into the VMCS as an exit qualification had a VM exit occurred instead of the
   * virtualization exception.
  UINT64 Exit;
   * The 64-bit value that would have been saved into the VMCS as a guest-linear address had a VM exit occurred instead of
   * the virtualization exception.
  UINT64 GuestLinearAddress;
   * The 64-bit value that would have been saved into the VMCS as a guest-physical address had a VM exit occurred instead of
   * the virtualization exception.
  UINT64 GuestPhysicalAddress;
   * The current 16-bit value of the EPTP index VM-execution control.
   *
  UINT16 CurrentEptpIndex;
} VMX_VIRTUALIZATION_EXCEPTION_INFORMATION;*/
return true
}

func (i *ia32)#define VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_BREAKPOINT_CONDITION()(ok bool){//col:18285
/*#define VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_BREAKPOINT_CONDITION(_) (((_) >> 0) & 0x0F)
    UINT64 Reserved1                                               : 9;
     *
     * [Bit 13] When set, this bit indicates that the cause of the debug exception is "debug register access detected."
    UINT64 DebugRegisterAccessDetected                             : 1;
#define VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_DEBUG_REGISTER_ACCESS_DETECTED_BIT 13
#define VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_DEBUG_REGISTER_ACCESS_DETECTED_FLAG 0x2000
#define VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_DEBUG_REGISTER_ACCESS_DETECTED_MASK 0x01
#define VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_DEBUG_REGISTER_ACCESS_DETECTED(_) (((_) >> 13) & 0x01)
     *
     * [Bit 14] When set, this bit indicates that the cause of the debug exception is either the execution of a single
     * instruction (if RFLAGS.TF = 1 and IA32_DEBUGCTL.BTF = 0) or a taken branch (if RFLAGS.TF = DEBUGCTL.BTF = 1).
    UINT64 SingleInstruction                                       : 1;
#define VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_SINGLE_INSTRUCTION_BIT 14
#define VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_SINGLE_INSTRUCTION_FLAG 0x4000
#define VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_SINGLE_INSTRUCTION_MASK 0x01
#define VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_SINGLE_INSTRUCTION(_) (((_) >> 14) & 0x01)
    UINT64 Reserved2                                               : 49;
  };
  UINT64 AsUInt;
} VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION;*/
return true
}

func (i *ia32)     * [Bits 15:0] Selector of task-state segment ()(ok bool){//col:18320
/*     * [Bits 15:0] Selector of task-state segment (TSS) to which the guest attempted to switch.
    UINT64 Selector                                                : 16;
#define VMX_EXIT_QUALIFICATION_TASK_SWITCH_SELECTOR_BIT              0
#define VMX_EXIT_QUALIFICATION_TASK_SWITCH_SELECTOR_FLAG             0xFFFF
#define VMX_EXIT_QUALIFICATION_TASK_SWITCH_SELECTOR_MASK             0xFFFF
#define VMX_EXIT_QUALIFICATION_TASK_SWITCH_SELECTOR(_)               (((_) >> 0) & 0xFFFF)
    UINT64 Reserved1                                               : 14;
     * [Bits 31:30] Source of task switch initiation.
    UINT64 Source                                                  : 2;
#define VMX_EXIT_QUALIFICATION_TASK_SWITCH_SOURCE_BIT                30
#define VMX_EXIT_QUALIFICATION_TASK_SWITCH_SOURCE_FLAG               0xC0000000
#define VMX_EXIT_QUALIFICATION_TASK_SWITCH_SOURCE_MASK               0x03
#define VMX_EXIT_QUALIFICATION_TASK_SWITCH_SOURCE(_)                 (((_) >> 30) & 0x03)
#define VMX_EXIT_QUALIFICATION_TYPE_CALL_INSTRUCTION                 0x00000000
#define VMX_EXIT_QUALIFICATION_TYPE_IRET_INSTRUCTION                 0x00000001
#define VMX_EXIT_QUALIFICATION_TYPE_JMP_INSTRUCTION                  0x00000002
#define VMX_EXIT_QUALIFICATION_TYPE_TASK_GATE_IN_IDT                 0x00000003
    UINT64 Reserved2                                               : 32;
  };
  UINT64 AsUInt;
} VMX_EXIT_QUALIFICATION_TASK_SWITCH;*/
return true
}

func (i *ia32)     * [Bits 3:0] Number of control register ()(ok bool){//col:18407
/*     * [Bits 3:0] Number of control register (0 for CLTS and LMSW). Bit 3 is always 0 on processors that do not support Intel
     * 64 architecture as they do not support CR8.
    UINT64 ControlRegister                                         : 4;
#define VMX_EXIT_QUALIFICATION_MOV_CR_CONTROL_REGISTER_BIT           0
#define VMX_EXIT_QUALIFICATION_MOV_CR_CONTROL_REGISTER_FLAG          0x0F
#define VMX_EXIT_QUALIFICATION_MOV_CR_CONTROL_REGISTER_MASK          0x0F
#define VMX_EXIT_QUALIFICATION_MOV_CR_CONTROL_REGISTER(_)            (((_) >> 0) & 0x0F)
#define VMX_EXIT_QUALIFICATION_REGISTER_CR0                          0x00000000
#define VMX_EXIT_QUALIFICATION_REGISTER_CR2                          0x00000002
#define VMX_EXIT_QUALIFICATION_REGISTER_CR3                          0x00000003
#define VMX_EXIT_QUALIFICATION_REGISTER_CR4                          0x00000004
#define VMX_EXIT_QUALIFICATION_REGISTER_CR8                          0x00000008
     * [Bits 5:4] Access type.
    UINT64 AccessType                                              : 2;
#define VMX_EXIT_QUALIFICATION_MOV_CR_ACCESS_TYPE_BIT                4
#define VMX_EXIT_QUALIFICATION_MOV_CR_ACCESS_TYPE_FLAG               0x30
#define VMX_EXIT_QUALIFICATION_MOV_CR_ACCESS_TYPE_MASK               0x03
#define VMX_EXIT_QUALIFICATION_MOV_CR_ACCESS_TYPE(_)                 (((_) >> 4) & 0x03)
#define VMX_EXIT_QUALIFICATION_ACCESS_MOV_TO_CR                      0x00000000
#define VMX_EXIT_QUALIFICATION_ACCESS_MOV_FROM_CR                    0x00000001
#define VMX_EXIT_QUALIFICATION_ACCESS_CLTS                           0x00000002
#define VMX_EXIT_QUALIFICATION_ACCESS_LMSW                           0x00000003
     * [Bit 6] LMSW operand type. For CLTS and MOV CR, cleared to 0.
    UINT64 LmswOperandType                                         : 1;
#define VMX_EXIT_QUALIFICATION_MOV_CR_LMSW_OPERAND_TYPE_BIT          6
#define VMX_EXIT_QUALIFICATION_MOV_CR_LMSW_OPERAND_TYPE_FLAG         0x40
#define VMX_EXIT_QUALIFICATION_MOV_CR_LMSW_OPERAND_TYPE_MASK         0x01
#define VMX_EXIT_QUALIFICATION_MOV_CR_LMSW_OPERAND_TYPE(_)           (((_) >> 6) & 0x01)
#define VMX_EXIT_QUALIFICATION_LMSW_OP_REGISTER                      0x00000000
#define VMX_EXIT_QUALIFICATION_LMSW_OP_MEMORY                        0x00000001
    UINT64 Reserved1                                               : 1;
     * [Bits 11:8] For MOV CR, the general-purpose register.
    UINT64 GeneralPurposeRegister                                  : 4;
#define VMX_EXIT_QUALIFICATION_MOV_CR_GENERAL_PURPOSE_REGISTER_BIT   8
#define VMX_EXIT_QUALIFICATION_MOV_CR_GENERAL_PURPOSE_REGISTER_FLAG  0xF00
#define VMX_EXIT_QUALIFICATION_MOV_CR_GENERAL_PURPOSE_REGISTER_MASK  0x0F
#define VMX_EXIT_QUALIFICATION_MOV_CR_GENERAL_PURPOSE_REGISTER(_)    (((_) >> 8) & 0x0F)
#define VMX_EXIT_QUALIFICATION_GENREG_RAX                            0x00000000
#define VMX_EXIT_QUALIFICATION_GENREG_RCX                            0x00000001
#define VMX_EXIT_QUALIFICATION_GENREG_RDX                            0x00000002
#define VMX_EXIT_QUALIFICATION_GENREG_RBX                            0x00000003
#define VMX_EXIT_QUALIFICATION_GENREG_RSP                            0x00000004
#define VMX_EXIT_QUALIFICATION_GENREG_RBP                            0x00000005
#define VMX_EXIT_QUALIFICATION_GENREG_RSI                            0x00000006
#define VMX_EXIT_QUALIFICATION_GENREG_RDI                            0x00000007
#define VMX_EXIT_QUALIFICATION_GENREG_R8                             0x00000008
#define VMX_EXIT_QUALIFICATION_GENREG_R9                             0x00000009
#define VMX_EXIT_QUALIFICATION_GENREG_R10                            0x0000000A
#define VMX_EXIT_QUALIFICATION_GENREG_R11                            0x0000000B
#define VMX_EXIT_QUALIFICATION_GENREG_R12                            0x0000000C
#define VMX_EXIT_QUALIFICATION_GENREG_R13                            0x0000000D
#define VMX_EXIT_QUALIFICATION_GENREG_R14                            0x0000000E
#define VMX_EXIT_QUALIFICATION_GENREG_R15                            0x0000000F
    UINT64 Reserved2                                               : 4;
     * [Bits 31:16] For LMSW, the LMSW source data. For CLTS and MOV CR, cleared to 0.
    UINT64 LmswSourceData                                          : 16;
#define VMX_EXIT_QUALIFICATION_MOV_CR_LMSW_SOURCE_DATA_BIT           16
#define VMX_EXIT_QUALIFICATION_MOV_CR_LMSW_SOURCE_DATA_FLAG          0xFFFF0000
#define VMX_EXIT_QUALIFICATION_MOV_CR_LMSW_SOURCE_DATA_MASK          0xFFFF
#define VMX_EXIT_QUALIFICATION_MOV_CR_LMSW_SOURCE_DATA(_)            (((_) >> 16) & 0xFFFF)
    UINT64 Reserved3                                               : 32;
  };
  UINT64 AsUInt;
} VMX_EXIT_QUALIFICATION_MOV_CR;*/
return true
}

func (i *ia32)#define VMX_EXIT_QUALIFICATION_MOV_DR_DEBUG_REGISTER()(ok bool){//col:18456
/*#define VMX_EXIT_QUALIFICATION_MOV_DR_DEBUG_REGISTER(_)              (((_) >> 0) & 0x07)
#define VMX_EXIT_QUALIFICATION_REGISTER_DR0                          0x00000000
#define VMX_EXIT_QUALIFICATION_REGISTER_DR1                          0x00000001
#define VMX_EXIT_QUALIFICATION_REGISTER_DR2                          0x00000002
#define VMX_EXIT_QUALIFICATION_REGISTER_DR3                          0x00000003
#define VMX_EXIT_QUALIFICATION_REGISTER_DR6                          0x00000006
#define VMX_EXIT_QUALIFICATION_REGISTER_DR7                          0x00000007
    UINT64 Reserved1                                               : 1;
     * [Bit 4] Direction of access (0 = MOV to DR; 1 = MOV from DR).
    UINT64 DirectionOfAccess                                       : 1;
#define VMX_EXIT_QUALIFICATION_MOV_DR_DIRECTION_OF_ACCESS_BIT        4
#define VMX_EXIT_QUALIFICATION_MOV_DR_DIRECTION_OF_ACCESS_FLAG       0x10
#define VMX_EXIT_QUALIFICATION_MOV_DR_DIRECTION_OF_ACCESS_MASK       0x01
#define VMX_EXIT_QUALIFICATION_MOV_DR_DIRECTION_OF_ACCESS(_)         (((_) >> 4) & 0x01)
#define VMX_EXIT_QUALIFICATION_DIRECTION_MOV_TO_DR                   0x00000000
#define VMX_EXIT_QUALIFICATION_DIRECTION_MOV_FROM_DR                 0x00000001
    UINT64 Reserved2                                               : 3;
     * [Bits 11:8] General-purpose register.
    UINT64 GeneralPurposeRegister                                  : 4;
#define VMX_EXIT_QUALIFICATION_MOV_DR_GENERAL_PURPOSE_REGISTER_BIT   8
#define VMX_EXIT_QUALIFICATION_MOV_DR_GENERAL_PURPOSE_REGISTER_FLAG  0xF00
#define VMX_EXIT_QUALIFICATION_MOV_DR_GENERAL_PURPOSE_REGISTER_MASK  0x0F
#define VMX_EXIT_QUALIFICATION_MOV_DR_GENERAL_PURPOSE_REGISTER(_)    (((_) >> 8) & 0x0F)
    UINT64 Reserved3                                               : 52;
  };
  UINT64 AsUInt;
} VMX_EXIT_QUALIFICATION_MOV_DR;*/
return true
}

func (i *ia32)#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_SIZE_OF_ACCESS()(ok bool){//col:18534
/*#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_SIZE_OF_ACCESS(_)      (((_) >> 0) & 0x07)
#define VMX_EXIT_QUALIFICATION_WIDTH_1_BYTE                          0x00000000
#define VMX_EXIT_QUALIFICATION_WIDTH_2_BYTE                          0x00000001
#define VMX_EXIT_QUALIFICATION_WIDTH_4_BYTE                          0x00000003
     * [Bit 3] Direction of the attempted access (0 = OUT, 1 = IN).
    UINT64 DirectionOfAccess                                       : 1;
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_DIRECTION_OF_ACCESS_BIT 3
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_DIRECTION_OF_ACCESS_FLAG 0x08
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_DIRECTION_OF_ACCESS_MASK 0x01
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_DIRECTION_OF_ACCESS(_) (((_) >> 3) & 0x01)
#define VMX_EXIT_QUALIFICATION_DIRECTION_OUT                         0x00000000
#define VMX_EXIT_QUALIFICATION_DIRECTION_IN                          0x00000001
     * [Bit 4] String instruction (0 = not string; 1 = string).
    UINT64 StringInstruction                                       : 1;
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_STRING_INSTRUCTION_BIT 4
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_STRING_INSTRUCTION_FLAG 0x10
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_STRING_INSTRUCTION_MASK 0x01
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_STRING_INSTRUCTION(_)  (((_) >> 4) & 0x01)
#define VMX_EXIT_QUALIFICATION_IS_STRING_NOT_STRING                  0x00000000
#define VMX_EXIT_QUALIFICATION_IS_STRING_STRING                      0x00000001
     * [Bit 5] REP prefixed (0 = not REP; 1 = REP).
    UINT64 RepPrefixed                                             : 1;
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_REP_PREFIXED_BIT       5
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_REP_PREFIXED_FLAG      0x20
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_REP_PREFIXED_MASK      0x01
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_REP_PREFIXED(_)        (((_) >> 5) & 0x01)
#define VMX_EXIT_QUALIFICATION_IS_REP_NOT_REP                        0x00000000
#define VMX_EXIT_QUALIFICATION_IS_REP_REP                            0x00000001
     * [Bit 6] Operand encoding (0 = DX, 1 = immediate).
    UINT64 OperandEncoding                                         : 1;
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_OPERAND_ENCODING_BIT   6
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_OPERAND_ENCODING_FLAG  0x40
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_OPERAND_ENCODING_MASK  0x01
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_OPERAND_ENCODING(_)    (((_) >> 6) & 0x01)
#define VMX_EXIT_QUALIFICATION_ENCODING_DX                           0x00000000
#define VMX_EXIT_QUALIFICATION_ENCODING_IMMEDIATE                    0x00000001
    UINT64 Reserved1                                               : 9;
     * [Bits 31:16] Port number (as specified in DX or in an immediate operand).
    UINT64 PortNumber                                              : 16;
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_PORT_NUMBER_BIT        16
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_PORT_NUMBER_FLAG       0xFFFF0000
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_PORT_NUMBER_MASK       0xFFFF
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_PORT_NUMBER(_)         (((_) >> 16) & 0xFFFF)
    UINT64 Reserved2                                               : 32;
  };
  UINT64 AsUInt;
} VMX_EXIT_QUALIFICATION_IO_INSTRUCTION;*/
return true
}

func (i *ia32)#define VMX_EXIT_QUALIFICATION_APIC_ACCESS_PAGE_OFFSET()(ok bool){//col:18594
/*#define VMX_EXIT_QUALIFICATION_APIC_ACCESS_PAGE_OFFSET(_)            (((_) >> 0) & 0xFFF)
     * [Bits 15:12] Access type.
    UINT64 AccessType                                              : 4;
#define VMX_EXIT_QUALIFICATION_APIC_ACCESS_ACCESS_TYPE_BIT           12
#define VMX_EXIT_QUALIFICATION_APIC_ACCESS_ACCESS_TYPE_FLAG          0xF000
#define VMX_EXIT_QUALIFICATION_APIC_ACCESS_ACCESS_TYPE_MASK          0x0F
#define VMX_EXIT_QUALIFICATION_APIC_ACCESS_ACCESS_TYPE(_)            (((_) >> 12) & 0x0F)
     * Linear access for a data read during instruction execution.
#define VMX_EXIT_QUALIFICATION_TYPE_LINEAR_READ                      0x00000000
     * Linear access for a data write during instruction execution.
#define VMX_EXIT_QUALIFICATION_TYPE_LINEAR_WRITE                     0x00000001
     * Linear access for an instruction fetch.
#define VMX_EXIT_QUALIFICATION_TYPE_LINEAR_INSTRUCTION_FETCH         0x00000002
     * Linear access (read or write) during event delivery.
#define VMX_EXIT_QUALIFICATION_TYPE_LINEAR_EVENT_DELIVERY            0x00000003
     * Guest-physical access during event delivery.
#define VMX_EXIT_QUALIFICATION_TYPE_PHYSICAL_EVENT_DELIVERY          0x0000000A
     * Guest-physical access for an instruction fetch or during instruction execution.
#define VMX_EXIT_QUALIFICATION_TYPE_PHYSICAL_INSTRUCTION_FETCH       0x0000000F
    UINT64 Reserved1                                               : 48;
  };
  UINT64 AsUInt;
} VMX_EXIT_QUALIFICATION_APIC_ACCESS;*/
return true
}

func (i *ia32)#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_READ_ACCESS()(ok bool){//col:18790
/*#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_READ_ACCESS(_)          (((_) >> 0) & 0x01)
     * [Bit 1] Set if the access causing the EPT violation was a data write.
    UINT64 WriteAccess                                             : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_WRITE_ACCESS_BIT        1
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_WRITE_ACCESS_FLAG       0x02
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_WRITE_ACCESS_MASK       0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_WRITE_ACCESS(_)         (((_) >> 1) & 0x01)
     * [Bit 2] Set if the access causing the EPT violation was an instruction fetch.
    UINT64 ExecuteAccess                                           : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EXECUTE_ACCESS_BIT      2
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EXECUTE_ACCESS_FLAG     0x04
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EXECUTE_ACCESS_MASK     0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EXECUTE_ACCESS(_)       (((_) >> 2) & 0x01)
     * [Bit 3] The logical-AND of bit 0 in the EPT paging-structure entries used to translate the guest-physical address of the
     * access causing the EPT violation (indicates whether the guest-physical address was readable).
    UINT64 EptReadable                                             : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_READABLE_BIT        3
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_READABLE_FLAG       0x08
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_READABLE_MASK       0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_READABLE(_)         (((_) >> 3) & 0x01)
     * [Bit 4] The logical-AND of bit 1 in the EPT paging-structure entries used to translate the guest-physical address of the
     * access causing the EPT violation (indicates whether the guest-physical address was writeable).
    UINT64 EptWriteable                                            : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_WRITEABLE_BIT       4
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_WRITEABLE_FLAG      0x10
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_WRITEABLE_MASK      0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_WRITEABLE(_)        (((_) >> 4) & 0x01)
     * [Bit 5] The logical-AND of bit 2 in the EPT paging-structure entries used to translate the guest-physical address of the
     * access causing the EPT violation.
     * If the "mode-based execute control for EPT" VM-execution control is 0, this indicates whether the guest-physical address
     * was executable. If that control is 1, this indicates whether the guest-physical address was executable for
     * supervisor-mode linear addresses.
    UINT64 EptExecutable                                           : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_EXECUTABLE_BIT      5
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_EXECUTABLE_FLAG     0x20
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_EXECUTABLE_MASK     0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_EXECUTABLE(_)       (((_) >> 5) & 0x01)
     * [Bit 6] If the "mode-based execute control" VM-execution control is 0, the value of this bit is undefined. If that
     * control is 1, this bit is the logical-AND of bit 10 in the EPT paging-structures entries used to translate the
     * guest-physical address of the access causing the EPT violation. In this case, it indicates whether the guest-physical
     * address was executable for user-mode linear addresses.
    UINT64 EptExecutableForUserMode                                : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_EXECUTABLE_FOR_USER_MODE_BIT 6
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_EXECUTABLE_FOR_USER_MODE_FLAG 0x40
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_EXECUTABLE_FOR_USER_MODE_MASK 0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_EXECUTABLE_FOR_USER_MODE(_) (((_) >> 6) & 0x01)
     * [Bit 7] Set if the guest linear-address field is valid. The guest linear-address field is valid for all EPT violations
     * except those resulting from an attempt to load the guest PDPTEs as part of the execution of the MOV CR instruction.
    UINT64 ValidGuestLinearAddress                                 : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_VALID_GUEST_LINEAR_ADDRESS_BIT 7
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_VALID_GUEST_LINEAR_ADDRESS_FLAG 0x80
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_VALID_GUEST_LINEAR_ADDRESS_MASK 0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_VALID_GUEST_LINEAR_ADDRESS(_) (((_) >> 7) & 0x01)
     * [Bit 8] If bit 7 is 1:
     * - Set if the access causing the EPT violation is to a guest-physical address that is the translation of a linear
     * address.
     * - Clear if the access causing the EPT violation is to a paging-structure entry as part of a page walk or the update of
     * an accessed or dirty bit.
     * Reserved if bit 7 is 0 (cleared to 0).
    UINT64 CausedByTranslation                                     : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_CAUSED_BY_TRANSLATION_BIT 8
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_CAUSED_BY_TRANSLATION_FLAG 0x100
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_CAUSED_BY_TRANSLATION_MASK 0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_CAUSED_BY_TRANSLATION(_) (((_) >> 8) & 0x01)
     * [Bit 9] This bit is 0 if the linear address is a supervisor-mode linear address and 1 if it is a user-mode linear
     * address. Otherwise, this bit is undefined.
     *
     *          CR0.PG = 0, the translation of every linear address is a user-mode linear address and thus this bit will be 1.)
    UINT64 UserModeLinearAddress                                   : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_USER_MODE_LINEAR_ADDRESS_BIT 9
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_USER_MODE_LINEAR_ADDRESS_FLAG 0x200
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_USER_MODE_LINEAR_ADDRESS_MASK 0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_USER_MODE_LINEAR_ADDRESS(_) (((_) >> 9) & 0x01)
     * [Bit 10] This bit is 0 if paging translates the linear address to a read-only page and 1 if it translates to a
     * read/write page. Otherwise, this bit is undefined
     *
     *          CR0.PG = 0, every linear address is read/write and thus this bit will be 1.)
    UINT64 ReadableWritablePage                                    : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_READABLE_WRITABLE_PAGE_BIT 10
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_READABLE_WRITABLE_PAGE_FLAG 0x400
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_READABLE_WRITABLE_PAGE_MASK 0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_READABLE_WRITABLE_PAGE(_) (((_) >> 10) & 0x01)
     * [Bit 11] This bit is 0 if paging translates the linear address to an executable page and 1 if it translates to an
     * execute-disable page. Otherwise, this bit is undefined.
     *
     *          CR0.PG = 0, CR4.PAE = 0, or IA32_EFER.NXE = 0, every linear address is executable and thus this bit will be 0.)
    UINT64 ExecuteDisablePage                                      : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EXECUTE_DISABLE_PAGE_BIT 11
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EXECUTE_DISABLE_PAGE_FLAG 0x800
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EXECUTE_DISABLE_PAGE_MASK 0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EXECUTE_DISABLE_PAGE(_) (((_) >> 11) & 0x01)
     * [Bit 12] NMI unblocking due to IRET.
    UINT64 NmiUnblocking                                           : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_NMI_UNBLOCKING_BIT      12
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_NMI_UNBLOCKING_FLAG     0x1000
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_NMI_UNBLOCKING_MASK     0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_NMI_UNBLOCKING(_)       (((_) >> 12) & 0x01)
     * [Bit 13] Set if the access causing the EPT violation was a shadow-stack access.
    UINT64 ShadowStackAccess                                       : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_SHADOW_STACK_ACCESS_BIT 13
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_SHADOW_STACK_ACCESS_FLAG 0x2000
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_SHADOW_STACK_ACCESS_MASK 0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_SHADOW_STACK_ACCESS(_)  (((_) >> 13) & 0x01)
     * [Bit 14] If supervisor shadow-stack control is enabled (by setting bit 7 of EPTP), this bit is the same as bit 60 in the
     * EPT paging-structure entry that maps the page of the guest-physical address of the access causing the EPT violation.
     * Otherwise (or if translation of the guest-physical address terminates before reaching an EPT paging-structure entry that
     * maps a page), this bit is undefined.
    UINT64 SupervisorShadowStack                                   : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_SUPERVISOR_SHADOW_STACK_BIT 14
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_SUPERVISOR_SHADOW_STACK_FLAG 0x4000
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_SUPERVISOR_SHADOW_STACK_MASK 0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_SUPERVISOR_SHADOW_STACK(_) (((_) >> 14) & 0x01)
     * [Bit 15] This bit is set if the EPT violation was caused as a result of guest-paging verification.
    UINT64 GuestPagingVerification                                 : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_GUEST_PAGING_VERIFICATION_BIT 15
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_GUEST_PAGING_VERIFICATION_FLAG 0x8000
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_GUEST_PAGING_VERIFICATION_MASK 0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_GUEST_PAGING_VERIFICATION(_) (((_) >> 15) & 0x01)
     * [Bit 16] This bit is set if the access was asynchronous to instruction execution not the result of event delivery. (The
     * bit is set if the access is related to trace output by Intel PT; see Section 25.5.4.) Otherwise, this bit is cleared.
    UINT64 AsynchronousToInstruction                               : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_ASYNCHRONOUS_TO_INSTRUCTION_BIT 16
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_ASYNCHRONOUS_TO_INSTRUCTION_FLAG 0x10000
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_ASYNCHRONOUS_TO_INSTRUCTION_MASK 0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_ASYNCHRONOUS_TO_INSTRUCTION(_) (((_) >> 16) & 0x01)
    UINT64 Reserved1                                               : 47;
  };
  UINT64 AsUInt;
} VMX_EXIT_QUALIFICATION_EPT_VIOLATION;*/
return true
}

func (i *ia32)     * 2: 64-bit ()(ok bool){//col:18849
/*     * 2: 64-bit (used only on processors that support Intel 64 architecture)
     * Other values not used.
    UINT64 AddressSize                                             : 3;
#define VMX_VMEXIT_INSTRUCTION_INFO_INS_OUTS_ADDRESS_SIZE_BIT        7
#define VMX_VMEXIT_INSTRUCTION_INFO_INS_OUTS_ADDRESS_SIZE_FLAG       0x380
#define VMX_VMEXIT_INSTRUCTION_INFO_INS_OUTS_ADDRESS_SIZE_MASK       0x07
#define VMX_VMEXIT_INSTRUCTION_INFO_INS_OUTS_ADDRESS_SIZE(_)         (((_) >> 7) & 0x07)
    UINT64 Reserved2                                               : 5;
     *
     * [Bits 17:15] 0: ES
     * 1: CS
     * 2: SS
     * 3: DS
     * 4: FS
     * 5: GS
     * Other values not used. Undefined for VM exits due to execution of INS.
    UINT64 SegmentRegister                                         : 3;
#define VMX_VMEXIT_INSTRUCTION_INFO_INS_OUTS_SEGMENT_REGISTER_BIT    15
#define VMX_VMEXIT_INSTRUCTION_INFO_INS_OUTS_SEGMENT_REGISTER_FLAG   0x38000
#define VMX_VMEXIT_INSTRUCTION_INFO_INS_OUTS_SEGMENT_REGISTER_MASK   0x07
#define VMX_VMEXIT_INSTRUCTION_INFO_INS_OUTS_SEGMENT_REGISTER(_)     (((_) >> 15) & 0x07)
    UINT64 Reserved3                                               : 46;
  };
  UINT64 AsUInt;
} VMX_VMEXIT_INSTRUCTION_INFO_INS_OUTS;*/
return true
}

func (i *ia32)     * 3: scale by 8 ()(ok bool){//col:18955
/*     * 3: scale by 8 (used only on processors that support Intel 64 architecture)
     * Undefined for instructions with no index register (bit 22 is set).
    UINT64 Scaling                                                 : 2;
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_SCALING_BIT           0
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_SCALING_FLAG          0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_SCALING_MASK          0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_SCALING(_)            (((_) >> 0) & 0x03)
    UINT64 Reserved1                                               : 5;
     *
     * [Bits 9:7] 0: 16-bit
     * 1: 32-bit
     * 2: 64-bit (used only on processors that support Intel 64 architecture)
     * Other values not used.
    UINT64 AddressSize                                             : 3;
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_ADDRESS_SIZE_BIT      7
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_ADDRESS_SIZE_FLAG     0x380
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_ADDRESS_SIZE_MASK     0x07
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_ADDRESS_SIZE(_)       (((_) >> 7) & 0x07)
    UINT64 Reserved2                                               : 5;
     *
     * [Bits 17:15] 0: ES
     * 1: CS
     * 2: SS
     * 3: DS
     * 4: FS
     * 5: GS
     * Other values not used. Undefined for VM exits due to execution of INS.
    UINT64 SegmentRegister                                         : 3;
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_SEGMENT_REGISTER_BIT  15
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_SEGMENT_REGISTER_FLAG 0x38000
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_SEGMENT_REGISTER_MASK 0x07
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_SEGMENT_REGISTER(_)   (((_) >> 15) & 0x07)
     * [Bits 21:18] General-purpose register. Undefined for instructions with no index register (bit 22 is set).
    UINT64 GeneralPurposeRegister                                  : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_GENERAL_PURPOSE_REGISTER_BIT 18
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_GENERAL_PURPOSE_REGISTER_FLAG 0x3C0000
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_GENERAL_PURPOSE_REGISTER_MASK 0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_GENERAL_PURPOSE_REGISTER(_) (((_) >> 18) & 0x0F)
     * [Bit 22] IndexReg invalid (0 = valid; 1 = invalid).
    UINT64 GeneralPurposeRegisterInvalid                           : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_GENERAL_PURPOSE_REGISTER_INVALID_BIT 22
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_GENERAL_PURPOSE_REGISTER_INVALID_FLAG 0x400000
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_GENERAL_PURPOSE_REGISTER_INVALID_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_GENERAL_PURPOSE_REGISTER_INVALID(_) (((_) >> 22) & 0x01)
     * [Bits 26:23] BaseReg (encoded as IndexReg above). Undefined for memory instructions with no base register (bit 27 is
     * set).
    UINT64 BaseRegister                                            : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_BASE_REGISTER_BIT     23
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_BASE_REGISTER_FLAG    0x7800000
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_BASE_REGISTER_MASK    0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_BASE_REGISTER(_)      (((_) >> 23) & 0x0F)
     * [Bit 27] BaseReg invalid (0 = valid; 1 = invalid).
    UINT64 BaseRegisterInvalid                                     : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_BASE_REGISTER_INVALID_BIT 27
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_BASE_REGISTER_INVALID_FLAG 0x8000000
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_BASE_REGISTER_INVALID_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_BASE_REGISTER_INVALID(_) (((_) >> 27) & 0x01)
     * [Bits 31:28] Reg2 (same encoding as IndexReg above).
    UINT64 Register2                                               : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_REGISTER_2_BIT        28
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_REGISTER_2_FLAG       0xF0000000
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_REGISTER_2_MASK       0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_REGISTER_2(_)         (((_) >> 28) & 0x0F)
    UINT64 Reserved3                                               : 32;
  };
  UINT64 AsUInt;
} VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE;*/
return true
}

func (i *ia32)     * 3: scale by 8 ()(ok bool){//col:19080
/*     * 3: scale by 8 (used only on processors that support Intel 64 architecture)
     * Undefined for instructions with no index register (bit 22 is set).
    UINT64 Scaling                                                 : 2;
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_SCALING_BIT     0
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_SCALING_FLAG    0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_SCALING_MASK    0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_SCALING(_)      (((_) >> 0) & 0x03)
    UINT64 Reserved1                                               : 5;
     *
     * [Bits 9:7] 0: 16-bit
     * 1: 32-bit
     * 2: 64-bit (used only on processors that support Intel 64 architecture)
     * Other values not used.
    UINT64 AddressSize                                             : 3;
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_ADDRESS_SIZE_BIT 7
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_ADDRESS_SIZE_FLAG 0x380
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_ADDRESS_SIZE_MASK 0x07
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_ADDRESS_SIZE(_) (((_) >> 7) & 0x07)
    UINT64 Reserved2                                               : 1;
     *
     * [Bit 11] 0: 16-bit
     * 1: 32-bit
     * Undefined for VM exits from 64-bit mode.
    UINT64 OperandSize                                             : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_OPERAND_SIZE_BIT 11
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_OPERAND_SIZE_FLAG 0x800
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_OPERAND_SIZE_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_OPERAND_SIZE(_) (((_) >> 11) & 0x01)
    UINT64 Reserved3                                               : 3;
     *
     * [Bits 17:15] 0: ES
     * 1: CS
     * 2: SS
     * 3: DS
     * 4: FS
     * 5: GS
     * Other values not used.
    UINT64 SegmentRegister                                         : 3;
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_SEGMENT_REGISTER_BIT 15
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_SEGMENT_REGISTER_FLAG 0x38000
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_SEGMENT_REGISTER_MASK 0x07
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_SEGMENT_REGISTER(_) (((_) >> 15) & 0x07)
     * [Bits 21:18] General-purpose register. Undefined for instructions with no index register (bit 22 is set).
    UINT64 GeneralPurposeRegister                                  : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_GENERAL_PURPOSE_REGISTER_BIT 18
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_GENERAL_PURPOSE_REGISTER_FLAG 0x3C0000
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_GENERAL_PURPOSE_REGISTER_MASK 0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_GENERAL_PURPOSE_REGISTER(_) (((_) >> 18) & 0x0F)
     * [Bit 22] IndexReg invalid (0 = valid; 1 = invalid).
    UINT64 GeneralPurposeRegisterInvalid                           : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_GENERAL_PURPOSE_REGISTER_INVALID_BIT 22
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_GENERAL_PURPOSE_REGISTER_INVALID_FLAG 0x400000
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_GENERAL_PURPOSE_REGISTER_INVALID_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_GENERAL_PURPOSE_REGISTER_INVALID(_) (((_) >> 22) & 0x01)
     * [Bits 26:23] BaseReg (encoded as IndexReg above). Undefined for memory instructions with no base register (bit 27 is
     * set).
    UINT64 BaseRegister                                            : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_BASE_REGISTER_BIT 23
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_BASE_REGISTER_FLAG 0x7800000
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_BASE_REGISTER_MASK 0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_BASE_REGISTER(_) (((_) >> 23) & 0x0F)
     * [Bit 27] BaseReg invalid (0 = valid; 1 = invalid).
    UINT64 BaseRegisterInvalid                                     : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_BASE_REGISTER_INVALID_BIT 27
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_BASE_REGISTER_INVALID_FLAG 0x8000000
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_BASE_REGISTER_INVALID_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_BASE_REGISTER_INVALID(_) (((_) >> 27) & 0x01)
     *
     * [Bits 29:28] 0: SGDT
     * 1: SIDT
     * 2: LGDT
     * 3: LIDT
    UINT64 Instruction                                             : 2;
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_INSTRUCTION_BIT 28
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_INSTRUCTION_FLAG 0x30000000
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_INSTRUCTION_MASK 0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_INSTRUCTION(_)  (((_) >> 28) & 0x03)
    UINT64 Reserved4                                               : 34;
  };
  UINT64 AsUInt;
} VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS;*/
return true
}

func (i *ia32)     * 3: scale by 8 ()(ok bool){//col:19210
/*     * 3: scale by 8 (used only on processors that support Intel 64 architecture)
     * Undefined for instructions with no index register (bit 22 is set).
    UINT64 Scaling                                                 : 2;
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_SCALING_BIT       0
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_SCALING_FLAG      0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_SCALING_MASK      0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_SCALING(_)        (((_) >> 0) & 0x03)
    UINT64 Reserved1                                               : 1;
     * [Bits 6:3] Reg1. Undefined for memory instructions (bit 10 is clear).
    UINT64 Reg1                                                    : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_REG_1_BIT         3
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_REG_1_FLAG        0x78
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_REG_1_MASK        0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_REG_1(_)          (((_) >> 3) & 0x0F)
     *
     * [Bits 9:7] 0: 16-bit
     * 1: 32-bit
     * 2: 64-bit (used only on processors that support Intel 64 architecture)
     * Other values not used. Undefined for register instructions (bit 10 is set).
    UINT64 AddressSize                                             : 3;
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_ADDRESS_SIZE_BIT  7
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_ADDRESS_SIZE_FLAG 0x380
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_ADDRESS_SIZE_MASK 0x07
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_ADDRESS_SIZE(_)   (((_) >> 7) & 0x07)
     * [Bit 10] Mem/Reg (0 = memory; 1 = register).
    UINT64 MemoryRegister                                          : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_MEMORY_REGISTER_BIT 10
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_MEMORY_REGISTER_FLAG 0x400
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_MEMORY_REGISTER_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_MEMORY_REGISTER(_) (((_) >> 10) & 0x01)
    UINT64 Reserved2                                               : 4;
     *
     * [Bits 17:15] 0: ES
     * 1: CS
     * 2: SS
     * 3: DS
     * 4: FS
     * 5: GS
     * Other values not used. Undefined for register instructions (bit 10 is set).
    UINT64 SegmentRegister                                         : 3;
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_SEGMENT_REGISTER_BIT 15
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_SEGMENT_REGISTER_FLAG 0x38000
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_SEGMENT_REGISTER_MASK 0x07
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_SEGMENT_REGISTER(_) (((_) >> 15) & 0x07)
     * [Bits 21:18] General-purpose register. Undefined for register instructions (bit 10 is set) and for memory instructions
     * with no index register (bit 10 is clear and bit 22 is set).
    UINT64 GeneralPurposeRegister                                  : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_GENERAL_PURPOSE_REGISTER_BIT 18
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_GENERAL_PURPOSE_REGISTER_FLAG 0x3C0000
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_GENERAL_PURPOSE_REGISTER_MASK 0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_GENERAL_PURPOSE_REGISTER(_) (((_) >> 18) & 0x0F)
     * [Bit 22] IndexReg invalid (0 = valid; 1 = invalid). Undefined for register instructions (bit 10 is set).
    UINT64 GeneralPurposeRegisterInvalid                           : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_GENERAL_PURPOSE_REGISTER_INVALID_BIT 22
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_GENERAL_PURPOSE_REGISTER_INVALID_FLAG 0x400000
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_GENERAL_PURPOSE_REGISTER_INVALID_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_GENERAL_PURPOSE_REGISTER_INVALID(_) (((_) >> 22) & 0x01)
     * [Bits 26:23] BaseReg (encoded as IndexReg above). Undefined for register instructions (bit 10 is set) and for memory
     * instructions with no base register (bit 10 is clear and bit 27 is set).
    UINT64 BaseRegister                                            : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_BASE_REGISTER_BIT 23
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_BASE_REGISTER_FLAG 0x7800000
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_BASE_REGISTER_MASK 0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_BASE_REGISTER(_)  (((_) >> 23) & 0x0F)
     * [Bit 27] BaseReg invalid (0 = valid; 1 = invalid). Undefined for register instructions (bit 10 is set).
    UINT64 BaseRegisterInvalid                                     : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_BASE_REGISTER_INVALID_BIT 27
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_BASE_REGISTER_INVALID_FLAG 0x8000000
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_BASE_REGISTER_INVALID_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_BASE_REGISTER_INVALID(_) (((_) >> 27) & 0x01)
     *
     * [Bits 29:28] 0: SLDT
     * 1: STR
     * 2: LLDT
     * 3: LTR
    UINT64 Instruction                                             : 2;
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_INSTRUCTION_BIT   28
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_INSTRUCTION_FLAG  0x30000000
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_INSTRUCTION_MASK  0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_INSTRUCTION(_)    (((_) >> 28) & 0x03)
    UINT64 Reserved3                                               : 34;
  };
  UINT64 AsUInt;
} VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS;*/
return true
}

func (i *ia32)#define VMX_VMEXIT_INSTRUCTION_INFO_RDRAND_RDSEED_DESTINATION_REGISTER()(ok bool){//col:19248
/*#define VMX_VMEXIT_INSTRUCTION_INFO_RDRAND_RDSEED_DESTINATION_REGISTER(_) (((_) >> 3) & 0x0F)
    UINT64 Reserved2                                               : 4;
     *
     * [Bits 12:11] 0: 16-bit
     * 1: 32-bit
     * 2: 64-bit
     * The value 3 is not used.
    UINT64 OperandSize                                             : 2;
#define VMX_VMEXIT_INSTRUCTION_INFO_RDRAND_RDSEED_OPERAND_SIZE_BIT   11
#define VMX_VMEXIT_INSTRUCTION_INFO_RDRAND_RDSEED_OPERAND_SIZE_FLAG  0x1800
#define VMX_VMEXIT_INSTRUCTION_INFO_RDRAND_RDSEED_OPERAND_SIZE_MASK  0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_RDRAND_RDSEED_OPERAND_SIZE(_)    (((_) >> 11) & 0x03)
    UINT64 Reserved3                                               : 51;
  };
  UINT64 AsUInt;
} VMX_VMEXIT_INSTRUCTION_INFO_RDRAND_RDSEED;*/
return true
}

func (i *ia32)     * 3: scale by 8 ()(ok bool){//col:19345
/*     * 3: scale by 8 (used only on processors that support Intel 64 architecture)
     * Undefined for instructions with no index register (bit 22 is set).
    UINT64 Scaling                                                 : 2;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_SCALING_BIT       0
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_SCALING_FLAG      0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_SCALING_MASK      0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_SCALING(_)        (((_) >> 0) & 0x03)
    UINT64 Reserved1                                               : 5;
     *
     * [Bits 9:7] 0: 16-bit
     * 1: 32-bit
     * 2: 64-bit (used only on processors that support Intel 64 architecture)
     * Other values not used.
    UINT64 AddressSize                                             : 3;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_ADDRESS_SIZE_BIT  7
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_ADDRESS_SIZE_FLAG 0x380
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_ADDRESS_SIZE_MASK 0x07
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_ADDRESS_SIZE(_)   (((_) >> 7) & 0x07)
    UINT64 Reserved2                                               : 5;
     *
     * [Bits 17:15] 0: ES
     * 1: CS
     * 2: SS
     * 3: DS
     * 4: FS
     * 5: GS
     * Other values not used.
    UINT64 SegmentRegister                                         : 3;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_SEGMENT_REGISTER_BIT 15
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_SEGMENT_REGISTER_FLAG 0x38000
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_SEGMENT_REGISTER_MASK 0x07
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_SEGMENT_REGISTER(_) (((_) >> 15) & 0x07)
     * [Bits 21:18] General-purpose register. Undefined for instructions with no index register (bit 22 is set).
    UINT64 GeneralPurposeRegister                                  : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_GENERAL_PURPOSE_REGISTER_BIT 18
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_GENERAL_PURPOSE_REGISTER_FLAG 0x3C0000
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_GENERAL_PURPOSE_REGISTER_MASK 0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_GENERAL_PURPOSE_REGISTER(_) (((_) >> 18) & 0x0F)
     * [Bit 22] IndexReg invalid (0 = valid; 1 = invalid).
    UINT64 GeneralPurposeRegisterInvalid                           : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_GENERAL_PURPOSE_REGISTER_INVALID_BIT 22
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_GENERAL_PURPOSE_REGISTER_INVALID_FLAG 0x400000
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_GENERAL_PURPOSE_REGISTER_INVALID_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_GENERAL_PURPOSE_REGISTER_INVALID(_) (((_) >> 22) & 0x01)
     * [Bits 26:23] BaseReg (encoded as IndexReg above). Undefined for memory instructions with no base register (bit 27 is
     * set).
    UINT64 BaseRegister                                            : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_BASE_REGISTER_BIT 23
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_BASE_REGISTER_FLAG 0x7800000
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_BASE_REGISTER_MASK 0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_BASE_REGISTER(_)  (((_) >> 23) & 0x0F)
     * [Bit 27] BaseReg invalid (0 = valid; 1 = invalid).
    UINT64 BaseRegisterInvalid                                     : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_BASE_REGISTER_INVALID_BIT 27
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_BASE_REGISTER_INVALID_FLAG 0x8000000
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_BASE_REGISTER_INVALID_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_BASE_REGISTER_INVALID(_) (((_) >> 27) & 0x01)
    UINT64 Reserved3                                               : 36;
  };
  UINT64 AsUInt;
} VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES;*/
return true
}

func (i *ia32)     * 3: scale by 8 ()(ok bool){//col:19471
/*     * 3: scale by 8 (used only on processors that support Intel 64 architecture)
     * Undefined for register instructions (bit 10 is set) and for memory instructions with no index register (bit 10 is clear
     * and bit 22 is set).
    UINT64 Scaling                                                 : 2;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_SCALING_BIT       0
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_SCALING_FLAG      0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_SCALING_MASK      0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_SCALING(_)        (((_) >> 0) & 0x03)
    UINT64 Reserved1                                               : 1;
     * [Bits 6:3] Reg1. Undefined for memory instructions (bit 10 is clear).
    UINT64 Register1                                               : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_REGISTER_1_BIT    3
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_REGISTER_1_FLAG   0x78
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_REGISTER_1_MASK   0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_REGISTER_1(_)     (((_) >> 3) & 0x0F)
     *
     * [Bits 9:7] 0: 16-bit
     * 1: 32-bit
     * 2: 64-bit (used only on processors that support Intel 64 architecture)
     * Other values not used. Undefined for register instructions (bit 10 is set).
    UINT64 AddressSize                                             : 3;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_ADDRESS_SIZE_BIT  7
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_ADDRESS_SIZE_FLAG 0x380
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_ADDRESS_SIZE_MASK 0x07
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_ADDRESS_SIZE(_)   (((_) >> 7) & 0x07)
     * [Bit 10] Mem/Reg (0 = memory; 1 = register).
    UINT64 MemoryRegister                                          : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_MEMORY_REGISTER_BIT 10
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_MEMORY_REGISTER_FLAG 0x400
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_MEMORY_REGISTER_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_MEMORY_REGISTER(_) (((_) >> 10) & 0x01)
    UINT64 Reserved2                                               : 4;
     *
     * [Bits 17:15] 0: ES
     * 1: CS
     * 2: SS
     * 3: DS
     * 4: FS
     * 5: GS
     * Other values not used. Undefined for register instructions (bit 10 is set).
    UINT64 SegmentRegister                                         : 3;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_SEGMENT_REGISTER_BIT 15
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_SEGMENT_REGISTER_FLAG 0x38000
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_SEGMENT_REGISTER_MASK 0x07
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_SEGMENT_REGISTER(_) (((_) >> 15) & 0x07)
     * [Bits 21:18] General-purpose register. Undefined for register instructions (bit 10 is set) and for memory instructions
     * with no index register (bit 10 is clear and bit 22 is set).
    UINT64 GeneralPurposeRegister                                  : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_GENERAL_PURPOSE_REGISTER_BIT 18
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_GENERAL_PURPOSE_REGISTER_FLAG 0x3C0000
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_GENERAL_PURPOSE_REGISTER_MASK 0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_GENERAL_PURPOSE_REGISTER(_) (((_) >> 18) & 0x0F)
     * [Bit 22] IndexReg invalid (0 = valid; 1 = invalid). Undefined for register instructions (bit 10 is set).
    UINT64 GeneralPurposeRegisterInvalid                           : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_GENERAL_PURPOSE_REGISTER_INVALID_BIT 22
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_GENERAL_PURPOSE_REGISTER_INVALID_FLAG 0x400000
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_GENERAL_PURPOSE_REGISTER_INVALID_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_GENERAL_PURPOSE_REGISTER_INVALID(_) (((_) >> 22) & 0x01)
     * [Bits 26:23] BaseReg (encoded as Reg1 above). Undefined for register instructions (bit 10 is set) and for memory
     * instructions with no base register (bit 10 is clear and bit 27 is set).
    UINT64 BaseRegister                                            : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_BASE_REGISTER_BIT 23
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_BASE_REGISTER_FLAG 0x7800000
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_BASE_REGISTER_MASK 0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_BASE_REGISTER(_)  (((_) >> 23) & 0x0F)
     * [Bit 27] BaseReg invalid (0 = valid; 1 = invalid).
    UINT64 BaseRegisterInvalid                                     : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_BASE_REGISTER_INVALID_BIT 27
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_BASE_REGISTER_INVALID_FLAG 0x8000000
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_BASE_REGISTER_INVALID_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_BASE_REGISTER_INVALID(_) (((_) >> 27) & 0x01)
     * [Bits 31:28] Reg2 (same encoding as IndexReg above).
    UINT64 Register2                                               : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_REGISTER_2_BIT    28
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_REGISTER_2_FLAG   0xF0000000
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_REGISTER_2_MASK   0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_REGISTER_2(_)     (((_) >> 28) & 0x0F)
    UINT64 Reserved3                                               : 32;
  };
  UINT64 AsUInt;
} VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE;*/
return true
}

func (i *ia32) *        ()(ok bool){//col:19582
/* *        (bits 11:8) are reserved in this VMCS field.
 *        - Bit 16 indicates an unusable segment. Attempts to use such a segment fault except in 64-bit mode. In general, a
 *        segment register is unusable if it has been loaded with a null selector.
 *        - Bits 31:17 are reserved
 *
 *       following a task switch that fails after its commit point. In contrast, the TR register is usable after processor reset
 *       despite having a null selector
typedef union
{
  struct
  {
     * [Bits 3:0] Segment type.
    UINT32 Type                                                    : 4;
#define VMX_SEGMENT_ACCESS_RIGHTS_TYPE_BIT                           0
#define VMX_SEGMENT_ACCESS_RIGHTS_TYPE_FLAG                          0x0F
#define VMX_SEGMENT_ACCESS_RIGHTS_TYPE_MASK                          0x0F
#define VMX_SEGMENT_ACCESS_RIGHTS_TYPE(_)                            (((_) >> 0) & 0x0F)
     * [Bit 4] S - Descriptor type (0 = system; 1 = code or data).
    UINT32 DescriptorType                                          : 1;
#define VMX_SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_TYPE_BIT                4
#define VMX_SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_TYPE_FLAG               0x10
#define VMX_SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_TYPE_MASK               0x01
#define VMX_SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_TYPE(_)                 (((_) >> 4) & 0x01)
     * [Bits 6:5] DPL - Descriptor privilege level.
    UINT32 DescriptorPrivilegeLevel                                : 2;
#define VMX_SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_PRIVILEGE_LEVEL_BIT     5
#define VMX_SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_PRIVILEGE_LEVEL_FLAG    0x60
#define VMX_SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_PRIVILEGE_LEVEL_MASK    0x03
#define VMX_SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_PRIVILEGE_LEVEL(_)      (((_) >> 5) & 0x03)
     * [Bit 7] P - Segment present.
    UINT32 Present                                                 : 1;
#define VMX_SEGMENT_ACCESS_RIGHTS_PRESENT_BIT                        7
#define VMX_SEGMENT_ACCESS_RIGHTS_PRESENT_FLAG                       0x80
#define VMX_SEGMENT_ACCESS_RIGHTS_PRESENT_MASK                       0x01
#define VMX_SEGMENT_ACCESS_RIGHTS_PRESENT(_)                         (((_) >> 7) & 0x01)
    UINT32 Reserved1                                               : 4;
     * [Bit 12] AVL - Available for use by system software.
    UINT32 AvailableBit                                            : 1;
#define VMX_SEGMENT_ACCESS_RIGHTS_AVAILABLE_BIT_BIT                  12
#define VMX_SEGMENT_ACCESS_RIGHTS_AVAILABLE_BIT_FLAG                 0x1000
#define VMX_SEGMENT_ACCESS_RIGHTS_AVAILABLE_BIT_MASK                 0x01
#define VMX_SEGMENT_ACCESS_RIGHTS_AVAILABLE_BIT(_)                   (((_) >> 12) & 0x01)
     * [Bit 13] Reserved (except for CS). L - 64-bit mode active (for CS only).
    UINT32 LongMode                                                : 1;
#define VMX_SEGMENT_ACCESS_RIGHTS_LONG_MODE_BIT                      13
#define VMX_SEGMENT_ACCESS_RIGHTS_LONG_MODE_FLAG                     0x2000
#define VMX_SEGMENT_ACCESS_RIGHTS_LONG_MODE_MASK                     0x01
#define VMX_SEGMENT_ACCESS_RIGHTS_LONG_MODE(_)                       (((_) >> 13) & 0x01)
     * [Bit 14] D/B - Default operation size (0 = 16-bit segment; 1 = 32-bit segment).
    UINT32 DefaultBig                                              : 1;
#define VMX_SEGMENT_ACCESS_RIGHTS_DEFAULT_BIG_BIT                    14
#define VMX_SEGMENT_ACCESS_RIGHTS_DEFAULT_BIG_FLAG                   0x4000
#define VMX_SEGMENT_ACCESS_RIGHTS_DEFAULT_BIG_MASK                   0x01
#define VMX_SEGMENT_ACCESS_RIGHTS_DEFAULT_BIG(_)                     (((_) >> 14) & 0x01)
     * [Bit 15] G - Granularity.
    UINT32 Granularity                                             : 1;
#define VMX_SEGMENT_ACCESS_RIGHTS_GRANULARITY_BIT                    15
#define VMX_SEGMENT_ACCESS_RIGHTS_GRANULARITY_FLAG                   0x8000
#define VMX_SEGMENT_ACCESS_RIGHTS_GRANULARITY_MASK                   0x01
#define VMX_SEGMENT_ACCESS_RIGHTS_GRANULARITY(_)                     (((_) >> 15) & 0x01)
     * [Bit 16] Segment unusable (0 = usable; 1 = unusable).
    UINT32 Unusable                                                : 1;
#define VMX_SEGMENT_ACCESS_RIGHTS_UNUSABLE_BIT                       16
#define VMX_SEGMENT_ACCESS_RIGHTS_UNUSABLE_FLAG                      0x10000
#define VMX_SEGMENT_ACCESS_RIGHTS_UNUSABLE_MASK                      0x01
#define VMX_SEGMENT_ACCESS_RIGHTS_UNUSABLE(_)                        (((_) >> 16) & 0x01)
    UINT32 Reserved2                                               : 15;
  };
  UINT32 AsUInt;
} VMX_SEGMENT_ACCESS_RIGHTS;*/
return true
}

func (i *ia32)#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_STI()(ok bool){//col:19661
/*#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_STI(_)                (((_) >> 0) & 0x01)
     * [Bit 1] Execution of a MOV to SS or a POP to SS blocks or suppresses certain debug exceptions as well as interrupts
     * (maskable and nonmaskable) on the instruction boundary following its execution. Setting this bit indicates that this
     * blocking is in effect. This document uses the term "blocking by MOV SS," but it applies equally to POP SS.
     *
    UINT32 BlockingByMovSs                                         : 1;
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_MOV_SS_BIT            1
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_MOV_SS_FLAG           0x02
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_MOV_SS_MASK           0x01
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_MOV_SS(_)             (((_) >> 1) & 0x01)
     * [Bit 2] System-management interrupts (SMIs) are disabled while the processor is in system-management mode (SMM). Setting
     * this bit indicates that blocking of SMIs is in effect.
     *
    UINT32 BlockingBySmi                                           : 1;
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_SMI_BIT               2
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_SMI_FLAG              0x04
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_SMI_MASK              0x01
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_SMI(_)                (((_) >> 2) & 0x01)
     * [Bit 3] Delivery of a non-maskable interrupt (NMI) or a system-management interrupt (SMI) blocks subsequent NMIs until
     * the next execution of IRET. Setting this bit indicates that blocking of NMIs is in effect. Clearing this bit does not
     * imply that NMIs are not (temporarily) blocked for other reasons. If the "virtual NMIs" VM-execution control is 1, this
     * bit does not control the blocking of NMIs. Instead, it refers to "virtual-NMI blocking" (the fact that guest software is
     * not ready for an NMI).
     *
    UINT32 BlockingByNmi                                           : 1;
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_NMI_BIT               3
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_NMI_FLAG              0x08
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_NMI_MASK              0x01
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_NMI(_)                (((_) >> 3) & 0x01)
     * [Bit 4] A VM exit saves this bit as 1 to indicate that the VM exit was incident to enclave mode.
    UINT32 EnclaveInterruption                                     : 1;
#define VMX_INTERRUPTIBILITY_STATE_ENCLAVE_INTERRUPTION_BIT          4
#define VMX_INTERRUPTIBILITY_STATE_ENCLAVE_INTERRUPTION_FLAG         0x10
#define VMX_INTERRUPTIBILITY_STATE_ENCLAVE_INTERRUPTION_MASK         0x01
#define VMX_INTERRUPTIBILITY_STATE_ENCLAVE_INTERRUPTION(_)           (((_) >> 4) & 0x01)
    UINT32 Reserved1                                               : 27;
  };
  UINT32 AsUInt;
} VMX_INTERRUPTIBILITY_STATE;*/
return true
}

func (i *ia32)   * The logical processor is inactive because it is waiting for a startup-IPI ()(ok bool){//col:19684
/*   * The logical processor is inactive because it is waiting for a startup-IPI (SIPI).
  VmxWaitForSipi                                               = 0x00000003,
} VMX_GUEST_ACTIVITY_STATE;*/
return true
}

func (i *ia32)#define VMX_PENDING_DEBUG_EXCEPTIONS_B0()(ok bool){//col:19770
/*#define VMX_PENDING_DEBUG_EXCEPTIONS_B0(_)                           (((_) >> 0) & 0x01)
     * [Bit 1] When set, indicates that the corresponding breakpoint condition was met. May be set even if the corresponding
     * enabling bit in DR7 is not set.
    UINT64 B1                                                      : 1;
#define VMX_PENDING_DEBUG_EXCEPTIONS_B1_BIT                          1
#define VMX_PENDING_DEBUG_EXCEPTIONS_B1_FLAG                         0x02
#define VMX_PENDING_DEBUG_EXCEPTIONS_B1_MASK                         0x01
#define VMX_PENDING_DEBUG_EXCEPTIONS_B1(_)                           (((_) >> 1) & 0x01)
     * [Bit 2] When set, indicates that the corresponding breakpoint condition was met. May be set even if the corresponding
     * enabling bit in DR7 is not set.
    UINT64 B2                                                      : 1;
#define VMX_PENDING_DEBUG_EXCEPTIONS_B2_BIT                          2
#define VMX_PENDING_DEBUG_EXCEPTIONS_B2_FLAG                         0x04
#define VMX_PENDING_DEBUG_EXCEPTIONS_B2_MASK                         0x01
#define VMX_PENDING_DEBUG_EXCEPTIONS_B2(_)                           (((_) >> 2) & 0x01)
     * [Bit 3] When set, indicates that the corresponding breakpoint condition was met. May be set even if the corresponding
     * enabling bit in DR7 is not set.
    UINT64 B3                                                      : 1;
#define VMX_PENDING_DEBUG_EXCEPTIONS_B3_BIT                          3
#define VMX_PENDING_DEBUG_EXCEPTIONS_B3_FLAG                         0x08
#define VMX_PENDING_DEBUG_EXCEPTIONS_B3_MASK                         0x01
#define VMX_PENDING_DEBUG_EXCEPTIONS_B3(_)                           (((_) >> 3) & 0x01)
    UINT64 Reserved1                                               : 8;
     * [Bit 12] When set, this bit indicates that at least one data or I/O breakpoint was met and was enabled in DR7.
    UINT64 EnabledBreakpoint                                       : 1;
#define VMX_PENDING_DEBUG_EXCEPTIONS_ENABLED_BREAKPOINT_BIT          12
#define VMX_PENDING_DEBUG_EXCEPTIONS_ENABLED_BREAKPOINT_FLAG         0x1000
#define VMX_PENDING_DEBUG_EXCEPTIONS_ENABLED_BREAKPOINT_MASK         0x01
#define VMX_PENDING_DEBUG_EXCEPTIONS_ENABLED_BREAKPOINT(_)           (((_) >> 12) & 0x01)
    UINT64 Reserved2                                               : 1;
     * [Bit 14] When set, this bit indicates that a debug exception would have been triggered by single-step execution mode.
    UINT64 Bs                                                      : 1;
#define VMX_PENDING_DEBUG_EXCEPTIONS_BS_BIT                          14
#define VMX_PENDING_DEBUG_EXCEPTIONS_BS_FLAG                         0x4000
#define VMX_PENDING_DEBUG_EXCEPTIONS_BS_MASK                         0x01
#define VMX_PENDING_DEBUG_EXCEPTIONS_BS(_)                           (((_) >> 14) & 0x01)
    UINT64 Reserved3                                               : 1;
     * [Bit 16] When set, this bit indicates that a debug exception (\#DB) or a breakpoint exception (\#BP) occurred inside an
     * RTM region while advanced debugging of RTM transactional regions was enabled.
    UINT64 Rtm                                                     : 1;
#define VMX_PENDING_DEBUG_EXCEPTIONS_RTM_BIT                         16
#define VMX_PENDING_DEBUG_EXCEPTIONS_RTM_FLAG                        0x10000
#define VMX_PENDING_DEBUG_EXCEPTIONS_RTM_MASK                        0x01
#define VMX_PENDING_DEBUG_EXCEPTIONS_RTM(_)                          (((_) >> 16) & 0x01)
    UINT64 Reserved4                                               : 47;
  };
  UINT64 AsUInt;
} VMX_PENDING_DEBUG_EXCEPTIONS;*/
return true
}

func (i *ia32) * Exit reason ()(ok bool){//col:19856
/* * Exit reason (32 bits). This field encodes the reason for the VM exit and has the structure.
 *
typedef union
{
  struct
  {
     * [Bits 15:0] Provides basic information about the cause of the VM exit (if bit 31 is clear) or of the VM-entry failure
     * (if bit 31 is set).
    UINT32 BasicExitReason                                         : 16;
#define VMX_VMEXIT_REASON_BASIC_EXIT_REASON_BIT                      0
#define VMX_VMEXIT_REASON_BASIC_EXIT_REASON_FLAG                     0xFFFF
#define VMX_VMEXIT_REASON_BASIC_EXIT_REASON_MASK                     0xFFFF
#define VMX_VMEXIT_REASON_BASIC_EXIT_REASON(_)                       (((_) >> 0) & 0xFFFF)
     * [Bit 16] Always cleared to 0.
    UINT32 Always0                                                 : 1;
#define VMX_VMEXIT_REASON_ALWAYS0_BIT                                16
#define VMX_VMEXIT_REASON_ALWAYS0_FLAG                               0x10000
#define VMX_VMEXIT_REASON_ALWAYS0_MASK                               0x01
#define VMX_VMEXIT_REASON_ALWAYS0(_)                                 (((_) >> 16) & 0x01)
    UINT32 Reserved1                                               : 10;
#define VMX_VMEXIT_REASON_RESERVED1_BIT                              17
#define VMX_VMEXIT_REASON_RESERVED1_FLAG                             0x7FE0000
#define VMX_VMEXIT_REASON_RESERVED1_MASK                             0x3FF
#define VMX_VMEXIT_REASON_RESERVED1(_)                               (((_) >> 17) & 0x3FF)
     * [Bit 27] A VM exit saves this bit as 1 to indicate that the VM exit was incident to enclave mode.
    UINT32 EnclaveMode                                             : 1;
#define VMX_VMEXIT_REASON_ENCLAVE_MODE_BIT                           27
#define VMX_VMEXIT_REASON_ENCLAVE_MODE_FLAG                          0x8000000
#define VMX_VMEXIT_REASON_ENCLAVE_MODE_MASK                          0x01
#define VMX_VMEXIT_REASON_ENCLAVE_MODE(_)                            (((_) >> 27) & 0x01)
     * [Bit 28] Pending MTF VM exit.
    UINT32 PendingMtfVmExit                                        : 1;
#define VMX_VMEXIT_REASON_PENDING_MTF_VM_EXIT_BIT                    28
#define VMX_VMEXIT_REASON_PENDING_MTF_VM_EXIT_FLAG                   0x10000000
#define VMX_VMEXIT_REASON_PENDING_MTF_VM_EXIT_MASK                   0x01
#define VMX_VMEXIT_REASON_PENDING_MTF_VM_EXIT(_)                     (((_) >> 28) & 0x01)
     * [Bit 29] VM exit from VMX root operation.
    UINT32 VmExitFromVmxRoot                                       : 1;
#define VMX_VMEXIT_REASON_VM_EXIT_FROM_VMX_ROOT_BIT                  29
#define VMX_VMEXIT_REASON_VM_EXIT_FROM_VMX_ROOT_FLAG                 0x20000000
#define VMX_VMEXIT_REASON_VM_EXIT_FROM_VMX_ROOT_MASK                 0x01
#define VMX_VMEXIT_REASON_VM_EXIT_FROM_VMX_ROOT(_)                   (((_) >> 29) & 0x01)
    UINT32 Reserved2                                               : 1;
#define VMX_VMEXIT_REASON_RESERVED2_BIT                              30
#define VMX_VMEXIT_REASON_RESERVED2_FLAG                             0x40000000
#define VMX_VMEXIT_REASON_RESERVED2_MASK                             0x01
#define VMX_VMEXIT_REASON_RESERVED2(_)                               (((_) >> 30) & 0x01)
     * [Bit 31] VM-entry failure:
     *   - 0 = true VM exit
     *   - 1 = VM-entry failure
    UINT32 VmEntryFailure                                          : 1;
#define VMX_VMEXIT_REASON_VM_ENTRY_FAILURE_BIT                       31
#define VMX_VMEXIT_REASON_VM_ENTRY_FAILURE_FLAG                      0x80000000
#define VMX_VMEXIT_REASON_VM_ENTRY_FAILURE_MASK                      0x01
#define VMX_VMEXIT_REASON_VM_ENTRY_FAILURE(_)                        (((_) >> 31) & 0x01)
  };
  UINT32 AsUInt;
} VMX_VMEXIT_REASON;*/
return true
}

func (i *ia32) * The extended page-table mechanism ()(ok bool){//col:19966
/* * The extended page-table mechanism (EPT) is a feature that can be used to support the virtualization of physical memory.
 * When EPT is in use, certain addresses that would normally be treated as physical addresses (and used to access memory)
 * are instead treated as guest-physical addresses. Guest-physical addresses are translated by traversing a set of EPT
 * paging structures to produce physical addresses that are used to access memory.
 *
 *
 * The extended-page-table pointer (EPTP) contains the address of the base of EPT PML4 table, as well as other EPT
 * configuration information.
 *
typedef union
{
  struct
  {
     * [Bits 2:0] EPT paging-structure memory type:
     * - 0 = Uncacheable (UC)
     * - 6 = Write-back (WB)
     * Other values are reserved.
     *
    UINT64 MemoryType                                              : 3;
#define EPT_POINTER_MEMORY_TYPE_BIT                                  0
#define EPT_POINTER_MEMORY_TYPE_FLAG                                 0x07
#define EPT_POINTER_MEMORY_TYPE_MASK                                 0x07
#define EPT_POINTER_MEMORY_TYPE(_)                                   (((_) >> 0) & 0x07)
     * [Bits 5:3] This value is 1 less than the EPT page-walk length.
     *
    UINT64 PageWalkLength                                          : 3;
#define EPT_POINTER_PAGE_WALK_LENGTH_BIT                             3
#define EPT_POINTER_PAGE_WALK_LENGTH_FLAG                            0x38
#define EPT_POINTER_PAGE_WALK_LENGTH_MASK                            0x07
#define EPT_POINTER_PAGE_WALK_LENGTH(_)                              (((_) >> 3) & 0x07)
#define EPT_PAGE_WALK_LENGTH_4                                       0x00000003
     * [Bit 6] Setting this control to 1 enables accessed and dirty flags for EPT.
     *
    UINT64 EnableAccessAndDirtyFlags                               : 1;
#define EPT_POINTER_ENABLE_ACCESS_AND_DIRTY_FLAGS_BIT                6
#define EPT_POINTER_ENABLE_ACCESS_AND_DIRTY_FLAGS_FLAG               0x40
#define EPT_POINTER_ENABLE_ACCESS_AND_DIRTY_FLAGS_MASK               0x01
#define EPT_POINTER_ENABLE_ACCESS_AND_DIRTY_FLAGS(_)                 (((_) >> 6) & 0x01)
     * [Bit 7] Setting this control to 1 enables enforcement of access rights for supervisor shadow-stack pages.
     *
    UINT64 EnableSupervisorShadowStackPages                        : 1;
#define EPT_POINTER_ENABLE_SUPERVISOR_SHADOW_STACK_PAGES_BIT         7
#define EPT_POINTER_ENABLE_SUPERVISOR_SHADOW_STACK_PAGES_FLAG        0x80
#define EPT_POINTER_ENABLE_SUPERVISOR_SHADOW_STACK_PAGES_MASK        0x01
#define EPT_POINTER_ENABLE_SUPERVISOR_SHADOW_STACK_PAGES(_)          (((_) >> 7) & 0x01)
    UINT64 Reserved1                                               : 4;
     * [Bits 47:12] Bits N-1:12 of the physical address of the 4-KByte aligned EPT PML4 table.
    UINT64 PageFrameNumber                                         : 36;
#define EPT_POINTER_PAGE_FRAME_NUMBER_BIT                            12
#define EPT_POINTER_PAGE_FRAME_NUMBER_FLAG                           0xFFFFFFFFF000
#define EPT_POINTER_PAGE_FRAME_NUMBER_MASK                           0xFFFFFFFFF
#define EPT_POINTER_PAGE_FRAME_NUMBER(_)                             (((_) >> 12) & 0xFFFFFFFFF)
    UINT64 Reserved2                                               : 16;
  };
  UINT64 AsUInt;
} EPT_POINTER;*/
return true
}

func (i *ia32) * extended-page-table pointer ()(ok bool){//col:20055
/* * extended-page-table pointer (EPTP), a VM-execution control field. An EPT PML4 table comprises 512 64-bit entries (EPT
 * PML4Es). An EPT PML4E is selected using the physical address defined as follows:
 * - Bits 63:52 are all 0.
 * - Bits 51:12 are from the EPTP.
 * - Bits 11:3 are bits 47:39 of the guest-physical address.
 * - Bits 2:0 are all 0.
 * Because an EPT PML4E is identified using bits 47:39 of the guest-physical address, it controls access to a 512- GByte
 * region of the guest-physical-address space.
 *
typedef union
{
  struct
  {
     * [Bit 0] Read access; indicates whether reads are allowed from the 512-GByte region controlled by this entry.
    UINT64 ReadAccess                                              : 1;
#define EPT_PML4E_READ_ACCESS_BIT                                    0
#define EPT_PML4E_READ_ACCESS_FLAG                                   0x01
#define EPT_PML4E_READ_ACCESS_MASK                                   0x01
#define EPT_PML4E_READ_ACCESS(_)                                     (((_) >> 0) & 0x01)
     * [Bit 1] Write access; indicates whether writes are allowed from the 512-GByte region controlled by this entry.
    UINT64 WriteAccess                                             : 1;
#define EPT_PML4E_WRITE_ACCESS_BIT                                   1
#define EPT_PML4E_WRITE_ACCESS_FLAG                                  0x02
#define EPT_PML4E_WRITE_ACCESS_MASK                                  0x01
#define EPT_PML4E_WRITE_ACCESS(_)                                    (((_) >> 1) & 0x01)
     * [Bit 2] If the "mode-based execute control for EPT" VM-execution control is 0, execute access; indicates whether
     * instruction fetches are allowed from the 512-GByte region controlled by this entry.
     * If that control is 1, execute access for supervisor-mode linear addresses; indicates whether instruction fetches are
     * allowed from supervisor-mode linear addresses in the 512-GByte region controlled by this entry.
    UINT64 ExecuteAccess                                           : 1;
#define EPT_PML4E_EXECUTE_ACCESS_BIT                                 2
#define EPT_PML4E_EXECUTE_ACCESS_FLAG                                0x04
#define EPT_PML4E_EXECUTE_ACCESS_MASK                                0x01
#define EPT_PML4E_EXECUTE_ACCESS(_)                                  (((_) >> 2) & 0x01)
    UINT64 Reserved1                                               : 5;
     * [Bit 8] If bit 6 of EPTP is 1, accessed flag for EPT; indicates whether software has accessed the 512-GByte region
     * controlled by this entry. Ignored if bit 6 of EPTP is 0.
     *
    UINT64 Accessed                                                : 1;
#define EPT_PML4E_ACCESSED_BIT                                       8
#define EPT_PML4E_ACCESSED_FLAG                                      0x100
#define EPT_PML4E_ACCESSED_MASK                                      0x01
#define EPT_PML4E_ACCESSED(_)                                        (((_) >> 8) & 0x01)
    UINT64 Reserved2                                               : 1;
     * [Bit 10] Execute access for user-mode linear addresses. If the "mode-based execute control for EPT" VM-execution control
     * is 1, indicates whether instruction fetches are allowed from user-mode linear addresses in the 512-GByte region
     * controlled by this entry. If that control is 0, this bit is ignored.
    UINT64 UserModeExecute                                         : 1;
#define EPT_PML4E_USER_MODE_EXECUTE_BIT                              10
#define EPT_PML4E_USER_MODE_EXECUTE_FLAG                             0x400
#define EPT_PML4E_USER_MODE_EXECUTE_MASK                             0x01
#define EPT_PML4E_USER_MODE_EXECUTE(_)                               (((_) >> 10) & 0x01)
    UINT64 Reserved3                                               : 1;
     * [Bits 47:12] Physical address of 4-KByte aligned EPT page-directory-pointer table referenced by this entry.
    UINT64 PageFrameNumber                                         : 36;
#define EPT_PML4E_PAGE_FRAME_NUMBER_BIT                              12
#define EPT_PML4E_PAGE_FRAME_NUMBER_FLAG                             0xFFFFFFFFF000
#define EPT_PML4E_PAGE_FRAME_NUMBER_MASK                             0xFFFFFFFFF
#define EPT_PML4E_PAGE_FRAME_NUMBER(_)                               (((_) >> 12) & 0xFFFFFFFFF)
    UINT64 Reserved4                                               : 16;
  };
  UINT64 AsUInt;
} EPT_PML4E;*/
return true
}

func (i *ia32)#define EPT_PDPTE_1GB_READ_ACCESS()(ok bool){//col:20225
/*#define EPT_PDPTE_1GB_READ_ACCESS(_)                                 (((_) >> 0) & 0x01)
     * [Bit 1] Write access; indicates whether writes are allowed from the 1-GByte page referenced by this entry.
    UINT64 WriteAccess                                             : 1;
#define EPT_PDPTE_1GB_WRITE_ACCESS_BIT                               1
#define EPT_PDPTE_1GB_WRITE_ACCESS_FLAG                              0x02
#define EPT_PDPTE_1GB_WRITE_ACCESS_MASK                              0x01
#define EPT_PDPTE_1GB_WRITE_ACCESS(_)                                (((_) >> 1) & 0x01)
     * [Bit 2] If the "mode-based execute control for EPT" VM-execution control is 0, execute access; indicates whether
     * instruction fetches are allowed from the 1-GByte page controlled by this entry.
     * If that control is 1, execute access for supervisor-mode linear addresses; indicates whether instruction fetches are
     * allowed from supervisor-mode linear addresses in the 1-GByte page controlled by this entry.
    UINT64 ExecuteAccess                                           : 1;
#define EPT_PDPTE_1GB_EXECUTE_ACCESS_BIT                             2
#define EPT_PDPTE_1GB_EXECUTE_ACCESS_FLAG                            0x04
#define EPT_PDPTE_1GB_EXECUTE_ACCESS_MASK                            0x01
#define EPT_PDPTE_1GB_EXECUTE_ACCESS(_)                              (((_) >> 2) & 0x01)
     * [Bits 5:3] EPT memory type for this 1-GByte page.
     *
    UINT64 MemoryType                                              : 3;
#define EPT_PDPTE_1GB_MEMORY_TYPE_BIT                                3
#define EPT_PDPTE_1GB_MEMORY_TYPE_FLAG                               0x38
#define EPT_PDPTE_1GB_MEMORY_TYPE_MASK                               0x07
#define EPT_PDPTE_1GB_MEMORY_TYPE(_)                                 (((_) >> 3) & 0x07)
     * [Bit 6] Ignore PAT memory type for this 1-GByte page.
     *
    UINT64 IgnorePat                                               : 1;
#define EPT_PDPTE_1GB_IGNORE_PAT_BIT                                 6
#define EPT_PDPTE_1GB_IGNORE_PAT_FLAG                                0x40
#define EPT_PDPTE_1GB_IGNORE_PAT_MASK                                0x01
#define EPT_PDPTE_1GB_IGNORE_PAT(_)                                  (((_) >> 6) & 0x01)
     * [Bit 7] Must be 1 (otherwise, this entry references an EPT page directory).
    UINT64 LargePage                                               : 1;
#define EPT_PDPTE_1GB_LARGE_PAGE_BIT                                 7
#define EPT_PDPTE_1GB_LARGE_PAGE_FLAG                                0x80
#define EPT_PDPTE_1GB_LARGE_PAGE_MASK                                0x01
#define EPT_PDPTE_1GB_LARGE_PAGE(_)                                  (((_) >> 7) & 0x01)
     * [Bit 8] If bit 6 of EPTP is 1, accessed flag for EPT; indicates whether software has accessed the 1-GByte page
     * referenced by this entry. Ignored if bit 6 of EPTP is 0.
     *
    UINT64 Accessed                                                : 1;
#define EPT_PDPTE_1GB_ACCESSED_BIT                                   8
#define EPT_PDPTE_1GB_ACCESSED_FLAG                                  0x100
#define EPT_PDPTE_1GB_ACCESSED_MASK                                  0x01
#define EPT_PDPTE_1GB_ACCESSED(_)                                    (((_) >> 8) & 0x01)
     * [Bit 9] If bit 6 of EPTP is 1, dirty flag for EPT; indicates whether software has written to the 1-GByte page referenced
     * by this entry. Ignored if bit 6 of EPTP is 0.
     *
    UINT64 Dirty                                                   : 1;
#define EPT_PDPTE_1GB_DIRTY_BIT                                      9
#define EPT_PDPTE_1GB_DIRTY_FLAG                                     0x200
#define EPT_PDPTE_1GB_DIRTY_MASK                                     0x01
#define EPT_PDPTE_1GB_DIRTY(_)                                       (((_) >> 9) & 0x01)
     * [Bit 10] Execute access for user-mode linear addresses. If the "mode-based execute control for EPT" VM-execution control
     * is 1, indicates whether instruction fetches are allowed from user-mode linear addresses in the 1-GByte page controlled
     * by this entry. If that control is 0, this bit is ignored.
    UINT64 UserModeExecute                                         : 1;
#define EPT_PDPTE_1GB_USER_MODE_EXECUTE_BIT                          10
#define EPT_PDPTE_1GB_USER_MODE_EXECUTE_FLAG                         0x400
#define EPT_PDPTE_1GB_USER_MODE_EXECUTE_MASK                         0x01
#define EPT_PDPTE_1GB_USER_MODE_EXECUTE(_)                           (((_) >> 10) & 0x01)
    UINT64 Reserved1                                               : 19;
     * [Bits 47:30] Physical address of 4-KByte aligned EPT page-directory-pointer table referenced by this entry.
    UINT64 PageFrameNumber                                         : 18;
#define EPT_PDPTE_1GB_PAGE_FRAME_NUMBER_BIT                          30
#define EPT_PDPTE_1GB_PAGE_FRAME_NUMBER_FLAG                         0xFFFFC0000000
#define EPT_PDPTE_1GB_PAGE_FRAME_NUMBER_MASK                         0x3FFFF
#define EPT_PDPTE_1GB_PAGE_FRAME_NUMBER(_)                           (((_) >> 30) & 0x3FFFF)
    UINT64 Reserved2                                               : 9;
     * [Bit 57] Verify guest paging. If the "guest-paging verification" VM-execution control is 1, indicates limits on the
     * guest paging structures used to access the 1-GByte page controlled by this entry (see Section 28.3.3.2). If that control
     * is 0, this bit is ignored.
     *
    UINT64 VerifyGuestPaging                                       : 1;
#define EPT_PDPTE_1GB_VERIFY_GUEST_PAGING_BIT                        57
#define EPT_PDPTE_1GB_VERIFY_GUEST_PAGING_FLAG                       0x200000000000000
#define EPT_PDPTE_1GB_VERIFY_GUEST_PAGING_MASK                       0x01
#define EPT_PDPTE_1GB_VERIFY_GUEST_PAGING(_)                         (((_) >> 57) & 0x01)
     * [Bit 58] Paging-write access. If the "EPT paging-write control" VM-execution control is 1, indicates that guest paging
     * may update the 1-GByte page controlled by this entry (see Section 28.3.3.2). If that control is 0, this bit is ignored
     *
    UINT64 PagingWriteAccess                                       : 1;
#define EPT_PDPTE_1GB_PAGING_WRITE_ACCESS_BIT                        58
#define EPT_PDPTE_1GB_PAGING_WRITE_ACCESS_FLAG                       0x400000000000000
#define EPT_PDPTE_1GB_PAGING_WRITE_ACCESS_MASK                       0x01
#define EPT_PDPTE_1GB_PAGING_WRITE_ACCESS(_)                         (((_) >> 58) & 0x01)
    UINT64 Reserved3                                               : 1;
     * [Bit 60] Supervisor shadow stack. If bit 7 of EPTP is 1, indicates whether supervisor shadow stack accesses are allowed
     * to guest-physical addresses in the 1-GByte page mapped by this entry (see Section 28.3.3.2)
     *
    UINT64 SupervisorShadowStack                                   : 1;
#define EPT_PDPTE_1GB_SUPERVISOR_SHADOW_STACK_BIT                    60
#define EPT_PDPTE_1GB_SUPERVISOR_SHADOW_STACK_FLAG                   0x1000000000000000
#define EPT_PDPTE_1GB_SUPERVISOR_SHADOW_STACK_MASK                   0x01
#define EPT_PDPTE_1GB_SUPERVISOR_SHADOW_STACK(_)                     (((_) >> 60) & 0x01)
    UINT64 Reserved4                                               : 2;
     * [Bit 63] Suppress \#VE. If the "EPT-violation \#VE" VM-execution control is 1, EPT violations caused by accesses to this
     * page are convertible to virtualization exceptions only if this bit is 0. If "EPT-violation \#VE" VMexecution control is
     * 0, this bit is ignored.
     *
    UINT64 SuppressVe                                              : 1;
#define EPT_PDPTE_1GB_SUPPRESS_VE_BIT                                63
#define EPT_PDPTE_1GB_SUPPRESS_VE_FLAG                               0x8000000000000000
#define EPT_PDPTE_1GB_SUPPRESS_VE_MASK                               0x01
#define EPT_PDPTE_1GB_SUPPRESS_VE(_)                                 (((_) >> 63) & 0x01)
  };
  UINT64 AsUInt;
} EPT_PDPTE_1GB;*/
return true
}

func (i *ia32)#define EPT_PDPTE_READ_ACCESS()(ok bool){//col:20302
/*#define EPT_PDPTE_READ_ACCESS(_)                                     (((_) >> 0) & 0x01)
     * [Bit 1] Write access; indicates whether writes are allowed from the 1-GByte region controlled by this entry.
    UINT64 WriteAccess                                             : 1;
#define EPT_PDPTE_WRITE_ACCESS_BIT                                   1
#define EPT_PDPTE_WRITE_ACCESS_FLAG                                  0x02
#define EPT_PDPTE_WRITE_ACCESS_MASK                                  0x01
#define EPT_PDPTE_WRITE_ACCESS(_)                                    (((_) >> 1) & 0x01)
     * [Bit 2] If the "mode-based execute control for EPT" VM-execution control is 0, execute access; indicates whether
     * instruction fetches are allowed from the 1-GByte region controlled by this entry.
     * If that control is 1, execute access for supervisor-mode linear addresses; indicates whether instruction fetches are
     * allowed from supervisor-mode linear addresses in the 1-GByte region controlled by this entry.
    UINT64 ExecuteAccess                                           : 1;
#define EPT_PDPTE_EXECUTE_ACCESS_BIT                                 2
#define EPT_PDPTE_EXECUTE_ACCESS_FLAG                                0x04
#define EPT_PDPTE_EXECUTE_ACCESS_MASK                                0x01
#define EPT_PDPTE_EXECUTE_ACCESS(_)                                  (((_) >> 2) & 0x01)
    UINT64 Reserved1                                               : 5;
     * [Bit 8] If bit 6 of EPTP is 1, accessed flag for EPT; indicates whether software has accessed the 1-GByte region
     * controlled by this entry. Ignored if bit 6 of EPTP is 0.
     *
    UINT64 Accessed                                                : 1;
#define EPT_PDPTE_ACCESSED_BIT                                       8
#define EPT_PDPTE_ACCESSED_FLAG                                      0x100
#define EPT_PDPTE_ACCESSED_MASK                                      0x01
#define EPT_PDPTE_ACCESSED(_)                                        (((_) >> 8) & 0x01)
    UINT64 Reserved2                                               : 1;
     * [Bit 10] Execute access for user-mode linear addresses. If the "mode-based execute control for EPT" VM-execution control
     * is 1, indicates whether instruction fetches are allowed from user-mode linear addresses in the 1-GByte region controlled
     * by this entry. If that control is 0, this bit is ignored.
    UINT64 UserModeExecute                                         : 1;
#define EPT_PDPTE_USER_MODE_EXECUTE_BIT                              10
#define EPT_PDPTE_USER_MODE_EXECUTE_FLAG                             0x400
#define EPT_PDPTE_USER_MODE_EXECUTE_MASK                             0x01
#define EPT_PDPTE_USER_MODE_EXECUTE(_)                               (((_) >> 10) & 0x01)
    UINT64 Reserved3                                               : 1;
     * [Bits 47:12] Physical address of 4-KByte aligned EPT page-directory-pointer table referenced by this entry.
    UINT64 PageFrameNumber                                         : 36;
#define EPT_PDPTE_PAGE_FRAME_NUMBER_BIT                              12
#define EPT_PDPTE_PAGE_FRAME_NUMBER_FLAG                             0xFFFFFFFFF000
#define EPT_PDPTE_PAGE_FRAME_NUMBER_MASK                             0xFFFFFFFFF
#define EPT_PDPTE_PAGE_FRAME_NUMBER(_)                               (((_) >> 12) & 0xFFFFFFFFF)
    UINT64 Reserved4                                               : 16;
  };
  UINT64 AsUInt;
} EPT_PDPTE;*/
return true
}

func (i *ia32)#define EPT_PDE_2MB_READ_ACCESS()(ok bool){//col:20472
/*#define EPT_PDE_2MB_READ_ACCESS(_)                                   (((_) >> 0) & 0x01)
     * [Bit 1] Write access; indicates whether writes are allowed from the 2-MByte page referenced by this entry.
    UINT64 WriteAccess                                             : 1;
#define EPT_PDE_2MB_WRITE_ACCESS_BIT                                 1
#define EPT_PDE_2MB_WRITE_ACCESS_FLAG                                0x02
#define EPT_PDE_2MB_WRITE_ACCESS_MASK                                0x01
#define EPT_PDE_2MB_WRITE_ACCESS(_)                                  (((_) >> 1) & 0x01)
     * [Bit 2] If the "mode-based execute control for EPT" VM-execution control is 0, execute access; indicates whether
     * instruction fetches are allowed from the 2-MByte page controlled by this entry.
     * If that control is 1, execute access for supervisor-mode linear addresses; indicates whether instruction fetches are
     * allowed from supervisor-mode linear addresses in the 2-MByte page controlled by this entry.
    UINT64 ExecuteAccess                                           : 1;
#define EPT_PDE_2MB_EXECUTE_ACCESS_BIT                               2
#define EPT_PDE_2MB_EXECUTE_ACCESS_FLAG                              0x04
#define EPT_PDE_2MB_EXECUTE_ACCESS_MASK                              0x01
#define EPT_PDE_2MB_EXECUTE_ACCESS(_)                                (((_) >> 2) & 0x01)
     * [Bits 5:3] EPT memory type for this 2-MByte page.
     *
    UINT64 MemoryType                                              : 3;
#define EPT_PDE_2MB_MEMORY_TYPE_BIT                                  3
#define EPT_PDE_2MB_MEMORY_TYPE_FLAG                                 0x38
#define EPT_PDE_2MB_MEMORY_TYPE_MASK                                 0x07
#define EPT_PDE_2MB_MEMORY_TYPE(_)                                   (((_) >> 3) & 0x07)
     * [Bit 6] Ignore PAT memory type for this 2-MByte page.
     *
    UINT64 IgnorePat                                               : 1;
#define EPT_PDE_2MB_IGNORE_PAT_BIT                                   6
#define EPT_PDE_2MB_IGNORE_PAT_FLAG                                  0x40
#define EPT_PDE_2MB_IGNORE_PAT_MASK                                  0x01
#define EPT_PDE_2MB_IGNORE_PAT(_)                                    (((_) >> 6) & 0x01)
     * [Bit 7] Must be 1 (otherwise, this entry references an EPT page table).
    UINT64 LargePage                                               : 1;
#define EPT_PDE_2MB_LARGE_PAGE_BIT                                   7
#define EPT_PDE_2MB_LARGE_PAGE_FLAG                                  0x80
#define EPT_PDE_2MB_LARGE_PAGE_MASK                                  0x01
#define EPT_PDE_2MB_LARGE_PAGE(_)                                    (((_) >> 7) & 0x01)
     * [Bit 8] If bit 6 of EPTP is 1, accessed flag for EPT; indicates whether software has accessed the 2-MByte page
     * referenced by this entry. Ignored if bit 6 of EPTP is 0.
     *
    UINT64 Accessed                                                : 1;
#define EPT_PDE_2MB_ACCESSED_BIT                                     8
#define EPT_PDE_2MB_ACCESSED_FLAG                                    0x100
#define EPT_PDE_2MB_ACCESSED_MASK                                    0x01
#define EPT_PDE_2MB_ACCESSED(_)                                      (((_) >> 8) & 0x01)
     * [Bit 9] If bit 6 of EPTP is 1, dirty flag for EPT; indicates whether software has written to the 2-MByte page referenced
     * by this entry. Ignored if bit 6 of EPTP is 0.
     *
    UINT64 Dirty                                                   : 1;
#define EPT_PDE_2MB_DIRTY_BIT                                        9
#define EPT_PDE_2MB_DIRTY_FLAG                                       0x200
#define EPT_PDE_2MB_DIRTY_MASK                                       0x01
#define EPT_PDE_2MB_DIRTY(_)                                         (((_) >> 9) & 0x01)
     * [Bit 10] Execute access for user-mode linear addresses. If the "mode-based execute control for EPT" VM-execution control
     * is 1, indicates whether instruction fetches are allowed from user-mode linear addresses in the 2-MByte page controlled
     * by this entry. If that control is 0, this bit is ignored.
    UINT64 UserModeExecute                                         : 1;
#define EPT_PDE_2MB_USER_MODE_EXECUTE_BIT                            10
#define EPT_PDE_2MB_USER_MODE_EXECUTE_FLAG                           0x400
#define EPT_PDE_2MB_USER_MODE_EXECUTE_MASK                           0x01
#define EPT_PDE_2MB_USER_MODE_EXECUTE(_)                             (((_) >> 10) & 0x01)
    UINT64 Reserved1                                               : 10;
     * [Bits 47:21] Physical address of 4-KByte aligned EPT page-directory-pointer table referenced by this entry.
    UINT64 PageFrameNumber                                         : 27;
#define EPT_PDE_2MB_PAGE_FRAME_NUMBER_BIT                            21
#define EPT_PDE_2MB_PAGE_FRAME_NUMBER_FLAG                           0xFFFFFFE00000
#define EPT_PDE_2MB_PAGE_FRAME_NUMBER_MASK                           0x7FFFFFF
#define EPT_PDE_2MB_PAGE_FRAME_NUMBER(_)                             (((_) >> 21) & 0x7FFFFFF)
    UINT64 Reserved2                                               : 9;
     * [Bit 57] Verify guest paging. If the "guest-paging verification" VM-execution control is 1, indicates limits on the
     * guest paging structures used to access the 2-MByte page controlled by this entry (see Section 28.3.3.2). If that control
     * is 0, this bit is ignored.
     *
    UINT64 VerifyGuestPaging                                       : 1;
#define EPT_PDE_2MB_VERIFY_GUEST_PAGING_BIT                          57
#define EPT_PDE_2MB_VERIFY_GUEST_PAGING_FLAG                         0x200000000000000
#define EPT_PDE_2MB_VERIFY_GUEST_PAGING_MASK                         0x01
#define EPT_PDE_2MB_VERIFY_GUEST_PAGING(_)                           (((_) >> 57) & 0x01)
     * [Bit 58] Paging-write access. If the "EPT paging-write control" VM-execution control is 1, indicates that guest paging
     * may update the 2-MByte page controlled by this entry (see Section 28.3.3.2). If that control is 0, this bit is ignored
     *
    UINT64 PagingWriteAccess                                       : 1;
#define EPT_PDE_2MB_PAGING_WRITE_ACCESS_BIT                          58
#define EPT_PDE_2MB_PAGING_WRITE_ACCESS_FLAG                         0x400000000000000
#define EPT_PDE_2MB_PAGING_WRITE_ACCESS_MASK                         0x01
#define EPT_PDE_2MB_PAGING_WRITE_ACCESS(_)                           (((_) >> 58) & 0x01)
    UINT64 Reserved3                                               : 1;
     * [Bit 60] Supervisor shadow stack. If bit 7 of EPTP is 1, indicates whether supervisor shadow stack accesses are allowed
     * to guest-physical addresses in the 2-MByte page mapped by this entry (see Section 28.3.3.2)
     *
    UINT64 SupervisorShadowStack                                   : 1;
#define EPT_PDE_2MB_SUPERVISOR_SHADOW_STACK_BIT                      60
#define EPT_PDE_2MB_SUPERVISOR_SHADOW_STACK_FLAG                     0x1000000000000000
#define EPT_PDE_2MB_SUPERVISOR_SHADOW_STACK_MASK                     0x01
#define EPT_PDE_2MB_SUPERVISOR_SHADOW_STACK(_)                       (((_) >> 60) & 0x01)
    UINT64 Reserved4                                               : 2;
     * [Bit 63] Suppress \#VE. If the "EPT-violation \#VE" VM-execution control is 1, EPT violations caused by accesses to this
     * page are convertible to virtualization exceptions only if this bit is 0. If "EPT-violation \#VE" VMexecution control is
     * 0, this bit is ignored.
     *
    UINT64 SuppressVe                                              : 1;
#define EPT_PDE_2MB_SUPPRESS_VE_BIT                                  63
#define EPT_PDE_2MB_SUPPRESS_VE_FLAG                                 0x8000000000000000
#define EPT_PDE_2MB_SUPPRESS_VE_MASK                                 0x01
#define EPT_PDE_2MB_SUPPRESS_VE(_)                                   (((_) >> 63) & 0x01)
  };
  UINT64 AsUInt;
} EPT_PDE_2MB;*/
return true
}

func (i *ia32)#define EPT_PDE_READ_ACCESS()(ok bool){//col:20549
/*#define EPT_PDE_READ_ACCESS(_)                                       (((_) >> 0) & 0x01)
     * [Bit 1] Write access; indicates whether writes are allowed from the 2-MByte region controlled by this entry.
    UINT64 WriteAccess                                             : 1;
#define EPT_PDE_WRITE_ACCESS_BIT                                     1
#define EPT_PDE_WRITE_ACCESS_FLAG                                    0x02
#define EPT_PDE_WRITE_ACCESS_MASK                                    0x01
#define EPT_PDE_WRITE_ACCESS(_)                                      (((_) >> 1) & 0x01)
     * [Bit 2] If the "mode-based execute control for EPT" VM-execution control is 0, execute access; indicates whether
     * instruction fetches are allowed from the 2-MByte region controlled by this entry.
     * If that control is 1, execute access for supervisor-mode linear addresses; indicates whether instruction fetches are
     * allowed from supervisor-mode linear addresses in the 2-MByte region controlled by this entry.
    UINT64 ExecuteAccess                                           : 1;
#define EPT_PDE_EXECUTE_ACCESS_BIT                                   2
#define EPT_PDE_EXECUTE_ACCESS_FLAG                                  0x04
#define EPT_PDE_EXECUTE_ACCESS_MASK                                  0x01
#define EPT_PDE_EXECUTE_ACCESS(_)                                    (((_) >> 2) & 0x01)
    UINT64 Reserved1                                               : 5;
     * [Bit 8] If bit 6 of EPTP is 1, accessed flag for EPT; indicates whether software has accessed the 2-MByte region
     * controlled by this entry. Ignored if bit 6 of EPTP is 0.
     *
    UINT64 Accessed                                                : 1;
#define EPT_PDE_ACCESSED_BIT                                         8
#define EPT_PDE_ACCESSED_FLAG                                        0x100
#define EPT_PDE_ACCESSED_MASK                                        0x01
#define EPT_PDE_ACCESSED(_)                                          (((_) >> 8) & 0x01)
    UINT64 Reserved2                                               : 1;
     * [Bit 10] Execute access for user-mode linear addresses. If the "mode-based execute control for EPT" VM-execution control
     * is 1, indicates whether instruction fetches are allowed from user-mode linear addresses in the 2-MByte region controlled
     * by this entry. If that control is 0, this bit is ignored.
    UINT64 UserModeExecute                                         : 1;
#define EPT_PDE_USER_MODE_EXECUTE_BIT                                10
#define EPT_PDE_USER_MODE_EXECUTE_FLAG                               0x400
#define EPT_PDE_USER_MODE_EXECUTE_MASK                               0x01
#define EPT_PDE_USER_MODE_EXECUTE(_)                                 (((_) >> 10) & 0x01)
    UINT64 Reserved3                                               : 1;
     * [Bits 47:12] Physical address of 4-KByte aligned EPT page table referenced by this entry.
    UINT64 PageFrameNumber                                         : 36;
#define EPT_PDE_PAGE_FRAME_NUMBER_BIT                                12
#define EPT_PDE_PAGE_FRAME_NUMBER_FLAG                               0xFFFFFFFFF000
#define EPT_PDE_PAGE_FRAME_NUMBER_MASK                               0xFFFFFFFFF
#define EPT_PDE_PAGE_FRAME_NUMBER(_)                                 (((_) >> 12) & 0xFFFFFFFFF)
    UINT64 Reserved4                                               : 16;
  };
  UINT64 AsUInt;
} EPT_PDE;*/
return true
}

func (i *ia32)#define EPT_PTE_READ_ACCESS()(ok bool){//col:20725
/*#define EPT_PTE_READ_ACCESS(_)                                       (((_) >> 0) & 0x01)
     * [Bit 1] Write access; indicates whether writes are allowed from the 4-KByte page referenced by this entry.
    UINT64 WriteAccess                                             : 1;
#define EPT_PTE_WRITE_ACCESS_BIT                                     1
#define EPT_PTE_WRITE_ACCESS_FLAG                                    0x02
#define EPT_PTE_WRITE_ACCESS_MASK                                    0x01
#define EPT_PTE_WRITE_ACCESS(_)                                      (((_) >> 1) & 0x01)
     * [Bit 2] If the "mode-based execute control for EPT" VM-execution control is 0, execute access; indicates whether
     * instruction fetches are allowed from the 4-KByte page controlled by this entry.
     * If that control is 1, execute access for supervisor-mode linear addresses; indicates whether instruction fetches are
     * allowed from supervisor-mode linear addresses in the 4-KByte page controlled by this entry.
    UINT64 ExecuteAccess                                           : 1;
#define EPT_PTE_EXECUTE_ACCESS_BIT                                   2
#define EPT_PTE_EXECUTE_ACCESS_FLAG                                  0x04
#define EPT_PTE_EXECUTE_ACCESS_MASK                                  0x01
#define EPT_PTE_EXECUTE_ACCESS(_)                                    (((_) >> 2) & 0x01)
     * [Bits 5:3] EPT memory type for this 4-KByte page.
     *
    UINT64 MemoryType                                              : 3;
#define EPT_PTE_MEMORY_TYPE_BIT                                      3
#define EPT_PTE_MEMORY_TYPE_FLAG                                     0x38
#define EPT_PTE_MEMORY_TYPE_MASK                                     0x07
#define EPT_PTE_MEMORY_TYPE(_)                                       (((_) >> 3) & 0x07)
     * [Bit 6] Ignore PAT memory type for this 4-KByte page.
     *
    UINT64 IgnorePat                                               : 1;
#define EPT_PTE_IGNORE_PAT_BIT                                       6
#define EPT_PTE_IGNORE_PAT_FLAG                                      0x40
#define EPT_PTE_IGNORE_PAT_MASK                                      0x01
#define EPT_PTE_IGNORE_PAT(_)                                        (((_) >> 6) & 0x01)
    UINT64 Reserved1                                               : 1;
     * [Bit 8] If bit 6 of EPTP is 1, accessed flag for EPT; indicates whether software has accessed the 4-KByte page
     * referenced by this entry. Ignored if bit 6 of EPTP is 0.
     *
    UINT64 Accessed                                                : 1;
#define EPT_PTE_ACCESSED_BIT                                         8
#define EPT_PTE_ACCESSED_FLAG                                        0x100
#define EPT_PTE_ACCESSED_MASK                                        0x01
#define EPT_PTE_ACCESSED(_)                                          (((_) >> 8) & 0x01)
     * [Bit 9] If bit 6 of EPTP is 1, dirty flag for EPT; indicates whether software has written to the 4-KByte page referenced
     * by this entry. Ignored if bit 6 of EPTP is 0.
     *
    UINT64 Dirty                                                   : 1;
#define EPT_PTE_DIRTY_BIT                                            9
#define EPT_PTE_DIRTY_FLAG                                           0x200
#define EPT_PTE_DIRTY_MASK                                           0x01
#define EPT_PTE_DIRTY(_)                                             (((_) >> 9) & 0x01)
     * [Bit 10] Execute access for user-mode linear addresses. If the "mode-based execute control for EPT" VM-execution control
     * is 1, indicates whether instruction fetches are allowed from user-mode linear addresses in the 4-KByte page controlled
     * by this entry. If that control is 0, this bit is ignored.
    UINT64 UserModeExecute                                         : 1;
#define EPT_PTE_USER_MODE_EXECUTE_BIT                                10
#define EPT_PTE_USER_MODE_EXECUTE_FLAG                               0x400
#define EPT_PTE_USER_MODE_EXECUTE_MASK                               0x01
#define EPT_PTE_USER_MODE_EXECUTE(_)                                 (((_) >> 10) & 0x01)
    UINT64 Reserved2                                               : 1;
     * [Bits 47:12] Physical address of the 4-KByte page referenced by this entry.
    UINT64 PageFrameNumber                                         : 36;
#define EPT_PTE_PAGE_FRAME_NUMBER_BIT                                12
#define EPT_PTE_PAGE_FRAME_NUMBER_FLAG                               0xFFFFFFFFF000
#define EPT_PTE_PAGE_FRAME_NUMBER_MASK                               0xFFFFFFFFF
#define EPT_PTE_PAGE_FRAME_NUMBER(_)                                 (((_) >> 12) & 0xFFFFFFFFF)
    UINT64 Reserved3                                               : 9;
     * [Bit 57] Verify guest paging. If the "guest-paging verification" VM-execution control is 1, indicates limits on the
     * guest paging structures used to access the 4-KByte page controlled by this entry (see Section 28.3.3.2). If that control
     * is 0, this bit is ignored.
     *
    UINT64 VerifyGuestPaging                                       : 1;
#define EPT_PTE_VERIFY_GUEST_PAGING_BIT                              57
#define EPT_PTE_VERIFY_GUEST_PAGING_FLAG                             0x200000000000000
#define EPT_PTE_VERIFY_GUEST_PAGING_MASK                             0x01
#define EPT_PTE_VERIFY_GUEST_PAGING(_)                               (((_) >> 57) & 0x01)
     * [Bit 58] Paging-write access. If the "EPT paging-write control" VM-execution control is 1, indicates that guest paging
     * may update the 4-KByte page controlled by this entry (see Section 28.3.3.2). If that control is 0, this bit is ignored
     *
    UINT64 PagingWriteAccess                                       : 1;
#define EPT_PTE_PAGING_WRITE_ACCESS_BIT                              58
#define EPT_PTE_PAGING_WRITE_ACCESS_FLAG                             0x400000000000000
#define EPT_PTE_PAGING_WRITE_ACCESS_MASK                             0x01
#define EPT_PTE_PAGING_WRITE_ACCESS(_)                               (((_) >> 58) & 0x01)
    UINT64 Reserved4                                               : 1;
     * [Bit 60] Supervisor shadow stack. If bit 7 of EPTP is 1, indicates whether supervisor shadow stack accesses are allowed
     * to guest-physical addresses in the 4-KByte page mapped by this entry (see Section 28.3.3.2)
     *
    UINT64 SupervisorShadowStack                                   : 1;
#define EPT_PTE_SUPERVISOR_SHADOW_STACK_BIT                          60
#define EPT_PTE_SUPERVISOR_SHADOW_STACK_FLAG                         0x1000000000000000
#define EPT_PTE_SUPERVISOR_SHADOW_STACK_MASK                         0x01
#define EPT_PTE_SUPERVISOR_SHADOW_STACK(_)                           (((_) >> 60) & 0x01)
     * [Bit 61] Sub-page write permissions. If the "sub-page write permissions for EPT" VM-execution control is 1, writes to
     * individual 128-byte regions of the 4-KByte page referenced by this entry may be allowed even if the page would normally
     * not be writable (see Section 28.3.4). If "sub-page write permissions for EPT" VM-execution control is 0, this bit is
     * ignored.
     *
    UINT64 SubPageWritePermissions                                 : 1;
#define EPT_PTE_SUB_PAGE_WRITE_PERMISSIONS_BIT                       61
#define EPT_PTE_SUB_PAGE_WRITE_PERMISSIONS_FLAG                      0x2000000000000000
#define EPT_PTE_SUB_PAGE_WRITE_PERMISSIONS_MASK                      0x01
#define EPT_PTE_SUB_PAGE_WRITE_PERMISSIONS(_)                        (((_) >> 61) & 0x01)
    UINT64 Reserved5                                               : 1;
     * [Bit 63] Suppress \#VE. If the "EPT-violation \#VE" VM-execution control is 1, EPT violations caused by accesses to this
     * page are convertible to virtualization exceptions only if this bit is 0. If "EPT-violation \#VE" VMexecution control is
     * 0, this bit is ignored.
     *
    UINT64 SuppressVe                                              : 1;
#define EPT_PTE_SUPPRESS_VE_BIT                                      63
#define EPT_PTE_SUPPRESS_VE_FLAG                                     0x8000000000000000
#define EPT_PTE_SUPPRESS_VE_MASK                                     0x01
#define EPT_PTE_SUPPRESS_VE(_)                                       (((_) >> 63) & 0x01)
  };
  UINT64 AsUInt;
} EPT_PTE;*/
return true
}

func (i *ia32)#define EPT_ENTRY_READ_ACCESS()(ok bool){//col:20794
/*#define EPT_ENTRY_READ_ACCESS(_)                                     (((_) >> 0) & 0x01)
    UINT64 WriteAccess                                             : 1;
#define EPT_ENTRY_WRITE_ACCESS_BIT                                   1
#define EPT_ENTRY_WRITE_ACCESS_FLAG                                  0x02
#define EPT_ENTRY_WRITE_ACCESS_MASK                                  0x01
#define EPT_ENTRY_WRITE_ACCESS(_)                                    (((_) >> 1) & 0x01)
    UINT64 ExecuteAccess                                           : 1;
#define EPT_ENTRY_EXECUTE_ACCESS_BIT                                 2
#define EPT_ENTRY_EXECUTE_ACCESS_FLAG                                0x04
#define EPT_ENTRY_EXECUTE_ACCESS_MASK                                0x01
#define EPT_ENTRY_EXECUTE_ACCESS(_)                                  (((_) >> 2) & 0x01)
    UINT64 MemoryType                                              : 3;
#define EPT_ENTRY_MEMORY_TYPE_BIT                                    3
#define EPT_ENTRY_MEMORY_TYPE_FLAG                                   0x38
#define EPT_ENTRY_MEMORY_TYPE_MASK                                   0x07
#define EPT_ENTRY_MEMORY_TYPE(_)                                     (((_) >> 3) & 0x07)
    UINT64 IgnorePat                                               : 1;
#define EPT_ENTRY_IGNORE_PAT_BIT                                     6
#define EPT_ENTRY_IGNORE_PAT_FLAG                                    0x40
#define EPT_ENTRY_IGNORE_PAT_MASK                                    0x01
#define EPT_ENTRY_IGNORE_PAT(_)                                      (((_) >> 6) & 0x01)
    UINT64 LargePage                                               : 1;
#define EPT_ENTRY_LARGE_PAGE_BIT                                     7
#define EPT_ENTRY_LARGE_PAGE_FLAG                                    0x80
#define EPT_ENTRY_LARGE_PAGE_MASK                                    0x01
#define EPT_ENTRY_LARGE_PAGE(_)                                      (((_) >> 7) & 0x01)
    UINT64 Accessed                                                : 1;
#define EPT_ENTRY_ACCESSED_BIT                                       8
#define EPT_ENTRY_ACCESSED_FLAG                                      0x100
#define EPT_ENTRY_ACCESSED_MASK                                      0x01
#define EPT_ENTRY_ACCESSED(_)                                        (((_) >> 8) & 0x01)
    UINT64 Dirty                                                   : 1;
#define EPT_ENTRY_DIRTY_BIT                                          9
#define EPT_ENTRY_DIRTY_FLAG                                         0x200
#define EPT_ENTRY_DIRTY_MASK                                         0x01
#define EPT_ENTRY_DIRTY(_)                                           (((_) >> 9) & 0x01)
    UINT64 UserModeExecute                                         : 1;
#define EPT_ENTRY_USER_MODE_EXECUTE_BIT                              10
#define EPT_ENTRY_USER_MODE_EXECUTE_FLAG                             0x400
#define EPT_ENTRY_USER_MODE_EXECUTE_MASK                             0x01
#define EPT_ENTRY_USER_MODE_EXECUTE(_)                               (((_) >> 10) & 0x01)
    UINT64 Reserved1                                               : 1;
    UINT64 PageFrameNumber                                         : 36;
#define EPT_ENTRY_PAGE_FRAME_NUMBER_BIT                              12
#define EPT_ENTRY_PAGE_FRAME_NUMBER_FLAG                             0xFFFFFFFFF000
#define EPT_ENTRY_PAGE_FRAME_NUMBER_MASK                             0xFFFFFFFFF
#define EPT_ENTRY_PAGE_FRAME_NUMBER(_)                               (((_) >> 12) & 0xFFFFFFFFF)
    UINT64 Reserved2                                               : 15;
    UINT64 SuppressVe                                              : 1;
#define EPT_ENTRY_SUPPRESS_VE_BIT                                    63
#define EPT_ENTRY_SUPPRESS_VE_FLAG                                   0x8000000000000000
#define EPT_ENTRY_SUPPRESS_VE_MASK                                   0x01
#define EPT_ENTRY_SUPPRESS_VE(_)                                     (((_) >> 63) & 0x01)
  };
  UINT64 AsUInt;
} EPT_ENTRY;*/
return true
}

func (i *ia32)   * all PCIDs. ()(ok bool){//col:20844
/*   * all PCIDs. (The instruction may invalidate mappings associated with other EP4TAs.)
  InveptSingleContext                                          = 0x00000001,
   * If the INVEPT type is 2, the logical processor invalidates guest-physical mappings and combined mappings associated with
   * all EP4TAs (and, for combined mappings, for all VPIDs and PCIDs).
  InveptAllContext                                             = 0x00000002,
} INVEPT_TYPE;*/
return true
}

func (i *ia32)   * and, for combined mappings, all EP4TAs. ()(ok bool){//col:20882
/*   * and, for combined mappings, all EP4TAs. (The instruction may also invalidate mappings associated with other VPIDs and
   * for other linear addresses).
  InvvpidIndividualAddress                                     = 0x00000000,
   * If the INVVPID type is 1, the logical processor invalidates all linear mappings and combined mappings associated with
   * the VPID specified in the INVVPID descriptor. Linear mappings and combined mappings for that VPID are invalidated for
   * all PCIDs and, for combined mappings, all EP4TAs. (The instruction may also invalidate mappings associated with other
   * VPIDs).
  InvvpidSingleContext                                         = 0x00000001,
   * If the INVVPID type is 2, the logical processor invalidates linear mappings and combined mappings associated with all
   * VPIDs except VPID 0000H and with all PCIDs. (The instruction may also invalidate linear mappings with VPID 0000H.)
   * Combined mappings are invalidated for all EP4TAs.
  InvvpidAllContext                                            = 0x00000002,
   * If the INVVPID type is 3, the logical processor invalidates linear mappings and combined mappings associated with the
   * VPID specified in the INVVPID descriptor. Linear mappings and combined mappings for that VPID are invalidated for all
   * PCIDs and, for combined mappings, all EP4TAs. The logical processor is not required to invalidate information that was
   * used for global translations (although it may do so). (The instruction may also invalidate mappings associated with
   * other VPIDs).
   *
  InvvpidSingleContextRetainingGlobals                         = 0x00000003,
} INVVPID_TYPE;*/
return true
}

func (i *ia32) * The hypervisor-managed linear-address translation pointer ()(ok bool){//col:20957
/* * The hypervisor-managed linear-address translation pointer (HLAT pointer or HLATP) is used by HLAT paging to locate and
 * access the first paging structure used for linear-address translation.
 *
typedef union
{
  struct
  {
    UINT64 Reserved1                                               : 3;
     * [Bit 3] Page-level write-through; indirectly determines the memory type used to access the first HLAT paging structure
     * during linear-address translation.
    UINT64 PageLevelWriteThrough                                   : 1;
#define HLAT_POINTER_PAGE_LEVEL_WRITE_THROUGH_BIT                    3
#define HLAT_POINTER_PAGE_LEVEL_WRITE_THROUGH_FLAG                   0x08
#define HLAT_POINTER_PAGE_LEVEL_WRITE_THROUGH_MASK                   0x01
#define HLAT_POINTER_PAGE_LEVEL_WRITE_THROUGH(_)                     (((_) >> 3) & 0x01)
     * [Bit 4] Page-level cache disable; indirectly determines the memory type used to access the first HLAT paging structure
     * during linear-address translation.
    UINT64 PageLevelCacheDisable                                   : 1;
#define HLAT_POINTER_PAGE_LEVEL_CACHE_DISABLE_BIT                    4
#define HLAT_POINTER_PAGE_LEVEL_CACHE_DISABLE_FLAG                   0x10
#define HLAT_POINTER_PAGE_LEVEL_CACHE_DISABLE_MASK                   0x01
#define HLAT_POINTER_PAGE_LEVEL_CACHE_DISABLE(_)                     (((_) >> 4) & 0x01)
    UINT64 Reserved2                                               : 7;
     * [Bits 47:12] Guest-physical address (4KB-aligned) of the first HLAT paging structure during linear-address translation)
    UINT64 PageFrameNumber                                         : 36;
#define HLAT_POINTER_PAGE_FRAME_NUMBER_BIT                           12
#define HLAT_POINTER_PAGE_FRAME_NUMBER_FLAG                          0xFFFFFFFFF000
#define HLAT_POINTER_PAGE_FRAME_NUMBER_MASK                          0xFFFFFFFFF
#define HLAT_POINTER_PAGE_FRAME_NUMBER(_)                            (((_) >> 12) & 0xFFFFFFFFF)
    UINT64 Reserved3                                               : 16;
  };
  UINT64 AsUInt;
} HLAT_POINTER;*/
return true
}

func (i *ia32) * A logical processor uses virtual-machine control data structures ()(ok bool){//col:21027
/* * A logical processor uses virtual-machine control data structures (VMCSs) while it is in VMX operation. These manage
 * transitions into and out of VMX non-root operation (VM entries and VM exits) as well as processor behavior in VMX
 * non-root operation. This structure is manipulated by the new instructions VMCLEAR, VMPTRLD, VMREAD, and VMWRITE.
 * A VMCS region comprises up to 4-KBytes. The exact size is implementation specific and can be determined by consulting
 * the VMX capability MSR IA32_VMX_BASIC.
 *
typedef struct
{
  struct
  {
     *
     * [Bits 30:0] Processors that maintain VMCS data in different formats (see below) use different VMCS revision identifiers.
     * These identifiers enable software to avoid using a VMCS region formatted for one processor on a processor that uses a
     * different format.
     * Software should write the VMCS revision identifier to the VMCS region before using that region for a VMCS. The VMCS
     * revision identifier is never written by the processor; VMPTRLD fails if its operand references a VMCS region whose VMCS
     * revision identifier differs from that used by the processor.
     * Software can discover the VMCS revision identifier that a processor uses by reading the VMX capability MSR
     * IA32_VMX_BASIC.
     *
    UINT32 RevisionId                                              : 31;
     *
     * [Bit 31] Software should clear or set the shadow-VMCS indicator depending on whether the VMCS is to be an ordinary VMCS
     * or a shadow VMCS. VMPTRLD fails if the shadow-VMCS indicator is set and the processor does not support the 1-setting of
     * the "VMCS shadowing" VM-execution control. Software can discover support for this setting by reading the VMX capability
     * MSR IA32_VMX_PROCBASED_CTLS2.
     *
    UINT32 ShadowVmcsIndicator                                     : 1;
  };
   *
   * The contents of these bits do not control processor operation in any way. A logical processor writes a non-zero value
   * into these bits if a VMX abort occurs. Software may also write into this field.
   *
  UINT32 AbortIndicator;
   *
   * These parts of the VMCS control VMX non-root operation and the VMX transitions.
   * The format of these data is implementation-specific. To ensure proper behavior in VMX operation, software should
   * maintain the VMCS region and related structures in writeback cacheable memory. Future implementations may allow or
   * require a different memory type. Software should consult the VMX capability MSR IA32_VMX_BASIC.
   *
  UINT8 Data[4088];
} VMCS;*/
return true
}

func (i *ia32)     * ()(ok bool){//col:21074
/*     * (Specifically, it should write the 31-bit VMCS revision identifier to bits 30:0 of the first 4 bytes of the VMXON
     * region; bit 31 should be cleared to 0.)
     *
    UINT32 RevisionId                                              : 31;
     * [Bit 31] Bit 31 is always 0.
    UINT32 MustBeZero                                              : 1;
  };
   *
   * The format of these data is implementation-specific. To ensure proper behavior in VMX operation, software should not
   * access or modify the VMXON region of a logical processor between execution of VMXON and VMXOFF on that logical
   * processor. Doing otherwise may lead to unpredictable behavior.
   *
  UINT8 Data[4092];
} VMXON;*/
return true
}

func (i *ia32) *           VMCS ()(ok bool){//col:21147
/* *           VMCS (VM Control Structure)
 *
 * Every component of the VMCS is encoded by a 32-bit field that can be used by VMREAD and VMWRITE. This enumerates all
 * fields in the VMCS and their encodings. Fields are grouped by width (16-bit, 32-bit, etc.) and type (guest-state,
 * host-state, etc.).
 *
typedef union
{
  struct
  {
     * [Bit 0] Access type (0 = full; 1 = high); must be full for 16-bit, 32-bit, and natural-width fields.
    UINT16 AccessType                                              : 1;
#define VMCS_COMPONENT_ENCODING_ACCESS_TYPE_BIT                      0
#define VMCS_COMPONENT_ENCODING_ACCESS_TYPE_FLAG                     0x01
#define VMCS_COMPONENT_ENCODING_ACCESS_TYPE_MASK                     0x01
#define VMCS_COMPONENT_ENCODING_ACCESS_TYPE(_)                       (((_) >> 0) & 0x01)
     * [Bits 9:1] Index.
    UINT16 Index                                                   : 9;
#define VMCS_COMPONENT_ENCODING_INDEX_BIT                            1
#define VMCS_COMPONENT_ENCODING_INDEX_FLAG                           0x3FE
#define VMCS_COMPONENT_ENCODING_INDEX_MASK                           0x1FF
#define VMCS_COMPONENT_ENCODING_INDEX(_)                             (((_) >> 1) & 0x1FF)
     * [Bits 11:10] Type:
     * 0: control
     * 1: VM-exit information
     * 2: guest state
     * 3: host state
    UINT16 Type                                                    : 2;
#define VMCS_COMPONENT_ENCODING_TYPE_BIT                             10
#define VMCS_COMPONENT_ENCODING_TYPE_FLAG                            0xC00
#define VMCS_COMPONENT_ENCODING_TYPE_MASK                            0x03
#define VMCS_COMPONENT_ENCODING_TYPE(_)                              (((_) >> 10) & 0x03)
     * [Bit 12] Reserved (must be 0).
    UINT16 MustBeZero                                              : 1;
#define VMCS_COMPONENT_ENCODING_MUST_BE_ZERO_BIT                     12
#define VMCS_COMPONENT_ENCODING_MUST_BE_ZERO_FLAG                    0x1000
#define VMCS_COMPONENT_ENCODING_MUST_BE_ZERO_MASK                    0x01
#define VMCS_COMPONENT_ENCODING_MUST_BE_ZERO(_)                      (((_) >> 12) & 0x01)
     * [Bits 14:13] Width:
     * 0: 16-bit
     * 1: 64-bit
     * 2: 32-bit
     * 3: natural-width
    UINT16 Width                                                   : 2;
#define VMCS_COMPONENT_ENCODING_WIDTH_BIT                            13
#define VMCS_COMPONENT_ENCODING_WIDTH_FLAG                           0x6000
#define VMCS_COMPONENT_ENCODING_WIDTH_MASK                           0x03
#define VMCS_COMPONENT_ENCODING_WIDTH(_)                             (((_) >> 13) & 0x03)
    UINT16 Reserved1                                               : 1;
  };
  UINT16 AsUInt;
} VMCS_COMPONENT_ENCODING;*/
return true
}

func (i *ia32) * Virtual-processor identifier ()(ok bool){//col:22264
/* * Virtual-processor identifier (VPID).
 *
#define VMCS_CTRL_VIRTUAL_PROCESSOR_IDENTIFIER                       0x00000000
 * Posted-interrupt notification vector.
 *
 *          control.
#define VMCS_CTRL_POSTED_INTERRUPT_NOTIFICATION_VECTOR               0x00000002
 * EPTP index.
 *
 *          control.
#define VMCS_CTRL_EPTP_INDEX                                         0x00000004
 * HLAT prefix size.
 *
#define VMCS_CTRL_HLAT_PREFIX_SIZE                                   0x00000006
 *           16-Bit Guest-State Fields
 *
 * 16-Bit Guest-State Fields.
 * Guest ES selector.
#define VMCS_GUEST_ES_SELECTOR                                       0x00000800
 * Guest CS selector.
#define VMCS_GUEST_CS_SELECTOR                                       0x00000802
 * Guest SS selector.
#define VMCS_GUEST_SS_SELECTOR                                       0x00000804
 * Guest DS selector.
#define VMCS_GUEST_DS_SELECTOR                                       0x00000806
 * Guest FS selector.
#define VMCS_GUEST_FS_SELECTOR                                       0x00000808
 * Guest GS selector.
#define VMCS_GUEST_GS_SELECTOR                                       0x0000080A
 * Guest LDTR selector.
#define VMCS_GUEST_LDTR_SELECTOR                                     0x0000080C
 * Guest TR selector.
#define VMCS_GUEST_TR_SELECTOR                                       0x0000080E
 * Guest interrupt status.
 *
 *          VM-execution control.
#define VMCS_GUEST_INTERRUPT_STATUS                                  0x00000810
 * PML index.
 *
#define VMCS_GUEST_PML_INDEX                                         0x00000812
 *           16-Bit Host-State Fields
 *
 * 16-Bit Host-State Fields.
 * Host ES selector.
#define VMCS_HOST_ES_SELECTOR                                        0x00000C00
 * Host CS selector.
#define VMCS_HOST_CS_SELECTOR                                        0x00000C02
 * Host SS selector.
#define VMCS_HOST_SS_SELECTOR                                        0x00000C04
 * Host DS selector.
#define VMCS_HOST_DS_SELECTOR                                        0x00000C06
 * Host FS selector.
#define VMCS_HOST_FS_SELECTOR                                        0x00000C08
 * Host GS selector.
#define VMCS_HOST_GS_SELECTOR                                        0x00000C0A
 * Host TR selector.
#define VMCS_HOST_TR_SELECTOR                                        0x00000C0C
 *           64-Bit Fields
 *
 * 64-Bit Fields.
 *
 *           64-Bit Control Fields
 *
 * 64-Bit Control Fields.
 * Address of I/O bitmap A.
#define VMCS_CTRL_IO_BITMAP_A_ADDRESS                                0x00002000
 * Address of I/O bitmap B.
#define VMCS_CTRL_IO_BITMAP_B_ADDRESS                                0x00002002
 * Address of MSR bitmaps.
#define VMCS_CTRL_MSR_BITMAP_ADDRESS                                 0x00002004
 * VM-exit MSR-store address.
#define VMCS_CTRL_VMEXIT_MSR_STORE_ADDRESS                           0x00002006
 * VM-exit MSR-load address.
#define VMCS_CTRL_VMEXIT_MSR_LOAD_ADDRESS                            0x00002008
 * VM-entry MSR-load address.
#define VMCS_CTRL_VMENTRY_MSR_LOAD_ADDRESS                           0x0000200A
 * Executive-VMCS pointer.
#define VMCS_CTRL_EXECUTIVE_VMCS_POINTER                             0x0000200C
 * PML address.
#define VMCS_CTRL_PML_ADDRESS                                        0x0000200E
 * TSC offset.
#define VMCS_CTRL_TSC_OFFSET                                         0x00002010
 * Virtual-APIC address.
#define VMCS_CTRL_VIRTUAL_APIC_ADDRESS                               0x00002012
 * APIC-access address.
#define VMCS_CTRL_APIC_ACCESS_ADDRESS                                0x00002014
 * Posted-interrupt descriptor address
#define VMCS_CTRL_POSTED_INTERRUPT_DESCRIPTOR_ADDRESS                0x00002016
 * VM-function controls.
#define VMCS_CTRL_VMFUNC_CONTROLS                                    0x00002018
 * EPT pointer.
#define VMCS_CTRL_EPT_POINTER                                        0x0000201A
 * EOI-exit bitmap 0.
#define VMCS_CTRL_EOI_EXIT_BITMAP_0                                  0x0000201C
 * EOI-exit bitmap 1.
#define VMCS_CTRL_EOI_EXIT_BITMAP_1                                  0x0000201E
 * EOI-exit bitmap 2.
#define VMCS_CTRL_EOI_EXIT_BITMAP_2                                  0x00002020
 * EOI-exit bitmap 3.
#define VMCS_CTRL_EOI_EXIT_BITMAP_3                                  0x00002022
 * EPTP-list address.
#define VMCS_CTRL_EPT_POINTER_LIST_ADDRESS                           0x00002024
 * VMREAD-bitmap address.
#define VMCS_CTRL_VMREAD_BITMAP_ADDRESS                              0x00002026
 * VMWRITE-bitmap address.
#define VMCS_CTRL_VMWRITE_BITMAP_ADDRESS                             0x00002028
 * Virtualization-exception information address.
#define VMCS_CTRL_VIRTUALIZATION_EXCEPTION_INFORMATION_ADDRESS       0x0000202A
 * XSS-exiting bitmap.
#define VMCS_CTRL_XSS_EXITING_BITMAP                                 0x0000202C
 * ENCLS-exiting bitmap.
#define VMCS_CTRL_ENCLS_EXITING_BITMAP                               0x0000202E
 * Sub-page-permission-table pointer.
#define VMCS_CTRL_SUB_PAGE_PERMISSION_TABLE_POINTER                  0x00002030
 * TSC multiplier.
#define VMCS_CTRL_TSC_MULTIPLIER                                     0x00002032
 * Tertiary processor-based VM-execution controls.
#define VMCS_CTRL_TERTIARY_PROCESSOR_BASED_VM_EXECUTION_CONTROLS     0x00002034
 * ENCLV-exiting bitmap.
#define VMCS_CTRL_ENCLV_EXITING_BITMAP                               0x00002036
 * Hypervisor-managed linear-address translation pointer.
#define VMCS_CTRL_HLAT_POINTER                                       0x00002040
 * Secondary VM-exit controls.
#define VMCS_CTRL_SECONDARY_VMEXIT_CONTROLS                          0x00002044
 *           64-Bit Read-Only Data Field
 *
 * 64-Bit Read-Only Data Field.
 * Guest-physical address.
#define VMCS_GUEST_PHYSICAL_ADDRESS                                  0x00002400
 *           64-Bit Guest-State Fields
 *
 * 64-Bit Guest-State Fields.
 * VMCS link pointer.
#define VMCS_GUEST_VMCS_LINK_POINTER                                 0x00002800
 * Guest IA32_DEBUGCTL.
#define VMCS_GUEST_DEBUGCTL                                          0x00002802
 * Guest IA32_PAT.
#define VMCS_GUEST_PAT                                               0x00002804
 * Guest IA32_EFER.
#define VMCS_GUEST_EFER                                              0x00002806
 * Guest IA32_PERF_GLOBAL_CTRL.
#define VMCS_GUEST_PERF_GLOBAL_CTRL                                  0x00002808
 * Guest PDPTE0.
#define VMCS_GUEST_PDPTE0                                            0x0000280A
 * Guest PDPTE1.
#define VMCS_GUEST_PDPTE1                                            0x0000280C
 * Guest PDPTE2.
#define VMCS_GUEST_PDPTE2                                            0x0000280E
 * Guest PDPTE3.
#define VMCS_GUEST_PDPTE3                                            0x00002810
 * Guest IA32_BNDCFGS.
#define VMCS_GUEST_BNDCFGS                                           0x00002812
 * Guest IA32_RTIT_CTL.
#define VMCS_GUEST_RTIT_CTL                                          0x00002814
 * Guest IA32_LBR_CTL.
#define VMCS_GUEST_LBR_CTL                                           0x00002816
 * Guest IA32_PKRS
#define VMCS_GUEST_PKRS                                              0x00002818
 *           64-Bit Host-State Fields
 *
 * 64-Bit Host-State Fields.
 * Host IA32_PAT.
#define VMCS_HOST_PAT                                                0x00002C00
 * Host IA32_EFER.
#define VMCS_HOST_EFER                                               0x00002C02
 * Host IA32_PERF_GLOBAL_CTRL.
#define VMCS_HOST_PERF_GLOBAL_CTRL                                   0x00002C04
 * Host IA32_PKRS
#define VMCS_HOST_PKRS                                               0x00002C06
 *           32-Bit Fields
 *
 * 32-Bit Fields.
 *
 *           32-Bit Control Fields
 *
 * 32-Bit Control Fields.
 * Pin-based VM-execution controls.
#define VMCS_CTRL_PIN_BASED_VM_EXECUTION_CONTROLS                    0x00004000
 * Primary processor-based VM-execution controls.
#define VMCS_CTRL_PROCESSOR_BASED_VM_EXECUTION_CONTROLS              0x00004002
 * Exception bitmap.
#define VMCS_CTRL_EXCEPTION_BITMAP                                   0x00004004
 * Page-fault error-code mask.
#define VMCS_CTRL_PAGEFAULT_ERROR_CODE_MASK                          0x00004006
 * Page-fault error-code match.
#define VMCS_CTRL_PAGEFAULT_ERROR_CODE_MATCH                         0x00004008
 * CR3-target count.
#define VMCS_CTRL_CR3_TARGET_COUNT                                   0x0000400A
 * Primary VM-exit controls.
#define VMCS_CTRL_PRIMARY_VMEXIT_CONTROLS                            0x0000400C
 * VM-exit MSR-store count.
#define VMCS_CTRL_VMEXIT_MSR_STORE_COUNT                             0x0000400E
 * VM-exit MSR-load count.
#define VMCS_CTRL_VMEXIT_MSR_LOAD_COUNT                              0x00004010
 * VM-entry controls.
#define VMCS_CTRL_VMENTRY_CONTROLS                                   0x00004012
 * VM-entry MSR-load count.
#define VMCS_CTRL_VMENTRY_MSR_LOAD_COUNT                             0x00004014
 * VM-entry interruption-information field.
#define VMCS_CTRL_VMENTRY_INTERRUPTION_INFORMATION_FIELD             0x00004016
 * VM-entry exception error code.
#define VMCS_CTRL_VMENTRY_EXCEPTION_ERROR_CODE                       0x00004018
 * VM-entry instruction length.
#define VMCS_CTRL_VMENTRY_INSTRUCTION_LENGTH                         0x0000401A
 * TPR threshold.
#define VMCS_CTRL_TPR_THRESHOLD                                      0x0000401C
 * Secondary processor-based VM-execution controls.
#define VMCS_CTRL_SECONDARY_PROCESSOR_BASED_VM_EXECUTION_CONTROLS    0x0000401E
 * PLE_Gap.
#define VMCS_CTRL_PLE_GAP                                            0x00004020
 * PLE_Window.
#define VMCS_CTRL_PLE_WINDOW                                         0x00004022
 *           32-Bit Read-Only Data Fields
 *
 * 32-Bit Read-Only Data Fields.
 * VM-instruction error.
#define VMCS_VM_INSTRUCTION_ERROR                                    0x00004400
 * Exit reason.
#define VMCS_EXIT_REASON                                             0x00004402
 * VM-exit interruption information.
#define VMCS_VMEXIT_INTERRUPTION_INFORMATION                         0x00004404
 * VM-exit interruption error code.
#define VMCS_VMEXIT_INTERRUPTION_ERROR_CODE                          0x00004406
 * IDT-vectoring information field.
#define VMCS_IDT_VECTORING_INFORMATION                               0x00004408
 * IDT-vectoring error code.
#define VMCS_IDT_VECTORING_ERROR_CODE                                0x0000440A
 * VM-exit instruction length.
#define VMCS_VMEXIT_INSTRUCTION_LENGTH                               0x0000440C
 * VM-exit instruction information.
#define VMCS_VMEXIT_INSTRUCTION_INFO                                 0x0000440E
 *           32-Bit Guest-State Fields
 *
 * 32-Bit Guest-State Fields.
 * Guest ES limit.
#define VMCS_GUEST_ES_LIMIT                                          0x00004800
 * Guest CS limit.
#define VMCS_GUEST_CS_LIMIT                                          0x00004802
 * Guest SS limit.
#define VMCS_GUEST_SS_LIMIT                                          0x00004804
 * Guest DS limit.
#define VMCS_GUEST_DS_LIMIT                                          0x00004806
 * Guest FS limit.
#define VMCS_GUEST_FS_LIMIT                                          0x00004808
 * Guest GS limit.
#define VMCS_GUEST_GS_LIMIT                                          0x0000480A
 * Guest LDTR limit.
#define VMCS_GUEST_LDTR_LIMIT                                        0x0000480C
 * Guest TR limit.
#define VMCS_GUEST_TR_LIMIT                                          0x0000480E
 * Guest GDTR limit.
#define VMCS_GUEST_GDTR_LIMIT                                        0x00004810
 * Guest IDTR limit.
#define VMCS_GUEST_IDTR_LIMIT                                        0x00004812
 * Guest ES access rights.
#define VMCS_GUEST_ES_ACCESS_RIGHTS                                  0x00004814
 * Guest CS access rights.
#define VMCS_GUEST_CS_ACCESS_RIGHTS                                  0x00004816
 * Guest SS access rights.
#define VMCS_GUEST_SS_ACCESS_RIGHTS                                  0x00004818
 * Guest DS access rights.
#define VMCS_GUEST_DS_ACCESS_RIGHTS                                  0x0000481A
 * Guest FS access rights.
#define VMCS_GUEST_FS_ACCESS_RIGHTS                                  0x0000481C
 * Guest GS access rights.
#define VMCS_GUEST_GS_ACCESS_RIGHTS                                  0x0000481E
 * Guest LDTR access rights.
#define VMCS_GUEST_LDTR_ACCESS_RIGHTS                                0x00004820
 * Guest TR access rights.
#define VMCS_GUEST_TR_ACCESS_RIGHTS                                  0x00004822
 * Guest interruptibility state.
#define VMCS_GUEST_INTERRUPTIBILITY_STATE                            0x00004824
 * Guest activity state.
#define VMCS_GUEST_ACTIVITY_STATE                                    0x00004826
 * Guest SMBASE.
#define VMCS_GUEST_SMBASE                                            0x00004828
 * Guest IA32_SYSENTER_CS.
#define VMCS_GUEST_SYSENTER_CS                                       0x0000482A
 * VMX-preemption timer value.
#define VMCS_GUEST_VMX_PREEMPTION_TIMER_VALUE                        0x0000482E
 *           32-Bit Host-State Field
 *
 * 32-Bit Host-State Field.
 * Host IA32_SYSENTER_CS.
#define VMCS_HOST_SYSENTER_CS                                        0x00004C00
 *           Natural-Width Fields
 *
 * Natural-Width Fields.
 *
 *           Natural-Width Control Fields
 *
 * Natural-Width Control Fields
 * CR0 guest/host mask.
#define VMCS_CTRL_CR0_GUEST_HOST_MASK                                0x00006000
 * CR4 guest/host mask.
#define VMCS_CTRL_CR4_GUEST_HOST_MASK                                0x00006002
 * CR0 read shadow.
#define VMCS_CTRL_CR0_READ_SHADOW                                    0x00006004
 * CR4 read shadow.
#define VMCS_CTRL_CR4_READ_SHADOW                                    0x00006006
 * CR3-target value 0.
#define VMCS_CTRL_CR3_TARGET_VALUE_0                                 0x00006008
 * CR3-target value 1.
#define VMCS_CTRL_CR3_TARGET_VALUE_1                                 0x0000600A
 * CR3-target value 2.
#define VMCS_CTRL_CR3_TARGET_VALUE_2                                 0x0000600C
 * CR3-target value 3.
#define VMCS_CTRL_CR3_TARGET_VALUE_3                                 0x0000600E
 *           Natural-Width Read-Only Data Fields
 *
 * Natural-Width Read-Only Data Fields.
 * Exit qualification.
#define VMCS_EXIT_QUALIFICATION                                      0x00006400
 * I/O RCX.
#define VMCS_IO_RCX                                                  0x00006402
 * I/O RSI.
#define VMCS_IO_RSI                                                  0x00006404
 * I/O RDI.
#define VMCS_IO_RDI                                                  0x00006406
 * I/O RIP.
#define VMCS_IO_RIP                                                  0x00006408
 * Guest-linear address.
#define VMCS_EXIT_GUEST_LINEAR_ADDRESS                               0x0000640A
 *           Natural-Width Guest-State Fields
 *
 * Natural-Width Guest-State Fields.
 * Guest CR0.
#define VMCS_GUEST_CR0                                               0x00006800
 * Guest CR3.
#define VMCS_GUEST_CR3                                               0x00006802
 * Guest CR4.
#define VMCS_GUEST_CR4                                               0x00006804
 * Guest ES base.
#define VMCS_GUEST_ES_BASE                                           0x00006806
 * Guest CS base.
#define VMCS_GUEST_CS_BASE                                           0x00006808
 * Guest SS base.
#define VMCS_GUEST_SS_BASE                                           0x0000680A
 * Guest DS base.
#define VMCS_GUEST_DS_BASE                                           0x0000680C
 * Guest FS base.
#define VMCS_GUEST_FS_BASE                                           0x0000680E
 * Guest GS base.
#define VMCS_GUEST_GS_BASE                                           0x00006810
 * Guest LDTR base.
#define VMCS_GUEST_LDTR_BASE                                         0x00006812
 * Guest TR base.
#define VMCS_GUEST_TR_BASE                                           0x00006814
 * Guest GDTR base.
#define VMCS_GUEST_GDTR_BASE                                         0x00006816
 * Guest IDTR base.
#define VMCS_GUEST_IDTR_BASE                                         0x00006818
 * Guest DR7.
#define VMCS_GUEST_DR7                                               0x0000681A
 * Guest RSP.
#define VMCS_GUEST_RSP                                               0x0000681C
 * Guest RIP.
#define VMCS_GUEST_RIP                                               0x0000681E
 * Guest RFLAGS.
#define VMCS_GUEST_RFLAGS                                            0x00006820
 * Guest pending debug exceptions.
#define VMCS_GUEST_PENDING_DEBUG_EXCEPTIONS                          0x00006822
 * Guest IA32_SYSENTER_ESP.
#define VMCS_GUEST_SYSENTER_ESP                                      0x00006824
 * Guest IA32_SYSENTER_EIP.
#define VMCS_GUEST_SYSENTER_EIP                                      0x00006826
 * Guest IA32_S_CET.
#define VMCS_GUEST_S_CET                                             0x00006C28
 * Guest SSP.
#define VMCS_GUEST_SSP                                               0x00006C2A
 * Guest IA32_INTERRUPT_SSP_TABLE_ADDR.
#define VMCS_GUEST_INTERRUPT_SSP_TABLE_ADDR                          0x00006C2C
 *           Natural-Width Host-State Fields
 *
 * Natural-Width Host-State Fields.
 * Host CR0.
#define VMCS_HOST_CR0                                                0x00006C00
 * Host CR3.
#define VMCS_HOST_CR3                                                0x00006C02
 * Host CR4.
#define VMCS_HOST_CR4                                                0x00006C04
 * Host FS base.
#define VMCS_HOST_FS_BASE                                            0x00006C06
 * Host GS base.
#define VMCS_HOST_GS_BASE                                            0x00006C08
 * Host TR base.
#define VMCS_HOST_TR_BASE                                            0x00006C0A
 * Host GDTR base.
#define VMCS_HOST_GDTR_BASE                                          0x00006C0C
 * Host IDTR base.
#define VMCS_HOST_IDTR_BASE                                          0x00006C0E
 * Host IA32_SYSENTER_ESP.
#define VMCS_HOST_SYSENTER_ESP                                       0x00006C10
 * Host IA32_SYSENTER_EIP.
#define VMCS_HOST_SYSENTER_EIP                                       0x00006C12
 * Host RSP.
#define VMCS_HOST_RSP                                                0x00006C14
 * Host RIP.
#define VMCS_HOST_RIP                                                0x00006C16
 * Host IA32_S_CET.
#define VMCS_HOST_S_CET                                              0x00006C18
 * Host SSP.
#define VMCS_HOST_SSP                                                0x00006C1A
 * Host IA32_INTERRUPT_SSP_TABLE_ADDR.
#define VMCS_HOST_INTERRUPT_SSP_TABLE_ADDR                           0x00006C1C
typedef enum
{
   * External interrupt.
  ExternalInterrupt                                            = 0x00000000,
   * Non-maskable interrupt (NMI).
  NonMaskableInterrupt                                         = 0x00000002,
   * Hardware exception (e.g,. \#PF).
  HardwareException                                            = 0x00000003,
   * Software interrupt (INT n).
  SoftwareInterrupt                                            = 0x00000004,
   * Privileged software exception (INT1).
  PrivilegedSoftwareException                                  = 0x00000005,
   * Software exception (INT3 or INTO).
  SoftwareException                                            = 0x00000006,
   * Other event. This type is used for injection of events that are not delivered through the IDT.
  OtherEvent                                                   = 0x00000007,
} INTERRUPTION_TYPE;*/
return true
}

func (i *ia32)#define VMENTRY_INTERRUPT_INFORMATION_VECTOR()(ok bool){//col:22324
/*#define VMENTRY_INTERRUPT_INFORMATION_VECTOR(_)                      (((_) >> 0) & 0xFF)
     *
     * [Bits 10:8] Determines details of how the injection is performed.
    UINT32 InterruptionType                                        : 3;
#define VMENTRY_INTERRUPT_INFORMATION_INTERRUPTION_TYPE_BIT          8
#define VMENTRY_INTERRUPT_INFORMATION_INTERRUPTION_TYPE_FLAG         0x700
#define VMENTRY_INTERRUPT_INFORMATION_INTERRUPTION_TYPE_MASK         0x07
#define VMENTRY_INTERRUPT_INFORMATION_INTERRUPTION_TYPE(_)           (((_) >> 8) & 0x07)
     *
     * [Bit 11] Determines whether delivery pushes an error code on the guest stack.
    UINT32 DeliverErrorCode                                        : 1;
#define VMENTRY_INTERRUPT_INFORMATION_DELIVER_ERROR_CODE_BIT         11
#define VMENTRY_INTERRUPT_INFORMATION_DELIVER_ERROR_CODE_FLAG        0x800
#define VMENTRY_INTERRUPT_INFORMATION_DELIVER_ERROR_CODE_MASK        0x01
#define VMENTRY_INTERRUPT_INFORMATION_DELIVER_ERROR_CODE(_)          (((_) >> 11) & 0x01)
    UINT32 Reserved1                                               : 19;
     *
     * [Bit 31] VM entry injects an event if and only if the valid bit is 1. The valid bit in this field is cleared on every VM
     * exit.
    UINT32 Valid                                                   : 1;
#define VMENTRY_INTERRUPT_INFORMATION_VALID_BIT                      31
#define VMENTRY_INTERRUPT_INFORMATION_VALID_FLAG                     0x80000000
#define VMENTRY_INTERRUPT_INFORMATION_VALID_MASK                     0x01
#define VMENTRY_INTERRUPT_INFORMATION_VALID(_)                       (((_) >> 31) & 0x01)
  };
  UINT32 AsUInt;
} VMENTRY_INTERRUPT_INFORMATION;*/
return true
}

func (i *ia32)#define VMEXIT_INTERRUPT_INFORMATION_VECTOR()(ok bool){//col:22384
/*#define VMEXIT_INTERRUPT_INFORMATION_VECTOR(_)                       (((_) >> 0) & 0xFF)
     * [Bits 10:8] Interruption type.
    UINT32 InterruptionType                                        : 3;
#define VMEXIT_INTERRUPT_INFORMATION_INTERRUPTION_TYPE_BIT           8
#define VMEXIT_INTERRUPT_INFORMATION_INTERRUPTION_TYPE_FLAG          0x700
#define VMEXIT_INTERRUPT_INFORMATION_INTERRUPTION_TYPE_MASK          0x07
#define VMEXIT_INTERRUPT_INFORMATION_INTERRUPTION_TYPE(_)            (((_) >> 8) & 0x07)
     * [Bit 11] Deliver error code (0 = do not deliver; 1 = deliver).
    UINT32 ErrorCodeValid                                          : 1;
#define VMEXIT_INTERRUPT_INFORMATION_ERROR_CODE_VALID_BIT            11
#define VMEXIT_INTERRUPT_INFORMATION_ERROR_CODE_VALID_FLAG           0x800
#define VMEXIT_INTERRUPT_INFORMATION_ERROR_CODE_VALID_MASK           0x01
#define VMEXIT_INTERRUPT_INFORMATION_ERROR_CODE_VALID(_)             (((_) >> 11) & 0x01)
     * [Bit 12] NMI unblocking due to IRET.
    UINT32 NmiUnblocking                                           : 1;
#define VMEXIT_INTERRUPT_INFORMATION_NMI_UNBLOCKING_BIT              12
#define VMEXIT_INTERRUPT_INFORMATION_NMI_UNBLOCKING_FLAG             0x1000
#define VMEXIT_INTERRUPT_INFORMATION_NMI_UNBLOCKING_MASK             0x01
#define VMEXIT_INTERRUPT_INFORMATION_NMI_UNBLOCKING(_)               (((_) >> 12) & 0x01)
    UINT32 Reserved1                                               : 18;
     * [Bit 31] Valid.
    UINT32 Valid                                                   : 1;
#define VMEXIT_INTERRUPT_INFORMATION_VALID_BIT                       31
#define VMEXIT_INTERRUPT_INFORMATION_VALID_FLAG                      0x80000000
#define VMEXIT_INTERRUPT_INFORMATION_VALID_MASK                      0x01
#define VMEXIT_INTERRUPT_INFORMATION_VALID(_)                        (((_) >> 31) & 0x01)
  };
  UINT32 AsUInt;
} VMEXIT_INTERRUPT_INFORMATION;*/
return true
}

func (i *ia32) *           Advanced Programmable Interrupt Controller ()(ok bool){//col:22889
/* *           Advanced Programmable Interrupt Controller (APIC)
 *
 * Software interacts with the local APIC by reading and writing its registers. APIC registers are memory-mapped to a
 * 4-KByte region of the processor's physical address space with an initial starting address of FEE00000H. For correct APIC
 * operation, this address space must be mapped to an area of memory that has been designated as strong uncacheable (UC).
 *
 *          registers should be accessed using 128-bit aligned 32-bit loads or stores. Some processors may support loads and stores
 *          of less than 32 bits to some of the APIC registers. This is model specific behavior and is not guaranteed to work on all
 *          processors. Any FP/MMX/SSE access to an APIC register, or any access that touches bytes 4 through 15 of an APIC register
 *          may cause undefined behavior and must not be executed. This undefined behavior could include hangs, incorrect results or
 *          unexpected exceptions, including machine checks, and may vary between implementations. Wider registers (64-bit or
 *          256-bit) must be accessed using multiple 32-bit loads or stores, with all accesses being 128-bit aligned.
 * Local APIC Base Address.
 *
#define APIC_BASE_ADDRESS                                            0xFEE00000
 * Local APIC ID Register.
#define APIC_ID                                                      0x00000020
 * Local APIC Version Register.
#define APIC_VERSION                                                 0x00000030
 * Task Priority Register (TPR).
#define APIC_TASK_PRIORITY                                           0x00000080
 * Arbitration Priority Register (APR).
#define APIC_ARBITRATION_PRIORITY                                    0x00000090
 * Processor Priority Register (PPR).
#define APIC_PROCESSOR_PRIORITY                                      0x000000A0
 * EOI Register.
#define APIC_EOI                                                     0x000000B0
 * Remote Read Register (RRD).
#define APIC_REMOTE_READ                                             0x000000C0
 * Logical Destination Register.
#define APIC_LOGICAL_DESTINATION                                     0x000000D0
 * Destination Format Register.
 *
#define APIC_DESTINATION_FORMAT                                      0x000000E0
 * Spurious Interrupt Vector Register.
 *
#define APIC_SPURIOUS_INTERRUPT_VECTOR                               0x000000F0
 * In-Service Register (ISR); bits 31:0.
#define APIC_IN_SERVICE_BITS_31_0                                    0x00000100
 * In-Service Register (ISR); bits 63:32.
#define APIC_IN_SERVICE_BITS_63_32                                   0x00000110
 * In-Service Register (ISR); bits 95:64.
#define APIC_IN_SERVICE_BITS_95_64                                   0x00000120
 * In-Service Register (ISR); bits 127:96.
#define APIC_IN_SERVICE_BITS_127_96                                  0x00000130
 * In-Service Register (ISR); bits 159:128.
#define APIC_IN_SERVICE_BITS_159_128                                 0x00000140
 * In-Service Register (ISR); bits 191:160.
#define APIC_IN_SERVICE_BITS_191_160                                 0x00000150
 * In-Service Register (ISR); bits 223:192.
#define APIC_IN_SERVICE_BITS_223_192                                 0x00000160
 * In-Service Register (ISR); bits 255:224.
#define APIC_IN_SERVICE_BITS_255_224                                 0x00000170
 * Trigger Mode Register (TMR); bits 31:0.
#define APIC_TRIGGER_MODE_BITS_31_0                                  0x00000180
 * Trigger Mode Register (TMR); bits 63:32.
#define APIC_TRIGGER_MODE_BITS_63_32                                 0x00000190
 * Trigger Mode Register (TMR); bits 95:64.
#define APIC_TRIGGER_MODE_BITS_95_64                                 0x000001A0
 * Trigger Mode Register (TMR); bits 127:96.
#define APIC_TRIGGER_MODE_BITS_127_96                                0x000001B0
 * Trigger Mode Register (TMR); bits 159:128.
#define APIC_TRIGGER_MODE_BITS_159_128                               0x000001C0
 * Trigger Mode Register (TMR); bits 191:160.
#define APIC_TRIGGER_MODE_BITS_191_160                               0x000001D0
 * Trigger Mode Register (TMR); bits 223:192.
#define APIC_TRIGGER_MODE_BITS_223_192                               0x000001E0
 * Trigger Mode Register (TMR); bits 255:224.
#define APIC_TRIGGER_MODE_BITS_255_224                               0x000001F0
 * Interrupt Request Register (IRR); bits 31:0.
#define APIC_INTERRUPT_REQUEST_BITS_31_0                             0x00000200
 * Interrupt Request Register (IRR); bits 63:32.
#define APIC_INTERRUPT_REQUEST_BITS_63_32                            0x00000210
 * Interrupt Request Register (IRR); bits 95:64.
#define APIC_INTERRUPT_REQUEST_BITS_95_64                            0x00000220
 * Interrupt Request Register (IRR); bits 127:96.
#define APIC_INTERRUPT_REQUEST_BITS_127_96                           0x00000230
 * Interrupt Request Register (IRR); bits 159:128.
#define APIC_INTERRUPT_REQUEST_BITS_159_128                          0x00000240
 * Interrupt Request Register (IRR); bits 191:160.
#define APIC_INTERRUPT_REQUEST_BITS_191_160                          0x00000250
 * Interrupt Request Register (IRR); bits 223:192.
#define APIC_INTERRUPT_REQUEST_BITS_223_192                          0x00000260
 * Interrupt Request Register (IRR); bits 255:224.
#define APIC_INTERRUPT_REQUEST_BITS_255_224                          0x00000270
 * Error Status Register.
#define APIC_ERROR_STATUS                                            0x00000280
 * LVT Corrected Machine Check Interrupt (CMCI) Register.
#define APIC_LVT_CORRECTED_MACHINE_CHECK_INTERRUPT                   0x000002F0
 * Interrupt Command Register (ICR); bits 0-31.
#define APIC_INTERRUPT_COMMAND_BITS_0_31                             0x00000300
 * Interrupt Command Register (ICR); bits 32-63.
#define APIC_INTERRUPT_COMMAND_BITS_32_63                            0x00000310
 * LVT Timer Register.
#define APIC_LVT_TIMER                                               0x00000320
 * LVT Thermal Sensor Register.
#define APIC_LVT_THERMAL_SENSOR                                      0x00000330
 * LVT Performance Monitoring Counters Register.
#define APIC_LVT_PERFORMANCE_MONITORING_COUNTERS                     0x00000340
 * LVT LINT0 Register.
#define APIC_LVT_LINT0                                               0x00000350
 * LVT LINT1 Register.
#define APIC_LVT_LINT1                                               0x00000360
 * LVT Error Register.
#define APIC_LVT_ERROR                                               0x00000370
 * Initial Count Register (for Timer).
#define APIC_INITIAL_COUNT                                           0x00000380
 * Current Count Register (for Timer).
#define APIC_CURRENT_COUNT                                           0x00000390
 * Divide Configuration Register (for Timer).
#define APIC_DIVIDE_CONFIGURATION                                    0x000003E0
 * The 32-bit EFLAGS register contains a group of status flags, a control flag, and a group of system flags. The status
 * flags (bits 0, 2, 4, 6, 7, and 11) of the EFLAGS register indicate the results of arithmetic instructions, such as the
 * ADD, SUB, MUL, and DIV instructions.
 * The system flags and IOPL field in the EFLAGS register control operating-system or executive operations.
 *
typedef union
{
  struct
  {
     *
     * [Bit 0] Set if an arithmetic operation generates a carry or a borrow out of the mostsignificant bit of the result;
     * cleared otherwise. This flag indicates an overflow condition for unsigned-integer arithmetic. It is also used in
     * multiple-precision arithmetic.
    UINT32 CarryFlag                                               : 1;
#define EFLAGS_CARRY_FLAG_BIT                                        0
#define EFLAGS_CARRY_FLAG_FLAG                                       0x01
#define EFLAGS_CARRY_FLAG_MASK                                       0x01
#define EFLAGS_CARRY_FLAG(_)                                         (((_) >> 0) & 0x01)
     * [Bit 1] Reserved - always 1
    UINT32 ReadAs1                                                 : 1;
#define EFLAGS_READ_AS_1_BIT                                         1
#define EFLAGS_READ_AS_1_FLAG                                        0x02
#define EFLAGS_READ_AS_1_MASK                                        0x01
#define EFLAGS_READ_AS_1(_)                                          (((_) >> 1) & 0x01)
     *
     * [Bit 2] Set if the least-significant byte of the result contains an even number of 1 bits; cleared otherwise.
    UINT32 ParityFlag                                              : 1;
#define EFLAGS_PARITY_FLAG_BIT                                       2
#define EFLAGS_PARITY_FLAG_FLAG                                      0x04
#define EFLAGS_PARITY_FLAG_MASK                                      0x01
#define EFLAGS_PARITY_FLAG(_)                                        (((_) >> 2) & 0x01)
    UINT32 Reserved1                                               : 1;
     *
     * [Bit 4] Set if an arithmetic operation generates a carry or a borrow out of bit 3 of the result; cleared otherwise. This
     * flag is used in binary-coded decimal (BCD) arithmetic.
    UINT32 AuxiliaryCarryFlag                                      : 1;
#define EFLAGS_AUXILIARY_CARRY_FLAG_BIT                              4
#define EFLAGS_AUXILIARY_CARRY_FLAG_FLAG                             0x10
#define EFLAGS_AUXILIARY_CARRY_FLAG_MASK                             0x01
#define EFLAGS_AUXILIARY_CARRY_FLAG(_)                               (((_) >> 4) & 0x01)
    UINT32 Reserved2                                               : 1;
     *
     * [Bit 6] Set if the result is zero; cleared otherwise.
    UINT32 ZeroFlag                                                : 1;
#define EFLAGS_ZERO_FLAG_BIT                                         6
#define EFLAGS_ZERO_FLAG_FLAG                                        0x40
#define EFLAGS_ZERO_FLAG_MASK                                        0x01
#define EFLAGS_ZERO_FLAG(_)                                          (((_) >> 6) & 0x01)
     *
     * [Bit 7] Set equal to the most-significant bit of the result, which is the sign bit of a signed integer. (0 indicates a
     * positive value and 1 indicates a negative value.)
    UINT32 SignFlag                                                : 1;
#define EFLAGS_SIGN_FLAG_BIT                                         7
#define EFLAGS_SIGN_FLAG_FLAG                                        0x80
#define EFLAGS_SIGN_FLAG_MASK                                        0x01
#define EFLAGS_SIGN_FLAG(_)                                          (((_) >> 7) & 0x01)
     *
     * [Bit 8] Set to enable single-step mode for debugging; clear to disable single-step mode.
    UINT32 TrapFlag                                                : 1;
#define EFLAGS_TRAP_FLAG_BIT                                         8
#define EFLAGS_TRAP_FLAG_FLAG                                        0x100
#define EFLAGS_TRAP_FLAG_MASK                                        0x01
#define EFLAGS_TRAP_FLAG(_)                                          (((_) >> 8) & 0x01)
     *
     * [Bit 9] Controls the response of the processor to maskable interrupt requests. Set to respond to maskable interrupts;
     * cleared to inhibit maskable interrupts.
    UINT32 InterruptEnableFlag                                     : 1;
#define EFLAGS_INTERRUPT_ENABLE_FLAG_BIT                             9
#define EFLAGS_INTERRUPT_ENABLE_FLAG_FLAG                            0x200
#define EFLAGS_INTERRUPT_ENABLE_FLAG_MASK                            0x01
#define EFLAGS_INTERRUPT_ENABLE_FLAG(_)                              (((_) >> 9) & 0x01)
     *
     * [Bit 10] Controls string instructions (MOVS, CMPS, SCAS, LODS, and STOS). Setting the DF flag causes the string
     * instructions to auto-decrement (to process strings from high addresses to low addresses). Clearing the DF flag causes
     * the string instructions to auto-increment (process strings from low addresses to high addresses).
    UINT32 DirectionFlag                                           : 1;
#define EFLAGS_DIRECTION_FLAG_BIT                                    10
#define EFLAGS_DIRECTION_FLAG_FLAG                                   0x400
#define EFLAGS_DIRECTION_FLAG_MASK                                   0x01
#define EFLAGS_DIRECTION_FLAG(_)                                     (((_) >> 10) & 0x01)
     *
     * [Bit 11] Set if the integer result is too large a positive number or too small a negative number (excluding the
     * sign-bit) to fit in the destination operand; cleared otherwise. This flag indicates an overflow condition for
     * signed-integer (two's complement) arithmetic.
    UINT32 OverflowFlag                                            : 1;
#define EFLAGS_OVERFLOW_FLAG_BIT                                     11
#define EFLAGS_OVERFLOW_FLAG_FLAG                                    0x800
#define EFLAGS_OVERFLOW_FLAG_MASK                                    0x01
#define EFLAGS_OVERFLOW_FLAG(_)                                      (((_) >> 11) & 0x01)
     *
     * [Bits 13:12] Indicates the I/O privilege level of the currently running program or task. The current privilege level
     * (CPL) of the currently running program or task must be less than or equal to the I/O privilege level to access the I/O
     * address space. The POPF and IRET instructions can modify this field only when operating at a CPL of 0.
    UINT32 IoPrivilegeLevel                                        : 2;
#define EFLAGS_IO_PRIVILEGE_LEVEL_BIT                                12
#define EFLAGS_IO_PRIVILEGE_LEVEL_FLAG                               0x3000
#define EFLAGS_IO_PRIVILEGE_LEVEL_MASK                               0x03
#define EFLAGS_IO_PRIVILEGE_LEVEL(_)                                 (((_) >> 12) & 0x03)
     *
     * [Bit 14] Controls the chaining of interrupted and called tasks. Set when the current task is linked to the previously
     * executed task; cleared when the current task is not linked to another task.
    UINT32 NestedTaskFlag                                          : 1;
#define EFLAGS_NESTED_TASK_FLAG_BIT                                  14
#define EFLAGS_NESTED_TASK_FLAG_FLAG                                 0x4000
#define EFLAGS_NESTED_TASK_FLAG_MASK                                 0x01
#define EFLAGS_NESTED_TASK_FLAG(_)                                   (((_) >> 14) & 0x01)
    UINT32 Reserved3                                               : 1;
     *
     * [Bit 16] Controls the processor's response to debug exceptions.
    UINT32 ResumeFlag                                              : 1;
#define EFLAGS_RESUME_FLAG_BIT                                       16
#define EFLAGS_RESUME_FLAG_FLAG                                      0x10000
#define EFLAGS_RESUME_FLAG_MASK                                      0x01
#define EFLAGS_RESUME_FLAG(_)                                        (((_) >> 16) & 0x01)
     *
     * [Bit 17] Set to enable virtual-8086 mode; clear to return to protected mode without virtual-8086 mode semantics.
    UINT32 Virtual8086ModeFlag                                     : 1;
#define EFLAGS_VIRTUAL_8086_MODE_FLAG_BIT                            17
#define EFLAGS_VIRTUAL_8086_MODE_FLAG_FLAG                           0x20000
#define EFLAGS_VIRTUAL_8086_MODE_FLAG_MASK                           0x01
#define EFLAGS_VIRTUAL_8086_MODE_FLAG(_)                             (((_) >> 17) & 0x01)
     *
     * [Bit 18] If the AM bit is set in the CR0 register, alignment checking of user-mode data accesses is enabled if and only
     * if this flag is 1. If the SMAP bit is set in the CR4 register, explicit supervisor-mode data accesses to user-mode pages
     * are allowed if and only if this bit is 1.
     *
    UINT32 AlignmentCheckFlag                                      : 1;
#define EFLAGS_ALIGNMENT_CHECK_FLAG_BIT                              18
#define EFLAGS_ALIGNMENT_CHECK_FLAG_FLAG                             0x40000
#define EFLAGS_ALIGNMENT_CHECK_FLAG_MASK                             0x01
#define EFLAGS_ALIGNMENT_CHECK_FLAG(_)                               (((_) >> 18) & 0x01)
     *
     * [Bit 19] Virtual image of the IF flag. Used in conjunction with the VIP flag. (To use this flag and the VIP flag the
     * virtual mode extensions are enabled by setting the VME flag in control register CR4.)
    UINT32 VirtualInterruptFlag                                    : 1;
#define EFLAGS_VIRTUAL_INTERRUPT_FLAG_BIT                            19
#define EFLAGS_VIRTUAL_INTERRUPT_FLAG_FLAG                           0x80000
#define EFLAGS_VIRTUAL_INTERRUPT_FLAG_MASK                           0x01
#define EFLAGS_VIRTUAL_INTERRUPT_FLAG(_)                             (((_) >> 19) & 0x01)
     *
     * [Bit 20] Set to indicate that an interrupt is pending; clear when no interrupt is pending. (Software sets and clears
     * this flag; the processor only reads it.) Used in conjunction with the VIF flag.
    UINT32 VirtualInterruptPendingFlag                             : 1;
#define EFLAGS_VIRTUAL_INTERRUPT_PENDING_FLAG_BIT                    20
#define EFLAGS_VIRTUAL_INTERRUPT_PENDING_FLAG_FLAG                   0x100000
#define EFLAGS_VIRTUAL_INTERRUPT_PENDING_FLAG_MASK                   0x01
#define EFLAGS_VIRTUAL_INTERRUPT_PENDING_FLAG(_)                     (((_) >> 20) & 0x01)
     *
     * [Bit 21] The ability of a program to set or clear this flag indicates support for the CPUID instruction.
    UINT32 IdentificationFlag                                      : 1;
#define EFLAGS_IDENTIFICATION_FLAG_BIT                               21
#define EFLAGS_IDENTIFICATION_FLAG_FLAG                              0x200000
#define EFLAGS_IDENTIFICATION_FLAG_MASK                              0x01
#define EFLAGS_IDENTIFICATION_FLAG(_)                                (((_) >> 21) & 0x01)
    UINT32 Reserved4                                               : 10;
  };
  UINT32 AsUInt;
} EFLAGS;*/
return true
}

func (i *ia32)#define RFLAGS_CARRY_FLAG()(ok bool){//col:23106
/*#define RFLAGS_CARRY_FLAG(_)                                         (((_) >> 0) & 0x01)
     * [Bit 1] Reserved - always 1
    UINT64 ReadAs1                                                 : 1;
#define RFLAGS_READ_AS_1_BIT                                         1
#define RFLAGS_READ_AS_1_FLAG                                        0x02
#define RFLAGS_READ_AS_1_MASK                                        0x01
#define RFLAGS_READ_AS_1(_)                                          (((_) >> 1) & 0x01)
     *
     * [Bit 2] See the description in EFLAGS.
    UINT64 ParityFlag                                              : 1;
#define RFLAGS_PARITY_FLAG_BIT                                       2
#define RFLAGS_PARITY_FLAG_FLAG                                      0x04
#define RFLAGS_PARITY_FLAG_MASK                                      0x01
#define RFLAGS_PARITY_FLAG(_)                                        (((_) >> 2) & 0x01)
    UINT64 Reserved1                                               : 1;
     *
     * [Bit 4] See the description in EFLAGS.
    UINT64 AuxiliaryCarryFlag                                      : 1;
#define RFLAGS_AUXILIARY_CARRY_FLAG_BIT                              4
#define RFLAGS_AUXILIARY_CARRY_FLAG_FLAG                             0x10
#define RFLAGS_AUXILIARY_CARRY_FLAG_MASK                             0x01
#define RFLAGS_AUXILIARY_CARRY_FLAG(_)                               (((_) >> 4) & 0x01)
    UINT64 Reserved2                                               : 1;
     *
     * [Bit 6] See the description in EFLAGS.
    UINT64 ZeroFlag                                                : 1;
#define RFLAGS_ZERO_FLAG_BIT                                         6
#define RFLAGS_ZERO_FLAG_FLAG                                        0x40
#define RFLAGS_ZERO_FLAG_MASK                                        0x01
#define RFLAGS_ZERO_FLAG(_)                                          (((_) >> 6) & 0x01)
     *
     * [Bit 7] See the description in EFLAGS.
    UINT64 SignFlag                                                : 1;
#define RFLAGS_SIGN_FLAG_BIT                                         7
#define RFLAGS_SIGN_FLAG_FLAG                                        0x80
#define RFLAGS_SIGN_FLAG_MASK                                        0x01
#define RFLAGS_SIGN_FLAG(_)                                          (((_) >> 7) & 0x01)
     *
     * [Bit 8] See the description in EFLAGS.
    UINT64 TrapFlag                                                : 1;
#define RFLAGS_TRAP_FLAG_BIT                                         8
#define RFLAGS_TRAP_FLAG_FLAG                                        0x100
#define RFLAGS_TRAP_FLAG_MASK                                        0x01
#define RFLAGS_TRAP_FLAG(_)                                          (((_) >> 8) & 0x01)
     *
     * [Bit 9] See the description in EFLAGS.
    UINT64 InterruptEnableFlag                                     : 1;
#define RFLAGS_INTERRUPT_ENABLE_FLAG_BIT                             9
#define RFLAGS_INTERRUPT_ENABLE_FLAG_FLAG                            0x200
#define RFLAGS_INTERRUPT_ENABLE_FLAG_MASK                            0x01
#define RFLAGS_INTERRUPT_ENABLE_FLAG(_)                              (((_) >> 9) & 0x01)
     *
     * [Bit 10] See the description in EFLAGS.
    UINT64 DirectionFlag                                           : 1;
#define RFLAGS_DIRECTION_FLAG_BIT                                    10
#define RFLAGS_DIRECTION_FLAG_FLAG                                   0x400
#define RFLAGS_DIRECTION_FLAG_MASK                                   0x01
#define RFLAGS_DIRECTION_FLAG(_)                                     (((_) >> 10) & 0x01)
     *
     * [Bit 11] See the description in EFLAGS.
    UINT64 OverflowFlag                                            : 1;
#define RFLAGS_OVERFLOW_FLAG_BIT                                     11
#define RFLAGS_OVERFLOW_FLAG_FLAG                                    0x800
#define RFLAGS_OVERFLOW_FLAG_MASK                                    0x01
#define RFLAGS_OVERFLOW_FLAG(_)                                      (((_) >> 11) & 0x01)
     *
     * [Bits 13:12] See the description in EFLAGS.
    UINT64 IoPrivilegeLevel                                        : 2;
#define RFLAGS_IO_PRIVILEGE_LEVEL_BIT                                12
#define RFLAGS_IO_PRIVILEGE_LEVEL_FLAG                               0x3000
#define RFLAGS_IO_PRIVILEGE_LEVEL_MASK                               0x03
#define RFLAGS_IO_PRIVILEGE_LEVEL(_)                                 (((_) >> 12) & 0x03)
     *
     * [Bit 14] See the description in EFLAGS.
    UINT64 NestedTaskFlag                                          : 1;
#define RFLAGS_NESTED_TASK_FLAG_BIT                                  14
#define RFLAGS_NESTED_TASK_FLAG_FLAG                                 0x4000
#define RFLAGS_NESTED_TASK_FLAG_MASK                                 0x01
#define RFLAGS_NESTED_TASK_FLAG(_)                                   (((_) >> 14) & 0x01)
    UINT64 Reserved3                                               : 1;
     *
     * [Bit 16] See the description in EFLAGS.
    UINT64 ResumeFlag                                              : 1;
#define RFLAGS_RESUME_FLAG_BIT                                       16
#define RFLAGS_RESUME_FLAG_FLAG                                      0x10000
#define RFLAGS_RESUME_FLAG_MASK                                      0x01
#define RFLAGS_RESUME_FLAG(_)                                        (((_) >> 16) & 0x01)
     *
     * [Bit 17] See the description in EFLAGS.
    UINT64 Virtual8086ModeFlag                                     : 1;
#define RFLAGS_VIRTUAL_8086_MODE_FLAG_BIT                            17
#define RFLAGS_VIRTUAL_8086_MODE_FLAG_FLAG                           0x20000
#define RFLAGS_VIRTUAL_8086_MODE_FLAG_MASK                           0x01
#define RFLAGS_VIRTUAL_8086_MODE_FLAG(_)                             (((_) >> 17) & 0x01)
     *
     * [Bit 18] See the description in EFLAGS.
     *
    UINT64 AlignmentCheckFlag                                      : 1;
#define RFLAGS_ALIGNMENT_CHECK_FLAG_BIT                              18
#define RFLAGS_ALIGNMENT_CHECK_FLAG_FLAG                             0x40000
#define RFLAGS_ALIGNMENT_CHECK_FLAG_MASK                             0x01
#define RFLAGS_ALIGNMENT_CHECK_FLAG(_)                               (((_) >> 18) & 0x01)
     *
     * [Bit 19] See the description in EFLAGS.
    UINT64 VirtualInterruptFlag                                    : 1;
#define RFLAGS_VIRTUAL_INTERRUPT_FLAG_BIT                            19
#define RFLAGS_VIRTUAL_INTERRUPT_FLAG_FLAG                           0x80000
#define RFLAGS_VIRTUAL_INTERRUPT_FLAG_MASK                           0x01
#define RFLAGS_VIRTUAL_INTERRUPT_FLAG(_)                             (((_) >> 19) & 0x01)
     *
     * [Bit 20] See the description in EFLAGS.
    UINT64 VirtualInterruptPendingFlag                             : 1;
#define RFLAGS_VIRTUAL_INTERRUPT_PENDING_FLAG_BIT                    20
#define RFLAGS_VIRTUAL_INTERRUPT_PENDING_FLAG_FLAG                   0x100000
#define RFLAGS_VIRTUAL_INTERRUPT_PENDING_FLAG_MASK                   0x01
#define RFLAGS_VIRTUAL_INTERRUPT_PENDING_FLAG(_)                     (((_) >> 20) & 0x01)
     *
     * [Bit 21] See the description in EFLAGS.
    UINT64 IdentificationFlag                                      : 1;
#define RFLAGS_IDENTIFICATION_FLAG_BIT                               21
#define RFLAGS_IDENTIFICATION_FLAG_FLAG                              0x200000
#define RFLAGS_IDENTIFICATION_FLAG_MASK                              0x01
#define RFLAGS_IDENTIFICATION_FLAG(_)                                (((_) >> 21) & 0x01)
    UINT64 Reserved4                                               : 42;
  };
  UINT64 AsUInt;
} RFLAGS;*/
return true
}

func (i *ia32)#define CONTROL_PROTECTION_EXCEPTION_CPEC()(ok bool){//col:23148
/*#define CONTROL_PROTECTION_EXCEPTION_CPEC(_)                         (((_) >> 0) & 0x7FFF)
     * [Bit 15] If set to 1, indicates the \#CP occurred during enclave execution.
    UINT32 Encl                                                    : 1;
#define CONTROL_PROTECTION_EXCEPTION_ENCL_BIT                        15
#define CONTROL_PROTECTION_EXCEPTION_ENCL_FLAG                       0x8000
#define CONTROL_PROTECTION_EXCEPTION_ENCL_MASK                       0x01
#define CONTROL_PROTECTION_EXCEPTION_ENCL(_)                         (((_) >> 15) & 0x01)
    UINT32 Reserved1                                               : 16;
  };
  UINT32 AsUInt;
} CONTROL_PROTECTION_EXCEPTION;*/
return true
}

func (i *ia32) *        Each exception is given a mnemonic that consists of a pound sign ()(ok bool){//col:23309
/* *        Each exception is given a mnemonic that consists of a pound sign (\#) followed by two letters and an optional error code
 *        in parentheses. For example, \#GP(0) denotes a general protection exception with an error code of 0
 *
typedef enum
{
   * #DE - Divide Error.
   * Source: DIV and IDIV instructions.
   * Error Code: No.
  DivideError                                                  = 0x00000000,
   * #DB - Debug.
   * Source: Any code or data reference.
   * Error Code: No.
  Debug                                                        = 0x00000001,
   * Nonmaskable Interrupt.
   * Source: Generated externally by asserting the processor's NMI pin or
   *         through an NMI request set by the I/O APIC to the local APIC.
   * Error Code: No.
  Nmi                                                          = 0x00000002,
   * #BP - Breakpoint.
   * Source: INT3 instruction.
   * Error Code: No.
  Breakpoint                                                   = 0x00000003,
   * #OF - Overflow.
   * Source: INTO instruction.
   * Error Code: No.
  Overflow                                                     = 0x00000004,
   * #BR - BOUND Range Exceeded.
   * Source: BOUND instruction.
   * Error Code: No.
  BoundRangeExceeded                                           = 0x00000005,
   * #UD - Invalid Opcode (Undefined Opcode).
   * Source: UD instruction or reserved opcode.
   * Error Code: No.
  InvalidOpcode                                                = 0x00000006,
   * #NM - Device Not Available (No Math Coprocessor).
   * Source: Floating-point or WAIT/FWAIT instruction.
   * Error Code: No.
  DeviceNotAvailable                                           = 0x00000007,
   * #DF - Double Fault.
   * Source: Any instruction that can generate an exception, an NMI, or an INTR.
   * Error Code: Yes (zero).
  DoubleFault                                                  = 0x00000008,
   * #\## - Coprocessor Segment Overrun (reserved).
   * Source: Floating-point instruction.
   * Error Code: No.
   *
  CoprocessorSegmentOverrun                                    = 0x00000009,
   * #TS - Invalid TSS.
   * Source: Task switch or TSS access.
   * Error Code: Yes.
  InvalidTss                                                   = 0x0000000A,
   * #NP - Segment Not Present.
   * Source: Loading segment registers or accessing system segments.
   * Error Code: Yes.
  SegmentNotPresent                                            = 0x0000000B,
   * #SS - Stack Segment Fault.
   * Source: Stack operations and SS register loads.
   * Error Code: Yes.
  StackSegmentFault                                            = 0x0000000C,
   * #GP - General Protection.
   * Source: Any memory reference and other protection checks.
   * Error Code: Yes.
  GeneralProtection                                            = 0x0000000D,
   * #PF - Page Fault.
   * Source: Any memory reference.
   * Error Code: Yes.
  PageFault                                                    = 0x0000000E,
   * #MF - Floating-Point Error (Math Fault).
   * Source: Floating-point or WAIT/FWAIT instruction.
   * Error Code: No.
  X87FloatingPointError                                        = 0x00000010,
   * #AC - Alignment Check.
   * Source: Any data reference in memory.
   * Error Code: Yes.
  AlignmentCheck                                               = 0x00000011,
   * #MC - Machine Check.
   * Source: Model dependent machine check errors.
   * Error Code: No.
  MachineCheck                                                 = 0x00000012,
   * #XM - SIMD Floating-Point Numeric Error.
   * Source: SSE/SSE2/SSE3 floating-point instructions.
   * Error Code: No.
  SimdFloatingPointError                                       = 0x00000013,
   * #VE - Virtualization Exception.
   * Source: EPT violations.
   * Error Code: No.
  VirtualizationException                                      = 0x00000014,
   * #CP - Control Protection Exception.
   * Source: Control flow transfer attempt violated the control flow enforcement technology constraints.
   * Error Code: Yes.
  ControlProtection                                            = 0x00000015,
} EXCEPTION_VECTOR;*/
return true
}

func (i *ia32) *        error code onto the stack of the exception handler ()(ok bool){//col:23371
/* *        error code onto the stack of the exception handler (whether it is a procedure or task). The error code resembles a
 *        segment selector; however, instead of a TI flag and RPL field, the error code contains 3 different flags
 *
typedef union
{
  struct
  {
     * [Bit 0] When set, indicates that the exception occurred during delivery of an event external to the program, such as an
     * interrupt or an earlier exception. The bit is cleared if the exception occurred during delivery of a software interrupt
     * (INT n, INT3, or INTO).
    UINT32 ExternalEvent                                           : 1;
#define EXCEPTION_ERROR_CODE_EXTERNAL_EVENT_BIT                      0
#define EXCEPTION_ERROR_CODE_EXTERNAL_EVENT_FLAG                     0x01
#define EXCEPTION_ERROR_CODE_EXTERNAL_EVENT_MASK                     0x01
#define EXCEPTION_ERROR_CODE_EXTERNAL_EVENT(_)                       (((_) >> 0) & 0x01)
     * [Bit 1] When set, indicates that the index portion of the error code refers to a gate descriptor in the IDT; when clear,
     * indicates that the index refers to a descriptor in the GDT or the current LDT.
    UINT32 DescriptorLocation                                      : 1;
#define EXCEPTION_ERROR_CODE_DESCRIPTOR_LOCATION_BIT                 1
#define EXCEPTION_ERROR_CODE_DESCRIPTOR_LOCATION_FLAG                0x02
#define EXCEPTION_ERROR_CODE_DESCRIPTOR_LOCATION_MASK                0x01
#define EXCEPTION_ERROR_CODE_DESCRIPTOR_LOCATION(_)                  (((_) >> 1) & 0x01)
     * [Bit 2] Only used when the IDT flag is clear. When set, the TI flag indicates that the index portion of the error code
     * refers to a segment or gate descriptor in the LDT; when clear, it indicates that the index refers to a descriptor in the
     * current GDT.
    UINT32 GdtLdt                                                  : 1;
#define EXCEPTION_ERROR_CODE_GDT_LDT_BIT                             2
#define EXCEPTION_ERROR_CODE_GDT_LDT_FLAG                            0x04
#define EXCEPTION_ERROR_CODE_GDT_LDT_MASK                            0x01
#define EXCEPTION_ERROR_CODE_GDT_LDT(_)                              (((_) >> 2) & 0x01)
     * [Bits 15:3] The segment selector index field provides an index into the IDT, GDT, or current LDT to the segment or gate
     * selector being referenced by the error code. In some cases the error code is null (all bits are clear except possibly
     * EXT). A null error code indicates that the error was not caused by a reference to a specific segment or that a null
     * segment selector was referenced in an operation.
     *
    UINT32 Index                                                   : 13;
#define EXCEPTION_ERROR_CODE_INDEX_BIT                               3
#define EXCEPTION_ERROR_CODE_INDEX_FLAG                              0xFFF8
#define EXCEPTION_ERROR_CODE_INDEX_MASK                              0x1FFF
#define EXCEPTION_ERROR_CODE_INDEX(_)                                (((_) >> 3) & 0x1FFF)
    UINT32 Reserved1                                               : 16;
  };
  UINT32 AsUInt;
} EXCEPTION_ERROR_CODE;*/
return true
}

func (i *ia32)#define PAGE_FAULT_EXCEPTION_PRESENT()(ok bool){//col:23497
/*#define PAGE_FAULT_EXCEPTION_PRESENT(_)                              (((_) >> 0) & 0x01)
     * [Bit 1] If the access causing the page-fault exception was a write, this flag is 1; otherwise, it is 0. This flag
     * describes the access causing the page-fault exception, not the access rights specified by paging.
    UINT32 Write                                                   : 1;
#define PAGE_FAULT_EXCEPTION_WRITE_BIT                               1
#define PAGE_FAULT_EXCEPTION_WRITE_FLAG                              0x02
#define PAGE_FAULT_EXCEPTION_WRITE_MASK                              0x01
#define PAGE_FAULT_EXCEPTION_WRITE(_)                                (((_) >> 1) & 0x01)
     * [Bit 2] If a user-mode access caused the page-fault exception, this flag is 1; it is 0 if a supervisor-mode access did
     * so. This flag describes the access causing the page-fault exception, not the access rights specified by paging.
     *
    UINT32 UserModeAccess                                          : 1;
#define PAGE_FAULT_EXCEPTION_USER_MODE_ACCESS_BIT                    2
#define PAGE_FAULT_EXCEPTION_USER_MODE_ACCESS_FLAG                   0x04
#define PAGE_FAULT_EXCEPTION_USER_MODE_ACCESS_MASK                   0x01
#define PAGE_FAULT_EXCEPTION_USER_MODE_ACCESS(_)                     (((_) >> 2) & 0x01)
     * [Bit 3] This flag is 1 if there is no translation for the linear address because a reserved bit was set in one of the
     * pagingstructure entries used to translate that address. (Because reserved bits are not checked in a paging-structure
     * entry whose P flag is 0, bit 3 of the error code can be set only if bit 0 is also set). Bits reserved in the
     * paging-structure entries are reserved for future functionality. Software developers should be aware that such bits may
     * be used in the future and that a paging-structure entry that causes a page-fault exception on one processor might not do
     * so in the future.
    UINT32 ReservedBitViolation                                    : 1;
#define PAGE_FAULT_EXCEPTION_RESERVED_BIT_VIOLATION_BIT              3
#define PAGE_FAULT_EXCEPTION_RESERVED_BIT_VIOLATION_FLAG             0x08
#define PAGE_FAULT_EXCEPTION_RESERVED_BIT_VIOLATION_MASK             0x01
#define PAGE_FAULT_EXCEPTION_RESERVED_BIT_VIOLATION(_)               (((_) >> 3) & 0x01)
     * [Bit 4] This flag is 1 if (1) the access causing the page-fault exception was an instruction fetch; and (2) either (a)
     * CR4.SMEP = 1; or (b) both (i) CR4.PAE = 1 (either PAE paging or 4-level paging is in use); and (ii) IA32_EFER.NXE = 1.
     * Otherwise, the flag is 0. This flag describes the access causing the page-fault exception, not the access rights
     * specified by paging.
    UINT32 Execute                                                 : 1;
#define PAGE_FAULT_EXCEPTION_EXECUTE_BIT                             4
#define PAGE_FAULT_EXCEPTION_EXECUTE_FLAG                            0x10
#define PAGE_FAULT_EXCEPTION_EXECUTE_MASK                            0x01
#define PAGE_FAULT_EXCEPTION_EXECUTE(_)                              (((_) >> 4) & 0x01)
     * [Bit 5] This flag is 1 if (1) IA32_EFER.LMA = CR4.PKE = 1; (2) the access causing the page-fault exception was a data
     * access; (3) the linear address was a user-mode address with protection key i; and (5) the PKRU register is such that
     * either (a) ADi = 1; or (b) the following all hold: (i) WDi = 1; (ii) the access is a write access; and (iii) either
     * CR0.WP = 1 or the access causing the page-fault exception was a user-mode access.
     *
    UINT32 ProtectionKeyViolation                                  : 1;
#define PAGE_FAULT_EXCEPTION_PROTECTION_KEY_VIOLATION_BIT            5
#define PAGE_FAULT_EXCEPTION_PROTECTION_KEY_VIOLATION_FLAG           0x20
#define PAGE_FAULT_EXCEPTION_PROTECTION_KEY_VIOLATION_MASK           0x01
#define PAGE_FAULT_EXCEPTION_PROTECTION_KEY_VIOLATION(_)             (((_) >> 5) & 0x01)
     * [Bit 6] If the access causing the page-fault exception was a shadow-stack access (including shadow-stack accesses in
     * enclave mode), this flag is 1; otherwise, it is 0. This flag describes the access causing the page-fault exception, not
     * the access rights specified by paging.
     *
    UINT32 ShadowStack                                             : 1;
#define PAGE_FAULT_EXCEPTION_SHADOW_STACK_BIT                        6
#define PAGE_FAULT_EXCEPTION_SHADOW_STACK_FLAG                       0x40
#define PAGE_FAULT_EXCEPTION_SHADOW_STACK_MASK                       0x01
#define PAGE_FAULT_EXCEPTION_SHADOW_STACK(_)                         (((_) >> 6) & 0x01)
     * [Bit 7] This flag is 1 if there is no translation for the linear address using HLAT paging because, in one of the
     * paging- structure entries used to translate that address, either the P flag was 0 or a reserved bit was set. An error
     * code will set this flag only if it clears bit o or sets bit 3. This flag will not be set by a page fault resulting from
     * a violation of access rights, nor for one encountered during ordinary paging, including the case in which there has been
     * a restart of HLAT paging.
     *
    UINT32 Hlat                                                    : 1;
#define PAGE_FAULT_EXCEPTION_HLAT_BIT                                7
#define PAGE_FAULT_EXCEPTION_HLAT_FLAG                               0x80
#define PAGE_FAULT_EXCEPTION_HLAT_MASK                               0x01
#define PAGE_FAULT_EXCEPTION_HLAT(_)                                 (((_) >> 7) & 0x01)
    UINT32 Reserved1                                               : 7;
     * [Bit 15] This flag is 1 if the exception is unrelated to paging and resulted from violation of SGX-specific
     * access-control requirements. Because such a violation can occur only if there is no ordinary page fault, this flag is
     * set only if the P flag (bit 0) is 1 and the RSVD flag (bit 3) and the PK flag (bit 5) are both 0.
    UINT32 Sgx                                                     : 1;
#define PAGE_FAULT_EXCEPTION_SGX_BIT                                 15
#define PAGE_FAULT_EXCEPTION_SGX_FLAG                                0x8000
#define PAGE_FAULT_EXCEPTION_SGX_MASK                                0x01
#define PAGE_FAULT_EXCEPTION_SGX(_)                                  (((_) >> 15) & 0x01)
    UINT32 Reserved2                                               : 16;
  };
  UINT32 AsUInt;
} PAGE_FAULT_EXCEPTION;*/
return true
}

func (i *ia32) * of system memory, it allows the type of caching ()(ok bool){//col:23652
/* * of system memory, it allows the type of caching (also called memory type) to be specified.
 *
 *
 * System memory locations are not cached. All reads and writes appear on the system bus and are executed in program order
 * without reordering. No speculative memory accesses, pagetable walks, or prefetches of speculated branch targets are
 * made. This type of cache-control is useful for memory-mapped I/O devices. When used with normal RAM, it greatly reduces
 * processor performance.
#define MEMORY_TYPE_UNCACHEABLE                                      0x00000000
 *
 * System memory locations are not cached (as with uncacheable memory) and coherency is not enforced by the processor's bus
 * coherency protocol. Speculative reads are allowed. Writes may be delayed and combined in the write combining buffer (WC
 * buffer) to reduce memory accesses. If the WC buffer is partially filled, the writes may be delayed until the next
 * occurrence of a serializing event; such as, an SFENCE or MFENCE instruction, CPUID execution, a read or write to
 * uncached memory, an interrupt occurrence, or a LOCK instruction execution. This type of cache-control is appropriate for
 * video frame buffers, where the order of writes is unimportant as long as the writes update memory so they can be seen on
 * the graphics display. This memory type is available in the Pentium Pro and Pentium II processors by programming the
 * MTRRs; or in processor families starting from the Pentium III processors by programming the MTRRs or by selecting it
 * through the PAT.
 *
#define MEMORY_TYPE_WRITE_COMBINING                                  0x00000001
 *
 * Writes and reads to and from system memory are cached. Reads come from cache lines on cache hits; read misses cause
 * cache fills. Speculative reads are allowed. All writes are written to a cache line (when possible) and through to system
 * memory. When writing through to memory, invalid cache lines are never filled, and valid cache lines are either filled or
 * invalidated. Write combining is allowed. This type of cache-control is appropriate for frame buffers or when there are
 * devices on the system bus that access system memory, but do not perform snooping of memory accesses. It enforces
 * coherency between caches in the processors and system memory.
#define MEMORY_TYPE_WRITE_THROUGH                                    0x00000004
 *
 * Reads come from cache lines when possible, and read misses cause cache fills. Writes are propagated to the system bus
 * and cause corresponding cache lines on all processors on the bus to be invalidated. Speculative reads are allowed. This
 * memory type is available in processor families starting from the P6 family processors by programming the MTRRs.
#define MEMORY_TYPE_WRITE_PROTECTED                                  0x00000005
 *
 * Writes and reads to and from system memory are cached. Reads come from cache lines on cache hits; read misses cause
 * cache fills. Speculative reads are allowed. Write misses cause cache line fills (in processor families starting with the
 * P6 family processors), and writes are performed entirely in the cache, when possible. Write combining is allowed. The
 * write-back memory type reduces bus traffic by eliminating many unnecessary writes to system memory. Writes to a cache
 * line are not immediately forwarded to system memory; instead, they are accumulated in the cache. The modified cache
 * lines are written to system memory later, when a write-back operation is performed. Write-back operations are triggered
 * when cache lines need to be deallocated, such as when new cache lines are being allocated in a cache that is already
 * full. They also are triggered by the mechanisms used to maintain cache consistency. This type of cache-control provides
 * the best performance, but it requires that all devices that access system memory on the system bus be able to snoop
 * memory accesses to insure system memory and cache coherency.
#define MEMORY_TYPE_WRITE_BACK                                       0x00000006
 *
 * Has same characteristics as the strong uncacheable (UC) memory type, except that this memory type can be overridden by
 * programming the MTRRs for the WC memory type. This memory type is available in processor families starting from the
 * Pentium III processors and can only be selected through the PAT.
#define MEMORY_TYPE_UNCACHEABLE_MINUS                                0x00000007
#define MEMORY_TYPE_INVALID                                          0x000000FF
 *           VTD
 *        the register is 00b
 *
typedef struct
{
  union
  {
    struct
    {
       * [Bit 0] This field indicates whether the root-entry is present.
       * * 0: Indicates the root-entry is not present. All other fields are ignored by hardware.
       * * 1: Indicates the root-entry is present.
      UINT64 Present                                               : 1;
#define VTD_Lower64_PRESENT_BIT                                      0
#define VTD_Lower64_PRESENT_FLAG                                     0x01
#define VTD_Lower64_PRESENT_MASK                                     0x01
#define VTD_Lower64_PRESENT(_)                                       (((_) >> 0) & 0x01)
      UINT64 Reserved1                                             : 11;
       * [Bits 63:12] Pointer to Context-table for this bus. The Context-table is 4KB in size and size aligned. Hardware treats
       * bits 63:HAW as reserved (0), where HAW is the host address width of the platform.
      UINT64 ContextTablePointer                                   : 52;
#define VTD_Lower64_CONTEXT_TABLE_POINTER_BIT                        12
#define VTD_Lower64_CONTEXT_TABLE_POINTER_FLAG                       0xFFFFFFFFFFFFF000
#define VTD_Lower64_CONTEXT_TABLE_POINTER_MASK                       0xFFFFFFFFFFFFF
#define VTD_Lower64_CONTEXT_TABLE_POINTER(_)                         (((_) >> 12) & 0xFFFFFFFFFFFFF)
    };
    UINT64 AsUInt;
  } Lower64;
  union
  {
    struct
    {
       * [Bits 63:0] Reserved. Must be 0.
      UINT64 Reserved                                              : 64;
#define VTD_Upper64_RESERVED_BIT                                     0
#define VTD_Upper64_RESERVED_FLAG                                    0xFFFFFFFFFFFFFFFF
#define VTD_Upper64_RESERVED_MASK                                    0xFFFFFFFFFFFFFFFF
#define VTD_Upper64_RESERVED(_)                                      (((_) >> 0) & 0xFFFFFFFFFFFFFFFF)
    };
    UINT64 AsUInt;
  } Upper64;
} VTD_ROOT_ENTRY;*/
return true
}

func (i *ia32)       * * 0: Indicates the context-entry is not present. All other fields except Fault Processing Disable ()(ok bool){//col:23783
/*       * * 0: Indicates the context-entry is not present. All other fields except Fault Processing Disable (FPD) field are
       * ignored by hardware.
       * * 1: Indicates the context-entry is present.
      UINT64 Present                                               : 1;
#define VTD_Lower64_PRESENT_BIT                                      0
#define VTD_Lower64_PRESENT_FLAG                                     0x01
#define VTD_Lower64_PRESENT_MASK                                     0x01
#define VTD_Lower64_PRESENT(_)                                       (((_) >> 0) & 0x01)
       * [Bit 1] Enables or disables recording/reporting of qualified non-recoverable faults.
       * * 0: Qualified non-recoverable faults are recorded/reported for requests processed through this context-entry.
       * * 1: Qualified non-recoverable faults are not recorded/reported for requests processed through this context-entry.
       * This field is evaluated by hardware irrespective of the setting of the present (P) field.
      UINT64 FaultProcessingDisable                                : 1;
#define VTD_Lower64_FAULT_PROCESSING_DISABLE_BIT                     1
#define VTD_Lower64_FAULT_PROCESSING_DISABLE_FLAG                    0x02
#define VTD_Lower64_FAULT_PROCESSING_DISABLE_MASK                    0x01
#define VTD_Lower64_FAULT_PROCESSING_DISABLE(_)                      (((_) >> 1) & 0x01)
       * [Bits 3:2] This field is applicable only for requests-without-PASID, as hardware blocks all requests-with- PASID in
       * legacy mode before they can use context table.
       * * 00b: Untranslated requests are translated using second-level paging structures referenced through SLPTPTR field.
       * Translated requests and Translation Requests are blocked.
       * * 01b: Untranslated, Translated and Translation Requests are supported. This encoding is treated as reserved by hardware
       * implementations not supporting Device-TLBs (DT=0 in Extended Capability Register).
       * * 10b: Untranslated requests are processed as pass-through. SLPTPTR field is ignored by hardware. Translated and
       * Translation Requests are blocked. This encoding is treated by hardware as reserved for hardware implementations not
       * supporting Pass Through (PT=0 in Extended Capability Register).
       * * 11b: Reserved.
      UINT64 TranslationType                                       : 2;
#define VTD_Lower64_TRANSLATION_TYPE_BIT                             2
#define VTD_Lower64_TRANSLATION_TYPE_FLAG                            0x0C
#define VTD_Lower64_TRANSLATION_TYPE_MASK                            0x03
#define VTD_Lower64_TRANSLATION_TYPE(_)                              (((_) >> 2) & 0x03)
      UINT64 Reserved1                                             : 8;
       * [Bits 63:12] When the Translation-Type (TT) field is 00b or 01b, this field points to the base of second level paging
       * entries (described in Section 9.8).
       * Hardware treats bits 63:HAW as reserved (0), where HAW is the host address width of the platform.
       * This field is ignored by hardware when Translation-Type (TT) field is 10b (pass-through).
      UINT64 SecondLevelPageTranslationPointer                     : 52;
#define VTD_Lower64_SECOND_LEVEL_PAGE_TRANSLATION_POINTER_BIT        12
#define VTD_Lower64_SECOND_LEVEL_PAGE_TRANSLATION_POINTER_FLAG       0xFFFFFFFFFFFFF000
#define VTD_Lower64_SECOND_LEVEL_PAGE_TRANSLATION_POINTER_MASK       0xFFFFFFFFFFFFF
#define VTD_Lower64_SECOND_LEVEL_PAGE_TRANSLATION_POINTER(_)         (((_) >> 12) & 0xFFFFFFFFFFFFF)
    };
    UINT64 AsUInt;
  } Lower64;
  union
  {
    struct
    {
       * [Bits 2:0] When the Translation-type (TT) field is 00b or 01b, this field indicates the adjusted guest address- width
       * (AGAW) to be used by hardware for the second-level page-table walk. The following encodings are defined for this field:
       * * 000b: Reserved
       * * 001b: 39-bit AGAW (3-level page table)
       * * 010b: 48-bit AGAW (4-level page table)
       * * 011b: 57-bit AGAW (5-level page table)
       * * 100b-111b: Reserved
       * The value specified in this field must match an AGAW value supported by hardware (as reported in the SAGAW field in the
       * Capability Register).
       * When the Translation-type (TT) field indicates pass-through processing (10b), this field must be programmed to indicate
       * the largest AGAW value supported by hardware.
       * Untranslated requests-without-PASID processed through this context-entry and accessing addresses above 2X-1 (where X is
       * the AGAW value indicated by this field) are blocked and treated as translation faults.
      UINT64 AddressWidth                                          : 3;
#define VTD_Upper64_ADDRESS_WIDTH_BIT                                0
#define VTD_Upper64_ADDRESS_WIDTH_FLAG                               0x07
#define VTD_Upper64_ADDRESS_WIDTH_MASK                               0x07
#define VTD_Upper64_ADDRESS_WIDTH(_)                                 (((_) >> 0) & 0x07)
       * [Bits 6:3] Hardware ignores the programming of this field.
      UINT64 Ignored                                               : 4;
#define VTD_Upper64_IGNORED_BIT                                      3
#define VTD_Upper64_IGNORED_FLAG                                     0x78
#define VTD_Upper64_IGNORED_MASK                                     0x0F
#define VTD_Upper64_IGNORED(_)                                       (((_) >> 3) & 0x0F)
      UINT64 Reserved1                                             : 1;
       * [Bits 17:8] Identifier for the domain to which this context-entry maps. Hardware may use the domain identifier to tag
       * its internal caches.
       * The Capability Register reports the domain-id width supported by hardware. For implementations supporting less than
       * 16-bit domain-ids, unused bits of this field are treated as reserved by hardware. For example, for implementation
       * supporting 8-bit domain-ids, bits 87:80 of this field are treated as reserved.
       * Context-entries programmed with the same domain identifier must always reference same address translation (SLPTPTR
       * field). Context-entries referencing same address translation are recommended to be programmed with same domain id for
       * hardware efficiency.
       * When Caching Mode (CM) field in Capability Register is reported as Set, the domain-id value of zero is architecturally
       * reserved. Software must not use domain-id value of zero when CM is Set.
      UINT64 DomainIdentifier                                      : 10;
#define VTD_Upper64_DOMAIN_IDENTIFIER_BIT                            8
#define VTD_Upper64_DOMAIN_IDENTIFIER_FLAG                           0x3FF00
#define VTD_Upper64_DOMAIN_IDENTIFIER_MASK                           0x3FF
#define VTD_Upper64_DOMAIN_IDENTIFIER(_)                             (((_) >> 8) & 0x3FF)
      UINT64 Reserved2                                             : 46;
    };
    UINT64 AsUInt;
  } Upper64;
} VTD_CONTEXT_ENTRY;*/
return true
}

func (i *ia32)#define VTD_VERSION_MINOR()(ok bool){//col:23835
/*#define VTD_VERSION_MINOR(_)                                         (((_) >> 0) & 0x0F)
     *
     * [Bits 7:4] Indicates Major Version of Implementation.
    UINT32 Major                                                   : 4;
#define VTD_VERSION_MAJOR_BIT                                        4
#define VTD_VERSION_MAJOR_FLAG                                       0xF0
#define VTD_VERSION_MAJOR_MASK                                       0x0F
#define VTD_VERSION_MAJOR(_)                                         (((_) >> 4) & 0x0F)
    UINT32 Reserved1                                               : 24;
  };
  UINT32 AsUInt;
} VTD_VERSION_REGISTER;*/
return true
}

func (i *ia32)#define VTD_CAPABILITY_NUMBER_OF_DOMAINS_SUPPORTED()(ok bool){//col:24192
/*#define VTD_CAPABILITY_NUMBER_OF_DOMAINS_SUPPORTED(_)                (((_) >> 0) & 0x07)
     *
     * [Bit 3]
     * * 0: Indicates advanced fault logging is not supported. Only primary fault logging is supported.
     * * 1: Indicates advanced fault logging is supported.
    UINT64 AdvancedFaultLogging                                    : 1;
#define VTD_CAPABILITY_ADVANCED_FAULT_LOGGING_BIT                    3
#define VTD_CAPABILITY_ADVANCED_FAULT_LOGGING_FLAG                   0x08
#define VTD_CAPABILITY_ADVANCED_FAULT_LOGGING_MASK                   0x01
#define VTD_CAPABILITY_ADVANCED_FAULT_LOGGING(_)                     (((_) >> 3) & 0x01)
     *
     * [Bit 4]
     * * 0: Indicates no write-buffer flushing is needed to ensure changes to memory-resident structures are visible to
     * hardware.
     * * 1: Indicates software must explicitly flush the write buffers to ensure updates made to memory-resident remapping
     * structures are visible to hardware.
    UINT64 RequiredWriteBufferFlushing                             : 1;
#define VTD_CAPABILITY_REQUIRED_WRITE_BUFFER_FLUSHING_BIT            4
#define VTD_CAPABILITY_REQUIRED_WRITE_BUFFER_FLUSHING_FLAG           0x10
#define VTD_CAPABILITY_REQUIRED_WRITE_BUFFER_FLUSHING_MASK           0x01
#define VTD_CAPABILITY_REQUIRED_WRITE_BUFFER_FLUSHING(_)             (((_) >> 4) & 0x01)
     *
     * [Bit 5]
     * * 0: Indicates protected low-memory region is not supported.
     * * 1: Indicates protected low-memory region is supported.
    UINT64 ProtectedLowMemoryRegion                                : 1;
#define VTD_CAPABILITY_PROTECTED_LOW_MEMORY_REGION_BIT               5
#define VTD_CAPABILITY_PROTECTED_LOW_MEMORY_REGION_FLAG              0x20
#define VTD_CAPABILITY_PROTECTED_LOW_MEMORY_REGION_MASK              0x01
#define VTD_CAPABILITY_PROTECTED_LOW_MEMORY_REGION(_)                (((_) >> 5) & 0x01)
     *
     * [Bit 6]
     * * 0: Indicates protected high-memory region is not supported.
     * * 1: Indicates protected high-memory region is supported.
    UINT64 ProtectedHighMemoryRegion                               : 1;
#define VTD_CAPABILITY_PROTECTED_HIGH_MEMORY_REGION_BIT              6
#define VTD_CAPABILITY_PROTECTED_HIGH_MEMORY_REGION_FLAG             0x40
#define VTD_CAPABILITY_PROTECTED_HIGH_MEMORY_REGION_MASK             0x01
#define VTD_CAPABILITY_PROTECTED_HIGH_MEMORY_REGION(_)               (((_) >> 6) & 0x01)
     *
     * [Bit 7] This field applies to all DMA and Interrupt remap tables except FLtables. Hardware will not cache faulting
     * FL-only translations in IOTLB or FL-paging-structure caches.
     * * 0: Not-present and erroneous entries are not cached in any of the remapping caches. Invalidations are not required for
     * modifications to individual not present or invalid entries. However, any modifications that result in decreasing the
     * effective permissions or partial permission increases require invalidations for them to be effective.
     * * 1: Not-present and erroneous mappings may be cached in the remapping caches. Any software updates to the remapping
     * structures (including updates to "not-present" or erroneous entries) require explicit invalidation.
    UINT64 CachingMode                                             : 1;
#define VTD_CAPABILITY_CACHING_MODE_BIT                              7
#define VTD_CAPABILITY_CACHING_MODE_FLAG                             0x80
#define VTD_CAPABILITY_CACHING_MODE_MASK                             0x01
#define VTD_CAPABILITY_CACHING_MODE(_)                               (((_) >> 7) & 0x01)
     *
     * [Bits 12:8] This 5-bit field indicates the supported adjusted guest address widths (which in turn represents the levels
     * of page-table walks for the 4KB base page size) supported by the hardware implementation.
     * A value of 1 in any of these bits indicates the corresponding adjusted guest address width is supported. The adjusted
     * guest address widths corresponding to various bit positions within this field are:
     * * 0: Reserved
     * * 1: 39-bit AGAW (3-level page-table)
     * * 2: 48-bit AGAW (4-level page-table)
     * * 3: 57-bit AGAW (5-level page-table)
     * * 4: Reserved
     * Software must ensure that the adjusted guest address width used to set up the page tables is one of the supported guest
     * address widths reported in this field.
     * Hardware implementations reporting second-level translation support (SLTS) field as Clear also report this field as 0.
    UINT64 SupportedAdjustedGuestAddressWidths                     : 5;
#define VTD_CAPABILITY_SUPPORTED_ADJUSTED_GUEST_ADDRESS_WIDTHS_BIT   8
#define VTD_CAPABILITY_SUPPORTED_ADJUSTED_GUEST_ADDRESS_WIDTHS_FLAG  0x1F00
#define VTD_CAPABILITY_SUPPORTED_ADJUSTED_GUEST_ADDRESS_WIDTHS_MASK  0x1F
#define VTD_CAPABILITY_SUPPORTED_ADJUSTED_GUEST_ADDRESS_WIDTHS(_)    (((_) >> 8) & 0x1F)
    UINT64 Reserved1                                               : 3;
     *
     * [Bits 21:16] This field indicates the maximum guest physical address width supported by second-level translation in
     * remapping hardware. The Maximum Guest Address Width (MGAW) is computed as (N+1), where N is the valued reported in this
     * field. For example, a hardware implementation supporting 48-bit MGAW reports a value of 47 (101111b) in this field.
     * If the value in this field is X, untranslated DMA requests with addresses above 2(X+1)-1 that are subjected to
     * second-level translation are blocked by hardware. Device-TLB translation requests to addresses above 2(X+1)-1 that are
     * subjected to second-level translation from allowed devices return a null Translation-Completion Data with R=W=0.
     * Guest addressability for a given DMA request is limited to the minimum of the value reported through this field and the
     * adjusted guest address width of the corresponding page-table structure. (Adjusted guest address widths supported by
     * hardware are reported through the SAGAW field).
     * Implementations must support MGAW at least equal to the physical addressability (host address width) of the platform.
    UINT64 MaximumGuestAddressWidth                                : 6;
#define VTD_CAPABILITY_MAXIMUM_GUEST_ADDRESS_WIDTH_BIT               16
#define VTD_CAPABILITY_MAXIMUM_GUEST_ADDRESS_WIDTH_FLAG              0x3F0000
#define VTD_CAPABILITY_MAXIMUM_GUEST_ADDRESS_WIDTH_MASK              0x3F
#define VTD_CAPABILITY_MAXIMUM_GUEST_ADDRESS_WIDTH(_)                (((_) >> 16) & 0x3F)
     *
     * [Bit 22]
     * * 0: Indicates the remapping hardware unit blocks (and treats as fault) zero length DMA read requests to write-only
     * pages.
     * * 1: Indicates the remapping hardware unit supports zero length DMA read requests to write-only pages.
     * DMA remapping hardware implementations are recommended to report ZLR field as Set.
    UINT64 ZeroLengthRead                                          : 1;
#define VTD_CAPABILITY_ZERO_LENGTH_READ_BIT                          22
#define VTD_CAPABILITY_ZERO_LENGTH_READ_FLAG                         0x400000
#define VTD_CAPABILITY_ZERO_LENGTH_READ_MASK                         0x01
#define VTD_CAPABILITY_ZERO_LENGTH_READ(_)                           (((_) >> 22) & 0x01)
     *
     * [Bit 23] This field must be reported as 0 to ensure backward compatibility with older software.
    UINT64 Deprecated                                              : 1;
#define VTD_CAPABILITY_DEPRECATED_BIT                                23
#define VTD_CAPABILITY_DEPRECATED_FLAG                               0x800000
#define VTD_CAPABILITY_DEPRECATED_MASK                               0x01
#define VTD_CAPABILITY_DEPRECATED(_)                                 (((_) >> 23) & 0x01)
     *
     * [Bits 33:24] This field specifies the offset of the first fault recording register relative to the register base address
     * of this remapping hardware unit. If the register base address is X, and the value reported in this field is Y, the
     * address for the first fault recording register is calculated as X+(16*Y).
    UINT64 FaultRecordingRegisterOffset                            : 10;
#define VTD_CAPABILITY_FAULT_RECORDING_REGISTER_OFFSET_BIT           24
#define VTD_CAPABILITY_FAULT_RECORDING_REGISTER_OFFSET_FLAG          0x3FF000000
#define VTD_CAPABILITY_FAULT_RECORDING_REGISTER_OFFSET_MASK          0x3FF
#define VTD_CAPABILITY_FAULT_RECORDING_REGISTER_OFFSET(_)            (((_) >> 24) & 0x3FF)
     *
     * [Bits 37:34] This field indicates the large page sizes supported by hardware.
     * A value of 1 in any of these bits indicates the corresponding large page size is supported. The large-page sizes
     * corresponding to various bit positions within this field are:
     * * 0: 21-bit offset to page frame (2MB)
     * * 1: 30-bit offset to page frame (1GB)
     * * 2: Reserved
     * * 3: Reserved
     * Hardware implementations supporting a specific large-page size must support all smaller large-page sizes. i.e., only
     * valid values for this field are 0000b, 0001b, 0011b.
    UINT64 SecondLevelLargePageSupport                             : 4;
#define VTD_CAPABILITY_SECOND_LEVEL_LARGE_PAGE_SUPPORT_BIT           34
#define VTD_CAPABILITY_SECOND_LEVEL_LARGE_PAGE_SUPPORT_FLAG          0x3C00000000
#define VTD_CAPABILITY_SECOND_LEVEL_LARGE_PAGE_SUPPORT_MASK          0x0F
#define VTD_CAPABILITY_SECOND_LEVEL_LARGE_PAGE_SUPPORT(_)            (((_) >> 34) & 0x0F)
    UINT64 Reserved2                                               : 1;
     *
     * [Bit 39]
     * * 0: Hardware supports only global and domain-selective invalidates for IOTLB.
     * * 1: Hardware supports page-selective, domain-selective, and global invalidates for IOTLB.
     * Hardware implementations reporting this field as Set are recommended to support a Maximum Address Mask Value (MAMV)
     * value of at least 9 (or 18 if supporting 1GB pages with second level translation).
     * This field is applicable only for IOTLB invalidations for second-level translation. Irrespective of value reported in
     * this field, implementations supporting SMTS must support page/address selective IOTLB invalidation for first-level
     * translation.
    UINT64 PageSelectiveInvalidation                               : 1;
#define VTD_CAPABILITY_PAGE_SELECTIVE_INVALIDATION_BIT               39
#define VTD_CAPABILITY_PAGE_SELECTIVE_INVALIDATION_FLAG              0x8000000000
#define VTD_CAPABILITY_PAGE_SELECTIVE_INVALIDATION_MASK              0x01
#define VTD_CAPABILITY_PAGE_SELECTIVE_INVALIDATION(_)                (((_) >> 39) & 0x01)
     *
     * [Bits 47:40] Number of fault recording registers is computed as N+1, where N is the value reported in this field.
     * Implementations must support at least one fault recording register (NFR = 0) for each remapping hardware unit in the
     * platform.
     * The maximum number of fault recording registers per remapping hardware unit is 256.
    UINT64 NumberOfFaultRecordingRegisters                         : 8;
#define VTD_CAPABILITY_NUMBER_OF_FAULT_RECORDING_REGISTERS_BIT       40
#define VTD_CAPABILITY_NUMBER_OF_FAULT_RECORDING_REGISTERS_FLAG      0xFF0000000000
#define VTD_CAPABILITY_NUMBER_OF_FAULT_RECORDING_REGISTERS_MASK      0xFF
#define VTD_CAPABILITY_NUMBER_OF_FAULT_RECORDING_REGISTERS(_)        (((_) >> 40) & 0xFF)
     *
     * [Bits 53:48] The value in this field indicates the maximum supported value for the Address Mask (AM) field in the
     * Invalidation Address register (IVA_REG), and IOTLB Invalidation Descriptor (iotlb_inv_dsc) used for invalidations of
     * second-level translation.
     * This field is valid when the PSI field in Capability register is reported as Set.
     * Independent of value reported in this field, implementations supporting SMTS must support address-selective PASID-based
     * IOTLB invalidations (p_iotlb_inv_dsc) with any defined address mask.
    UINT64 MaximumAddressMaskValue                                 : 6;
#define VTD_CAPABILITY_MAXIMUM_ADDRESS_MASK_VALUE_BIT                48
#define VTD_CAPABILITY_MAXIMUM_ADDRESS_MASK_VALUE_FLAG               0x3F000000000000
#define VTD_CAPABILITY_MAXIMUM_ADDRESS_MASK_VALUE_MASK               0x3F
#define VTD_CAPABILITY_MAXIMUM_ADDRESS_MASK_VALUE(_)                 (((_) >> 48) & 0x3F)
     *
     * [Bit 54]
     * * 0: Hardware does not support draining of write requests on IOTLB Invalidation.
     * * 1: Hardware supports draining of write requests on IOTLB Invalidation.
     * Hardware implementation with Major Version 2 or higher (VER_REG), always performs required drain without software
     * explicitly requesting a drain in IOTLB invalidation. This field is deprecated and hardware will always report it as 1 to
     * maintain backward compatibility with software.
    UINT64 WriteDraining                                           : 1;
#define VTD_CAPABILITY_WRITE_DRAINING_BIT                            54
#define VTD_CAPABILITY_WRITE_DRAINING_FLAG                           0x40000000000000
#define VTD_CAPABILITY_WRITE_DRAINING_MASK                           0x01
#define VTD_CAPABILITY_WRITE_DRAINING(_)                             (((_) >> 54) & 0x01)
     *
     * [Bit 55]
     * * 0: Hardware does not support draining of read requests on IOTLB Invalidation.
     * * 1: Hardware supports draining of read requests on IOTLB Invalidation.
     * Hardware implementation with Major Version 2 or higher (VER_REG), always performs required drain without software
     * explicitly requesting a drain in IOTLB invalidation. This field is deprecated and hardware will always report it as 1 to
     * maintain backward compatibility with software.
    UINT64 ReadDraining                                            : 1;
#define VTD_CAPABILITY_READ_DRAINING_BIT                             55
#define VTD_CAPABILITY_READ_DRAINING_FLAG                            0x80000000000000
#define VTD_CAPABILITY_READ_DRAINING_MASK                            0x01
#define VTD_CAPABILITY_READ_DRAINING(_)                              (((_) >> 55) & 0x01)
     *
     * [Bit 56] A value of 1 in this field indicates 1-GByte page size is supported for first-level translation.
     * Hardware implementation reporting First-level Translation Support (FLTS) as Clear also report this field as Clear.
    UINT64 FirstLevel1GbytePageSupport                             : 1;
#define VTD_CAPABILITY_FIRST_LEVEL_1GBYTE_PAGE_SUPPORT_BIT           56
#define VTD_CAPABILITY_FIRST_LEVEL_1GBYTE_PAGE_SUPPORT_FLAG          0x100000000000000
#define VTD_CAPABILITY_FIRST_LEVEL_1GBYTE_PAGE_SUPPORT_MASK          0x01
#define VTD_CAPABILITY_FIRST_LEVEL_1GBYTE_PAGE_SUPPORT(_)            (((_) >> 56) & 0x01)
    UINT64 Reserved3                                               : 2;
     *
     * [Bit 59]
     * * 0: Hardware does not support Posting of Interrupts.
     * * 1: Hardware supports Posting of Interrupts.
     * Hardware implementation reporting Interrupt Remapping support (IR) field in Extended Capability Register as Clear also
     * report this field as Clear.
    UINT64 PostedInterruptsSupport                                 : 1;
#define VTD_CAPABILITY_POSTED_INTERRUPTS_SUPPORT_BIT                 59
#define VTD_CAPABILITY_POSTED_INTERRUPTS_SUPPORT_FLAG                0x800000000000000
#define VTD_CAPABILITY_POSTED_INTERRUPTS_SUPPORT_MASK                0x01
#define VTD_CAPABILITY_POSTED_INTERRUPTS_SUPPORT(_)                  (((_) >> 59) & 0x01)
     *
     * [Bit 60]
     * * 0: Hardware does not support 5-level paging for first-level translation.
     * * 1: Hardware supports 5-level paging for first-level translation.
     * Hardware implementation reporting First-level Translation Support (FLTS) as Clear also report this field as Clear.
    UINT64 FirstLevel5LevelPagingSupport                           : 1;
#define VTD_CAPABILITY_FIRST_LEVEL_5LEVEL_PAGING_SUPPORT_BIT         60
#define VTD_CAPABILITY_FIRST_LEVEL_5LEVEL_PAGING_SUPPORT_FLAG        0x1000000000000000
#define VTD_CAPABILITY_FIRST_LEVEL_5LEVEL_PAGING_SUPPORT_MASK        0x01
#define VTD_CAPABILITY_FIRST_LEVEL_5LEVEL_PAGING_SUPPORT(_)          (((_) >> 60) & 0x01)
    UINT64 Reserved4                                               : 1;
     *
     * [Bit 62]
     * * 0: Hardware does not invalidate all Interrupt remapping hardware translation caches as part of SIRTP flow.
     * * 1: Hardware invalidates all Interrupt remapping hardware translation caches as part of SIRTP flow.
    UINT64 EnhancedSetInterruptRemapTablePointerSupport            : 1;
#define VTD_CAPABILITY_ENHANCED_SET_INTERRUPT_REMAP_TABLE_POINTER_SUPPORT_BIT 62
#define VTD_CAPABILITY_ENHANCED_SET_INTERRUPT_REMAP_TABLE_POINTER_SUPPORT_FLAG 0x4000000000000000
#define VTD_CAPABILITY_ENHANCED_SET_INTERRUPT_REMAP_TABLE_POINTER_SUPPORT_MASK 0x01
#define VTD_CAPABILITY_ENHANCED_SET_INTERRUPT_REMAP_TABLE_POINTER_SUPPORT(_) (((_) >> 62) & 0x01)
     *
     * [Bit 63]
     * * 0: Hardware does not invalidate all DMA remapping hardware translation caches as part of SRTP flow.
     * * 1: Hardware invalidates all DMA remapping hardware translation caches as part of SRTP flow.
    UINT64 EnhancedSetRootTablePointerSupport                      : 1;
#define VTD_CAPABILITY_ENHANCED_SET_ROOT_TABLE_POINTER_SUPPORT_BIT   63
#define VTD_CAPABILITY_ENHANCED_SET_ROOT_TABLE_POINTER_SUPPORT_FLAG  0x8000000000000000
#define VTD_CAPABILITY_ENHANCED_SET_ROOT_TABLE_POINTER_SUPPORT_MASK  0x01
#define VTD_CAPABILITY_ENHANCED_SET_ROOT_TABLE_POINTER_SUPPORT(_)    (((_) >> 63) & 0x01)
  };
  UINT64 AsUInt;
} VTD_CAPABILITY_REGISTER;*/
return true
}

func (i *ia32)     * structures are coherent ()(ok bool){//col:24658
/*     * structures are coherent (snooped) or not.
     * * 0:Indicates hardware accesses to remapping structures are non-coherent.
     * * 1:Indicates hardware accesses to remapping structures are coherent.
     * Hardware access to advanced fault log, invalidation queue, invalidation semaphore, page-request queue are always
     * snooped.
    UINT64 PageWalkCoherency                                       : 1;
#define VTD_EXTENDED_CAPABILITY_PAGE_WALK_COHERENCY_BIT              0
#define VTD_EXTENDED_CAPABILITY_PAGE_WALK_COHERENCY_FLAG             0x01
#define VTD_EXTENDED_CAPABILITY_PAGE_WALK_COHERENCY_MASK             0x01
#define VTD_EXTENDED_CAPABILITY_PAGE_WALK_COHERENCY(_)               (((_) >> 0) & 0x01)
     *
     * [Bit 1]
     * * 0: Hardware does not support queued invalidations.
     * * 1: Hardware supports queued invalidations.
    UINT64 QueuedInvalidationSupport                               : 1;
#define VTD_EXTENDED_CAPABILITY_QUEUED_INVALIDATION_SUPPORT_BIT      1
#define VTD_EXTENDED_CAPABILITY_QUEUED_INVALIDATION_SUPPORT_FLAG     0x02
#define VTD_EXTENDED_CAPABILITY_QUEUED_INVALIDATION_SUPPORT_MASK     0x01
#define VTD_EXTENDED_CAPABILITY_QUEUED_INVALIDATION_SUPPORT(_)       (((_) >> 1) & 0x01)
     *
     * [Bit 2]
     * * 0: Hardware does not support Device-TLBs.
     * * 1: Hardware supports Device-TLBs.
     * Hardware implementation reporting Queued Invalidation support (QI) field as Clear also report this field as Clear.
    UINT64 DeviceTlbSupport                                        : 1;
#define VTD_EXTENDED_CAPABILITY_DEVICE_TLB_SUPPORT_BIT               2
#define VTD_EXTENDED_CAPABILITY_DEVICE_TLB_SUPPORT_FLAG              0x04
#define VTD_EXTENDED_CAPABILITY_DEVICE_TLB_SUPPORT_MASK              0x01
#define VTD_EXTENDED_CAPABILITY_DEVICE_TLB_SUPPORT(_)                (((_) >> 2) & 0x01)
     *
     * [Bit 3]
     * * 0: Hardware does not support interrupt remapping.
     * * 1: Hardware supports interrupt remapping.
     * Hardware implementation reporting Queued Invalidation support (QI) field as Clear also report this field as Clear.
    UINT64 InterruptRemappingSupport                               : 1;
#define VTD_EXTENDED_CAPABILITY_INTERRUPT_REMAPPING_SUPPORT_BIT      3
#define VTD_EXTENDED_CAPABILITY_INTERRUPT_REMAPPING_SUPPORT_FLAG     0x08
#define VTD_EXTENDED_CAPABILITY_INTERRUPT_REMAPPING_SUPPORT_MASK     0x01
#define VTD_EXTENDED_CAPABILITY_INTERRUPT_REMAPPING_SUPPORT(_)       (((_) >> 3) & 0x01)
     *
     * [Bit 4]
     * * 0: On Intel(R) 64 platforms, hardware supports only 8-bit APIC-IDs (xAPIC Mode).
     * * 1: On Intel(R) 64 platforms, hardware supports 32-bit APICIDs (x2APIC mode).
     * Hardware implementation reporting Interrupt Remapping support (IR) field as Clear also report this field as Clear.
    UINT64 ExtendedInterruptMode                                   : 1;
#define VTD_EXTENDED_CAPABILITY_EXTENDED_INTERRUPT_MODE_BIT          4
#define VTD_EXTENDED_CAPABILITY_EXTENDED_INTERRUPT_MODE_FLAG         0x10
#define VTD_EXTENDED_CAPABILITY_EXTENDED_INTERRUPT_MODE_MASK         0x01
#define VTD_EXTENDED_CAPABILITY_EXTENDED_INTERRUPT_MODE(_)           (((_) >> 4) & 0x01)
     *
     * [Bit 5] This field must be reported as 0 to ensure backward compatibility with older software.
    UINT64 Deprecated1                                             : 1;
#define VTD_EXTENDED_CAPABILITY_DEPRECATED1_BIT                      5
#define VTD_EXTENDED_CAPABILITY_DEPRECATED1_FLAG                     0x20
#define VTD_EXTENDED_CAPABILITY_DEPRECATED1_MASK                     0x01
#define VTD_EXTENDED_CAPABILITY_DEPRECATED1(_)                       (((_) >> 5) & 0x01)
     *
     * [Bit 6]
     * * 0: Hardware does not support pass-through translation type in context-entries and scalable-mode-pasid-table-entries.
     * * 1: Hardware supports pass-through translation type in context and scalable-mode-pasid-table-entries.
    UINT64 PassThrough                                             : 1;
#define VTD_EXTENDED_CAPABILITY_PASS_THROUGH_BIT                     6
#define VTD_EXTENDED_CAPABILITY_PASS_THROUGH_FLAG                    0x40
#define VTD_EXTENDED_CAPABILITY_PASS_THROUGH_MASK                    0x01
#define VTD_EXTENDED_CAPABILITY_PASS_THROUGH(_)                      (((_) >> 6) & 0x01)
     *
     * [Bit 7]
     * * 0: Hardware does not support 1-setting of the SNP field in the page-table entries.
     * * 1: Hardware supports the 1-setting of the SNP field in the page-table entries.
     * Implementations are recommended to support Snoop Control to support software usages that require Snoop Control for
     * assignment of devices behind a remapping hardware unit.
    UINT64 SnoopControl                                            : 1;
#define VTD_EXTENDED_CAPABILITY_SNOOP_CONTROL_BIT                    7
#define VTD_EXTENDED_CAPABILITY_SNOOP_CONTROL_FLAG                   0x80
#define VTD_EXTENDED_CAPABILITY_SNOOP_CONTROL_MASK                   0x01
#define VTD_EXTENDED_CAPABILITY_SNOOP_CONTROL(_)                     (((_) >> 7) & 0x01)
     *
     * [Bits 17:8] This field specifies the offset to the IOTLB registers relative to the register base address of this
     * remapping hardware unit.
     * If the register base address is X, and the value reported in this field is Y, the address for the IOTLB registers is
     * calculated as X+(16*Y).
    UINT64 IotlbRegisterOffset                                     : 10;
#define VTD_EXTENDED_CAPABILITY_IOTLB_REGISTER_OFFSET_BIT            8
#define VTD_EXTENDED_CAPABILITY_IOTLB_REGISTER_OFFSET_FLAG           0x3FF00
#define VTD_EXTENDED_CAPABILITY_IOTLB_REGISTER_OFFSET_MASK           0x3FF
#define VTD_EXTENDED_CAPABILITY_IOTLB_REGISTER_OFFSET(_)             (((_) >> 8) & 0x3FF)
    UINT64 Reserved1                                               : 2;
     *
     * [Bits 23:20] The value in this field indicates the maximum supported value for the Interrupt Mask (IM) field in the
     * Interrupt Entry Cache Invalidation Descriptor (iec_inv_dsc).
     * This field is unused and is reported as 0 if Interrupt Remapping support (IR) field is Clear.
    UINT64 MaximumHandleMaskValue                                  : 4;
#define VTD_EXTENDED_CAPABILITY_MAXIMUM_HANDLE_MASK_VALUE_BIT        20
#define VTD_EXTENDED_CAPABILITY_MAXIMUM_HANDLE_MASK_VALUE_FLAG       0xF00000
#define VTD_EXTENDED_CAPABILITY_MAXIMUM_HANDLE_MASK_VALUE_MASK       0x0F
#define VTD_EXTENDED_CAPABILITY_MAXIMUM_HANDLE_MASK_VALUE(_)         (((_) >> 20) & 0x0F)
     *
     * [Bit 24] In prior versions of this specification this bit was used to enumerate "Extended mode address translation"
     * which is now deprecated. This field must be reported as 0 to ensure backward compatibility with any software that
     * enables extended mode address translation.
    UINT64 Deprecated2                                             : 1;
#define VTD_EXTENDED_CAPABILITY_DEPRECATED2_BIT                      24
#define VTD_EXTENDED_CAPABILITY_DEPRECATED2_FLAG                     0x1000000
#define VTD_EXTENDED_CAPABILITY_DEPRECATED2_MASK                     0x01
#define VTD_EXTENDED_CAPABILITY_DEPRECATED2(_)                       (((_) >> 24) & 0x01)
     *
     * [Bit 25]
     * * 0: Hardware does not support Memory Type in first-level translation and Extended Memory type in second-level
     * translation.
     * * 1: Hardware supports Memory Type in first-level translation and Extended Memory type in second-level translation.
     * Hardware implementations reporting Scalable Mode Translation Support (SMTS) field as Clear also report this field as
     * Clear. Remapping hardware units with, one or more devices that operate in processor coherency domain, under its scope
     * must report this field as Set.
    UINT64 MemoryTypeSupport                                       : 1;
#define VTD_EXTENDED_CAPABILITY_MEMORY_TYPE_SUPPORT_BIT              25
#define VTD_EXTENDED_CAPABILITY_MEMORY_TYPE_SUPPORT_FLAG             0x2000000
#define VTD_EXTENDED_CAPABILITY_MEMORY_TYPE_SUPPORT_MASK             0x01
#define VTD_EXTENDED_CAPABILITY_MEMORY_TYPE_SUPPORT(_)               (((_) >> 25) & 0x01)
     *
     * [Bit 26]
     * * 0: Hardware does not support nested translations.
     * * 1: Hardware supports nested translations.
     * Hardware implementations reporting Scalable Mode Translation Support (SMTS) field as Clear or First-level Translation
     * Support (FLTS) field as Clear or Second-level Translation Support (SLTS) field as Clear also report this field as Clear.
    UINT64 NestedTranslationSupport                                : 1;
#define VTD_EXTENDED_CAPABILITY_NESTED_TRANSLATION_SUPPORT_BIT       26
#define VTD_EXTENDED_CAPABILITY_NESTED_TRANSLATION_SUPPORT_FLAG      0x4000000
#define VTD_EXTENDED_CAPABILITY_NESTED_TRANSLATION_SUPPORT_MASK      0x01
#define VTD_EXTENDED_CAPABILITY_NESTED_TRANSLATION_SUPPORT(_)        (((_) >> 26) & 0x01)
    UINT64 Reserved2                                               : 1;
     *
     * [Bit 28] This field must be reported as 0 to ensure backward compatibility with older software.
    UINT64 Deprecated3                                             : 1;
#define VTD_EXTENDED_CAPABILITY_DEPRECATED3_BIT                      28
#define VTD_EXTENDED_CAPABILITY_DEPRECATED3_FLAG                     0x10000000
#define VTD_EXTENDED_CAPABILITY_DEPRECATED3_MASK                     0x01
#define VTD_EXTENDED_CAPABILITY_DEPRECATED3(_)                       (((_) >> 28) & 0x01)
     *
     * [Bit 29]
     * * 0: Hardware does not support page requests.
     * * 1: Hardware supports page requests.
     * Hardware implementation reporting Device-TLB support (DT) field as Clear or Scalable Mode Translation Support (SMTS)
     * field as Clear also report this field as Clear.
    UINT64 PageRequestSupport                                      : 1;
#define VTD_EXTENDED_CAPABILITY_PAGE_REQUEST_SUPPORT_BIT             29
#define VTD_EXTENDED_CAPABILITY_PAGE_REQUEST_SUPPORT_FLAG            0x20000000
#define VTD_EXTENDED_CAPABILITY_PAGE_REQUEST_SUPPORT_MASK            0x01
#define VTD_EXTENDED_CAPABILITY_PAGE_REQUEST_SUPPORT(_)              (((_) >> 29) & 0x01)
     *
     * [Bit 30]
     * * 0: Hardware does not support requests-with-PASID seeking execute permission.
     * * 1: Hardware supports requests-with-PASID seeking execute permission.
     * Hardware implementations reporting Process Address Space ID support (PASID) field as Clear must report this field as
     * Clear.
    UINT64 ExecuteRequestSupport                                   : 1;
#define VTD_EXTENDED_CAPABILITY_EXECUTE_REQUEST_SUPPORT_BIT          30
#define VTD_EXTENDED_CAPABILITY_EXECUTE_REQUEST_SUPPORT_FLAG         0x40000000
#define VTD_EXTENDED_CAPABILITY_EXECUTE_REQUEST_SUPPORT_MASK         0x01
#define VTD_EXTENDED_CAPABILITY_EXECUTE_REQUEST_SUPPORT(_)           (((_) >> 30) & 0x01)
    UINT64 Reserved3                                               : 2;
     *
     * [Bit 33]
     * * 0: Hardware ignores the 'No Write' (NW) flag in Device-TLB translation-requests, and behaves as if NW is always 0.
     * * 1: Hardware supports the 'No Write' (NW) flag in Device-TLB translation-requests.
     * Hardware implementations reporting Device-TLB support (DT) field as Clear also report this field as Clear.
    UINT64 NoWriteFlagSupport                                      : 1;
#define VTD_EXTENDED_CAPABILITY_NO_WRITE_FLAG_SUPPORT_BIT            33
#define VTD_EXTENDED_CAPABILITY_NO_WRITE_FLAG_SUPPORT_FLAG           0x200000000
#define VTD_EXTENDED_CAPABILITY_NO_WRITE_FLAG_SUPPORT_MASK           0x01
#define VTD_EXTENDED_CAPABILITY_NO_WRITE_FLAG_SUPPORT(_)             (((_) >> 33) & 0x01)
     *
     * [Bit 34]
     * * 0: Hardware does not support the extended-accessed (EA) bit in first-level paging-structure entries.
     * * 1: Hardware supports the extended-accessed (EA) bit in first-level paging-structure entries.
     * Hardware implementations reporting Scalable-Mode Page-walk Coherency Support (SWPWCS) as Clear also report this field as
     * Clear.
    UINT64 ExtendedAccessedFlagSupport                             : 1;
#define VTD_EXTENDED_CAPABILITY_EXTENDED_ACCESSED_FLAG_SUPPORT_BIT   34
#define VTD_EXTENDED_CAPABILITY_EXTENDED_ACCESSED_FLAG_SUPPORT_FLAG  0x400000000
#define VTD_EXTENDED_CAPABILITY_EXTENDED_ACCESSED_FLAG_SUPPORT_MASK  0x01
#define VTD_EXTENDED_CAPABILITY_EXTENDED_ACCESSED_FLAG_SUPPORT(_)    (((_) >> 34) & 0x01)
     *
     * [Bits 39:35] This field reports the PASID size supported by the remapping hardware for requests-with-PASID. A value of N
     * in this field indicates hardware supports PASID field of N+1 bits (For example, value of 7 in this field, indicates
     * 8-bit PASIDs are supported).
     * Requests-with-PASID with PASID value beyond the limit specified by this field are treated as error by the remapping
     * hardware. This field is unused and reported as 0 if Scalable Mode Translation Support (SMTS) field is Clear.
    UINT64 PasidSizeSupported                                      : 5;
#define VTD_EXTENDED_CAPABILITY_PASID_SIZE_SUPPORTED_BIT             35
#define VTD_EXTENDED_CAPABILITY_PASID_SIZE_SUPPORTED_FLAG            0xF800000000
#define VTD_EXTENDED_CAPABILITY_PASID_SIZE_SUPPORTED_MASK            0x1F
#define VTD_EXTENDED_CAPABILITY_PASID_SIZE_SUPPORTED(_)              (((_) >> 35) & 0x1F)
     *
     * [Bit 40]
     * * 0: Hardware does not support requests tagged with Process Address Space IDs.
     * * 1: Hardware supports requests tagged with Process Address Space IDs.
     * Hardware implementations reporting Scalable Mode Translation Support (SMTS) field as Clear also report this field as
     * Clear.
    UINT64 ProcessAddressSpaceIdSupport                            : 1;
#define VTD_EXTENDED_CAPABILITY_PROCESS_ADDRESS_SPACE_ID_SUPPORT_BIT 40
#define VTD_EXTENDED_CAPABILITY_PROCESS_ADDRESS_SPACE_ID_SUPPORT_FLAG 0x10000000000
#define VTD_EXTENDED_CAPABILITY_PROCESS_ADDRESS_SPACE_ID_SUPPORT_MASK 0x01
#define VTD_EXTENDED_CAPABILITY_PROCESS_ADDRESS_SPACE_ID_SUPPORT(_)  (((_) >> 40) & 0x01)
     *
     * [Bit 41]
     * * 0: Hardware does not support Device-TLB Invalidation Throttling.
     * * 1: Hardware supports Device-TLB Invalidation Throttling.
     * Hardware implementations reporting Device-TLB support (DT) as Clear also report this field as Clear.
    UINT64 DeviceTlbInvalidationThrottle                           : 1;
#define VTD_EXTENDED_CAPABILITY_DEVICE_TLB_INVALIDATION_THROTTLE_BIT 41
#define VTD_EXTENDED_CAPABILITY_DEVICE_TLB_INVALIDATION_THROTTLE_FLAG 0x20000000000
#define VTD_EXTENDED_CAPABILITY_DEVICE_TLB_INVALIDATION_THROTTLE_MASK 0x01
#define VTD_EXTENDED_CAPABILITY_DEVICE_TLB_INVALIDATION_THROTTLE(_)  (((_) >> 41) & 0x01)
     *
     * [Bit 42]
     * * 0: Hardware does not support Page-request Drain (PD) flag in inv_wait_dsc.
     * * 1: Hardware supports Page-request Drain (PD) flag in inv_wait_dsc.
     * Hardware implementations reporting Device-TLB support (DT) as Clear also report this field as Clear.
    UINT64 PageRequestDrainSupport                                 : 1;
#define VTD_EXTENDED_CAPABILITY_PAGE_REQUEST_DRAIN_SUPPORT_BIT       42
#define VTD_EXTENDED_CAPABILITY_PAGE_REQUEST_DRAIN_SUPPORT_FLAG      0x40000000000
#define VTD_EXTENDED_CAPABILITY_PAGE_REQUEST_DRAIN_SUPPORT_MASK      0x01
#define VTD_EXTENDED_CAPABILITY_PAGE_REQUEST_DRAIN_SUPPORT(_)        (((_) >> 42) & 0x01)
     *
     * [Bit 43]
     * * 0: Hardware does not support Scalable Mode DMA Remapping.
     * * 1: Hardware supports Scalable Mode DMA Remapping through scalable-mode context-table and PASID-table structures.
     * Hardware implementation reporting Queued Invalidation (QI) field as Clear also report this field as Clear.
     * Hardware implementation reporting First-Level Translation Support (FLTS), Second-level Translation Support (SLTS) and
     * Pass-through Support (PT) as Clear also report this field as Clear.
    UINT64 ScalableModeTranslationSupport                          : 1;
#define VTD_EXTENDED_CAPABILITY_SCALABLE_MODE_TRANSLATION_SUPPORT_BIT 43
#define VTD_EXTENDED_CAPABILITY_SCALABLE_MODE_TRANSLATION_SUPPORT_FLAG 0x80000000000
#define VTD_EXTENDED_CAPABILITY_SCALABLE_MODE_TRANSLATION_SUPPORT_MASK 0x01
#define VTD_EXTENDED_CAPABILITY_SCALABLE_MODE_TRANSLATION_SUPPORT(_) (((_) >> 43) & 0x01)
     *
     * [Bit 44]
     * * 0: Hardware does not support command submission to virtual-DMA Remapping hardware.
     * * 1: Hardware does support command submission to virtual- DMA Remapping hardware.
     * Hardware implementations of this architecture report a value of 0 in this field. Software implementations (emulation) of
     * this architecture may report VCS=1.
     * Software managing remapping hardware should be written to handle both values of VCS.
    UINT64 VirtualCommandSupport                                   : 1;
#define VTD_EXTENDED_CAPABILITY_VIRTUAL_COMMAND_SUPPORT_BIT          44
#define VTD_EXTENDED_CAPABILITY_VIRTUAL_COMMAND_SUPPORT_FLAG         0x100000000000
#define VTD_EXTENDED_CAPABILITY_VIRTUAL_COMMAND_SUPPORT_MASK         0x01
#define VTD_EXTENDED_CAPABILITY_VIRTUAL_COMMAND_SUPPORT(_)           (((_) >> 44) & 0x01)
     *
     * [Bit 45]
     * * 0: Hardware does not support Accessed/Dirty bits in Second- Level translation.
     * * 1: Hardware supports Accessed/Dirty bits in Second-Level translation.
     * Hardware implementations reporting Scalable-Mode Page-walk Coherency Support (SMPWCS) as Clear also report this field as
     * Clear.
    UINT64 SecondLevelAccessedDirtySupport                         : 1;
#define VTD_EXTENDED_CAPABILITY_SECOND_LEVEL_ACCESSED_DIRTY_SUPPORT_BIT 45
#define VTD_EXTENDED_CAPABILITY_SECOND_LEVEL_ACCESSED_DIRTY_SUPPORT_FLAG 0x200000000000
#define VTD_EXTENDED_CAPABILITY_SECOND_LEVEL_ACCESSED_DIRTY_SUPPORT_MASK 0x01
#define VTD_EXTENDED_CAPABILITY_SECOND_LEVEL_ACCESSED_DIRTY_SUPPORT(_) (((_) >> 45) & 0x01)
     *
     * [Bit 46]
     * * 0: Hardware does not support PASID Granular Translation Type of second-level (PGTT=010b) in scalable-mode PASIDTable
     * entry.
     * * 1: Hardware supports PASID Granular Translation Type of second-level (PGTT=010b) in scalable-mode PASID-Table entry.
    UINT64 SecondLevelTranslationSupport                           : 1;
#define VTD_EXTENDED_CAPABILITY_SECOND_LEVEL_TRANSLATION_SUPPORT_BIT 46
#define VTD_EXTENDED_CAPABILITY_SECOND_LEVEL_TRANSLATION_SUPPORT_FLAG 0x400000000000
#define VTD_EXTENDED_CAPABILITY_SECOND_LEVEL_TRANSLATION_SUPPORT_MASK 0x01
#define VTD_EXTENDED_CAPABILITY_SECOND_LEVEL_TRANSLATION_SUPPORT(_)  (((_) >> 46) & 0x01)
     *
     * [Bit 47]
     * * 0: Hardware does not support PASID Granular Translation Type of first-level (PGTT=001b) in scalable-mode PASIDTable
     * entry.
     * * 1: Hardware supports PASID Granular Translation Type of first-level (PGTT=001b) in scalable-mode PASID-Table entry.
     * Hardware implementations reporting Scalable Mode Translation Support (SMTS) as Clear also report this field as Clear
    UINT64 FirstLevelTranslationSupport                            : 1;
#define VTD_EXTENDED_CAPABILITY_FIRST_LEVEL_TRANSLATION_SUPPORT_BIT  47
#define VTD_EXTENDED_CAPABILITY_FIRST_LEVEL_TRANSLATION_SUPPORT_FLAG 0x800000000000
#define VTD_EXTENDED_CAPABILITY_FIRST_LEVEL_TRANSLATION_SUPPORT_MASK 0x01
#define VTD_EXTENDED_CAPABILITY_FIRST_LEVEL_TRANSLATION_SUPPORT(_)   (((_) >> 47) & 0x01)
     *
     * [Bit 48]
     * * 0: Hardware access to paging structures accessed through PASID-table entry are not snooped.
     * * 1: Hardware access to paging structures accessed through PASID-table entry are snooped if PWSNP field in PASID-table
     * entry is Set. Paging-structures accessed through PASID-table entry are not snooped if PWSNP field in PASID-table entry
     * is Clear.
     * Hardware implementations reporting Scalable Mode Translation Support (SMTS) as Clear also report this field as Clear.
    UINT64 ScalableModePageWalkCoherency                           : 1;
#define VTD_EXTENDED_CAPABILITY_SCALABLE_MODE_PAGE_WALK_COHERENCY_BIT 48
#define VTD_EXTENDED_CAPABILITY_SCALABLE_MODE_PAGE_WALK_COHERENCY_FLAG 0x1000000000000
#define VTD_EXTENDED_CAPABILITY_SCALABLE_MODE_PAGE_WALK_COHERENCY_MASK 0x01
#define VTD_EXTENDED_CAPABILITY_SCALABLE_MODE_PAGE_WALK_COHERENCY(_) (((_) >> 48) & 0x01)
     *
     * [Bit 49]
     * * 0: Hardware does not support RID_PASID field in scalable mode context-entry. It uses the value of 0 for RID_PASID.
     * * 1: Hardware supports the RID_PASID field in scalable-mode context-entry.
     * Hardware implementations reporting Scalable Mode Translation Support (SMTS) as Clear also report this field as Clear.
    UINT64 RidPasidSupport                                         : 1;
#define VTD_EXTENDED_CAPABILITY_RID_PASID_SUPPORT_BIT                49
#define VTD_EXTENDED_CAPABILITY_RID_PASID_SUPPORT_FLAG               0x2000000000000
#define VTD_EXTENDED_CAPABILITY_RID_PASID_SUPPORT_MASK               0x01
#define VTD_EXTENDED_CAPABILITY_RID_PASID_SUPPORT(_)                 (((_) >> 49) & 0x01)
    UINT64 Reserved4                                               : 2;
     *
     * [Bit 52]
     * * 0: Hardware does not support Abort DMA Mode.
     * * 1: Hardware supports Abort DMA Mode.
    UINT64 AbortDmaModeSupport                                     : 1;
#define VTD_EXTENDED_CAPABILITY_ABORT_DMA_MODE_SUPPORT_BIT           52
#define VTD_EXTENDED_CAPABILITY_ABORT_DMA_MODE_SUPPORT_FLAG          0x10000000000000
#define VTD_EXTENDED_CAPABILITY_ABORT_DMA_MODE_SUPPORT_MASK          0x01
#define VTD_EXTENDED_CAPABILITY_ABORT_DMA_MODE_SUPPORT(_)            (((_) >> 52) & 0x01)
     *
     * [Bit 53]
     * * 0: Hardware does not support the RID_PRIV field in the scalable-mode context-entry. It uses the value of 0 for
     * RID_PRIV.
     * * 1: Hardware supports the RID_PRIV field in the scalable mode context-entry.
     * Hardware implementations reporting Supervisor Request Support (SRS) as Clear also report this field as Clear.
    UINT64 RidPrivSupport                                          : 1;
#define VTD_EXTENDED_CAPABILITY_RID_PRIV_SUPPORT_BIT                 53
#define VTD_EXTENDED_CAPABILITY_RID_PRIV_SUPPORT_FLAG                0x20000000000000
#define VTD_EXTENDED_CAPABILITY_RID_PRIV_SUPPORT_MASK                0x01
#define VTD_EXTENDED_CAPABILITY_RID_PRIV_SUPPORT(_)                  (((_) >> 53) & 0x01)
    UINT64 Reserved5                                               : 10;
  };
  UINT64 AsUInt;
} VTD_EXTENDED_CAPABILITY_REGISTER;*/
return true
}

func (i *ia32) * 3. if ()(ok bool){//col:24849
/* * 3. if (Y) {Command = (Status | (1 << X))} else {Command = (Status & ~(1 << X))}
 * 4. Write Command to GCMD_REG
 * 5. Wait until GSTS_REG[X] indicates command is serviced.
 *
#define VTD_GLOBAL_COMMAND                                           0x00000018
typedef union
{
  struct
  {
    UINT32 Reserved1                                               : 23;
     *
     * [Bit 23] This field is valid only for Intel(R) 64 implementations supporting interrupt remapping.
     * Software writes to this field to enable or disable Compatibility Format interrupts on Intel(R) 64 platforms. The value in
     * this field is effective only when interrupt-remapping is enabled and Extended Interrupt Mode (x2APIC mode) is not
     * enabled.
     * * 0: Block Compatibility format interrupts.
     * * 1: Process Compatibility format interrupts as pass-through (bypass interrupt remapping).
     * Hardware reports the status of updating this field through the CFIS field in the Global Status register.
     * The value returned on a read of this field is undefined.
    UINT32 CompatibilityFormatInterrupt                            : 1;
#define VTD_GLOBAL_COMMAND_COMPATIBILITY_FORMAT_INTERRUPT_BIT        23
#define VTD_GLOBAL_COMMAND_COMPATIBILITY_FORMAT_INTERRUPT_FLAG       0x800000
#define VTD_GLOBAL_COMMAND_COMPATIBILITY_FORMAT_INTERRUPT_MASK       0x01
#define VTD_GLOBAL_COMMAND_COMPATIBILITY_FORMAT_INTERRUPT(_)         (((_) >> 23) & 0x01)
     *
     * [Bit 24] This field is valid only for implementations supporting interrupt remapping.
     * Software sets this field to set/update the interrupt remapping table pointer used by hardware. The interrupt remapping
     * table pointer is specified through the Interrupt Remapping Table Address (IRTA_REG) register.
     * Hardware reports the status of the 'Set Interrupt Remap Table Pointer' operation through the IRTPS field in the Global
     * Status register.
     * The 'Set Interrupt Remap Table Pointer' operation must be performed before enabling or re-enabling (after disabling)
     * interrupt-remapping hardware through the IRE field.
     * Clearing this bit has no effect. The value returned on a read of this field is undefined.
    UINT32 SetInterruptRemapTablePointer                           : 1;
#define VTD_GLOBAL_COMMAND_SET_INTERRUPT_REMAP_TABLE_POINTER_BIT     24
#define VTD_GLOBAL_COMMAND_SET_INTERRUPT_REMAP_TABLE_POINTER_FLAG    0x1000000
#define VTD_GLOBAL_COMMAND_SET_INTERRUPT_REMAP_TABLE_POINTER_MASK    0x01
#define VTD_GLOBAL_COMMAND_SET_INTERRUPT_REMAP_TABLE_POINTER(_)      (((_) >> 24) & 0x01)
     *
     * [Bit 25] This field is valid only for implementations supporting interrupt remapping.
     * * 0: Disable interrupt-remapping hardware
     * * 1: Enable interrupt-remapping hardware
     * Hardware reports the status of the interrupt remapping enable operation through the IRES field in the Global Status
     * register.
     * There may be active interrupt requests in the platform when software updates this field. Hardware must enable or disable
     * interrupt-remapping logic only at deterministic transaction boundaries, so that any in-flight interrupts are either
     * subject to remapping or not at all.
     * For implementations reporting the Enhanced Set Interrupt Remap Table Pointer Support (ESIRTPS) field as Set, hardware
     * performs global invalidation on all Interrupt remapping caches as part of Interrupt Remapping Disable operation.
     * Hardware implementations must drain any in-flight interrupts requests queued in the Root-Complex before completing the
     * interrupt-remapping enable command and reflecting the status of the command through the IRES field in the Global Status
     * register.
     * The value returned on a read of this field is undefined.
    UINT32 InterruptRemappingEnable                                : 1;
#define VTD_GLOBAL_COMMAND_INTERRUPT_REMAPPING_ENABLE_BIT            25
#define VTD_GLOBAL_COMMAND_INTERRUPT_REMAPPING_ENABLE_FLAG           0x2000000
#define VTD_GLOBAL_COMMAND_INTERRUPT_REMAPPING_ENABLE_MASK           0x01
#define VTD_GLOBAL_COMMAND_INTERRUPT_REMAPPING_ENABLE(_)             (((_) >> 25) & 0x01)
     *
     * [Bit 26] This field is valid only for implementations supporting queued invalidations.
     * Software writes to this field to enable or disable queued invalidations.
     * * 0: Disable queued invalidations.
     * * 1: Enable use of queued invalidations.
     * Hardware reports the status of queued invalidation enable operation through QIES field in the Global Status register.
     * The value returned on a read of this field is undefined.
    UINT32 QueuedInvalidationEnable                                : 1;
#define VTD_GLOBAL_COMMAND_QUEUED_INVALIDATION_ENABLE_BIT            26
#define VTD_GLOBAL_COMMAND_QUEUED_INVALIDATION_ENABLE_FLAG           0x4000000
#define VTD_GLOBAL_COMMAND_QUEUED_INVALIDATION_ENABLE_MASK           0x01
#define VTD_GLOBAL_COMMAND_QUEUED_INVALIDATION_ENABLE(_)             (((_) >> 26) & 0x01)
     *
     * [Bit 27] This bit is valid only for implementations requiring write buffer flushing.
     * Software sets this field to request that hardware flush the Root-Complex internal write buffers. This is done to ensure
     * any updates to the memory resident remapping structures are not held in any internal write posting buffers.
     * Hardware reports the status of the write buffer flushing operation through the WBFS field in the Global Status register.
     * Clearing this bit has no effect. The value returned on a read of this field is undefined.
    UINT32 WriteBufferFlush                                        : 1;
#define VTD_GLOBAL_COMMAND_WRITE_BUFFER_FLUSH_BIT                    27
#define VTD_GLOBAL_COMMAND_WRITE_BUFFER_FLUSH_FLAG                   0x8000000
#define VTD_GLOBAL_COMMAND_WRITE_BUFFER_FLUSH_MASK                   0x01
#define VTD_GLOBAL_COMMAND_WRITE_BUFFER_FLUSH(_)                     (((_) >> 27) & 0x01)
     *
     * [Bit 28] This field is valid only for implementations supporting advanced fault logging.
     * Software writes to this field to request hardware to enable or disable advanced fault logging:
     * * 0: Disable advanced fault logging. In this case, translation faults are reported through the Fault Recording
     * registers.
     * * 1: Enable use of memory-resident fault log. When enabled, translation faults are recorded in the memory-resident log.
     * The fault log pointer must be set in hardware (through the SFL field) before enabling advanced fault logging. Hardware
     * reports the status of the advanced fault logging enable operation through the AFLS field in the Global Status register.
     * The value returned on read of this field is undefined.
    UINT32 EnableAdvancedFaultLogging                              : 1;
#define VTD_GLOBAL_COMMAND_ENABLE_ADVANCED_FAULT_LOGGING_BIT         28
#define VTD_GLOBAL_COMMAND_ENABLE_ADVANCED_FAULT_LOGGING_FLAG        0x10000000
#define VTD_GLOBAL_COMMAND_ENABLE_ADVANCED_FAULT_LOGGING_MASK        0x01
#define VTD_GLOBAL_COMMAND_ENABLE_ADVANCED_FAULT_LOGGING(_)          (((_) >> 28) & 0x01)
     *
     * [Bit 29] This field is valid only for implementations supporting advanced fault logging.
     * Software sets this field to request hardware to set/update the fault-log pointer used by hardware. The fault-log pointer
     * is specified through Advanced Fault Log register.
     * Hardware reports the status of the 'Set Fault Log' operation through the FLS field in the Global Status register.
     * The fault log pointer must be set before enabling advanced fault logging (through EAFL field). Once advanced fault
     * logging is enabled, the fault log pointer may be updated through this field while DMA remapping is active.
     * Clearing this bit has no effect. The value returned on read of this field is undefined.
    UINT32 SetFaultLog                                             : 1;
#define VTD_GLOBAL_COMMAND_SET_FAULT_LOG_BIT                         29
#define VTD_GLOBAL_COMMAND_SET_FAULT_LOG_FLAG                        0x20000000
#define VTD_GLOBAL_COMMAND_SET_FAULT_LOG_MASK                        0x01
#define VTD_GLOBAL_COMMAND_SET_FAULT_LOG(_)                          (((_) >> 29) & 0x01)
     *
     * [Bit 30] Software sets this field to set/update the root-table pointer (and translation table mode) used by hardware.
     * The root-table pointer (and translation table mode) is specified through the Root Table Address (RTADDR_REG) register.
     * Hardware reports the status of the 'Set Root Table Pointer' operation through the RTPS field in the Global Status
     * register.
     * The 'Set Root Table Pointer' operation must be performed before enabling or re-enabling (after disabling) DMA remapping
     * through the TE field. For details on invalidation that software may have to perform after the
     * Clearing this bit has no effect. The value returned on a read of this field is undefined.
    UINT32 SetRootTablePointer                                     : 1;
#define VTD_GLOBAL_COMMAND_SET_ROOT_TABLE_POINTER_BIT                30
#define VTD_GLOBAL_COMMAND_SET_ROOT_TABLE_POINTER_FLAG               0x40000000
#define VTD_GLOBAL_COMMAND_SET_ROOT_TABLE_POINTER_MASK               0x01
#define VTD_GLOBAL_COMMAND_SET_ROOT_TABLE_POINTER(_)                 (((_) >> 30) & 0x01)
     *
     * [Bit 31] Software writes to this field to request hardware to enable/disable DMA remapping:
     * * 0: Disable DMA remapping
     * * 1: Enable DMA remapping
     * Hardware reports the status of the translation enable operation through the TES field in the Global Status register.
     * There may be active DMA requests in the platform when software updates this field. Hardware must enable or disable
     * remapping logic only at deterministic transaction boundaries, so that any in-flight transaction is either subject to
     * remapping or not at all.
     * Hardware implementations supporting DMA draining must drain any inflight DMA read/write requests queued within the
     * Root-Complex before completing the translation enable command and reflecting the status of the command through the TES
     * field in the Global Status register.
     * For implementations reporting Scalable Mode Translation Support (SMTS) field as Set, hardware performs global
     * invalidation on all DMA remapping translation caches as part of Translation Disable operation.
     * The value returned on a read of this field is undefined.
    UINT32 TranslationEnable                                       : 1;
#define VTD_GLOBAL_COMMAND_TRANSLATION_ENABLE_BIT                    31
#define VTD_GLOBAL_COMMAND_TRANSLATION_ENABLE_FLAG                   0x80000000
#define VTD_GLOBAL_COMMAND_TRANSLATION_ENABLE_MASK                   0x01
#define VTD_GLOBAL_COMMAND_TRANSLATION_ENABLE(_)                     (((_) >> 31) & 0x01)
  };
  UINT32 AsUInt;
} VTD_GLOBAL_COMMAND_REGISTER;*/
return true
}

func (i *ia32)     * [Bit 23] This field indicates the status of Compatibility format interrupts on Intel()(ok bool){//col:24991
/*     * [Bit 23] This field indicates the status of Compatibility format interrupts on Intel(R) 64 implementations supporting
     * interrupt-remapping. The value reported in this field is applicable only when interrupt-remapping is enabled and
     * extended interrupt mode (x2APIC mode) is not enabled.
     * * 0: Compatibility format interrupts are blocked.
     * * 1: Compatibility format interrupts are processed as pass-through (bypassing interrupt remapping).
    UINT32 CompatibilityFormatInterruptStatus                      : 1;
#define VTD_GLOBAL_STATUS_COMPATIBILITY_FORMAT_INTERRUPT_STATUS_BIT  23
#define VTD_GLOBAL_STATUS_COMPATIBILITY_FORMAT_INTERRUPT_STATUS_FLAG 0x800000
#define VTD_GLOBAL_STATUS_COMPATIBILITY_FORMAT_INTERRUPT_STATUS_MASK 0x01
#define VTD_GLOBAL_STATUS_COMPATIBILITY_FORMAT_INTERRUPT_STATUS(_)   (((_) >> 23) & 0x01)
     *
     * [Bit 24] This field indicates the status of the interrupt remapping table pointer in hardware.
     * This field is cleared by hardware when software sets the SIRTP field in the Global Command register. This field is Set
     * by hardware when hardware completes the 'Set Interrupt Remap Table Pointer' operation using the value provided in the
     * Interrupt Remapping Table Address register.
    UINT32 InterruptRemappingTablePointerStatus                    : 1;
#define VTD_GLOBAL_STATUS_INTERRUPT_REMAPPING_TABLE_POINTER_STATUS_BIT 24
#define VTD_GLOBAL_STATUS_INTERRUPT_REMAPPING_TABLE_POINTER_STATUS_FLAG 0x1000000
#define VTD_GLOBAL_STATUS_INTERRUPT_REMAPPING_TABLE_POINTER_STATUS_MASK 0x01
#define VTD_GLOBAL_STATUS_INTERRUPT_REMAPPING_TABLE_POINTER_STATUS(_) (((_) >> 24) & 0x01)
     *
     * [Bit 25] This field indicates the status of Interrupt-remapping hardware.
     * * 0: Interrupt-remapping hardware is not enabled
     * * 1: Interrupt-remapping hardware is enabled
    UINT32 InterruptRemappingEnableStatus                          : 1;
#define VTD_GLOBAL_STATUS_INTERRUPT_REMAPPING_ENABLE_STATUS_BIT      25
#define VTD_GLOBAL_STATUS_INTERRUPT_REMAPPING_ENABLE_STATUS_FLAG     0x2000000
#define VTD_GLOBAL_STATUS_INTERRUPT_REMAPPING_ENABLE_STATUS_MASK     0x01
#define VTD_GLOBAL_STATUS_INTERRUPT_REMAPPING_ENABLE_STATUS(_)       (((_) >> 25) & 0x01)
     *
     * [Bit 26] This field indicates queued invalidation enable status.
     * * 0: queued invalidation is not enabled
     * * 1: queued invalidation is enabled
    UINT32 QueuedInvalidationEnableStatus                          : 1;
#define VTD_GLOBAL_STATUS_QUEUED_INVALIDATION_ENABLE_STATUS_BIT      26
#define VTD_GLOBAL_STATUS_QUEUED_INVALIDATION_ENABLE_STATUS_FLAG     0x4000000
#define VTD_GLOBAL_STATUS_QUEUED_INVALIDATION_ENABLE_STATUS_MASK     0x01
#define VTD_GLOBAL_STATUS_QUEUED_INVALIDATION_ENABLE_STATUS(_)       (((_) >> 26) & 0x01)
     *
     * [Bit 27] This field is valid only for implementations requiring write buffer flushing. This field indicates the status
     * of the write buffer flush command. It is
     * * Set by hardware when software sets the WBF field in the Global Command register.
     * * Cleared by hardware when hardware completes the write buffer flushing operation.
    UINT32 WriteBufferFlushStatus                                  : 1;
#define VTD_GLOBAL_STATUS_WRITE_BUFFER_FLUSH_STATUS_BIT              27
#define VTD_GLOBAL_STATUS_WRITE_BUFFER_FLUSH_STATUS_FLAG             0x8000000
#define VTD_GLOBAL_STATUS_WRITE_BUFFER_FLUSH_STATUS_MASK             0x01
#define VTD_GLOBAL_STATUS_WRITE_BUFFER_FLUSH_STATUS(_)               (((_) >> 27) & 0x01)
     *
     * [Bit 28] This field is valid only for implementations supporting advanced fault logging. It indicates the advanced fault
     * logging status:
     * * 0: Advanced Fault Logging is not enabled
     * * 1: Advanced Fault Logging is enabled
    UINT32 AdvancedFaultLoggingStatus                              : 1;
#define VTD_GLOBAL_STATUS_ADVANCED_FAULT_LOGGING_STATUS_BIT          28
#define VTD_GLOBAL_STATUS_ADVANCED_FAULT_LOGGING_STATUS_FLAG         0x10000000
#define VTD_GLOBAL_STATUS_ADVANCED_FAULT_LOGGING_STATUS_MASK         0x01
#define VTD_GLOBAL_STATUS_ADVANCED_FAULT_LOGGING_STATUS(_)           (((_) >> 28) & 0x01)
     *
     * [Bit 29] This field:
     * * Is cleared by hardware when software Sets the SFL field in the Global Command register.
     * * Is Set by hardware when hardware completes the 'Set Fault Log Pointer' operation using the value provided in the
     * Advanced Fault Log register.
    UINT32 FaultLogStatus                                          : 1;
#define VTD_GLOBAL_STATUS_FAULT_LOG_STATUS_BIT                       29
#define VTD_GLOBAL_STATUS_FAULT_LOG_STATUS_FLAG                      0x20000000
#define VTD_GLOBAL_STATUS_FAULT_LOG_STATUS_MASK                      0x01
#define VTD_GLOBAL_STATUS_FAULT_LOG_STATUS(_)                        (((_) >> 29) & 0x01)
     *
     * [Bit 30] This field indicates the status of the root-table pointer in hardware.
     * This field is cleared by hardware when software sets the SRTP field in the Global Command register. This field is set by
     * hardware when hardware completes the 'Set Root Table Pointer' operation using the value provided in the Root Table
     * Address register.
    UINT32 RootTablePointerStatus                                  : 1;
#define VTD_GLOBAL_STATUS_ROOT_TABLE_POINTER_STATUS_BIT              30
#define VTD_GLOBAL_STATUS_ROOT_TABLE_POINTER_STATUS_FLAG             0x40000000
#define VTD_GLOBAL_STATUS_ROOT_TABLE_POINTER_STATUS_MASK             0x01
#define VTD_GLOBAL_STATUS_ROOT_TABLE_POINTER_STATUS(_)               (((_) >> 30) & 0x01)
     *
     * [Bit 31] This field indicates the status of DMA-remapping hardware.
     * * 0: DMA remapping is not enabled
     * * 1: DMA remapping is enabled
    UINT32 TranslationEnableStatus                                 : 1;
#define VTD_GLOBAL_STATUS_TRANSLATION_ENABLE_STATUS_BIT              31
#define VTD_GLOBAL_STATUS_TRANSLATION_ENABLE_STATUS_FLAG             0x80000000
#define VTD_GLOBAL_STATUS_TRANSLATION_ENABLE_STATUS_MASK             0x01
#define VTD_GLOBAL_STATUS_TRANSLATION_ENABLE_STATUS(_)               (((_) >> 31) & 0x01)
  };
  UINT32 AsUInt;
} VTD_GLOBAL_STATUS_REGISTER;*/
return true
}

func (i *ia32) * SRTP field in the Global Command Register ()(ok bool){//col:25043
/* * SRTP field in the Global Command Register (GCMD_REG).
 *
#define VTD_ROOT_TABLE_ADDRESS                                       0x00000020
typedef union
{
  struct
  {
    UINT64 Reserved1                                               : 10;
     *
     * [Bits 11:10] This field specifies the translation mode used for DMA remapping.
     * * 00: legacy mode - uses root tables and context tables.
     * * 01: scalable mode - uses scalable-mode root tables and scalable mode context tables.
     * * 10: reserved - in prior version of this specification, this encoding was used to enable extended mode which is no
     * longer supported.
     * * 11: abort-dma mode.
     * For implementations reporting Enhanced SRTP Support (ESRTPS) field as Clear in the Capability register, software must
     * not modify this field while DMA remapping is active (TES=1 in Global Status register).
     * The value of this field takes effect only after software executes Set Root Table Pointer command.
    UINT64 TranslationTableMode                                    : 2;
#define VTD_ROOT_TABLE_ADDRESS_TRANSLATION_TABLE_MODE_BIT            10
#define VTD_ROOT_TABLE_ADDRESS_TRANSLATION_TABLE_MODE_FLAG           0xC00
#define VTD_ROOT_TABLE_ADDRESS_TRANSLATION_TABLE_MODE_MASK           0x03
#define VTD_ROOT_TABLE_ADDRESS_TRANSLATION_TABLE_MODE(_)             (((_) >> 10) & 0x03)
     *
     * [Bits 63:12] This field points to the base of the page-aligned, 4KB-sized root-table in system memory. Hardware may
     * ignore and not implement bits 63:HAW, where HAW is the host address width.
     * The value of this field takes effect only after software executes Set Root Table Pointer command.
    UINT64 RootTableAddress                                        : 52;
#define VTD_ROOT_TABLE_ADDRESS_ROOT_TABLE_ADDRESS_BIT                12
#define VTD_ROOT_TABLE_ADDRESS_ROOT_TABLE_ADDRESS_FLAG               0xFFFFFFFFFFFFF000
#define VTD_ROOT_TABLE_ADDRESS_ROOT_TABLE_ADDRESS_MASK               0xFFFFFFFFFFFFF
#define VTD_ROOT_TABLE_ADDRESS_ROOT_TABLE_ADDRESS(_)                 (((_) >> 12) & 0xFFFFFFFFFFFFF)
  };
  UINT64 AsUInt;
} VTD_ROOT_TABLE_ADDRESS_REGISTER;*/
return true
}

func (i *ia32)     * to this field is within this limit. Hardware ignores ()(ok bool){//col:25179
/*     * to this field is within this limit. Hardware ignores (and may not implement) bits 15:N, where N is the supported
     * domain-id width reported in the Capability register.
    UINT64 DomainId                                                : 16;
#define VTD_CONTEXT_COMMAND_DOMAIN_ID_BIT                            0
#define VTD_CONTEXT_COMMAND_DOMAIN_ID_FLAG                           0xFFFF
#define VTD_CONTEXT_COMMAND_DOMAIN_ID_MASK                           0xFFFF
#define VTD_CONTEXT_COMMAND_DOMAIN_ID(_)                             (((_) >> 0) & 0xFFFF)
     *
     * [Bits 31:16] Indicates the source-id of the device whose corresponding context-entry needs to be selectively
     * invalidated.This field along with the FM field must be programmed by software for device-selective invalidation
     * requests.
     * The value returned on a read of this field is undefined.
    UINT64 SourceId                                                : 16;
#define VTD_CONTEXT_COMMAND_SOURCE_ID_BIT                            16
#define VTD_CONTEXT_COMMAND_SOURCE_ID_FLAG                           0xFFFF0000
#define VTD_CONTEXT_COMMAND_SOURCE_ID_MASK                           0xFFFF
#define VTD_CONTEXT_COMMAND_SOURCE_ID(_)                             (((_) >> 16) & 0xFFFF)
     *
     * [Bits 33:32] Software may use the Function Mask to perform device-selective invalidations on behalf of devices
     * supporting PCI Express Phantom Functions.
     * This field specifies which bits of the function number portion (least significant three bits) of the SID field to mask
     * when performing device selective invalidations.The following encodings are defined for this field:
     * * 00: No bits in the SID field masked
     * * 01: Mask bit 2 in the SID field
     * * 10: Mask bits 2:1 in the SID field
     * * 11: Mask bits 2:0 in the SID field
     * The context-entries corresponding to the source-ids specified through the SID and FM fields must have the domain-id
     * specified in the DID field.
     * The value returned on a read of this field is undefined.
    UINT64 FunctionMask                                            : 2;
#define VTD_CONTEXT_COMMAND_FUNCTION_MASK_BIT                        32
#define VTD_CONTEXT_COMMAND_FUNCTION_MASK_FLAG                       0x300000000
#define VTD_CONTEXT_COMMAND_FUNCTION_MASK_MASK                       0x03
#define VTD_CONTEXT_COMMAND_FUNCTION_MASK(_)                         (((_) >> 32) & 0x03)
    UINT64 Reserved1                                               : 25;
     *
     * [Bits 60:59] Hardware reports the granularity at which an invalidation request was processed through the CAIG field at
     * the time of reporting invalidation completion (by clearing the ICC field).
     * The following are the encodings for this field:
     * * 00: Error. This indicates hardware detected an incorrect invalidation request and ignored the request, e.g., register
     * based invalidation when Translation Table Mode (TTM) in Root Table Address Register is not programmed to legacy mode
     * (RTADDR_REG.TTM!=00b).
     * On hardware implementations with Major Version 6 or higher (VER_REG), all invalidation requests through this register
     * are treated as incorrect invalidation requests. Software should use the Queued Invalidation interface to perform
     * context-cache invalidations for such hardware implementations. Refer to Section 6.5 for more details.
     * * 01: Global Invalidation performed. This could be in response to a global, domain-selective, or device-selective
     * invalidation request.
     * * 10: Domain-selective invalidation performed using the domain-id specified by software in the DID field. This could be
     * in response to a domain-selective or device-selective invalidation request.
     * * 11: Device-selective invalidation performed using the source-id and domain-id specified by software in the SID and FM
     * fields. This can only be in response to a device-selective invalidation request.
    UINT64 ContextActualInvalidationGranularity                    : 2;
#define VTD_CONTEXT_COMMAND_CONTEXT_ACTUAL_INVALIDATION_GRANULARITY_BIT 59
#define VTD_CONTEXT_COMMAND_CONTEXT_ACTUAL_INVALIDATION_GRANULARITY_FLAG 0x1800000000000000
#define VTD_CONTEXT_COMMAND_CONTEXT_ACTUAL_INVALIDATION_GRANULARITY_MASK 0x03
#define VTD_CONTEXT_COMMAND_CONTEXT_ACTUAL_INVALIDATION_GRANULARITY(_) (((_) >> 59) & 0x03)
     *
     * [Bits 62:61] Software provides the requested invalidation granularity through this field when setting the ICC field:
     * * 00: Reserved.
     * * 01: Global Invalidation request.
     * * 10: Domain-selective invalidation request. The target domain-id must be specified in the DID field.
     * * 11: Device-selective invalidation request. The target source-id(s) must be specified through the SID and FM fields,
     * and the domain-id [that was programmed in the context-entry for these device(s)] must be provided in the DID field.
     * Hardware implementations may process an invalidation request by performing invalidation at a coarser granularity than
     * requested. Hardware indicates completion of the invalidation request by clearing the ICC field. At this time, hardware
     * also indicates the granularity at which the actual invalidation was performed through the CAIG field.
    UINT64 ContextInvalidationRequestGranularity                   : 2;
#define VTD_CONTEXT_COMMAND_CONTEXT_INVALIDATION_REQUEST_GRANULARITY_BIT 61
#define VTD_CONTEXT_COMMAND_CONTEXT_INVALIDATION_REQUEST_GRANULARITY_FLAG 0x6000000000000000
#define VTD_CONTEXT_COMMAND_CONTEXT_INVALIDATION_REQUEST_GRANULARITY_MASK 0x03
#define VTD_CONTEXT_COMMAND_CONTEXT_INVALIDATION_REQUEST_GRANULARITY(_) (((_) >> 61) & 0x03)
     *
     * [Bit 63] Software requests invalidation of context-cache by setting this field. Software must also set the requested
     * invalidation granularity by programming the CIRG field. Software must read back and check the ICC field is Clear to
     * confirm the invalidation is complete. Software must not update this register when this field is Set.
     * Hardware clears the ICC field to indicate the invalidation request is complete.Hardware also indicates the granularity
     * at which the invalidation operation was performed through the CAIG field.
     * Software must submit a context-cache invalidation request through this field only when there are no invalidation
     * requests pending at this remapping hardware unit.
     * Since information from the context-cache may be used by hardware to tag IOTLB entries, software must perform
     * domain-selective (or global) invalidation of IOTLB after the context-cache invalidation has completed.
     * Hardware implementations reporting a write-buffer flushing requirement (RWBF=1 in the Capability register) must
     * implicitly perform a write buffer flush before invalidating the context-cache.
     * When Translation Table Mode field in Root Table Address register is not setup as legacy mode (RTADDR_REG.TTM!=00b),
     * hardware will ignore the value provided by software in this register, treat it as an incorrect invalidation request, and
     * report a value of 00b in CAIG field.
    UINT64 InvalidateContextCache                                  : 1;
#define VTD_CONTEXT_COMMAND_INVALIDATE_CONTEXT_CACHE_BIT             63
#define VTD_CONTEXT_COMMAND_INVALIDATE_CONTEXT_CACHE_FLAG            0x8000000000000000
#define VTD_CONTEXT_COMMAND_INVALIDATE_CONTEXT_CACHE_MASK            0x01
#define VTD_CONTEXT_COMMAND_INVALIDATE_CONTEXT_CACHE(_)              (((_) >> 63) & 0x01)
  };
  UINT64 AsUInt;
} VTD_CONTEXT_COMMAND_REGISTER;*/
return true
}

func (i *ia32)#define VTD_INVALIDATE_ADDRESS_ADDRESS_MASK()(ok bool){//col:25250
/*#define VTD_INVALIDATE_ADDRESS_ADDRESS_MASK(_)                       (((_) >> 0) & 0x3F)
     *
     * [Bit 6] The field provides hints to hardware about preserving or flushing the nonleaf (context-entry) entries that may
     * be cached in hardware:
     * * 0: Software may have modified both leaf and non-leaf second-level paging-structure entries corresponding to mappings
     * specified in the ADDR and AM fields. On a page-selective-within-domain invalidation request, hardware must invalidate
     * the cached entries associated with the mappings specified by DID, ADDR and AM fields, in both IOTLB and paging-structure
     * caches.
     * * 1: Software has not modified any second-level non-leaf paging entries associated with the mappings specified by the
     * ADDR and AM fields. On a page-selective-within-domain invalidation request, hardware may preserve the cached
     * second-level mappings in paging-structurecaches.
     * A value returned on a read of this field is undefined.
    UINT64 InvalidationHint                                        : 1;
#define VTD_INVALIDATE_ADDRESS_INVALIDATION_HINT_BIT                 6
#define VTD_INVALIDATE_ADDRESS_INVALIDATION_HINT_FLAG                0x40
#define VTD_INVALIDATE_ADDRESS_INVALIDATION_HINT_MASK                0x01
#define VTD_INVALIDATE_ADDRESS_INVALIDATION_HINT(_)                  (((_) >> 6) & 0x01)
    UINT64 Reserved1                                               : 5;
     *
     * [Bits 63:12] Software provides the second-level-input-address that needs to be page selectively invalidated. To make a
     * page-selective-within-domain invalidation request to hardware, software must first write the appropriate fields in this
     * register, and then issue the page-selective-within-domain invalidate command through the IOTLB_REG. Hardware ignores
     * bits 63:N, where N is the maximum guest address width (MGAW) supported.
     * A value returned on a read of this field is undefined.
    UINT64 PageAddress                                             : 52;
#define VTD_INVALIDATE_ADDRESS_PAGE_ADDRESS_BIT                      12
#define VTD_INVALIDATE_ADDRESS_PAGE_ADDRESS_FLAG                     0xFFFFFFFFFFFFF000
#define VTD_INVALIDATE_ADDRESS_PAGE_ADDRESS_MASK                     0xFFFFFFFFFFFFF
#define VTD_INVALIDATE_ADDRESS_PAGE_ADDRESS(_)                       (((_) >> 12) & 0xFFFFFFFFFFFFF)
  };
  UINT64 AsUInt;
} VTD_INVALIDATE_ADDRESS_REGISTER;*/
return true
}

func (i *ia32)     * to this field is within this limit. Hardware may ignore and not implement bits 47:()(ok bool){//col:25385
/*     * to this field is within this limit. Hardware may ignore and not implement bits 47:(32+N), where N is the supported
     * domain-id width reported in the Capability register.
    UINT64 DomainId                                                : 16;
#define VTD_IOTLB_INVALIDATE_DOMAIN_ID_BIT                           32
#define VTD_IOTLB_INVALIDATE_DOMAIN_ID_FLAG                          0xFFFF00000000
#define VTD_IOTLB_INVALIDATE_DOMAIN_ID_MASK                          0xFFFF
#define VTD_IOTLB_INVALIDATE_DOMAIN_ID(_)                            (((_) >> 32) & 0xFFFF)
     *
     * [Bit 48] This field is ignored by hardware if the DWD field is reported as Clear in the Capability register. When the
     * DWD field is reported as Set in the Capability register, the following encodings are supported for this field:
     * * 0: Hardware may complete the IOTLB invalidation without draining DMA write requests.
     * * 1: Hardware must drain relevant translated DMA write requests.
    UINT64 DrainWrites                                             : 1;
#define VTD_IOTLB_INVALIDATE_DRAIN_WRITES_BIT                        48
#define VTD_IOTLB_INVALIDATE_DRAIN_WRITES_FLAG                       0x1000000000000
#define VTD_IOTLB_INVALIDATE_DRAIN_WRITES_MASK                       0x01
#define VTD_IOTLB_INVALIDATE_DRAIN_WRITES(_)                         (((_) >> 48) & 0x01)
     *
     * [Bit 49] This field is ignored by hardware if the DRD field is reported as Clear in the Capability register. When the
     * DRD field is reported as Set in the Capability register, the following encodings are supported for this field:
     * * 0: Hardware may complete the IOTLB invalidation without draining DMA read requests.
     * * 1: Hardware must drain DMA read requests.
    UINT64 DrainReads                                              : 1;
#define VTD_IOTLB_INVALIDATE_DRAIN_READS_BIT                         49
#define VTD_IOTLB_INVALIDATE_DRAIN_READS_FLAG                        0x2000000000000
#define VTD_IOTLB_INVALIDATE_DRAIN_READS_MASK                        0x01
#define VTD_IOTLB_INVALIDATE_DRAIN_READS(_)                          (((_) >> 49) & 0x01)
    UINT64 Reserved2                                               : 7;
     *
     * [Bits 58:57] Hardware reports the granularity at which an invalidation request was processed through this field when
     * reporting invalidation completion (by clearing the IVT field).
     * The following are the encodings for this field.
     * * 00: Error. This indicates hardware detected an incorrect invalidation request and ignored the request, e.g., register
     * based invalidation when Translation Table Mode (TTM) in Root Table Address Register is not programmed to legacy mode
     * (RTADDR_REG.TTM!=00b), detected an unsupported address mask value in Invalidate Address register for page-selective
     * invalidation requests.
     * On hardware implementations with Major Version 6 or higher (VER_REG), all invalidation requests through this register
     * are treated as incorrect invalidation requests. Software should use the Queued Invalidation interface to perform IOTLB
     * invalidations for such hardware implementations. Refer to Section 6.5 for more details.
     * * 01: Global Invalidation performed. This could be in response to a global, domain-selective, or page-selective
     * invalidation request.
     * * 10: Domain-selective invalidation performed using the domain-id specified by software in the DID field. This could be
     * in response to a domain-selective or a page-selective invalidation request.
     * * 11: Page-selective-within-domain invalidation performed using the address, mask and hint specified by software in the
     * Invalidate Address register and domain-id specified in DID field. This can be in response to a
     * page-selective-within-domain invalidation request.
    UINT64 IotlbActualInvalidationGranularity                      : 2;
#define VTD_IOTLB_INVALIDATE_IOTLB_ACTUAL_INVALIDATION_GRANULARITY_BIT 57
#define VTD_IOTLB_INVALIDATE_IOTLB_ACTUAL_INVALIDATION_GRANULARITY_FLAG 0x600000000000000
#define VTD_IOTLB_INVALIDATE_IOTLB_ACTUAL_INVALIDATION_GRANULARITY_MASK 0x03
#define VTD_IOTLB_INVALIDATE_IOTLB_ACTUAL_INVALIDATION_GRANULARITY(_) (((_) >> 57) & 0x03)
    UINT64 Reserved3                                               : 1;
     *
     * [Bits 61:60] When requesting hardware to invalidate the IOTLB (by setting the IVT field), software writes the requested
     * invalidation granularity through this field. The following are the encodings for the field.
     * * 00: Reserved.
     * * 01: Global invalidation request.
     * * 10: Domain-selective invalidation request. The target domain-id must be specified in the DID field.
     * * 11: Page-selective-within-domain invalidation request. The target address, mask, and invalidation hint must be
     * specified in the Invalidate Address register, and the domain-id must be provided in the DID field.
     * Hardware implementations may process an invalidation request by performing invalidation at a coarser granularity than
     * requested. Hardware indicates completion of the invalidation request by clearing the IVT field. At that time, the
     * granularity at which actual invalidation was performed is reported through the IAIG field.
    UINT64 IotlbInvalidationRequestGranularity                     : 2;
#define VTD_IOTLB_INVALIDATE_IOTLB_INVALIDATION_REQUEST_GRANULARITY_BIT 60
#define VTD_IOTLB_INVALIDATE_IOTLB_INVALIDATION_REQUEST_GRANULARITY_FLAG 0x3000000000000000
#define VTD_IOTLB_INVALIDATE_IOTLB_INVALIDATION_REQUEST_GRANULARITY_MASK 0x03
#define VTD_IOTLB_INVALIDATE_IOTLB_INVALIDATION_REQUEST_GRANULARITY(_) (((_) >> 60) & 0x03)
    UINT64 Reserved4                                               : 1;
     *
     * [Bit 63] Software requests IOTLB invalidation by setting this field. Software must also set the requested invalidation
     * granularity by programming the IIRG field.
     * Hardware clears the IVT field to indicate the invalidation request is complete. Hardware also indicates the granularity
     * at which the invalidation operation was performed through the IAIG field. Software must not submit another invalidation
     * request through this register while the IVT field is Set, nor update the associated Invalidate Address register.
     * Software must not submit IOTLB invalidation requests when there is a context-cache invalidation request pending at this
     * remapping hardware unit.
     * Hardware implementations reporting a write-buffer flushing requirement (RWBF=1 in Capability register) must implicitly
     * perform a write buffer flushing before invalidating the IOTLB. Refer to Section 6.8 for write buffer flushing
     * requirements.
     * When Translation Table Mode field in Root Table Address registers is not setup as legacy mode (RTADDR_REG.TTM!=00b),
     * hardware will ignore the value provided by software in this register, treat it as an incorrect invalidation request, and
     * report a value of 00b in IAIG field.
    UINT64 InvalidateIotlb                                         : 1;
#define VTD_IOTLB_INVALIDATE_INVALIDATE_IOTLB_BIT                    63
#define VTD_IOTLB_INVALIDATE_INVALIDATE_IOTLB_FLAG                   0x8000000000000000
#define VTD_IOTLB_INVALIDATE_INVALIDATE_IOTLB_MASK                   0x01
#define VTD_IOTLB_INVALIDATE_INVALIDATE_IOTLB(_)                     (((_) >> 63) & 0x01)
  };
  UINT64 AsUInt;
} VTD_IOTLB_INVALIDATE_REGISTER;*/
return true
}

func (i *ia32)#define XCR0_X87()(ok bool){//col:25487
/*#define XCR0_X87(_)                                                  (((_) >> 0) & 0x01)
     * [Bit 1] If 1, the XSAVE feature set can be used to manage MXCSR and the XMM registers (XMM0-XMM15 in 64-bit mode;
     * otherwise XMM0-XMM7).
    UINT64 Sse                                                     : 1;
#define XCR0_SSE_BIT                                                 1
#define XCR0_SSE_FLAG                                                0x02
#define XCR0_SSE_MASK                                                0x01
#define XCR0_SSE(_)                                                  (((_) >> 1) & 0x01)
     * [Bit 2] If 1, AVX instructions can be executed and the XSAVE feature set can be used to manage the upper halves of the
     * YMM registers (YMM0-YMM15 in 64-bit mode; otherwise YMM0-YMM7).
    UINT64 Avx                                                     : 1;
#define XCR0_AVX_BIT                                                 2
#define XCR0_AVX_FLAG                                                0x04
#define XCR0_AVX_MASK                                                0x01
#define XCR0_AVX(_)                                                  (((_) >> 2) & 0x01)
     * [Bit 3] If 1, MPX instructions can be executed and the XSAVE feature set can be used to manage the bounds registers
     * BND0-BND3.
    UINT64 Bndreg                                                  : 1;
#define XCR0_BNDREG_BIT                                              3
#define XCR0_BNDREG_FLAG                                             0x08
#define XCR0_BNDREG_MASK                                             0x01
#define XCR0_BNDREG(_)                                               (((_) >> 3) & 0x01)
     * [Bit 4] If 1, MPX instructions can be executed and the XSAVE feature set can be used to manage the BNDCFGU and BNDSTATUS
     * registers.
    UINT64 Bndcsr                                                  : 1;
#define XCR0_BNDCSR_BIT                                              4
#define XCR0_BNDCSR_FLAG                                             0x10
#define XCR0_BNDCSR_MASK                                             0x01
#define XCR0_BNDCSR(_)                                               (((_) >> 4) & 0x01)
     * [Bit 5] If 1, AVX-512 instructions can be executed and the XSAVE feature set can be used to manage the opmask registers
     * k0-k7.
    UINT64 Opmask                                                  : 1;
#define XCR0_OPMASK_BIT                                              5
#define XCR0_OPMASK_FLAG                                             0x20
#define XCR0_OPMASK_MASK                                             0x01
#define XCR0_OPMASK(_)                                               (((_) >> 5) & 0x01)
     * [Bit 6] If 1, AVX-512 instructions can be executed and the XSAVE feature set can be used to manage the upper halves of
     * the lower ZMM registers (ZMM0-ZMM15 in 64-bit mode; otherwise ZMM0-ZMM7).
    UINT64 ZmmHi256                                                : 1;
#define XCR0_ZMM_HI256_BIT                                           6
#define XCR0_ZMM_HI256_FLAG                                          0x40
#define XCR0_ZMM_HI256_MASK                                          0x01
#define XCR0_ZMM_HI256(_)                                            (((_) >> 6) & 0x01)
     * [Bit 7] If 1, AVX-512 instructions can be executed and the XSAVE feature set can be used to manage the upper ZMM
     * registers (ZMM16-ZMM31, oonly in 64-bit mode).
    UINT64 ZmmHi16                                                 : 1;
#define XCR0_ZMM_HI16_BIT                                            7
#define XCR0_ZMM_HI16_FLAG                                           0x80
#define XCR0_ZMM_HI16_MASK                                           0x01
#define XCR0_ZMM_HI16(_)                                             (((_) >> 7) & 0x01)
    UINT64 Reserved1                                               : 1;
     * [Bit 9] If 1, the XSAVE feature set can be used to manage the PKRU register.
    UINT64 Pkru                                                    : 1;
#define XCR0_PKRU_BIT                                                9
#define XCR0_PKRU_FLAG                                               0x200
#define XCR0_PKRU_MASK                                               0x01
#define XCR0_PKRU(_)                                                 (((_) >> 9) & 0x01)
    UINT64 Reserved2                                               : 54;
  };
  UINT64 AsUInt;
} XCR0;*/
return true
}



